import nimcrypto,marshal
import hkdf
import endians, sequtils
import binaryparse, parsers

const
    PerspectiveServer = 1
    PerspectiveClient = 2
    gcmStandardNonceSize* = 12
    gcmBlockSize* = 16

type AeadAESGCM*[T] = ref object
    clientIV: seq[uint8]
    serverIV: seq[uint8]
    encrypter: GCM[T]
    decrypter: GCM[T]


proc computeSecrets*(HashType: typedesc, cid: string): tuple[clientSecret,serverSecret: seq[uint8]] =
    var initialSecret = hkdfExtract(HashType, cast[string](initialSalt), cid)
    result.clientSecret = hkdfExpandLabel(HashType, initialSecret.data, "client in", sha256.sizeDigest)
    result.serverSecret = hkdfExpandLabel(HashType, initialSecret.data, "server in", sha256.sizeDigest)

proc computeAEADKeyAndIV*(HashType: typedesc, secret: seq[byte]): tuple[key, iv, hp: seq[byte]] =
    result.key = hkdfExpandLabel(HashType, secret, "quic key", 16)
    result.iv = hkdfExpandLabel(HashType, secret, "quic iv", 12)
    result.hp = hkdfExpandLabel(HashType, secret, "quic hp", 16)


proc authenticatedEncryption*(key: seq[byte], iv: seq[byte], plainText: seq[byte], aad: seq[byte], nonce: seq[byte] = @[]): seq[byte] =
    var ectx, dctx: GCM[aes128]
    var etag: array[aes128.sizeBlock, byte]

    ectx.init(key, iv, cast[seq[byte]](aad))
    dctx.init(key, iv, cast[seq[byte]](aad))
    if plaintext.len > (1 shl 32 - 2)*16:
        echo "crypto/cipher: message too large for GCM"
    result = newSeq[byte](len(plaintext))
    ectx.encrypt(plaintext, result)
    ectx.getTag(etag)
    ectx.clear()
    echo "etag:" & etag.toHex


proc open*[T](aead: AeadAESGCM[T], encText: seq[byte], aad: string): seq[byte] =
    var dtag: array[aes128.sizeBlock, uint8]
    result = newSeq[byte](len(aad))
    aead.dctx.decrypt(encText, result)
    aead.dctx.getTag(dtag)
    aead.dctx.clear()

# when isMainModule:


    # The labels generated by the hkdfExpandLabel function are:
    # client in: 00200f746c73313320636c69656e7420696e00
    # server in: 00200f746c7331332073657276657220696e00
    # quic key: 00100e746c7331332071756963206b657900
    # quic iv: 000c0d746c733133207175696320697600
    # quic hp: 00100d746c733133207175696320687000
    # The initial secret is common:initialSecret = hkdfExtract(initialSalt, cid) = 
    # 524e374c6da8cf8b496f4bcb696783507aafee6198b202b4bc823ebf7514a423
    # The secrets for protecting client packets are: clientSecret = hkdfExpandLabel(initialSecret, "client in", _, 32) = 
    # fda3953aecc040e48b34e27ef87de3a6098ecf0e38b7e032c5c57bcbd5975b84
    # FDA3953AECC040E48B34E27EF87DE3A6098ECF0E38B7E032C5C57BCBD5975B84
    # key = hkdfExpandLabel(clientSecret, "quic key", _, 16) = af7fd7efebd21878ff66811248983694
    # iv = hkdfExpandLabel(clientSecret, "quic iv", _, 12) = 8681359410a70bb9c92f0420
    # hp = hkdfExpandLabel(clientSecret, "quic hp", _, 16) = a980b8b4fb7d9fbc13e814c23164253d
    # The secrets for protecting server packets are: serverSecret = hkdfExpandLabel(initialSecret, "server in", _, 32) =
    # 554366b81912ff90be41f17e8022213090ab17d8149179bcadf222f29ff2ddd5
    # key = hkdfExpandLabel(serverSecret, "quic key", _, 16) = 5d51da9ee897a21b2659ccc7e5bfa577
    # iv = hkdfExpandLabel(serverSecret, "quic iv", _, 12) = 5e5ae651fd1e8495af13508b
    # hp = hkdfExpandLabel(serverSecret, "quic hp", _, 16) = a8ed82e6664f865aedf6106943f95fb8





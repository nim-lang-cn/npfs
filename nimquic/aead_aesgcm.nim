import nimcrypto,marshal
import hkdf
import endians, sequtils
import binaryparse, parsers

const
    PerspectiveServer = 1
    PerspectiveClient = 2
    gcmStandardNonceSize* = 12
    gcmBlockSize* = 16

type AeadAESGCM*[T] = ref object
    otherIV: seq[uint8]
    myIV: seq[uint8]
    encrypter: GCM[T]
    decrypter: GCM[T]


proc computeSecrets*(HashType: typedesc, cid: string): tuple[clientSecret,serverSecret: seq[uint8]] =
    var initialSecret = hkdfExtract(HashType, cast[string](initialSalt), cid)
    result.clientSecret = hkdfExpandLabel(HashType, initialSecret.data, "client in", sha256.sizeDigest)
    result.serverSecret = hkdfExpandLabel(HashType, initialSecret.data, "server in", sha256.sizeDigest)

proc computeAEADKeyAndIV*(HashType: typedesc, secret: seq[byte]): tuple[key, iv, hp: seq[byte]] =
    result.key = hkdfExpandLabel(HashType, secret, "quic key", 16)
    result.iv = hkdfExpandLabel(HashType, secret, "quic iv", 12)
    result.hp = hkdfExpandLabel(HashType, secret, "quic hp", 16)

proc newAEAD*[T,S](HashType: typedesc[T], aesType: typedesc[S], connectionId: string, pers: int = PerspectiveClient, myhp: var seq[byte]): AeadAESGCM[S] =
    var (clientSecret, serverSecret) = computeSecrets(HashType, connectionId)
    var mySecret, otherSecret: seq[byte]
    if pers == PerspectiveClient:
        mySecret = clientSecret
        otherSecret = serverSecret
    else:
        mySecret = serverSecret
        otherSecret = clientSecret
    var myKey, myIV: seq[byte]
    var otherKey, otherIV: seq[byte]
    (myKey, myIV, myhp) = computeAEADKeyAndIV(HashType, mySecret)
    (otherKey, otherIV) = computeAEADKeyAndIV(HashType, otherSecret)
    var ectx, dctx: GCM[S]
    var aad = "Alice Authentication Data"
    ectx.init(myKey, myIV, cast[seq[byte]](aad))
    dctx.init(otherKey, otherIV, cast[seq[byte]](aad))
    result = AeadAESGCM[S](otherIV:otherIV, myIV:myIV, encrypter: ectx, decrypter:dctx)

proc makeNonce*(iv: seq[uint8], packetNumber: uint64): seq[uint8] =
    result.setLen iv.len
    bigEndian64(unsafeAddr result[4], unsafeAddr packetNumber)
    for i in 0..<iv.len:
        result[i] = result[i] xor iv[i]

proc seal*[T](aead: AeadAESGCM[T], plaintext: string, aad: string): seq[uint8] =
    if plaintext.len > (1 shl 32 - 2)*16:
        echo "crypto/cipher: message too large for GCM"
    result = newSeq[uint8](len(aad))
    aead.encrypter.encrypt(cast[seq[byte]](plaintext), result)
    aead.encrypter.clear()


proc open*[T](aead: AeadAESGCM[T], encText: string, aad: string): seq[uint8] =
    var dtag: array[aes128.sizeBlock, uint8]
    result = newSeq[uint8](len(aad))
    aead.dctx.dencrypt(encText, result)
    aead.dctx.getTag(dtag)
    aead.dctx.clear()

when isMainModule:
    # The labels generated by the hkdfExpandLabel function are:
    # client in: 00200f746c73313320636c69656e7420696e00
    # server in: 00200f746c7331332073657276657220696e00
    # quic key: 00100e746c7331332071756963206b657900
    # quic iv: 000c0d746c733133207175696320697600
    # quic hp: 00100d746c733133207175696320687000
    # The initial secret is common:initialSecret = hkdfExtract(initialSalt, cid) = 
    # 524e374c6da8cf8b496f4bcb696783507aafee6198b202b4bc823ebf7514a423
    # The secrets for protecting client packets are: clientSecret = hkdfExpandLabel(initialSecret, "client in", _, 32) = 
    # fda3953aecc040e48b34e27ef87de3a6098ecf0e38b7e032c5c57bcbd5975b84
    # FDA3953AECC040E48B34E27EF87DE3A6098ECF0E38B7E032C5C57BCBD5975B84
    # key = hkdfExpandLabel(clientSecret, "quic key", _, 16) = af7fd7efebd21878ff66811248983694
    # iv = hkdfExpandLabel(clientSecret, "quic iv", _, 12) = 8681359410a70bb9c92f0420
    # hp = hkdfExpandLabel(clientSecret, "quic hp", _, 16) = a980b8b4fb7d9fbc13e814c23164253d
    # The secrets for protecting server packets are: serverSecret = hkdfExpandLabel(initialSecret, "server in", _, 32) =
    # 554366b81912ff90be41f17e8022213090ab17d8149179bcadf222f29ff2ddd5
    # key = hkdfExpandLabel(serverSecret, "quic key", _, 16) = 5d51da9ee897a21b2659ccc7e5bfa577
    # iv = hkdfExpandLabel(serverSecret, "quic iv", _, 12) = 5e5ae651fd1e8495af13508b
    # hp = hkdfExpandLabel(serverSecret, "quic hp", _, 16) = a8ed82e6664f865aedf6106943f95fb8

    import strutils, strformat

    var connId = @[0x83'u8, 0x94, 0xc8, 0xf0, 0x3e, 0x51, 0x57, 0x08]
    var connStr = cast[string](connId)
    var (clientSecret, serverSecret) = computeSecrets(sha256, connStr)

    var clientHp, serverHp: seq[byte]
    var clientAead = sha256.newAEAD(aes128, connStr, PerspectiveClient, clientHp)
    var serverAead = sha256.newAEAD(aes128, connStr, PerspectiveServer, serverHp)





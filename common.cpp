#include <inttypes.h>
#include <math.h>
#include <signal.h>
#include <stdint.h>
#include <stdio.h>
#include <assert.h>
#include <inttypes.h>
#include <math.h>
#include <limits.h>
#include <signal.h>
#include <stdint.h>
#include <stdarg.h>
#include <assert.h>
#include <stdio.h>
#include <time.h>
#include <stddef.h>
#include <string.h>
#include <stdlib.h>
#include <errno.h>
#include <pthread.h>
#include <unistd.h>
#include <iconv.h>
#include <ev.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <netinet/ip.h>
#include <fcntl.h>
#include <netinet/udp.h>
#include <sys/mman.h>
#include <chrono>
#include <cstdlib>
#include <cassert>
#include <getopt.h>
#include <netdb.h>
#include <vector>
#include <unordered_map>
#include <map>
#include <string>
#include <deque>
#include <string_view>
#include <array>
#include <memory>
#include <random>
#include <functional>
#include <iostream>
#include <functional>
#include <fstream>
#include <cstring>
#include <algorithm>
#include <limits>
#include <arpa/inet.h>


typedef enum ngtcp2_crypto_side
{
  NGTCP2_CRYPTO_SIDE_CLIENT,
  NGTCP2_CRYPTO_SIDE_SERVER
} ngtcp2_crypto_side;

typedef ptrdiff_t ngtcp2_ssize;
typedef void *(*ngtcp2_malloc)(size_t size, void *mem_user_data);
typedef void (*ngtcp2_free)(void *ptr, void *mem_user_data);
typedef void *(*ngtcp2_calloc)(size_t nmemb, size_t size, void *mem_user_data);
typedef void *(*ngtcp2_realloc)(void *ptr, size_t size, void *mem_user_data);
typedef struct ngtcp2_mem
{
  void *mem_user_data;
  ngtcp2_malloc malloc;
  ngtcp2_free free;
  ngtcp2_calloc calloc;
  ngtcp2_realloc realloc;
} ngtcp2_mem;
typedef enum ngtcp2_ecn
{
  NGTCP2_ECN_NOT_ECT = 0x0,
  NGTCP2_ECN_ECT_1 = 0x1,
  NGTCP2_ECN_ECT_0 = 0x2,
  NGTCP2_ECN_CE = 0x3,
  NGTCP2_ECN_MASK = 0x3
} ngtcp2_ecn;
typedef struct ngtcp2_pkt_info
{
  uint32_t ecn;
} ngtcp2_pkt_info;
typedef enum ngtcp2_lib_error
{
  NGTCP2_ERR_INVALID_ARGUMENT = -201,
  NGTCP2_ERR_NOBUF = -203,
  NGTCP2_ERR_PROTO = -205,
  NGTCP2_ERR_INVALID_STATE = -206,
  NGTCP2_ERR_ACK_FRAME = -207,
  NGTCP2_ERR_STREAM_ID_BLOCKED = -208,
  NGTCP2_ERR_STREAM_IN_USE = -209,
  NGTCP2_ERR_STREAM_DATA_BLOCKED = -210,
  NGTCP2_ERR_FLOW_CONTROL = -211,
  NGTCP2_ERR_CONNECTION_ID_LIMIT = -212,
  NGTCP2_ERR_STREAM_LIMIT = -213,
  NGTCP2_ERR_FINAL_SIZE = -214,
  NGTCP2_ERR_CRYPTO = -215,
  NGTCP2_ERR_PKT_NUM_EXHAUSTED = -216,
  NGTCP2_ERR_REQUIRED_TRANSPORT_PARAM = -217,
  NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM = -218,
  NGTCP2_ERR_FRAME_ENCODING = -219,
  NGTCP2_ERR_TLS_DECRYPT = -220,
  NGTCP2_ERR_STREAM_SHUT_WR = -221,
  NGTCP2_ERR_STREAM_NOT_FOUND = -222,
  NGTCP2_ERR_STREAM_STATE = -226,
  NGTCP2_ERR_RECV_VERSION_NEGOTIATION = -229,
  NGTCP2_ERR_CLOSING = -230,
  NGTCP2_ERR_DRAINING = -231,
  NGTCP2_ERR_TRANSPORT_PARAM = -234,
  NGTCP2_ERR_DISCARD_PKT = -235,
  NGTCP2_ERR_PATH_VALIDATION_FAILED = -236,
  NGTCP2_ERR_CONN_ID_BLOCKED = -237,
  NGTCP2_ERR_INTERNAL = -238,
  NGTCP2_ERR_CRYPTO_BUFFER_EXCEEDED = -239,
  NGTCP2_ERR_WRITE_MORE = -240,
  NGTCP2_ERR_RETRY = -241,
  NGTCP2_ERR_DROP_CONN = -242,
  NGTCP2_ERR_AEAD_LIMIT_REACHED = -243,
  NGTCP2_ERR_FATAL = -500,
  NGTCP2_ERR_NOMEM = -501,
  NGTCP2_ERR_CALLBACK_FAILURE = -502,
} ngtcp2_lib_error;
typedef enum ngtcp2_pkt_flag
{
  NGTCP2_PKT_FLAG_NONE = 0,
  NGTCP2_PKT_FLAG_LONG_FORM = 0x01,
  NGTCP2_PKT_FLAG_KEY_PHASE = 0x04
} ngtcp2_pkt_flag;
typedef enum ngtcp2_pkt_type
{
  NGTCP2_PKT_VERSION_NEGOTIATION = 0xf0,
  NGTCP2_PKT_INITIAL = 0x0,
  NGTCP2_PKT_0RTT = 0x1,
  NGTCP2_PKT_HANDSHAKE = 0x2,
  NGTCP2_PKT_RETRY = 0x3,
  NGTCP2_PKT_SHORT = 0x70
} ngtcp2_pkt_type;
typedef enum ngtcp2_path_validation_result
{
  NGTCP2_PATH_VALIDATION_RESULT_SUCCESS,
  NGTCP2_PATH_VALIDATION_RESULT_FAILURE,
} ngtcp2_path_validation_result;
typedef uint64_t ngtcp2_tstamp;
typedef uint64_t ngtcp2_duration;
typedef struct ngtcp2_cid
{
  size_t datalen;
  uint8_t data[20];
} ngtcp2_cid;
typedef struct ngtcp2_vec
{
  uint8_t *base;
  size_t len;
} ngtcp2_vec;
void ngtcp2_cid_init(ngtcp2_cid *cid, const uint8_t *data,
                     size_t datalen);
typedef struct ngtcp2_pkt_hd
{
  ngtcp2_cid dcid;
  ngtcp2_cid scid;
  int64_t pkt_num;
  ngtcp2_vec token;
  size_t pkt_numlen;
  size_t len;
  uint32_t version;
  uint8_t type;
  uint8_t flags;
} ngtcp2_pkt_hd;
typedef struct ngtcp2_pkt_stateless_reset
{
  uint8_t stateless_reset_token[16];
  const uint8_t *rand;
  size_t randlen;
} ngtcp2_pkt_stateless_reset;
typedef enum ngtcp2_transport_param_id
{
  NGTCP2_TRANSPORT_PARAM_ORIGINAL_DESTINATION_CONNECTION_ID = 0x0000,
  NGTCP2_TRANSPORT_PARAM_MAX_IDLE_TIMEOUT = 0x0001,
  NGTCP2_TRANSPORT_PARAM_STATELESS_RESET_TOKEN = 0x0002,
  NGTCP2_TRANSPORT_PARAM_MAX_UDP_PAYLOAD_SIZE = 0x0003,
  NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_DATA = 0x0004,
  NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_STREAM_DATA_BIDI_LOCAL = 0x0005,
  NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_STREAM_DATA_BIDI_REMOTE = 0x0006,
  NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_STREAM_DATA_UNI = 0x0007,
  NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_STREAMS_BIDI = 0x0008,
  NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_STREAMS_UNI = 0x0009,
  NGTCP2_TRANSPORT_PARAM_ACK_DELAY_EXPONENT = 0x000a,
  NGTCP2_TRANSPORT_PARAM_MAX_ACK_DELAY = 0x000b,
  NGTCP2_TRANSPORT_PARAM_DISABLE_ACTIVE_MIGRATION = 0x000c,
  NGTCP2_TRANSPORT_PARAM_PREFERRED_ADDRESS = 0x000d,
  NGTCP2_TRANSPORT_PARAM_ACTIVE_CONNECTION_ID_LIMIT = 0x000e,
  NGTCP2_TRANSPORT_PARAM_INITIAL_SOURCE_CONNECTION_ID = 0x000f,
  NGTCP2_TRANSPORT_PARAM_RETRY_SOURCE_CONNECTION_ID = 0x0010
} ngtcp2_transport_param_id;
typedef enum ngtcp2_transport_params_type
{
  NGTCP2_TRANSPORT_PARAMS_TYPE_CLIENT_HELLO,
  NGTCP2_TRANSPORT_PARAMS_TYPE_ENCRYPTED_EXTENSIONS
} ngtcp2_transport_params_type;
typedef enum ngtcp2_rand_usage
{
  NGTCP2_RAND_USAGE_NONE,
  NGTCP2_RAND_USAGE_PATH_CHALLENGE
} ngtcp2_rand_usage;
typedef struct ngtcp2_preferred_addr
{
  ngtcp2_cid cid;
  uint16_t ipv4_port;
  uint16_t ipv6_port;
  uint8_t ipv4_addr[4];
  uint8_t ipv6_addr[16];
  uint8_t stateless_reset_token[16];
} ngtcp2_preferred_addr;
typedef struct ngtcp2_transport_params
{
  ngtcp2_preferred_addr preferred_address;
  ngtcp2_cid original_dcid;
  ngtcp2_cid initial_scid;
  ngtcp2_cid retry_scid;
  uint64_t initial_max_stream_data_bidi_local;
  uint64_t initial_max_stream_data_bidi_remote;
  uint64_t initial_max_stream_data_uni;
  uint64_t initial_max_data;
  uint64_t initial_max_streams_bidi;
  uint64_t initial_max_streams_uni;
  ngtcp2_duration max_idle_timeout;
  uint64_t max_udp_payload_size;
  uint64_t active_connection_id_limit;
  uint64_t ack_delay_exponent;
  ngtcp2_duration max_ack_delay;
  uint8_t stateless_reset_token_present;
  uint8_t disable_active_migration;
  uint8_t retry_scid_present;
  uint8_t preferred_address_present;
  uint8_t stateless_reset_token[16];
} ngtcp2_transport_params;
typedef struct ngtcp2_log ngtcp2_log;
typedef enum ngtcp2_pktns_id
{
  NGTCP2_PKTNS_ID_INITIAL,
  NGTCP2_PKTNS_ID_HANDSHAKE,
  NGTCP2_PKTNS_ID_APP,
  NGTCP2_PKTNS_ID_MAX
} ngtcp2_pktns_id;
typedef struct ngtcp2_conn_stat
{
  ngtcp2_duration latest_rtt;
  ngtcp2_duration min_rtt;
  ngtcp2_duration smoothed_rtt;
  ngtcp2_duration rttvar;
  ngtcp2_duration initial_rtt;
  ngtcp2_tstamp first_rtt_sample_ts;
  size_t pto_count;
  ngtcp2_tstamp loss_detection_timer;
  ngtcp2_tstamp last_tx_pkt_ts[NGTCP2_PKTNS_ID_MAX];
  ngtcp2_tstamp loss_time[NGTCP2_PKTNS_ID_MAX];
  uint64_t cwnd;
  uint64_t ssthresh;
  ngtcp2_tstamp congestion_recovery_start_ts;
  uint64_t bytes_in_flight;
  size_t max_udp_payload_size;
  uint64_t bytes_sent;
  uint64_t bytes_recv;
  uint64_t delivery_rate_sec;
  uint64_t recv_rate_sec;
} ngtcp2_conn_stat;
typedef enum ngtcp2_cc_algo
{
  NGTCP2_CC_ALGO_RENO = 0x00,
  NGTCP2_CC_ALGO_CUBIC = 0x01,
  NGTCP2_CC_ALGO_CUSTOM = 0xff
} ngtcp2_cc_algo;
typedef struct ngtcp2_cc_base
{
  ngtcp2_log *log;
} ngtcp2_cc_base;
typedef struct
{
  int64_t pkt_num;
  size_t pktlen;
  ngtcp2_pktns_id pktns_id;
  ngtcp2_tstamp ts_sent;
} ngtcp2_cc_pkt;
typedef struct ngtcp2_cc ngtcp2_cc;
typedef void (*ngtcp2_cc_on_pkt_acked)(ngtcp2_cc *cc, ngtcp2_conn_stat *cstat,
                                       const ngtcp2_cc_pkt *pkt,
                                       ngtcp2_tstamp ts);
typedef void (*ngtcp2_cc_congestion_event)(ngtcp2_cc *cc,
                                           ngtcp2_conn_stat *cstat,
                                           ngtcp2_tstamp ts_sent,
                                           ngtcp2_tstamp ts);
typedef void (*ngtcp2_cc_on_persistent_congestion)(ngtcp2_cc *cc,
                                                   ngtcp2_conn_stat *cstat,
                                                   ngtcp2_tstamp ts);
typedef void (*ngtcp2_cc_on_ack_recv)(ngtcp2_cc *cc, ngtcp2_conn_stat *cstat,
                                      ngtcp2_tstamp ts);
typedef void (*ngtcp2_cc_on_pkt_sent)(ngtcp2_cc *cc, ngtcp2_conn_stat *cstat,
                                      const ngtcp2_cc_pkt *pkt);
typedef void (*ngtcp2_cc_new_rtt_sample)(ngtcp2_cc *cc, ngtcp2_conn_stat *cstat,
                                         ngtcp2_tstamp ts);
typedef void (*ngtcp2_cc_reset)(ngtcp2_cc *cc);
typedef enum ngtcp2_cc_event_type
{
  NGTCP2_CC_EVENT_TYPE_TX_START
} ngtcp2_cc_event_type;
typedef void (*ngtcp2_cc_event)(ngtcp2_cc *cc, ngtcp2_conn_stat *cstat,
                                ngtcp2_cc_event_type event, ngtcp2_tstamp ts);
typedef struct ngtcp2_cc
{
  ngtcp2_cc_base *ccb;
  ngtcp2_cc_on_pkt_acked on_pkt_acked;
  ngtcp2_cc_congestion_event congestion_event;
  ngtcp2_cc_on_persistent_congestion on_persistent_congestion;
  ngtcp2_cc_on_ack_recv on_ack_recv;
  ngtcp2_cc_on_pkt_sent on_pkt_sent;
  ngtcp2_cc_new_rtt_sample new_rtt_sample;
  ngtcp2_cc_reset reset;
  ngtcp2_cc_event event;
} ngtcp2_cc;
typedef void (*ngtcp2_printf)(void *user_data, const char *format, ...);
typedef enum ngtcp2_qlog_write_flag
{
  NGTCP2_QLOG_WRITE_FLAG_NONE = 0,
  NGTCP2_QLOG_WRITE_FLAG_FIN = 0x01
} ngtcp2_qlog_write_flag;
typedef struct ngtcp2_rand_ctx
{
  void *native_handle;
} ngtcp2_rand_ctx;
typedef void (*ngtcp2_qlog_write)(void *user_data, uint32_t flags,
                                  const void *data, size_t datalen);
typedef struct ngtcp2_qlog_settings
{
  ngtcp2_cid odcid;
  ngtcp2_qlog_write write;
} ngtcp2_qlog_settings;
typedef struct ngtcp2_settings
{
  ngtcp2_transport_params transport_params;
  ngtcp2_qlog_settings qlog;
  ngtcp2_cc_algo cc_algo;
  ngtcp2_cc *cc;
  ngtcp2_tstamp initial_ts;
  ngtcp2_duration initial_rtt;
  ngtcp2_printf log_printf;
  size_t max_udp_payload_size;
  ngtcp2_vec token;
  ngtcp2_rand_ctx rand_ctx;
  uint64_t max_window;
  uint64_t max_stream_window;
} ngtcp2_settings;
typedef struct ngtcp2_addr
{
  size_t addrlen;
  struct sockaddr *addr;
  void *user_data;
} ngtcp2_addr;
typedef struct ngtcp2_path
{
  ngtcp2_addr local;
  ngtcp2_addr remote;
} ngtcp2_path;
typedef struct ngtcp2_path_storage
{
  struct sockaddr_storage local_addrbuf;
  struct sockaddr_storage remote_addrbuf;
  ngtcp2_path path;
} ngtcp2_path_storage;
typedef struct ngtcp2_crypto_md
{
  void *native_handle;
} ngtcp2_crypto_md;
typedef struct ngtcp2_crypto_aead
{
  void *native_handle;
} ngtcp2_crypto_aead;
typedef struct ngtcp2_crypto_cipher
{
  void *native_handle;
} ngtcp2_crypto_cipher;
typedef struct ngtcp2_crypto_aead_ctx
{
  void *native_handle;
} ngtcp2_crypto_aead_ctx;
typedef struct ngtcp2_crypto_cipher_ctx
{
  void *native_handle;
} ngtcp2_crypto_cipher_ctx;
typedef struct ngtcp2_crypto_ctx
{
  ngtcp2_crypto_aead aead;
  ngtcp2_crypto_md md;
  ngtcp2_crypto_cipher hp;
  uint64_t max_encryption;
  uint64_t max_decryption_failure;
} ngtcp2_crypto_ctx;
ngtcp2_ssize ngtcp2_encode_transport_params(
    uint8_t *dest, size_t destlen, ngtcp2_transport_params_type exttype,
    const ngtcp2_transport_params *params);
int ngtcp2_decode_transport_params(ngtcp2_transport_params *params,
                                   ngtcp2_transport_params_type exttype,
                                   const uint8_t *data, size_t datalen);
int ngtcp2_pkt_decode_version_cid(uint32_t *pversion, const uint8_t **pdcid,
                                  size_t *pdcidlen, const uint8_t **pscid,
                                  size_t *pscidlen, const uint8_t *data,
                                  size_t datalen, size_t short_dcidlen);
ngtcp2_ssize ngtcp2_pkt_decode_hd_long(ngtcp2_pkt_hd *dest,
                                       const uint8_t *pkt,
                                       size_t pktlen);
ngtcp2_ssize ngtcp2_pkt_decode_hd_short(ngtcp2_pkt_hd *dest,
                                        const uint8_t *pkt,
                                        size_t pktlen,
                                        size_t dcidlen);
ngtcp2_ssize ngtcp2_pkt_write_stateless_reset(
    uint8_t *dest, size_t destlen, const uint8_t *stateless_reset_token,
    const uint8_t *rand, size_t randlen);
ngtcp2_ssize ngtcp2_pkt_write_version_negotiation(
    uint8_t *dest, size_t destlen, uint8_t unused_random, const uint8_t *dcid,
    size_t dcidlen, const uint8_t *scid, size_t scidlen, const uint32_t *sv,
    size_t nsv);
uint8_t ngtcp2_pkt_get_type_long(uint8_t c);
struct ngtcp2_conn;
typedef struct ngtcp2_conn ngtcp2_conn;
typedef int (*ngtcp2_client_initial)(ngtcp2_conn *conn, void *user_data);
typedef int (*ngtcp2_recv_client_initial)(ngtcp2_conn *conn,
                                          const ngtcp2_cid *dcid,
                                          void *user_data);
typedef enum ngtcp2_crypto_level
{
  NGTCP2_CRYPTO_LEVEL_INITIAL,
  NGTCP2_CRYPTO_LEVEL_HANDSHAKE,
  NGTCP2_CRYPTO_LEVEL_APP,
  NGTCP2_CRYPTO_LEVEL_EARLY
} ngtcp2_crypto_level;
typedef int (*ngtcp2_recv_crypto_data)(ngtcp2_conn *conn,
                                       ngtcp2_crypto_level crypto_level,
                                       uint64_t offset, const uint8_t *data,
                                       size_t datalen, void *user_data);
typedef int (*ngtcp2_handshake_completed)(ngtcp2_conn *conn, void *user_data);
typedef int (*ngtcp2_handshake_confirmed)(ngtcp2_conn *conn, void *user_data);
typedef int (*ngtcp2_recv_version_negotiation)(ngtcp2_conn *conn,
                                               const ngtcp2_pkt_hd *hd,
                                               const uint32_t *sv, size_t nsv,
                                               void *user_data);
typedef int (*ngtcp2_recv_retry)(ngtcp2_conn *conn, const ngtcp2_pkt_hd *hd,
                                 void *user_data);
typedef int (*ngtcp2_encrypt)(uint8_t *dest, const ngtcp2_crypto_aead *aead,
                              const ngtcp2_crypto_aead_ctx *aead_ctx,
                              const uint8_t *plaintext, size_t plaintextlen,
                              const uint8_t *nonce, size_t noncelen,
                              const uint8_t *ad, size_t adlen);
typedef int (*ngtcp2_decrypt)(uint8_t *dest, const ngtcp2_crypto_aead *aead,
                              const ngtcp2_crypto_aead_ctx *aead_ctx,
                              const uint8_t *ciphertext, size_t ciphertextlen,
                              const uint8_t *nonce, size_t noncelen,
                              const uint8_t *ad, size_t adlen);
typedef int (*ngtcp2_hp_mask)(uint8_t *dest, const ngtcp2_crypto_cipher *hp,
                              const ngtcp2_crypto_cipher_ctx *hp_ctx,
                              const uint8_t *sample);
typedef enum ngtcp2_stream_data_flag
{
  NGTCP2_STREAM_DATA_FLAG_NONE = 0x00,
  NGTCP2_STREAM_DATA_FLAG_FIN = 0x01,
  NGTCP2_STREAM_DATA_FLAG_0RTT = 0x02
} ngtcp2_stream_data_flag;
typedef int (*ngtcp2_recv_stream_data)(ngtcp2_conn *conn, uint32_t flags,
                                       int64_t stream_id, uint64_t offset,
                                       const uint8_t *data, size_t datalen,
                                       void *user_data, void *stream_user_data);
typedef int (*ngtcp2_stream_open)(ngtcp2_conn *conn, int64_t stream_id,
                                  void *user_data);
typedef int (*ngtcp2_stream_close)(ngtcp2_conn *conn, int64_t stream_id,
                                   uint64_t app_error_code, void *user_data,
                                   void *stream_user_data);
typedef int (*ngtcp2_stream_reset)(ngtcp2_conn *conn, int64_t stream_id,
                                   uint64_t final_size, uint64_t app_error_code,
                                   void *user_data, void *stream_user_data);
typedef int (*ngtcp2_acked_stream_data_offset)(
    ngtcp2_conn *conn, int64_t stream_id, uint64_t offset, uint64_t datalen,
    void *user_data, void *stream_user_data);
typedef int (*ngtcp2_acked_crypto_offset)(ngtcp2_conn *conn,
                                          ngtcp2_crypto_level crypto_level,
                                          uint64_t offset, uint64_t datalen,
                                          void *user_data);
typedef int (*ngtcp2_recv_stateless_reset)(ngtcp2_conn *conn,
                                           const ngtcp2_pkt_stateless_reset *sr,
                                           void *user_data);
typedef int (*ngtcp2_extend_max_streams)(ngtcp2_conn *conn,
                                         uint64_t max_streams, void *user_data);
typedef int (*ngtcp2_extend_max_stream_data)(ngtcp2_conn *conn,
                                             int64_t stream_id,
                                             uint64_t max_data, void *user_data,
                                             void *stream_user_data);
typedef int (*ngtcp2_rand)(uint8_t *dest, size_t destlen,
                           const ngtcp2_rand_ctx *rand_ctx,
                           ngtcp2_rand_usage usage);
typedef int (*ngtcp2_get_new_connection_id)(ngtcp2_conn *conn, ngtcp2_cid *cid,
                                            uint8_t *token, size_t cidlen,
                                            void *user_data);
typedef int (*ngtcp2_remove_connection_id)(ngtcp2_conn *conn,
                                           const ngtcp2_cid *cid,
                                           void *user_data);
typedef int (*ngtcp2_update_key)(
    ngtcp2_conn *conn, uint8_t *rx_secret, uint8_t *tx_secret,
    ngtcp2_crypto_aead_ctx *rx_aead_ctx, uint8_t *rx_iv,
    ngtcp2_crypto_aead_ctx *tx_aead_ctx, uint8_t *tx_iv,
    const uint8_t *current_rx_secret, const uint8_t *current_tx_secret,
    size_t secretlen, void *user_data);
typedef int (*ngtcp2_path_validation)(ngtcp2_conn *conn,
                                      const ngtcp2_path *path,
                                      ngtcp2_path_validation_result res,
                                      void *user_data);
typedef int (*ngtcp2_select_preferred_addr)(ngtcp2_conn *conn,
                                            ngtcp2_addr *dest,
                                            const ngtcp2_preferred_addr *paddr,
                                            void *user_data);
typedef enum ngtcp2_connection_id_status_type
{
  NGTCP2_CONNECTION_ID_STATUS_TYPE_ACTIVATE,
  NGTCP2_CONNECTION_ID_STATUS_TYPE_DEACTIVATE
} ngtcp2_connection_id_status_type;
typedef int (*ngtcp2_connection_id_status)(ngtcp2_conn *conn, int type,
                                           uint64_t seq, const ngtcp2_cid *cid,
                                           const uint8_t *token,
                                           void *user_data);
typedef int (*ngtcp2_recv_new_token)(ngtcp2_conn *conn, const ngtcp2_vec *token,
                                     void *user_data);
typedef void (*ngtcp2_delete_crypto_aead_ctx)(ngtcp2_conn *conn,
                                              ngtcp2_crypto_aead_ctx *aead_ctx,
                                              void *user_data);
typedef void (*ngtcp2_delete_crypto_cipher_ctx)(
    ngtcp2_conn *conn, ngtcp2_crypto_cipher_ctx *cipher_ctx, void *user_data);
typedef struct ngtcp2_conn_callbacks
{
  ngtcp2_client_initial client_initial;
  ngtcp2_recv_client_initial recv_client_initial;
  ngtcp2_recv_crypto_data recv_crypto_data;
  ngtcp2_handshake_completed handshake_completed;
  ngtcp2_recv_version_negotiation recv_version_negotiation;
  ngtcp2_encrypt encrypt;
  ngtcp2_decrypt decrypt;
  ngtcp2_hp_mask hp_mask;
  ngtcp2_recv_stream_data recv_stream_data;
  ngtcp2_acked_crypto_offset acked_crypto_offset;
  ngtcp2_acked_stream_data_offset acked_stream_data_offset;
  ngtcp2_stream_open stream_open;
  ngtcp2_stream_close stream_close;
  ngtcp2_recv_stateless_reset recv_stateless_reset;
  ngtcp2_recv_retry recv_retry;
  ngtcp2_extend_max_streams extend_max_local_streams_bidi;
  ngtcp2_extend_max_streams extend_max_local_streams_uni;
  ngtcp2_rand rand;
  ngtcp2_get_new_connection_id get_new_connection_id;
  ngtcp2_remove_connection_id remove_connection_id;
  ngtcp2_update_key update_key;
  ngtcp2_path_validation path_validation;
  ngtcp2_select_preferred_addr select_preferred_addr;
  ngtcp2_stream_reset stream_reset;
  ngtcp2_extend_max_streams extend_max_remote_streams_bidi;
  ngtcp2_extend_max_streams extend_max_remote_streams_uni;
  ngtcp2_extend_max_stream_data extend_max_stream_data;
  ngtcp2_connection_id_status dcid_status;
  ngtcp2_handshake_confirmed handshake_confirmed;
  ngtcp2_recv_new_token recv_new_token;
  ngtcp2_delete_crypto_aead_ctx delete_crypto_aead_ctx;
  ngtcp2_delete_crypto_cipher_ctx delete_crypto_cipher_ctx;
} ngtcp2_conn_callbacks;
ngtcp2_ssize ngtcp2_pkt_write_connection_close(
    uint8_t *dest, size_t destlen, uint32_t version, const ngtcp2_cid *dcid,
    const ngtcp2_cid *scid, uint64_t error_code, ngtcp2_encrypt encrypt,
    const ngtcp2_crypto_aead *aead, const ngtcp2_crypto_aead_ctx *aead_ctx,
    const uint8_t *iv, ngtcp2_hp_mask hp_mask, const ngtcp2_crypto_cipher *hp,
    const ngtcp2_crypto_cipher_ctx *hp_ctx);
ngtcp2_ssize ngtcp2_pkt_write_retry(
    uint8_t *dest, size_t destlen, uint32_t version, const ngtcp2_cid *dcid,
    const ngtcp2_cid *scid, const ngtcp2_cid *odcid, const uint8_t *token,
    size_t tokenlen, ngtcp2_encrypt encrypt, const ngtcp2_crypto_aead *aead,
    const ngtcp2_crypto_aead_ctx *aead_ctx);
int ngtcp2_accept(ngtcp2_pkt_hd *dest, const uint8_t *pkt,
                  size_t pktlen);
int ngtcp2_conn_client_new(ngtcp2_conn **pconn, const ngtcp2_cid *dcid,
                           const ngtcp2_cid *scid, const ngtcp2_path *path,
                           uint32_t version, const ngtcp2_conn_callbacks *callbacks,
                           const ngtcp2_settings *settings, const ngtcp2_mem *mem,
                           void *user_data);
int ngtcp2_conn_server_new(ngtcp2_conn **pconn, const ngtcp2_cid *dcid,
                           const ngtcp2_cid *scid, const ngtcp2_path *path,
                           uint32_t version, const ngtcp2_conn_callbacks *callbacks,
                           const ngtcp2_settings *settings, const ngtcp2_mem *mem,
                           void *user_data);
void ngtcp2_conn_del(ngtcp2_conn *conn);
int ngtcp2_conn_read_pkt(ngtcp2_conn *conn,
                         const ngtcp2_path *path,
                         const ngtcp2_pkt_info *pi,
                         const uint8_t *pkt, size_t pktlen,
                         ngtcp2_tstamp ts);
ngtcp2_ssize ngtcp2_conn_write_pkt(ngtcp2_conn *conn,
                                   ngtcp2_path *path,
                                   ngtcp2_pkt_info *pi,
                                   uint8_t *dest, size_t destlen,
                                   ngtcp2_tstamp ts);
void ngtcp2_conn_handshake_completed(ngtcp2_conn *conn);
int ngtcp2_conn_get_handshake_completed(ngtcp2_conn *conn);
int ngtcp2_conn_install_initial_key(
    ngtcp2_conn *conn, const ngtcp2_crypto_aead_ctx *rx_aead_ctx,
    const uint8_t *rx_iv, const ngtcp2_crypto_cipher_ctx *rx_hp_ctx,
    const ngtcp2_crypto_aead_ctx *tx_aead_ctx, const uint8_t *tx_iv,
    const ngtcp2_crypto_cipher_ctx *tx_hp_ctx, size_t ivlen);
int ngtcp2_conn_install_rx_handshake_key(
    ngtcp2_conn *conn, const ngtcp2_crypto_aead_ctx *aead_ctx,
    const uint8_t *iv, size_t ivlen, const ngtcp2_crypto_cipher_ctx *hp_ctx);
int ngtcp2_conn_install_tx_handshake_key(
    ngtcp2_conn *conn, const ngtcp2_crypto_aead_ctx *aead_ctx,
    const uint8_t *iv, size_t ivlen, const ngtcp2_crypto_cipher_ctx *hp_ctx);
void ngtcp2_conn_set_aead_overhead(ngtcp2_conn *conn,
                                   size_t aead_overhead);
size_t ngtcp2_conn_get_aead_overhead(ngtcp2_conn *conn);
int ngtcp2_conn_install_early_key(
    ngtcp2_conn *conn, const ngtcp2_crypto_aead_ctx *aead_ctx,
    const uint8_t *iv, size_t ivlen, const ngtcp2_crypto_cipher_ctx *hp_ctx);
int ngtcp2_conn_install_rx_key(
    ngtcp2_conn *conn, const uint8_t *secret, size_t secretlen,
    const ngtcp2_crypto_aead_ctx *aead_ctx, const uint8_t *iv, size_t ivlen,
    const ngtcp2_crypto_cipher_ctx *hp_ctx);
int ngtcp2_conn_install_tx_key(
    ngtcp2_conn *conn, const uint8_t *secret, size_t secretlen,
    const ngtcp2_crypto_aead_ctx *aead_ctx, const uint8_t *iv, size_t ivlen,
    const ngtcp2_crypto_cipher_ctx *hp_ctx);
int ngtcp2_conn_initiate_key_update(ngtcp2_conn *conn,
                                    ngtcp2_tstamp ts);
void ngtcp2_conn_set_tls_error(ngtcp2_conn *conn, int liberr);
int ngtcp2_conn_get_tls_error(ngtcp2_conn *conn);
ngtcp2_tstamp
ngtcp2_conn_loss_detection_expiry(ngtcp2_conn *conn);
ngtcp2_tstamp ngtcp2_conn_ack_delay_expiry(ngtcp2_conn *conn);
ngtcp2_tstamp ngtcp2_conn_get_expiry(ngtcp2_conn *conn);
int ngtcp2_conn_handle_expiry(ngtcp2_conn *conn,
                              ngtcp2_tstamp ts);
void ngtcp2_conn_cancel_expired_ack_delay_timer(ngtcp2_conn *conn,
                                                ngtcp2_tstamp ts);
ngtcp2_tstamp ngtcp2_conn_get_idle_expiry(ngtcp2_conn *conn);
ngtcp2_duration ngtcp2_conn_get_pto(ngtcp2_conn *conn);
int ngtcp2_conn_set_remote_transport_params(ngtcp2_conn *conn,
                                            const ngtcp2_transport_params *params);
void ngtcp2_conn_get_remote_transport_params(ngtcp2_conn *conn,
                                             ngtcp2_transport_params *params);
void ngtcp2_conn_set_early_remote_transport_params(
    ngtcp2_conn *conn, const ngtcp2_transport_params *params);
int ngtcp2_conn_set_local_transport_params(ngtcp2_conn *conn,
                                           const ngtcp2_transport_params *params);
void ngtcp2_conn_get_local_transport_params(ngtcp2_conn *conn,
                                            ngtcp2_transport_params *params);
int ngtcp2_conn_open_bidi_stream(ngtcp2_conn *conn,
                                 int64_t *pstream_id,
                                 void *stream_user_data);
int ngtcp2_conn_open_uni_stream(ngtcp2_conn *conn,
                                int64_t *pstream_id,
                                void *stream_user_data);
int ngtcp2_conn_shutdown_stream(ngtcp2_conn *conn,
                                int64_t stream_id,
                                uint64_t app_error_code);
int ngtcp2_conn_shutdown_stream_write(ngtcp2_conn *conn,
                                      int64_t stream_id,
                                      uint64_t app_error_code);
int ngtcp2_conn_shutdown_stream_read(ngtcp2_conn *conn,
                                     int64_t stream_id,
                                     uint64_t app_error_code);
typedef enum ngtcp2_write_stream_flag
{
  NGTCP2_WRITE_STREAM_FLAG_NONE = 0x00,
  NGTCP2_WRITE_STREAM_FLAG_MORE = 0x01,
  NGTCP2_WRITE_STREAM_FLAG_FIN = 0x02
} ngtcp2_write_stream_flag;
ngtcp2_ssize ngtcp2_conn_write_stream(
    ngtcp2_conn *conn, ngtcp2_path *path, ngtcp2_pkt_info *pi, uint8_t *dest,
    size_t destlen, ngtcp2_ssize *pdatalen, uint32_t flags, int64_t stream_id,
    const uint8_t *data, size_t datalen, ngtcp2_tstamp ts);
ngtcp2_ssize ngtcp2_conn_writev_stream(
    ngtcp2_conn *conn, ngtcp2_path *path, ngtcp2_pkt_info *pi, uint8_t *dest,
    size_t destlen, ngtcp2_ssize *pdatalen, uint32_t flags, int64_t stream_id,
    const ngtcp2_vec *datav, size_t datavcnt, ngtcp2_tstamp ts);
ngtcp2_ssize ngtcp2_conn_write_connection_close(
    ngtcp2_conn *conn, ngtcp2_path *path, ngtcp2_pkt_info *pi, uint8_t *dest,
    size_t destlen, uint64_t error_code, ngtcp2_tstamp ts);
ngtcp2_ssize ngtcp2_conn_write_application_close(
    ngtcp2_conn *conn, ngtcp2_path *path, ngtcp2_pkt_info *pi, uint8_t *dest,
    size_t destlen, uint64_t app_error_code, ngtcp2_tstamp ts);
int ngtcp2_conn_is_in_closing_period(ngtcp2_conn *conn);
int ngtcp2_conn_is_in_draining_period(ngtcp2_conn *conn);
int ngtcp2_conn_extend_max_stream_offset(ngtcp2_conn *conn,
                                         int64_t stream_id,
                                         uint64_t datalen);
void ngtcp2_conn_extend_max_offset(ngtcp2_conn *conn,
                                   uint64_t datalen);
void ngtcp2_conn_extend_max_streams_bidi(ngtcp2_conn *conn,
                                         size_t n);
void ngtcp2_conn_extend_max_streams_uni(ngtcp2_conn *conn,
                                        size_t n);
const ngtcp2_cid *ngtcp2_conn_get_dcid(ngtcp2_conn *conn);
size_t ngtcp2_conn_get_num_scid(ngtcp2_conn *conn);
size_t ngtcp2_conn_get_scid(ngtcp2_conn *conn, ngtcp2_cid *dest);
size_t ngtcp2_conn_get_num_active_dcid(ngtcp2_conn *conn);
typedef struct ngtcp2_cid_token
{
  uint64_t seq;
  ngtcp2_cid cid;
  ngtcp2_path_storage ps;
  uint8_t token[16];
  uint8_t token_present;
} ngtcp2_cid_token;
size_t ngtcp2_conn_get_active_dcid(ngtcp2_conn *conn,
                                   ngtcp2_cid_token *dest);
uint32_t ngtcp2_conn_get_negotiated_version(ngtcp2_conn *conn);
int ngtcp2_conn_early_data_rejected(ngtcp2_conn *conn);
void ngtcp2_conn_get_conn_stat(ngtcp2_conn *conn,
                               ngtcp2_conn_stat *cstat);
int ngtcp2_conn_on_loss_detection_timer(ngtcp2_conn *conn,
                                        ngtcp2_tstamp ts);
int ngtcp2_conn_submit_crypto_data(ngtcp2_conn *conn,
                                   ngtcp2_crypto_level crypto_level,
                                   const uint8_t *data, const size_t datalen);
int ngtcp2_conn_submit_new_token(ngtcp2_conn *conn,
                                 const uint8_t *token,
                                 size_t tokenlen);
void ngtcp2_conn_set_local_addr(ngtcp2_conn *conn,
                                const ngtcp2_addr *addr);
void ngtcp2_conn_set_remote_addr(ngtcp2_conn *conn,
                                 const ngtcp2_addr *addr);
const ngtcp2_addr *ngtcp2_conn_get_remote_addr(ngtcp2_conn *conn);
int ngtcp2_conn_initiate_migration(ngtcp2_conn *conn,
                                   const ngtcp2_path *path,
                                   ngtcp2_tstamp ts);
uint64_t ngtcp2_conn_get_max_local_streams_uni(ngtcp2_conn *conn);
uint64_t ngtcp2_conn_get_max_data_left(ngtcp2_conn *conn);
uint64_t ngtcp2_conn_get_streams_bidi_left(ngtcp2_conn *conn);
uint64_t ngtcp2_conn_get_streams_uni_left(ngtcp2_conn *conn);
void ngtcp2_conn_set_initial_crypto_ctx(ngtcp2_conn *conn,
                                        const ngtcp2_crypto_ctx *ctx);
const ngtcp2_crypto_ctx *
ngtcp2_conn_get_initial_crypto_ctx(ngtcp2_conn *conn);
void ngtcp2_conn_set_crypto_ctx(ngtcp2_conn *conn,
                                const ngtcp2_crypto_ctx *ctx);
void *ngtcp2_conn_get_tls_native_handle(ngtcp2_conn *conn);
void ngtcp2_conn_set_tls_native_handle(ngtcp2_conn *conn,
                                       void *tls_native_handle);
void ngtcp2_conn_set_retry_aead(ngtcp2_conn *conn, const ngtcp2_crypto_aead *aead,
                                const ngtcp2_crypto_aead_ctx *aead_ctx);
const ngtcp2_crypto_ctx *
ngtcp2_conn_get_crypto_ctx(ngtcp2_conn *conn);
typedef enum ngtcp2_connection_close_error_code_type
{
  NGTCP2_CONNECTION_CLOSE_ERROR_CODE_TYPE_TRANSPORT,
  NGTCP2_CONNECTION_CLOSE_ERROR_CODE_TYPE_APPLICATION,
} ngtcp2_connection_close_error_code_type;
typedef struct ngtcp2_connection_close_error_code
{
  uint64_t error_code;
  ngtcp2_connection_close_error_code_type type;
} ngtcp2_connection_close_error_code;
void ngtcp2_conn_get_connection_close_error_code(
    ngtcp2_conn *conn, ngtcp2_connection_close_error_code *ccec);
int ngtcp2_conn_is_local_stream(ngtcp2_conn *conn,
                                int64_t stream_id);
int ngtcp2_conn_is_server(ngtcp2_conn *conn);
int ngtcp2_conn_after_retry(ngtcp2_conn *conn);
int ngtcp2_conn_set_stream_user_data(ngtcp2_conn *conn,
                                     int64_t stream_id,
                                     void *stream_user_data);
const char *ngtcp2_strerror(int liberr);
int ngtcp2_err_is_fatal(int liberr);
uint64_t ngtcp2_err_infer_quic_transport_error_code(int liberr);
ngtcp2_addr *ngtcp2_addr_init(ngtcp2_addr *dest,
                              const struct sockaddr *addr,
                              size_t addrlen, void *user_data);
void ngtcp2_path_storage_init(ngtcp2_path_storage *ps,
                              const struct sockaddr *local_addr,
                              size_t local_addrlen,
                              void *local_user_data,
                              const struct sockaddr *remote_addr,
                              size_t remote_addrlen,
                              void *remote_user_data);
void ngtcp2_path_storage_zero(ngtcp2_path_storage *ps);
void ngtcp2_settings_default(ngtcp2_settings *settings);
const ngtcp2_mem *ngtcp2_mem_default(void);
typedef struct ngtcp2_info
{
  int age;
  int version_num;
  const char *version_str;
} ngtcp2_info;
ngtcp2_info *ngtcp2_version(int least_version);
int ngtcp2_is_bidi_stream(int64_t stream_id);
typedef enum
{
  NGTCP2_LOG_EVENT_NONE,
  NGTCP2_LOG_EVENT_CON,
  NGTCP2_LOG_EVENT_PKT,
  NGTCP2_LOG_EVENT_FRM,
  NGTCP2_LOG_EVENT_RCV,
  NGTCP2_LOG_EVENT_CRY,
  NGTCP2_LOG_EVENT_PTV,
} ngtcp2_log_event;
void ngtcp2_log_info(ngtcp2_log *log, ngtcp2_log_event ev,
                     const char *fmt, ...);
void *ngtcp2_mem_malloc(const ngtcp2_mem *mem, size_t size);
void ngtcp2_mem_free(const ngtcp2_mem *mem, void *ptr);
void ngtcp2_mem_free2(ngtcp2_free free_func, void *ptr, void *mem_user_data);
void *ngtcp2_mem_calloc(const ngtcp2_mem *mem, size_t nmemb, size_t size);
void *ngtcp2_mem_realloc(const ngtcp2_mem *mem, void *ptr, size_t size);
typedef enum
{
  NGTCP2_CRYPTO_KM_FLAG_NONE,
  NGTCP2_CRYPTO_KM_FLAG_KEY_PHASE_ONE = 0x01,
} ngtcp2_crypto_km_flag;
typedef struct
{
  ngtcp2_vec secret;
  ngtcp2_crypto_aead_ctx aead_ctx;
  ngtcp2_vec iv;
  int64_t pkt_num;
  uint64_t use_count;
  uint8_t flags;
} ngtcp2_crypto_km;
int ngtcp2_crypto_km_new(ngtcp2_crypto_km **pckm, const uint8_t *secret,
                         size_t secretlen,
                         const ngtcp2_crypto_aead_ctx *aead_ctx,
                         const uint8_t *iv, size_t ivlen,
                         const ngtcp2_mem *mem);
int ngtcp2_crypto_km_nocopy_new(ngtcp2_crypto_km **pckm, size_t secretlen,
                                size_t ivlen, const ngtcp2_mem *mem);
void ngtcp2_crypto_km_del(ngtcp2_crypto_km *ckm, const ngtcp2_mem *mem);
typedef struct
{
  ngtcp2_crypto_aead aead;
  ngtcp2_crypto_cipher hp;
  ngtcp2_crypto_km *ckm;
  ngtcp2_crypto_cipher_ctx hp_ctx;
  size_t aead_overhead;
  ngtcp2_encrypt encrypt;
  ngtcp2_decrypt decrypt;
  ngtcp2_hp_mask hp_mask;
} ngtcp2_crypto_cc;
void ngtcp2_crypto_create_nonce(uint8_t *dest, const uint8_t *iv, size_t ivlen,
                                int64_t pkt_num);
void *ngtcp2_cpymem(void *dest, const void *src, size_t n);
uint8_t *ngtcp2_setmem(uint8_t *dest, uint8_t b, size_t n);
uint8_t *ngtcp2_encode_hex(uint8_t *dest, const uint8_t *data, size_t len);
uint8_t *ngtcp2_encode_ipv4(uint8_t *dest, const uint8_t *addr);
uint8_t *ngtcp2_encode_ipv6(uint8_t *dest, const uint8_t *addr);
char *ngtcp2_encode_printable_ascii(char *dest, const uint8_t *data,
                                    size_t len);
int ngtcp2_verify_stateless_reset_token(const uint8_t *want,
                                        const uint8_t *got);
int ngtcp2_check_invalid_stateless_reset_token(const uint8_t *token);
int ngtcp2_cmemeq(const uint8_t *a, const uint8_t *b, size_t n);
uint64_t ngtcp2_get_uint64(const uint8_t *p);
uint64_t ngtcp2_get_uint48(const uint8_t *p);
uint32_t ngtcp2_get_uint32(const uint8_t *p);
uint32_t ngtcp2_get_uint24(const uint8_t *p);
uint16_t ngtcp2_get_uint16(const uint8_t *p);
uint64_t ngtcp2_get_varint(size_t *plen, const uint8_t *p);
int64_t ngtcp2_get_pkt_num(const uint8_t *p, size_t pkt_numlen);
uint8_t *ngtcp2_put_uint64be(uint8_t *p, uint64_t n);
uint8_t *ngtcp2_put_uint48be(uint8_t *p, uint64_t n);
uint8_t *ngtcp2_put_uint32be(uint8_t *p, uint32_t n);
uint8_t *ngtcp2_put_uint24be(uint8_t *p, uint32_t n);
uint8_t *ngtcp2_put_uint16be(uint8_t *p, uint16_t n);
uint8_t *ngtcp2_put_varint(uint8_t *p, uint64_t n);
uint8_t *ngtcp2_put_varint14(uint8_t *p, uint16_t n);
uint8_t *ngtcp2_put_pkt_num(uint8_t *p, int64_t pkt_num, size_t len);
size_t ngtcp2_get_varint_len(const uint8_t *p);
size_t ngtcp2_put_varint_len(uint64_t n);
int64_t ngtcp2_nth_server_bidi_id(uint64_t n);
int64_t ngtcp2_nth_client_bidi_id(uint64_t n);
int64_t ngtcp2_nth_server_uni_id(uint64_t n);
int64_t ngtcp2_nth_client_uni_id(uint64_t n);
uint64_t ngtcp2_ord_stream_id(int64_t stream_id);
typedef struct ngtcp2_pkt_retry
{
  ngtcp2_cid odcid;
  ngtcp2_vec token;
  uint8_t tag[16];
} ngtcp2_pkt_retry;
typedef enum
{
  NGTCP2_FRAME_PADDING = 0x00,
  NGTCP2_FRAME_PING = 0x01,
  NGTCP2_FRAME_ACK = 0x02,
  NGTCP2_FRAME_ACK_ECN = 0x03,
  NGTCP2_FRAME_RESET_STREAM = 0x04,
  NGTCP2_FRAME_STOP_SENDING = 0x05,
  NGTCP2_FRAME_CRYPTO = 0x06,
  NGTCP2_FRAME_NEW_TOKEN = 0x07,
  NGTCP2_FRAME_STREAM = 0x08,
  NGTCP2_FRAME_MAX_DATA = 0x10,
  NGTCP2_FRAME_MAX_STREAM_DATA = 0x11,
  NGTCP2_FRAME_MAX_STREAMS_BIDI = 0x12,
  NGTCP2_FRAME_MAX_STREAMS_UNI = 0x13,
  NGTCP2_FRAME_DATA_BLOCKED = 0x14,
  NGTCP2_FRAME_STREAM_DATA_BLOCKED = 0x15,
  NGTCP2_FRAME_STREAMS_BLOCKED_BIDI = 0x16,
  NGTCP2_FRAME_STREAMS_BLOCKED_UNI = 0x17,
  NGTCP2_FRAME_NEW_CONNECTION_ID = 0x18,
  NGTCP2_FRAME_RETIRE_CONNECTION_ID = 0x19,
  NGTCP2_FRAME_PATH_CHALLENGE = 0x1a,
  NGTCP2_FRAME_PATH_RESPONSE = 0x1b,
  NGTCP2_FRAME_CONNECTION_CLOSE = 0x1c,
  NGTCP2_FRAME_CONNECTION_CLOSE_APP = 0x1d,
  NGTCP2_FRAME_HANDSHAKE_DONE = 0x1e,
} ngtcp2_frame_type;
typedef struct
{
  uint8_t type;
  uint8_t flags;
  uint8_t fin;
  int64_t stream_id;
  uint64_t offset;
  size_t datacnt;
  ngtcp2_vec data[1];
} ngtcp2_stream;
typedef struct
{
  uint64_t gap;
  uint64_t blklen;
} ngtcp2_ack_blk;
typedef struct
{
  uint8_t type;
  int64_t largest_ack;
  uint64_t ack_delay;
  ngtcp2_duration ack_delay_unscaled;
  struct
  {
    uint64_t ect0;
    uint64_t ect1;
    uint64_t ce;
  } ecn;
  uint64_t first_ack_blklen;
  size_t num_blks;
  ngtcp2_ack_blk blks[1];
} ngtcp2_ack;
typedef struct
{
  uint8_t type;
  size_t len;
} ngtcp2_padding;
typedef struct
{
  uint8_t type;
  int64_t stream_id;
  uint64_t app_error_code;
  uint64_t final_size;
} ngtcp2_reset_stream;
typedef struct
{
  uint8_t type;
  uint64_t error_code;
  uint64_t frame_type;
  size_t reasonlen;
  uint8_t *reason;
} ngtcp2_connection_close;
typedef struct
{
  uint8_t type;
  uint64_t max_data;
} ngtcp2_max_data;
typedef struct
{
  uint8_t type;
  int64_t stream_id;
  uint64_t max_stream_data;
} ngtcp2_max_stream_data;
typedef struct
{
  uint8_t type;
  uint64_t max_streams;
} ngtcp2_max_streams;
typedef struct
{
  uint8_t type;
} ngtcp2_ping;
typedef struct
{
  uint8_t type;
  uint64_t offset;
} ngtcp2_data_blocked;
typedef struct
{
  uint8_t type;
  int64_t stream_id;
  uint64_t offset;
} ngtcp2_stream_data_blocked;
typedef struct
{
  uint8_t type;
  uint64_t stream_limit;
} ngtcp2_streams_blocked;
typedef struct
{
  uint8_t type;
  uint64_t seq;
  uint64_t retire_prior_to;
  ngtcp2_cid cid;
  uint8_t stateless_reset_token[16];
} ngtcp2_new_connection_id;
typedef struct
{
  uint8_t type;
  int64_t stream_id;
  uint64_t app_error_code;
} ngtcp2_stop_sending;
typedef struct
{
  uint8_t type;
  uint8_t data[8];
} ngtcp2_path_challenge;
typedef struct
{
  uint8_t type;
  uint8_t data[8];
} ngtcp2_path_response;
typedef struct
{
  uint8_t type;
  uint64_t offset;
  size_t datacnt;
  ngtcp2_vec data[1];
} ngtcp2_crypto;
typedef struct
{
  uint8_t type;
  ngtcp2_vec token;
} ngtcp2_new_token;
typedef struct
{
  uint8_t type;
  uint64_t seq;
} ngtcp2_retire_connection_id;
typedef struct
{
  uint8_t type;
} ngtcp2_handshake_done;
typedef union
{
  uint8_t type;
  ngtcp2_stream stream;
  ngtcp2_ack ack;
  ngtcp2_padding padding;
  ngtcp2_reset_stream reset_stream;
  ngtcp2_connection_close connection_close;
  ngtcp2_max_data max_data;
  ngtcp2_max_stream_data max_stream_data;
  ngtcp2_max_streams max_streams;
  ngtcp2_ping ping;
  ngtcp2_data_blocked data_blocked;
  ngtcp2_stream_data_blocked stream_data_blocked;
  ngtcp2_streams_blocked streams_blocked;
  ngtcp2_new_connection_id new_connection_id;
  ngtcp2_stop_sending stop_sending;
  ngtcp2_path_challenge path_challenge;
  ngtcp2_path_response path_response;
  ngtcp2_crypto crypto;
  ngtcp2_new_token new_token;
  ngtcp2_retire_connection_id retire_connection_id;
  ngtcp2_handshake_done handshake_done;
} ngtcp2_frame;
struct ngtcp2_pkt_chain;
typedef struct ngtcp2_pkt_chain ngtcp2_pkt_chain;
struct ngtcp2_pkt_chain
{
  ngtcp2_path_storage path;
  ngtcp2_pkt_info pi;
  ngtcp2_pkt_chain *next;
  uint8_t *pkt;
  size_t pktlen;
  ngtcp2_tstamp ts;
};
int ngtcp2_pkt_chain_new(ngtcp2_pkt_chain **ppc, const ngtcp2_path *path,
                         const ngtcp2_pkt_info *pi, const uint8_t *pkt,
                         size_t pktlen, ngtcp2_tstamp ts,
                         const ngtcp2_mem *mem);
void ngtcp2_pkt_chain_del(ngtcp2_pkt_chain *pc, const ngtcp2_mem *mem);
void ngtcp2_pkt_hd_init(ngtcp2_pkt_hd *hd, uint8_t flags, uint8_t type,
                        const ngtcp2_cid *dcid, const ngtcp2_cid *scid,
                        int64_t pkt_num, size_t pkt_numlen, uint32_t version,
                        size_t len);
ngtcp2_ssize ngtcp2_pkt_encode_hd_long(uint8_t *out, size_t outlen,
                                       const ngtcp2_pkt_hd *hd);
ngtcp2_ssize ngtcp2_pkt_encode_hd_short(uint8_t *out, size_t outlen,
                                        const ngtcp2_pkt_hd *hd);
ngtcp2_ssize ngtcp2_pkt_decode_frame(ngtcp2_frame *dest, const uint8_t *payload,
                                     size_t payloadlen);
ngtcp2_ssize ngtcp2_pkt_encode_frame(uint8_t *out, size_t outlen,
                                     ngtcp2_frame *fr);
size_t ngtcp2_pkt_decode_version_negotiation(uint32_t *dest,
                                             const uint8_t *payload,
                                             size_t payloadlen);
int ngtcp2_pkt_decode_stateless_reset(ngtcp2_pkt_stateless_reset *sr,
                                      const uint8_t *payload,
                                      size_t payloadlen);
int ngtcp2_pkt_decode_retry(ngtcp2_pkt_retry *dest, const uint8_t *payload,
                            size_t payloadlen);
ngtcp2_ssize ngtcp2_pkt_decode_stream_frame(ngtcp2_stream *dest,
                                            const uint8_t *payload,
                                            size_t payloadlen);
ngtcp2_ssize ngtcp2_pkt_decode_ack_frame(ngtcp2_ack *dest,
                                         const uint8_t *payload,
                                         size_t payloadlen);
size_t ngtcp2_pkt_decode_padding_frame(ngtcp2_padding *dest,
                                       const uint8_t *payload,
                                       size_t payloadlen);
ngtcp2_ssize ngtcp2_pkt_decode_reset_stream_frame(ngtcp2_reset_stream *dest,
                                                  const uint8_t *payload,
                                                  size_t payloadlen);
ngtcp2_ssize ngtcp2_pkt_decode_connection_close_frame(
    ngtcp2_connection_close *dest, const uint8_t *payload, size_t payloadlen);
ngtcp2_ssize ngtcp2_pkt_decode_max_data_frame(ngtcp2_max_data *dest,
                                              const uint8_t *payload,
                                              size_t payloadlen);
ngtcp2_ssize ngtcp2_pkt_decode_max_stream_data_frame(
    ngtcp2_max_stream_data *dest, const uint8_t *payload, size_t payloadlen);
ngtcp2_ssize ngtcp2_pkt_decode_max_streams_frame(ngtcp2_max_streams *dest,
                                                 const uint8_t *payload,
                                                 size_t payloadlen);
ngtcp2_ssize ngtcp2_pkt_decode_ping_frame(ngtcp2_ping *dest,
                                          const uint8_t *payload,
                                          size_t payloadlen);
ngtcp2_ssize ngtcp2_pkt_decode_data_blocked_frame(ngtcp2_data_blocked *dest,
                                                  const uint8_t *payload,
                                                  size_t payloadlen);
ngtcp2_ssize
ngtcp2_pkt_decode_stream_data_blocked_frame(ngtcp2_stream_data_blocked *dest,
                                            const uint8_t *payload,
                                            size_t payloadlen);
ngtcp2_ssize ngtcp2_pkt_decode_streams_blocked_frame(
    ngtcp2_streams_blocked *dest, const uint8_t *payload, size_t payloadlen);
ngtcp2_ssize ngtcp2_pkt_decode_new_connection_id_frame(
    ngtcp2_new_connection_id *dest, const uint8_t *payload, size_t payloadlen);
ngtcp2_ssize ngtcp2_pkt_decode_stop_sending_frame(ngtcp2_stop_sending *dest,
                                                  const uint8_t *payload,
                                                  size_t payloadlen);
ngtcp2_ssize ngtcp2_pkt_decode_path_challenge_frame(ngtcp2_path_challenge *dest,
                                                    const uint8_t *payload,
                                                    size_t payloadlen);
ngtcp2_ssize ngtcp2_pkt_decode_path_response_frame(ngtcp2_path_response *dest,
                                                   const uint8_t *payload,
                                                   size_t payloadlen);
ngtcp2_ssize ngtcp2_pkt_decode_crypto_frame(ngtcp2_crypto *dest,
                                            const uint8_t *payload,
                                            size_t payloadlen);
ngtcp2_ssize ngtcp2_pkt_decode_new_token_frame(ngtcp2_new_token *dest,
                                               const uint8_t *payload,
                                               size_t payloadlen);
ngtcp2_ssize
ngtcp2_pkt_decode_retire_connection_id_frame(ngtcp2_retire_connection_id *dest,
                                             const uint8_t *payload,
                                             size_t payloadlen);
ngtcp2_ssize ngtcp2_pkt_decode_handshake_done_frame(ngtcp2_handshake_done *dest,
                                                    const uint8_t *payload,
                                                    size_t payloadlen);
ngtcp2_ssize ngtcp2_pkt_encode_stream_frame(uint8_t *out, size_t outlen,
                                            ngtcp2_stream *fr);
ngtcp2_ssize ngtcp2_pkt_encode_ack_frame(uint8_t *out, size_t outlen,
                                         ngtcp2_ack *fr);
ngtcp2_ssize ngtcp2_pkt_encode_padding_frame(uint8_t *out, size_t outlen,
                                             const ngtcp2_padding *fr);
ngtcp2_ssize
ngtcp2_pkt_encode_reset_stream_frame(uint8_t *out, size_t outlen,
                                     const ngtcp2_reset_stream *fr);
ngtcp2_ssize
ngtcp2_pkt_encode_connection_close_frame(uint8_t *out, size_t outlen,
                                         const ngtcp2_connection_close *fr);
ngtcp2_ssize ngtcp2_pkt_encode_max_data_frame(uint8_t *out, size_t outlen,
                                              const ngtcp2_max_data *fr);
ngtcp2_ssize
ngtcp2_pkt_encode_max_stream_data_frame(uint8_t *out, size_t outlen,
                                        const ngtcp2_max_stream_data *fr);
ngtcp2_ssize ngtcp2_pkt_encode_max_streams_frame(uint8_t *out, size_t outlen,
                                                 const ngtcp2_max_streams *fr);
ngtcp2_ssize ngtcp2_pkt_encode_ping_frame(uint8_t *out, size_t outlen,
                                          const ngtcp2_ping *fr);
ngtcp2_ssize
ngtcp2_pkt_encode_data_blocked_frame(uint8_t *out, size_t outlen,
                                     const ngtcp2_data_blocked *fr);
ngtcp2_ssize ngtcp2_pkt_encode_stream_data_blocked_frame(
    uint8_t *out, size_t outlen, const ngtcp2_stream_data_blocked *fr);
ngtcp2_ssize
ngtcp2_pkt_encode_streams_blocked_frame(uint8_t *out, size_t outlen,
                                        const ngtcp2_streams_blocked *fr);
ngtcp2_ssize
ngtcp2_pkt_encode_new_connection_id_frame(uint8_t *out, size_t outlen,
                                          const ngtcp2_new_connection_id *fr);
ngtcp2_ssize
ngtcp2_pkt_encode_stop_sending_frame(uint8_t *out, size_t outlen,
                                     const ngtcp2_stop_sending *fr);
ngtcp2_ssize
ngtcp2_pkt_encode_path_challenge_frame(uint8_t *out, size_t outlen,
                                       const ngtcp2_path_challenge *fr);
ngtcp2_ssize
ngtcp2_pkt_encode_path_response_frame(uint8_t *out, size_t outlen,
                                      const ngtcp2_path_response *fr);
ngtcp2_ssize ngtcp2_pkt_encode_crypto_frame(uint8_t *out, size_t outlen,
                                            const ngtcp2_crypto *fr);
ngtcp2_ssize ngtcp2_pkt_encode_new_token_frame(uint8_t *out, size_t outlen,
                                               const ngtcp2_new_token *fr);
ngtcp2_ssize ngtcp2_pkt_encode_retire_connection_id_frame(
    uint8_t *out, size_t outlen, const ngtcp2_retire_connection_id *fr);
ngtcp2_ssize
ngtcp2_pkt_encode_handshake_done_frame(uint8_t *out, size_t outlen,
                                       const ngtcp2_handshake_done *fr);
int64_t ngtcp2_pkt_adjust_pkt_num(int64_t max_pkt_num, int64_t pkt_num,
                                  size_t n);
int ngtcp2_pkt_validate_ack(ngtcp2_ack *fr);
size_t ngtcp2_pkt_stream_max_datalen(int64_t stream_id, uint64_t offset,
                                     size_t len, size_t left);
size_t ngtcp2_pkt_crypto_max_datalen(uint64_t offset, size_t len, size_t left);
int ngtcp2_pkt_verify_reserved_bits(uint8_t c);
ngtcp2_ssize ngtcp2_pkt_encode_pseudo_retry(
    uint8_t *dest, size_t destlen, const ngtcp2_pkt_hd *hd, uint8_t unused,
    const ngtcp2_cid *odcid, const uint8_t *token, size_t tokenlen);
int ngtcp2_pkt_verify_retry_tag(const ngtcp2_pkt_retry *retry,
                                const uint8_t *pkt, size_t pktlen,
                                ngtcp2_encrypt encrypt,
                                const ngtcp2_crypto_aead *aead,
                                const ngtcp2_crypto_aead_ctx *aead_ctx);
struct ngtcp2_log
{
  ngtcp2_printf log_printf;
  ngtcp2_tstamp ts;
  ngtcp2_tstamp last_ts;
  void *user_data;
  uint8_t scid[20 * 2 + 1];
};
typedef struct ngtcp2_log ngtcp2_log;
void ngtcp2_log_init(ngtcp2_log *log, const ngtcp2_cid *scid,
                     ngtcp2_printf log_printf, ngtcp2_tstamp ts,
                     void *user_data);
void ngtcp2_log_rx_fr(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                      const ngtcp2_frame *fr);
void ngtcp2_log_tx_fr(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                      const ngtcp2_frame *fr);
void ngtcp2_log_rx_vn(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                      const uint32_t *sv, size_t nsv);
void ngtcp2_log_rx_sr(ngtcp2_log *log, const ngtcp2_pkt_stateless_reset *sr);
void ngtcp2_log_remote_tp(ngtcp2_log *log, uint8_t exttype,
                          const ngtcp2_transport_params *params);
void ngtcp2_log_pkt_lost(ngtcp2_log *log, int64_t pkt_num, uint8_t type,
                         uint8_t flags, ngtcp2_tstamp sent_ts);
void ngtcp2_log_rx_pkt_hd(ngtcp2_log *log, const ngtcp2_pkt_hd *hd);
void ngtcp2_log_tx_pkt_hd(ngtcp2_log *log, const ngtcp2_pkt_hd *hd);
void ngtcp2_log_tx_cancel(ngtcp2_log *log, const ngtcp2_pkt_hd *hd);
typedef struct
{
  size_t index;
} ngtcp2_pq_entry;
typedef int (*ngtcp2_less)(const ngtcp2_pq_entry *lhs,
                           const ngtcp2_pq_entry *rhs);
typedef struct
{
  ngtcp2_pq_entry **q;
  const ngtcp2_mem *mem;
  size_t length;
  size_t capacity;
  ngtcp2_less less;
} ngtcp2_pq;
void ngtcp2_pq_init(ngtcp2_pq *pq, ngtcp2_less less, const ngtcp2_mem *mem);
void ngtcp2_pq_free(ngtcp2_pq *pq);
int ngtcp2_pq_push(ngtcp2_pq *pq, ngtcp2_pq_entry *item);
ngtcp2_pq_entry *ngtcp2_pq_top(ngtcp2_pq *pq);
void ngtcp2_pq_pop(ngtcp2_pq *pq);
int ngtcp2_pq_empty(ngtcp2_pq *pq);
size_t ngtcp2_pq_size(ngtcp2_pq *pq);
typedef int (*ngtcp2_pq_item_cb)(ngtcp2_pq_entry *item, void *arg);
int ngtcp2_pq_each(ngtcp2_pq *pq, ngtcp2_pq_item_cb fun, void *arg);
void ngtcp2_pq_remove(ngtcp2_pq *pq, ngtcp2_pq_entry *item);
void ngtcp2_path_init(ngtcp2_path *path, const ngtcp2_addr *local,
                      const ngtcp2_addr *remote);
void ngtcp2_path_copy(ngtcp2_path *dest, const ngtcp2_path *src);
int ngtcp2_path_eq(const ngtcp2_path *a, const ngtcp2_path *b);
void ngtcp2_path_storage_init2(ngtcp2_path_storage *ps,
                               const ngtcp2_path *path);
typedef enum
{
  NGTCP2_SCID_FLAG_NONE,
  NGTCP2_SCID_FLAG_USED = 0x01,
  NGTCP2_SCID_FLAG_RETIRED = 0x02,
} ngtcp2_scid_flag;
typedef struct
{
  ngtcp2_pq_entry pe;
  uint64_t seq;
  ngtcp2_cid cid;
  ngtcp2_tstamp ts_retired;
  uint8_t flags;
  uint8_t token[16];
} ngtcp2_scid;
typedef struct
{
  uint64_t seq;
  ngtcp2_cid cid;
  ngtcp2_path_storage ps;
  ngtcp2_tstamp ts_retired;
  uint8_t token[16];
} ngtcp2_dcid;
void ngtcp2_cid_zero(ngtcp2_cid *cid);
int ngtcp2_cid_eq(const ngtcp2_cid *cid, const ngtcp2_cid *other);
int ngtcp2_cid_less(const ngtcp2_cid *lhs, const ngtcp2_cid *rhs);
int ngtcp2_cid_empty(const ngtcp2_cid *cid);
void ngtcp2_scid_init(ngtcp2_scid *scid, uint64_t seq, const ngtcp2_cid *cid,
                      const uint8_t *token);
void ngtcp2_scid_copy(ngtcp2_scid *dest, const ngtcp2_scid *src);
void ngtcp2_dcid_init(ngtcp2_dcid *dcid, uint64_t seq, const ngtcp2_cid *cid,
                      const uint8_t *token);
void ngtcp2_dcid_copy(ngtcp2_dcid *dest, const ngtcp2_dcid *src);
void ngtcp2_dcid_copy_no_path(ngtcp2_dcid *dest, const ngtcp2_dcid *src);
int ngtcp2_dcid_verify_uniqueness(ngtcp2_dcid *dcid, uint64_t seq,
                                  const ngtcp2_cid *cid, const uint8_t *token);
ngtcp2_vec *ngtcp2_vec_init(ngtcp2_vec *vec, const uint8_t *base, size_t len);
int ngtcp2_vec_new(ngtcp2_vec **pvec, const uint8_t *data, size_t datalen,
                   const ngtcp2_mem *mem);
void ngtcp2_vec_del(ngtcp2_vec *vec, const ngtcp2_mem *mem);
size_t ngtcp2_vec_len(const ngtcp2_vec *vec, size_t n);
ngtcp2_ssize ngtcp2_vec_split(ngtcp2_vec *src, size_t *psrccnt, ngtcp2_vec *dst,
                              size_t *pdstcnt, size_t left, size_t maxcnt);
size_t ngtcp2_vec_merge(ngtcp2_vec *dst, size_t *pdstcnt, ngtcp2_vec *src,
                        size_t *psrccnt, size_t left, size_t maxcnt);
size_t ngtcp2_vec_copy_at_most(ngtcp2_vec *dst, size_t *pnwritten,
                               size_t dstcnt, const ngtcp2_vec *src,
                               size_t srccnt, size_t left);
void ngtcp2_vec_copy(ngtcp2_vec *dst, const ngtcp2_vec *src, size_t cnt);
void ngtcp2_addr_copy(ngtcp2_addr *dest, const ngtcp2_addr *src);
void ngtcp2_addr_copy_byte(ngtcp2_addr *dest, const struct sockaddr *addr,
                           size_t addrlen);
int ngtcp2_addr_eq(const ngtcp2_addr *a, const ngtcp2_addr *b);
typedef enum ngtcp2_addr_compare_flag
{
  NGTCP2_ADDR_COMPARE_FLAG_NONE = 0x0,
  NGTCP2_ADDR_COMPARE_FLAG_ADDR = 0x1,
  NGTCP2_ADDR_COMPARE_FLAG_PORT = 0x2,
  NGTCP2_ADDR_COMPARE_FLAG_FAMILY = 0x4,
} ngtcp2_addr_compare_flag;
uint32_t ngtcp2_addr_compare(const ngtcp2_addr *a, const ngtcp2_addr *b);
int ngtcp2_addr_empty(const ngtcp2_addr *addr);
typedef void ngtcp2_ksl_key;
struct ngtcp2_ksl_node;
typedef struct ngtcp2_ksl_node ngtcp2_ksl_node;
struct ngtcp2_ksl_blk;
typedef struct ngtcp2_ksl_blk ngtcp2_ksl_blk;
struct ngtcp2_ksl_node
{
  union
  {
    ngtcp2_ksl_blk *blk;
    void *data;
  };
  union
  {
    uint64_t align;
    uint8_t key[1];
  };
};
struct ngtcp2_ksl_blk
{
  ngtcp2_ksl_blk *next;
  ngtcp2_ksl_blk *prev;
  size_t n;
  int leaf;
  union
  {
    uint64_t align;
    uint8_t nodes[1];
  };
};
typedef int (*ngtcp2_ksl_compar)(const ngtcp2_ksl_key *lhs,
                                 const ngtcp2_ksl_key *rhs);
struct ngtcp2_ksl;
typedef struct ngtcp2_ksl ngtcp2_ksl;
struct ngtcp2_ksl_it;
typedef struct ngtcp2_ksl_it ngtcp2_ksl_it;
struct ngtcp2_ksl_it
{
  const ngtcp2_ksl *ksl;
  ngtcp2_ksl_blk *blk;
  size_t i;
};
struct ngtcp2_ksl
{
  ngtcp2_ksl_blk *head;
  ngtcp2_ksl_blk *front;
  ngtcp2_ksl_blk *back;
  ngtcp2_ksl_compar compar;
  size_t n;
  size_t keylen;
  size_t nodelen;
  const ngtcp2_mem *mem;
};
int ngtcp2_ksl_init(ngtcp2_ksl *ksl, ngtcp2_ksl_compar compar, size_t keylen,
                    const ngtcp2_mem *mem);
void ngtcp2_ksl_free(ngtcp2_ksl *ksl);
int ngtcp2_ksl_insert(ngtcp2_ksl *ksl, ngtcp2_ksl_it *it,
                      const ngtcp2_ksl_key *key, void *data);
int ngtcp2_ksl_remove(ngtcp2_ksl *ksl, ngtcp2_ksl_it *it,
                      const ngtcp2_ksl_key *key);
ngtcp2_ksl_it ngtcp2_ksl_lower_bound(ngtcp2_ksl *ksl,
                                     const ngtcp2_ksl_key *key);
ngtcp2_ksl_it ngtcp2_ksl_lower_bound_compar(ngtcp2_ksl *ksl,
                                            const ngtcp2_ksl_key *key,
                                            ngtcp2_ksl_compar compar);
void ngtcp2_ksl_update_key(ngtcp2_ksl *ksl, const ngtcp2_ksl_key *old_key,
                           const ngtcp2_ksl_key *new_key);
ngtcp2_ksl_it ngtcp2_ksl_begin(const ngtcp2_ksl *ksl);
ngtcp2_ksl_it ngtcp2_ksl_end(const ngtcp2_ksl *ksl);
size_t ngtcp2_ksl_len(ngtcp2_ksl *ksl);
void ngtcp2_ksl_clear(ngtcp2_ksl *ksl);
void ngtcp2_ksl_print(ngtcp2_ksl *ksl);
void ngtcp2_ksl_it_init(ngtcp2_ksl_it *it, const ngtcp2_ksl *ksl,
                        ngtcp2_ksl_blk *blk, size_t i);
void *ngtcp2_ksl_it_get(const ngtcp2_ksl_it *it);
void ngtcp2_ksl_it_prev(ngtcp2_ksl_it *it);
int ngtcp2_ksl_it_begin(const ngtcp2_ksl_it *it);
int ngtcp2_ksl_range_compar(const ngtcp2_ksl_key *lhs,
                            const ngtcp2_ksl_key *rhs);
int ngtcp2_ksl_range_exclusive_compar(const ngtcp2_ksl_key *lhs,
                                      const ngtcp2_ksl_key *rhs);
typedef struct
{
  ngtcp2_ksl gap;
  const ngtcp2_mem *mem;
} ngtcp2_gaptr;
int ngtcp2_gaptr_init(ngtcp2_gaptr *gaptr, const ngtcp2_mem *mem);
void ngtcp2_gaptr_free(ngtcp2_gaptr *gaptr);
int ngtcp2_gaptr_push(ngtcp2_gaptr *gaptr, uint64_t offset, size_t datalen);
uint64_t ngtcp2_gaptr_first_gap_offset(ngtcp2_gaptr *gaptr);
ngtcp2_ksl_it ngtcp2_gaptr_get_first_gap_after(ngtcp2_gaptr *gaptr,
                                               uint64_t offset);
int ngtcp2_gaptr_is_pushed(ngtcp2_gaptr *gaptr, uint64_t offset,
                           size_t datalen);
void ngtcp2_gaptr_drop_first_gap(ngtcp2_gaptr *gaptr);
typedef struct
{
  ngtcp2_gaptr gap;
  int server;
} ngtcp2_idtr;
int ngtcp2_idtr_init(ngtcp2_idtr *idtr, int server, const ngtcp2_mem *mem);
void ngtcp2_idtr_free(ngtcp2_idtr *idtr);
int ngtcp2_idtr_open(ngtcp2_idtr *idtr, int64_t stream_id);
int ngtcp2_idtr_is_open(ngtcp2_idtr *idtr, int64_t stream_id);
uint64_t ngtcp2_idtr_first_gap(ngtcp2_idtr *idtr);
typedef struct
{
  uint64_t begin;
  uint64_t end;
} ngtcp2_range;
void ngtcp2_range_init(ngtcp2_range *r, uint64_t begin, uint64_t end);
ngtcp2_range ngtcp2_range_intersect(const ngtcp2_range *a,
                                    const ngtcp2_range *b);
uint64_t ngtcp2_range_len(const ngtcp2_range *r);
int ngtcp2_range_eq(const ngtcp2_range *a, const ngtcp2_range *b);
void ngtcp2_range_cut(ngtcp2_range *left, ngtcp2_range *right,
                      const ngtcp2_range *a, const ngtcp2_range *b);
int ngtcp2_range_not_after(const ngtcp2_range *a, const ngtcp2_range *b);
typedef uint64_t key_type;
typedef struct ngtcp2_map_entry
{
  struct ngtcp2_map_entry *next;
  key_type key;
} ngtcp2_map_entry;
typedef struct ngtcp2_map_bucket
{
  ngtcp2_map_entry *ptr;
  ngtcp2_ksl *ksl;
} ngtcp2_map_bucket;
typedef struct
{
  ngtcp2_map_bucket *table;
  const ngtcp2_mem *mem;
  size_t size;
  uint32_t tablelen;
} ngtcp2_map;
int ngtcp2_map_init(ngtcp2_map *map, const ngtcp2_mem *mem);
void ngtcp2_map_free(ngtcp2_map *map);
void ngtcp2_map_each_free(ngtcp2_map *map,
                          int (*func)(ngtcp2_map_entry *entry, void *ptr),
                          void *ptr);
void ngtcp2_map_entry_init(ngtcp2_map_entry *entry, key_type key);
int ngtcp2_map_insert(ngtcp2_map *map, ngtcp2_map_entry *entry);
ngtcp2_map_entry *ngtcp2_map_find(ngtcp2_map *map, key_type key);
int ngtcp2_map_remove(ngtcp2_map *map, key_type key);
void ngtcp2_map_clear(ngtcp2_map *map);
size_t ngtcp2_map_size(ngtcp2_map *map);
int ngtcp2_map_each(ngtcp2_map *map,
                    int (*func)(ngtcp2_map_entry *entry, void *ptr), void *ptr);
extern "C"
{
  typedef struct http_parser http_parser;
  typedef struct http_parser_settings http_parser_settings;
  typedef int (*http_data_cb)(http_parser *, const char *at, size_t length);
  typedef int (*http_cb)(http_parser *);
  enum http_status
  {
    HTTP_STATUS_CONTINUE = 100,
    HTTP_STATUS_SWITCHING_PROTOCOLS = 101,
    HTTP_STATUS_PROCESSING = 102,
    HTTP_STATUS_OK = 200,
    HTTP_STATUS_CREATED = 201,
    HTTP_STATUS_ACCEPTED = 202,
    HTTP_STATUS_NON_AUTHORITATIVE_INFORMATION = 203,
    HTTP_STATUS_NO_CONTENT = 204,
    HTTP_STATUS_RESET_CONTENT = 205,
    HTTP_STATUS_PARTIAL_CONTENT = 206,
    HTTP_STATUS_MULTI_STATUS = 207,
    HTTP_STATUS_ALREADY_REPORTED = 208,
    HTTP_STATUS_IM_USED = 226,
    HTTP_STATUS_MULTIPLE_CHOICES = 300,
    HTTP_STATUS_MOVED_PERMANENTLY = 301,
    HTTP_STATUS_FOUND = 302,
    HTTP_STATUS_SEE_OTHER = 303,
    HTTP_STATUS_NOT_MODIFIED = 304,
    HTTP_STATUS_USE_PROXY = 305,
    HTTP_STATUS_TEMPORARY_REDIRECT = 307,
    HTTP_STATUS_PERMANENT_REDIRECT = 308,
    HTTP_STATUS_BAD_REQUEST = 400,
    HTTP_STATUS_UNAUTHORIZED = 401,
    HTTP_STATUS_PAYMENT_REQUIRED = 402,
    HTTP_STATUS_FORBIDDEN = 403,
    HTTP_STATUS_NOT_FOUND = 404,
    HTTP_STATUS_METHOD_NOT_ALLOWED = 405,
    HTTP_STATUS_NOT_ACCEPTABLE = 406,
    HTTP_STATUS_PROXY_AUTHENTICATION_REQUIRED = 407,
    HTTP_STATUS_REQUEST_TIMEOUT = 408,
    HTTP_STATUS_CONFLICT = 409,
    HTTP_STATUS_GONE = 410,
    HTTP_STATUS_LENGTH_REQUIRED = 411,
    HTTP_STATUS_PRECONDITION_FAILED = 412,
    HTTP_STATUS_PAYLOAD_TOO_LARGE = 413,
    HTTP_STATUS_URI_TOO_LONG = 414,
    HTTP_STATUS_UNSUPPORTED_MEDIA_TYPE = 415,
    HTTP_STATUS_RANGE_NOT_SATISFIABLE = 416,
    HTTP_STATUS_EXPECTATION_FAILED = 417,
    HTTP_STATUS_MISDIRECTED_REQUEST = 421,
    HTTP_STATUS_UNPROCESSABLE_ENTITY = 422,
    HTTP_STATUS_LOCKED = 423,
    HTTP_STATUS_FAILED_DEPENDENCY = 424,
    HTTP_STATUS_UPGRADE_REQUIRED = 426,
    HTTP_STATUS_PRECONDITION_REQUIRED = 428,
    HTTP_STATUS_TOO_MANY_REQUESTS = 429,
    HTTP_STATUS_REQUEST_HEADER_FIELDS_TOO_LARGE = 431,
    HTTP_STATUS_UNAVAILABLE_FOR_LEGAL_REASONS = 451,
    HTTP_STATUS_INTERNAL_SERVER_ERROR = 500,
    HTTP_STATUS_NOT_IMPLEMENTED = 501,
    HTTP_STATUS_BAD_GATEWAY = 502,
    HTTP_STATUS_SERVICE_UNAVAILABLE = 503,
    HTTP_STATUS_GATEWAY_TIMEOUT = 504,
    HTTP_STATUS_HTTP_VERSION_NOT_SUPPORTED = 505,
    HTTP_STATUS_VARIANT_ALSO_NEGOTIATES = 506,
    HTTP_STATUS_INSUFFICIENT_STORAGE = 507,
    HTTP_STATUS_LOOP_DETECTED = 508,
    HTTP_STATUS_NOT_EXTENDED = 510,
    HTTP_STATUS_NETWORK_AUTHENTICATION_REQUIRED = 511,
  };
  enum http_method
  {
    HTTP_DELETE = 0,
    HTTP_GET = 1,
    HTTP_HEAD = 2,
    HTTP_POST = 3,
    HTTP_PUT = 4,
    HTTP_CONNECT = 5,
    HTTP_OPTIONS = 6,
    HTTP_TRACE = 7,
    HTTP_COPY = 8,
    HTTP_LOCK = 9,
    HTTP_MKCOL = 10,
    HTTP_MOVE = 11,
    HTTP_PROPFIND = 12,
    HTTP_PROPPATCH = 13,
    HTTP_SEARCH = 14,
    HTTP_UNLOCK = 15,
    HTTP_BIND = 16,
    HTTP_REBIND = 17,
    HTTP_UNBIND = 18,
    HTTP_ACL = 19,
    HTTP_REPORT = 20,
    HTTP_MKACTIVITY = 21,
    HTTP_CHECKOUT = 22,
    HTTP_MERGE = 23,
    HTTP_MSEARCH = 24,
    HTTP_NOTIFY = 25,
    HTTP_SUBSCRIBE = 26,
    HTTP_UNSUBSCRIBE = 27,
    HTTP_PATCH = 28,
    HTTP_PURGE = 29,
    HTTP_MKCALENDAR = 30,
    HTTP_LINK = 31,
    HTTP_UNLINK = 32,
  };
  enum http_parser_type
  {
    HTTP_REQUEST,
    HTTP_RESPONSE,
    HTTP_BOTH
  };
  enum flags
  {
    F_CHUNKED = 1 << 0,
    F_CONNECTION_KEEP_ALIVE = 1 << 1,
    F_CONNECTION_CLOSE = 1 << 2,
    F_CONNECTION_UPGRADE = 1 << 3,
    F_TRAILING = 1 << 4,
    F_UPGRADE = 1 << 5,
    F_SKIPBODY = 1 << 6,
    F_CONTENTLENGTH = 1 << 7
  };
  enum http_errno
  {
    HPE_OK,
    HPE_CB_message_begin,
    HPE_CB_url,
    HPE_CB_header_field,
    HPE_CB_header_value,
    HPE_CB_headers_complete,
    HPE_CB_body,
    HPE_CB_message_complete,
    HPE_CB_status,
    HPE_CB_chunk_header,
    HPE_CB_chunk_complete,
    HPE_INVALID_EOF_STATE,
    HPE_HEADER_OVERFLOW,
    HPE_CLOSED_CONNECTION,
    HPE_INVALID_VERSION,
    HPE_INVALID_STATUS,
    HPE_INVALID_METHOD,
    HPE_INVALID_URL,
    HPE_INVALID_HOST,
    HPE_INVALID_PORT,
    HPE_INVALID_PATH,
    HPE_INVALID_QUERY_STRING,
    HPE_INVALID_FRAGMENT,
    HPE_LF_EXPECTED,
    HPE_INVALID_HEADER_TOKEN,
    HPE_INVALID_CONTENT_LENGTH,
    HPE_UNEXPECTED_CONTENT_LENGTH,
    HPE_INVALID_CHUNK_SIZE,
    HPE_INVALID_CONSTANT,
    HPE_INVALID_INTERNAL_STATE,
    HPE_STRICT,
    HPE_PAUSED,
    HPE_UNKNOWN,
  };
  struct http_parser
  {
    unsigned int type : 2;
    unsigned int flags : 8;
    unsigned int state : 7;
    unsigned int header_state : 7;
    unsigned int index : 7;
    unsigned int lenient_http_headers : 1;
    uint32_t nread;
    uint64_t content_length;
    unsigned short http_major;
    unsigned short http_minor;
    unsigned int status_code : 16;
    unsigned int method : 8;
    unsigned int http_errno : 7;
    unsigned int upgrade : 1;
    void *data;
  };
  struct http_parser_settings
  {
    http_cb on_message_begin;
    http_data_cb on_url;
    http_data_cb on_status;
    http_data_cb on_header_field;
    http_data_cb on_header_value;
    http_cb on_headers_complete;
    http_data_cb on_body;
    http_cb on_message_complete;
    http_cb on_chunk_header;
    http_cb on_chunk_complete;
  };
  enum http_parser_url_fields
  {
    UF_SCHEMA = 0,
    UF_HOST = 1,
    UF_PORT = 2,
    UF_PATH = 3,
    UF_QUERY = 4,
    UF_FRAGMENT = 5,
    UF_USERINFO = 6,
    UF_MAX = 7
  };
  struct http_parser_url
  {
    uint16_t field_set;
    uint16_t port;
    struct
    {
      uint16_t off;
      uint16_t len;
    } field_data[UF_MAX];
  };
  unsigned long http_parser_version(void);
  void http_parser_init(http_parser *parser, enum http_parser_type type);
  void http_parser_settings_init(http_parser_settings *settings);
  size_t http_parser_execute(http_parser *parser,
                             const http_parser_settings *settings,
                             const char *data,
                             size_t len);
  int http_should_keep_alive(const http_parser *parser);
  const char *http_method_str(enum http_method m);
  const char *http_errno_name(enum http_errno err);
  const char *http_errno_description(enum http_errno err);
  void http_parser_url_init(struct http_parser_url *u);
  int http_parser_parse_url(const char *buf, size_t buflen,
                            int is_connect,
                            struct http_parser_url *u);
  void http_parser_pause(http_parser *parser, int paused);
  int http_body_is_final(const http_parser *parser);
}
typedef struct
{
  uint8_t *buf;
  const ngtcp2_mem *mem;
  size_t nmemb;
  size_t size;
  size_t first;
  size_t len;
} ngtcp2_ringbuf;
int ngtcp2_ringbuf_init(ngtcp2_ringbuf *rb, size_t nmemb, size_t size,
                        const ngtcp2_mem *mem);
void ngtcp2_ringbuf_free(ngtcp2_ringbuf *rb);
void *ngtcp2_ringbuf_push_front(ngtcp2_ringbuf *rb);
void *ngtcp2_ringbuf_push_back(ngtcp2_ringbuf *rb);
void ngtcp2_ringbuf_pop_front(ngtcp2_ringbuf *rb);
void ngtcp2_ringbuf_pop_back(ngtcp2_ringbuf *rb);
void ngtcp2_ringbuf_resize(ngtcp2_ringbuf *rb, size_t len);
void *ngtcp2_ringbuf_get(ngtcp2_ringbuf *rb, size_t offset);
int ngtcp2_ringbuf_full(ngtcp2_ringbuf *rb);
struct ngtcp2_acktr_entry;
typedef struct ngtcp2_acktr_entry ngtcp2_acktr_entry;
struct ngtcp2_log;
typedef struct ngtcp2_log ngtcp2_log;
struct ngtcp2_acktr_entry
{
  int64_t pkt_num;
  size_t len;
  ngtcp2_tstamp tstamp;
};
int ngtcp2_acktr_entry_new(ngtcp2_acktr_entry **ent, int64_t pkt_num,
                           ngtcp2_tstamp tstamp, const ngtcp2_mem *mem);
void ngtcp2_acktr_entry_del(ngtcp2_acktr_entry *ent, const ngtcp2_mem *mem);
typedef struct
{
  int64_t largest_ack;
  int64_t pkt_num;
} ngtcp2_acktr_ack_entry;
typedef enum
{
  NGTCP2_ACKTR_FLAG_NONE = 0x00,
  NGTCP2_ACKTR_FLAG_IMMEDIATE_ACK = 0x01,
  NGTCP2_ACKTR_FLAG_ACTIVE_ACK = 0x02,
  NGTCP2_ACKTR_FLAG_ACK_FINISHED_ACK = 0x80,
  NGTCP2_ACKTR_FLAG_CANCEL_TIMER = 0x0100,
} ngtcp2_acktr_flag;
typedef struct
{
  ngtcp2_ringbuf acks;
  ngtcp2_ksl ents;
  ngtcp2_log *log;
  const ngtcp2_mem *mem;
  uint16_t flags;
  ngtcp2_tstamp first_unacked_ts;
  size_t rx_npkt;
} ngtcp2_acktr;
int ngtcp2_acktr_init(ngtcp2_acktr *acktr, ngtcp2_log *log,
                      const ngtcp2_mem *mem);
void ngtcp2_acktr_free(ngtcp2_acktr *acktr);
int ngtcp2_acktr_add(ngtcp2_acktr *acktr, int64_t pkt_num, int active_ack,
                     ngtcp2_tstamp ts);
void ngtcp2_acktr_forget(ngtcp2_acktr *acktr, ngtcp2_acktr_entry *ent);
ngtcp2_ksl_it ngtcp2_acktr_get(ngtcp2_acktr *acktr);
int ngtcp2_acktr_empty(ngtcp2_acktr *acktr);
ngtcp2_acktr_ack_entry *
ngtcp2_acktr_add_ack(ngtcp2_acktr *acktr, int64_t pkt_num, int64_t largest_ack);
void ngtcp2_acktr_recv_ack(ngtcp2_acktr *acktr, const ngtcp2_ack *fr);
void ngtcp2_acktr_commit_ack(ngtcp2_acktr *acktr);
int ngtcp2_acktr_require_active_ack(ngtcp2_acktr *acktr,
                                    ngtcp2_duration max_ack_delay,
                                    ngtcp2_tstamp ts);
void ngtcp2_acktr_immediate_ack(ngtcp2_acktr *acktr);
struct ngtcp2_conn;
typedef struct ngtcp2_conn ngtcp2_conn;
typedef struct ngtcp2_pktns ngtcp2_pktns;
struct ngtcp2_frame_chain;
typedef struct ngtcp2_frame_chain ngtcp2_frame_chain;
struct ngtcp2_log;
typedef struct ngtcp2_log ngtcp2_log;
struct ngtcp2_qlog;
typedef struct ngtcp2_qlog ngtcp2_qlog;
struct ngtcp2_strm;
typedef struct ngtcp2_strm ngtcp2_strm;
struct ngtcp2_rst;
typedef struct ngtcp2_rst ngtcp2_rst;
typedef enum ngtcp2_frame_chain_binder_flag
{
  NGTCP2_FRAME_CHAIN_BINDER_FLAG_NONE = 0x00,
  NGTCP2_FRAME_CHAIN_BINDER_FLAG_ACK = 0x01,
} ngtcp2_frame_chain_binder_flag;
typedef struct ngtcp2_frame_chain_binder
{
  size_t refcount;
  uint32_t flags;
} ngtcp2_frame_chain_binder;
int ngtcp2_frame_chain_binder_new(ngtcp2_frame_chain_binder **pbinder,
                                  const ngtcp2_mem *mem);
int ngtcp2_bind_frame_chains(ngtcp2_frame_chain *a, ngtcp2_frame_chain *b,
                             const ngtcp2_mem *mem);
struct ngtcp2_frame_chain
{
  ngtcp2_frame_chain *next;
  ngtcp2_frame_chain_binder *binder;
  ngtcp2_frame fr;
};
int ngtcp2_frame_chain_new(ngtcp2_frame_chain **pfrc, const ngtcp2_mem *mem);
int ngtcp2_frame_chain_extralen_new(ngtcp2_frame_chain **pfrc, size_t extralen,
                                    const ngtcp2_mem *mem);
int ngtcp2_frame_chain_stream_datacnt_new(ngtcp2_frame_chain **pfrc,
                                          size_t datacnt,
                                          const ngtcp2_mem *mem);
int ngtcp2_frame_chain_crypto_datacnt_new(ngtcp2_frame_chain **pfrc,
                                          size_t datacnt,
                                          const ngtcp2_mem *mem);
int ngtcp2_frame_chain_new_token_new(ngtcp2_frame_chain **pfrc,
                                     const ngtcp2_vec *token,
                                     const ngtcp2_mem *mem);
void ngtcp2_frame_chain_del(ngtcp2_frame_chain *frc, const ngtcp2_mem *mem);
void ngtcp2_frame_chain_init(ngtcp2_frame_chain *frc);
void ngtcp2_frame_chain_list_del(ngtcp2_frame_chain *frc,
                                 const ngtcp2_mem *mem);
typedef enum
{
  NGTCP2_RTB_FLAG_NONE = 0x00,
  NGTCP2_RTB_FLAG_PROBE = 0x01,
  NGTCP2_RTB_FLAG_RETRANSMITTABLE = 0x02,
  NGTCP2_RTB_FLAG_ACK_ELICITING = 0x04,
  NGTCP2_RTB_FLAG_PTO_RECLAIMED = 0x08,
  NGTCP2_RTB_FLAG_LOST_RETRANSMITTED = 0x10,
  NGTCP2_RTB_FLAG_ECN = 0x20,
} ngtcp2_rtb_flag;
struct ngtcp2_rtb_entry;
typedef struct ngtcp2_rtb_entry ngtcp2_rtb_entry;
struct ngtcp2_rtb_entry
{
  ngtcp2_rtb_entry *next;
  struct
  {
    int64_t pkt_num;
    uint8_t type;
    uint8_t flags;
  } hd;
  ngtcp2_frame_chain *frc;
  ngtcp2_tstamp ts;
  ngtcp2_tstamp lost_ts;
  size_t pktlen;
  struct
  {
    uint64_t delivered;
    ngtcp2_tstamp delivered_ts;
    ngtcp2_tstamp first_sent_ts;
    int is_app_limited;
  } rst;
  uint8_t flags;
};
int ngtcp2_rtb_entry_new(ngtcp2_rtb_entry **pent, const ngtcp2_pkt_hd *hd,
                         ngtcp2_frame_chain *frc, ngtcp2_tstamp ts,
                         size_t pktlen, uint8_t flags, const ngtcp2_mem *mem);
void ngtcp2_rtb_entry_del(ngtcp2_rtb_entry *ent, const ngtcp2_mem *mem);
typedef struct
{
  ngtcp2_ksl ents;
  ngtcp2_strm *crypto;
  ngtcp2_rst *rst;
  ngtcp2_cc *cc;
  ngtcp2_log *log;
  ngtcp2_qlog *qlog;
  const ngtcp2_mem *mem;
  int64_t largest_acked_tx_pkt_num;
  size_t num_ack_eliciting;
  size_t num_retransmittable;
  size_t probe_pkt_left;
  ngtcp2_pktns_id pktns_id;
  int64_t cc_pkt_num;
  uint64_t cc_bytes_in_flight;
  ngtcp2_tstamp persistent_congestion_start_ts;
  size_t num_lost_pkts;
} ngtcp2_rtb;
void ngtcp2_rtb_init(ngtcp2_rtb *rtb, ngtcp2_pktns_id pktns_id,
                     ngtcp2_strm *crypto, ngtcp2_rst *rst, ngtcp2_cc *cc,
                     ngtcp2_log *log, ngtcp2_qlog *qlog, const ngtcp2_mem *mem);
void ngtcp2_rtb_free(ngtcp2_rtb *rtb);
int ngtcp2_rtb_add(ngtcp2_rtb *rtb, ngtcp2_rtb_entry *ent,
                   ngtcp2_conn_stat *cstat);
ngtcp2_ksl_it ngtcp2_rtb_head(ngtcp2_rtb *rtb);
ngtcp2_ssize ngtcp2_rtb_recv_ack(ngtcp2_rtb *rtb, const ngtcp2_ack *fr,
                                 ngtcp2_conn_stat *cstat, ngtcp2_conn *conn,
                                 ngtcp2_pktns *pktns, ngtcp2_tstamp pkt_ts,
                                 ngtcp2_tstamp ts);
int ngtcp2_rtb_detect_lost_pkt(ngtcp2_rtb *rtb, ngtcp2_conn *conn,
                               ngtcp2_pktns *pktns, ngtcp2_conn_stat *cstat,
                               ngtcp2_duration pto, ngtcp2_tstamp ts);
void ngtcp2_rtb_remove_expired_lost_pkt(ngtcp2_rtb *rtb, ngtcp2_duration pto,
                                        ngtcp2_tstamp ts);
ngtcp2_tstamp ngtcp2_rtb_lost_pkt_ts(ngtcp2_rtb *rtb);
int ngtcp2_rtb_remove_all(ngtcp2_rtb *rtb, ngtcp2_conn *conn,
                          ngtcp2_pktns *pktns, ngtcp2_conn_stat *cstat);
int ngtcp2_rtb_empty(ngtcp2_rtb *rtb);
void ngtcp2_rtb_reset_cc_state(ngtcp2_rtb *rtb, int64_t cc_pkt_num);
void ngtcp2_rtb_remove_excessive_lost_pkt(ngtcp2_rtb *rtb, size_t n);
ngtcp2_ssize ngtcp2_rtb_reclaim_on_pto(ngtcp2_rtb *rtb, ngtcp2_conn *conn,
                                       ngtcp2_pktns *pktns, size_t num_pkts);
struct ngtcp2_rob_gap;
typedef struct ngtcp2_rob_gap ngtcp2_rob_gap;
struct ngtcp2_rob_gap
{
  ngtcp2_range range;
};
int ngtcp2_rob_gap_new(ngtcp2_rob_gap **pg, uint64_t begin, uint64_t end,
                       const ngtcp2_mem *mem);
void ngtcp2_rob_gap_del(ngtcp2_rob_gap *g, const ngtcp2_mem *mem);
struct ngtcp2_rob_data;
typedef struct ngtcp2_rob_data ngtcp2_rob_data;
struct ngtcp2_rob_data
{
  ngtcp2_range range;
  uint8_t *begin;
  uint8_t *end;
};
int ngtcp2_rob_data_new(ngtcp2_rob_data **pd, uint64_t offset, size_t chunk,
                        const ngtcp2_mem *mem);
void ngtcp2_rob_data_del(ngtcp2_rob_data *d, const ngtcp2_mem *mem);
typedef struct
{
  ngtcp2_ksl gapksl;
  ngtcp2_ksl dataksl;
  const ngtcp2_mem *mem;
  size_t chunk;
} ngtcp2_rob;
int ngtcp2_rob_init(ngtcp2_rob *rob, size_t chunk, const ngtcp2_mem *mem);
void ngtcp2_rob_free(ngtcp2_rob *rob);
int ngtcp2_rob_push(ngtcp2_rob *rob, uint64_t offset, const uint8_t *data,
                    size_t datalen);
int ngtcp2_rob_remove_prefix(ngtcp2_rob *rob, uint64_t offset);
size_t ngtcp2_rob_data_at(ngtcp2_rob *rob, const uint8_t **pdest,
                          uint64_t offset);
void ngtcp2_rob_pop(ngtcp2_rob *rob, uint64_t offset, size_t len);
uint64_t ngtcp2_rob_first_gap_offset(ngtcp2_rob *rob);
int ngtcp2_rob_data_buffered(ngtcp2_rob *rob);
struct ngtcp2_frame_chain;
typedef struct ngtcp2_frame_chain ngtcp2_frame_chain;
typedef enum
{
  NGTCP2_STRM_FLAG_NONE = 0,
  NGTCP2_STRM_FLAG_SHUT_RD = 0x01,
  NGTCP2_STRM_FLAG_SHUT_WR = 0x02,
  NGTCP2_STRM_FLAG_SHUT_RDWR =
      NGTCP2_STRM_FLAG_SHUT_RD | NGTCP2_STRM_FLAG_SHUT_WR,
  NGTCP2_STRM_FLAG_SENT_RST = 0x04,
  NGTCP2_STRM_FLAG_RECV_RST = 0x08,
  NGTCP2_STRM_FLAG_STOP_SENDING = 0x10,
  NGTCP2_STRM_FLAG_RST_ACKED = 0x20,
  NGTCP2_STRM_FLAG_FIN_ACKED = 0x40,
} ngtcp2_strm_flags;
struct ngtcp2_strm;
typedef struct ngtcp2_strm ngtcp2_strm;
struct ngtcp2_strm
{
  ngtcp2_map_entry me;
  ngtcp2_pq_entry pe;
  uint64_t cycle;
  struct
  {
    ngtcp2_gaptr *acked_offset;
    uint64_t cont_acked_offset;
    ngtcp2_ksl *streamfrq;
    uint64_t offset;
    uint64_t max_offset;
    ngtcp2_tstamp last_max_stream_data_ts;
  } tx;
  struct
  {
    ngtcp2_rob *rob;
    uint64_t cont_offset;
    uint64_t last_offset;
    uint64_t max_offset;
    uint64_t unsent_max_offset;
    uint64_t window;
  } rx;
  const ngtcp2_mem *mem;
  int64_t stream_id;
  void *stream_user_data;
  uint32_t flags;
  uint64_t app_error_code;
};
int ngtcp2_strm_init(ngtcp2_strm *strm, int64_t stream_id, uint32_t flags,
                     uint64_t max_rx_offset, uint64_t max_tx_offset,
                     void *stream_user_data, const ngtcp2_mem *mem);
void ngtcp2_strm_free(ngtcp2_strm *strm);
uint64_t ngtcp2_strm_rx_offset(ngtcp2_strm *strm);
int ngtcp2_strm_recv_reordering(ngtcp2_strm *strm, const uint8_t *data,
                                size_t datalen, uint64_t offset);
int ngtcp2_strm_update_rx_offset(ngtcp2_strm *strm, uint64_t offset);
void ngtcp2_strm_shutdown(ngtcp2_strm *strm, uint32_t flags);
int ngtcp2_strm_streamfrq_push(ngtcp2_strm *strm, ngtcp2_frame_chain *frc);
int ngtcp2_strm_streamfrq_pop(ngtcp2_strm *strm, ngtcp2_frame_chain **pfrc,
                              size_t left);
uint64_t ngtcp2_strm_streamfrq_unacked_offset(ngtcp2_strm *strm);
ngtcp2_frame_chain *ngtcp2_strm_streamfrq_top(ngtcp2_strm *strm);
int ngtcp2_strm_streamfrq_empty(ngtcp2_strm *strm);
void ngtcp2_strm_streamfrq_clear(ngtcp2_strm *strm);
int ngtcp2_strm_is_tx_queued(ngtcp2_strm *strm);
int ngtcp2_strm_is_all_tx_data_acked(ngtcp2_strm *strm);
ngtcp2_range ngtcp2_strm_get_unacked_range_after(ngtcp2_strm *strm,
                                                 uint64_t offset);
uint64_t ngtcp2_strm_get_acked_offset(ngtcp2_strm *strm);
int ngtcp2_strm_ack_data(ngtcp2_strm *strm, uint64_t offset, uint64_t len);
struct ngtcp2_log;
typedef struct ngtcp2_log ngtcp2_log;
uint64_t ngtcp2_cc_compute_initcwnd(size_t max_packet_size);
ngtcp2_cc_pkt *ngtcp2_cc_pkt_init(ngtcp2_cc_pkt *pkt, int64_t pkt_num,
                                  size_t pktlen, ngtcp2_pktns_id pktns_id,
                                  ngtcp2_tstamp ts_sent);
struct ngtcp2_reno_cc
{
  ngtcp2_cc_base ccb;
  uint64_t max_delivery_rate_sec;
  uint64_t target_cwnd;
  uint64_t pending_add;
};
typedef struct ngtcp2_reno_cc ngtcp2_reno_cc;
int ngtcp2_cc_reno_cc_init(ngtcp2_cc *cc, ngtcp2_log *log,
                           const ngtcp2_mem *mem);
void ngtcp2_cc_reno_cc_free(ngtcp2_cc *cc, const ngtcp2_mem *mem);
void ngtcp2_reno_cc_init(ngtcp2_reno_cc *cc, ngtcp2_log *log);
void ngtcp2_reno_cc_free(ngtcp2_reno_cc *cc);
void ngtcp2_cc_reno_cc_on_pkt_acked(ngtcp2_cc *cc, ngtcp2_conn_stat *cstat,
                                    const ngtcp2_cc_pkt *pkt, ngtcp2_tstamp ts);
void ngtcp2_cc_reno_cc_congestion_event(ngtcp2_cc *cc, ngtcp2_conn_stat *cstat,
                                        ngtcp2_tstamp ts_sent,
                                        ngtcp2_tstamp ts);
void ngtcp2_cc_reno_cc_on_persistent_congestion(ngtcp2_cc *cc,
                                                ngtcp2_conn_stat *cstat,
                                                ngtcp2_tstamp ts);
void ngtcp2_cc_reno_cc_on_ack_recv(ngtcp2_cc *cc, ngtcp2_conn_stat *cstat,
                                   ngtcp2_tstamp ts);
void ngtcp2_cc_reno_cc_reset(ngtcp2_cc *cc);
typedef struct ngtcp2_cubic_cc
{
  ngtcp2_cc_base ccb;
  uint64_t max_delivery_rate_sec;
  uint64_t target_cwnd;
  uint64_t w_last_max;
  uint64_t w_tcp;
  uint64_t origin_point;
  ngtcp2_tstamp epoch_start;
  uint64_t k;
  size_t rtt_sample_count;
  uint64_t current_round_min_rtt;
  uint64_t last_round_min_rtt;
  int64_t window_end;
  uint64_t pending_add;
  uint64_t pending_w_add;
} ngtcp2_cubic_cc;
int ngtcp2_cc_cubic_cc_init(ngtcp2_cc *cc, ngtcp2_log *log,
                            const ngtcp2_mem *mem);
void ngtcp2_cc_cubic_cc_free(ngtcp2_cc *cc, const ngtcp2_mem *mem);
void ngtcp2_cubic_cc_init(ngtcp2_cubic_cc *cc, ngtcp2_log *log);
void ngtcp2_cubic_cc_free(ngtcp2_cubic_cc *cc);
void ngtcp2_cc_cubic_cc_on_pkt_acked(ngtcp2_cc *cc, ngtcp2_conn_stat *cstat,
                                     const ngtcp2_cc_pkt *pkt,
                                     ngtcp2_tstamp ts);
void ngtcp2_cc_cubic_cc_congestion_event(ngtcp2_cc *cc, ngtcp2_conn_stat *cstat,
                                         ngtcp2_tstamp ts_sent,
                                         ngtcp2_tstamp ts);
void ngtcp2_cc_cubic_cc_on_persistent_congestion(ngtcp2_cc *cc,
                                                 ngtcp2_conn_stat *cstat,
                                                 ngtcp2_tstamp ts);
void ngtcp2_cc_cubic_cc_on_ack_recv(ngtcp2_cc *cc, ngtcp2_conn_stat *cstat,
                                    ngtcp2_tstamp ts);
void ngtcp2_cc_cubic_cc_on_pkt_sent(ngtcp2_cc *cc, ngtcp2_conn_stat *cstat,
                                    const ngtcp2_cc_pkt *pkt);
void ngtcp2_cc_cubic_cc_new_rtt_sample(ngtcp2_cc *cc, ngtcp2_conn_stat *cstat,
                                       ngtcp2_tstamp ts);
void ngtcp2_cc_cubic_cc_reset(ngtcp2_cc *cc);
void ngtcp2_cc_cubic_cc_event(ngtcp2_cc *cc, ngtcp2_conn_stat *cstat,
                              ngtcp2_cc_event_type event, ngtcp2_tstamp ts);
struct ngtcp2_log;
typedef struct ngtcp2_log ngtcp2_log;
struct ngtcp2_frame_chain;
typedef struct ngtcp2_frame_chain ngtcp2_frame_chain;
typedef struct
{
  ngtcp2_tstamp expiry;
  uint8_t data[8];
} ngtcp2_pv_entry;
void ngtcp2_pv_entry_init(ngtcp2_pv_entry *pvent, const uint8_t *data,
                          ngtcp2_tstamp expiry);
typedef enum
{
  NGTCP2_PV_FLAG_NONE,
  NGTCP2_PV_FLAG_DONT_CARE = 0x01,
  NGTCP2_PV_FLAG_CANCEL_TIMER = 0x02,
  NGTCP2_PV_FLAG_FALLBACK_ON_FAILURE = 0x04,
} ngtcp2_pv_flag;
struct ngtcp2_pv;
typedef struct ngtcp2_pv ngtcp2_pv;
struct ngtcp2_pv
{
  const ngtcp2_mem *mem;
  ngtcp2_log *log;
  ngtcp2_dcid dcid;
  ngtcp2_dcid fallback_dcid;
  ngtcp2_ringbuf ents;
  ngtcp2_duration timeout;
  ngtcp2_tstamp started_ts;
  size_t round;
  size_t probe_pkt_left;
  uint8_t flags;
};
int ngtcp2_pv_new(ngtcp2_pv **ppv, const ngtcp2_dcid *dcid,
                  ngtcp2_duration timeout, uint8_t flags, ngtcp2_log *log,
                  const ngtcp2_mem *mem);
void ngtcp2_pv_del(ngtcp2_pv *pv);
void ngtcp2_pv_add_entry(ngtcp2_pv *pv, const uint8_t *data,
                         ngtcp2_tstamp expiry, ngtcp2_tstamp ts);
int ngtcp2_pv_full(ngtcp2_pv *pv);
int ngtcp2_pv_validate(ngtcp2_pv *pv, const uint8_t *data);
void ngtcp2_pv_handle_entry_expiry(ngtcp2_pv *pv, ngtcp2_tstamp ts);
int ngtcp2_pv_should_send_probe(ngtcp2_pv *pv);
int ngtcp2_pv_validation_timed_out(ngtcp2_pv *pv, ngtcp2_tstamp ts);
ngtcp2_tstamp ngtcp2_pv_next_expiry(ngtcp2_pv *pv);
void ngtcp2_pv_cancel_expired_timer(ngtcp2_pv *pv, ngtcp2_tstamp ts);
typedef struct
{
  uint8_t *begin;
  uint8_t *end;
  uint8_t *pos;
  uint8_t *last;
} ngtcp2_buf;
void ngtcp2_buf_init(ngtcp2_buf *buf, uint8_t *begin, size_t len);
void ngtcp2_buf_reset(ngtcp2_buf *buf);
size_t ngtcp2_buf_left(const ngtcp2_buf *buf);
size_t ngtcp2_buf_len(const ngtcp2_buf *buf);
size_t ngtcp2_buf_cap(const ngtcp2_buf *buf);
typedef struct
{
  ngtcp2_buf buf;
  ngtcp2_crypto_cc *cc;
  size_t hdlen;
  size_t len_offset;
  size_t pkt_num_offset;
  size_t pkt_numlen;
  size_t sample_offset;
  int64_t pkt_num;
  uint8_t nonce[32];
} ngtcp2_ppe;
void ngtcp2_ppe_init(ngtcp2_ppe *ppe, uint8_t *out, size_t outlen,
                     ngtcp2_crypto_cc *cc);
int ngtcp2_ppe_encode_hd(ngtcp2_ppe *ppe, const ngtcp2_pkt_hd *hd);
int ngtcp2_ppe_encode_frame(ngtcp2_ppe *ppe, ngtcp2_frame *fr);
ngtcp2_ssize ngtcp2_ppe_final(ngtcp2_ppe *ppe, const uint8_t **ppkt);
size_t ngtcp2_ppe_left(ngtcp2_ppe *ppe);
size_t ngtcp2_ppe_pktlen(ngtcp2_ppe *ppe);
size_t ngtcp2_ppe_padding(ngtcp2_ppe *ppe);
size_t ngtcp2_ppe_padding_hp_sample(ngtcp2_ppe *ppe);
size_t ngtcp2_ppe_padding_size(ngtcp2_ppe *ppe, size_t n);
int ngtcp2_ppe_ensure_hp_sample(ngtcp2_ppe *ppe);
typedef enum ngtcp2_qlog_side
{
  NGTCP2_QLOG_SIDE_LOCAL,
  NGTCP2_QLOG_SIDE_REMOTE,
} ngtcp2_qlog_side;
typedef struct ngtcp2_qlog
{
  ngtcp2_qlog_write write;
  ngtcp2_tstamp ts;
  ngtcp2_tstamp last_ts;
  ngtcp2_buf buf;
  void *user_data;
} ngtcp2_qlog;
void ngtcp2_qlog_init(ngtcp2_qlog *qlog, ngtcp2_qlog_write write,
                      ngtcp2_tstamp ts, void *user_data);
void ngtcp2_qlog_start(ngtcp2_qlog *qlog, const ngtcp2_cid *odcid, int server);
void ngtcp2_qlog_end(ngtcp2_qlog *qlog);
void ngtcp2_qlog_write_frame(ngtcp2_qlog *qlog, const ngtcp2_frame *fr);
void ngtcp2_qlog_pkt_received_start(ngtcp2_qlog *qlog, const ngtcp2_pkt_hd *hd);
void ngtcp2_qlog_pkt_received_end(ngtcp2_qlog *qlog, const ngtcp2_pkt_hd *hd,
                                  size_t pktlen);
void ngtcp2_qlog_pkt_sent_start(ngtcp2_qlog *qlog, const ngtcp2_pkt_hd *hd);
void ngtcp2_qlog_pkt_sent_end(ngtcp2_qlog *qlog, const ngtcp2_pkt_hd *hd,
                              size_t pktlen);
void ngtcp2_qlog_parameters_set_transport_params(
    ngtcp2_qlog *qlog, const ngtcp2_transport_params *params, int server,
    ngtcp2_qlog_side side);
void ngtcp2_qlog_metrics_updated(ngtcp2_qlog *qlog,
                                 const ngtcp2_conn_stat *cstat);
void ngtcp2_qlog_pkt_lost(ngtcp2_qlog *qlog, ngtcp2_rtb_entry *ent);
struct ngtcp2_rtb_entry;
typedef struct ngtcp2_rtb_entry ngtcp2_rtb_entry;
typedef struct ngtcp2_rs
{
  ngtcp2_duration interval;
  uint64_t delivered;
  uint64_t prior_delivered;
  ngtcp2_tstamp prior_ts;
  ngtcp2_duration send_elapsed;
  ngtcp2_duration ack_elapsed;
  int is_app_limited;
} ngtcp2_rs;
void ngtcp2_rs_init(ngtcp2_rs *rs);
typedef struct ngtcp2_rst
{
  ngtcp2_rs rs;
  uint64_t delivered;
  ngtcp2_tstamp delivered_ts;
  ngtcp2_tstamp first_sent_ts;
  uint64_t app_limited;
} ngtcp2_rst;
void ngtcp2_rst_init(ngtcp2_rst *rst);
void ngtcp2_rst_on_pkt_sent(ngtcp2_rst *rst, ngtcp2_rtb_entry *ent,
                            const ngtcp2_conn_stat *cstat);
int ngtcp2_rst_on_ack_recv(ngtcp2_rst *rst, ngtcp2_conn_stat *cstat);
void ngtcp2_rst_update_rate_sample(ngtcp2_rst *rst, const ngtcp2_rtb_entry *ent,
                                   ngtcp2_tstamp ts);
void ngtcp2_rst_update_app_limited(ngtcp2_rst *rst, ngtcp2_conn_stat *cstat);
typedef enum
{
  NGTCP2_CS_CLIENT_INITIAL,
  NGTCP2_CS_CLIENT_WAIT_HANDSHAKE,
  NGTCP2_CS_CLIENT_TLS_HANDSHAKE_FAILED,
  NGTCP2_CS_SERVER_INITIAL,
  NGTCP2_CS_SERVER_WAIT_HANDSHAKE,
  NGTCP2_CS_SERVER_TLS_HANDSHAKE_FAILED,
  NGTCP2_CS_POST_HANDSHAKE,
  NGTCP2_CS_CLOSING,
  NGTCP2_CS_DRAINING,
} ngtcp2_conn_state;
typedef union
{
  ngtcp2_frame fr;
  struct
  {
    ngtcp2_ack ack;
    ngtcp2_ack_blk blks[32 - 1];
  } ackfr;
} ngtcp2_max_frame;
typedef struct
{
  ngtcp2_path_storage ps;
  uint8_t data[8];
} ngtcp2_path_challenge_entry;
void ngtcp2_path_challenge_entry_init(ngtcp2_path_challenge_entry *pcent,
                                      const ngtcp2_path *path,
                                      const uint8_t *data);
typedef enum
{
  NGTCP2_CONN_FLAG_NONE = 0x00,
  NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED = 0x01,
  NGTCP2_CONN_FLAG_CONN_ID_NEGOTIATED = 0x02,
  NGTCP2_CONN_FLAG_TRANSPORT_PARAM_RECVED = 0x04,
  NGTCP2_CONN_FLAG_RECV_PROTECTED_PKT = 0x08,
  NGTCP2_CONN_FLAG_RECV_RETRY = 0x10,
  NGTCP2_CONN_FLAG_EARLY_DATA_REJECTED = 0x20,
  NGTCP2_CONN_FLAG_SADDR_VERIFIED = 0x40,
  NGTCP2_CONN_FLAG_HANDSHAKE_CONFIRMED = 0x80,
  NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED_HANDLED = 0x0100,
  NGTCP2_CONN_FLAG_HANDSHAKE_EARLY_RETRANSMIT = 0x0200,
  NGTCP2_CONN_FLAG_KEY_UPDATE_NOT_CONFIRMED = 0x0800,
  NGTCP2_CONN_FLAG_PPE_PENDING = 0x1000,
  NGTCP2_CONN_FLAG_RESTART_IDLE_TIMER_ON_WRITE = 0x2000,
  NGTCP2_CONN_FLAG_SERVER_ADDR_VERIFIED = 0x4000,
} ngtcp2_conn_flag;
typedef struct
{
  ngtcp2_buf buf;
  uint8_t pkt_type;
} ngtcp2_crypto_data;
typedef struct ngtcp2_pktns
{
  struct
  {
    int64_t last_pkt_num;
    ngtcp2_frame_chain *frq;
    size_t num_non_ack_pkt;
    struct
    {
      size_t ect0;
      int64_t start_pkt_num;
      size_t validation_pkt_sent;
      size_t validation_pkt_lost;
    } ecn;
  } tx;
  struct
  {
    ngtcp2_gaptr pngap;
    int64_t max_pkt_num;
    ngtcp2_tstamp max_pkt_ts;
    int64_t max_ack_eliciting_pkt_num;
    ngtcp2_pkt_chain *buffed_pkts;
    struct
    {
      size_t ect0;
      size_t ect1;
      size_t ce;
      struct
      {
        size_t ect0;
        size_t ect1;
        size_t ce;
      } ack;
    } ecn;
  } rx;
  struct
  {
    struct
    {
      ngtcp2_ksl frq;
      uint64_t offset;
      ngtcp2_crypto_km *ckm;
      ngtcp2_crypto_cipher_ctx hp_ctx;
    } tx;
    struct
    {
      ngtcp2_crypto_km *ckm;
      ngtcp2_crypto_cipher_ctx hp_ctx;
    } rx;
    ngtcp2_strm strm;
    ngtcp2_crypto_ctx ctx;
  } crypto;
  ngtcp2_acktr acktr;
  ngtcp2_rtb rtb;
} ngtcp2_pktns;
typedef enum ngtcp2_ecn_state
{
  NGTCP2_ECN_STATE_TESTING,
  NGTCP2_ECN_STATE_UNKNOWN,
  NGTCP2_ECN_STATE_FAILED,
  NGTCP2_ECN_STATE_CAPABLE,
} ngtcp2_ecn_state;
struct ngtcp2_conn
{
  ngtcp2_conn_state state;
  ngtcp2_conn_callbacks callbacks;
  ngtcp2_cid rcid;
  ngtcp2_cid oscid;
  ngtcp2_cid retry_scid;
  ngtcp2_pktns *in_pktns;
  ngtcp2_pktns *hs_pktns;
  ngtcp2_pktns pktns;
  struct
  {
    ngtcp2_dcid current;
    ngtcp2_ringbuf bound;
    ngtcp2_ringbuf unused;
    ngtcp2_ringbuf retired;
    ngtcp2_gaptr seqgap;
    uint64_t retire_prior_to;
    size_t num_retire_queued;
  } dcid;
  struct
  {
    ngtcp2_ksl set;
    ngtcp2_pq used;
    uint64_t last_seq;
    size_t num_retired;
  } scid;
  struct
  {
    ngtcp2_pq strmq;
    ngtcp2_frame *ack;
    size_t max_ack_blks;
    uint64_t offset;
    uint64_t max_offset;
    ngtcp2_tstamp last_max_data_ts;
    struct
    {
      ngtcp2_ecn_state state;
      ngtcp2_tstamp validation_start_ts;
      size_t dgram_sent;
    } ecn;
  } tx;
  struct
  {
    uint64_t unsent_max_offset;
    uint64_t offset;
    uint64_t max_offset;
    uint64_t window;
    ngtcp2_ringbuf path_challenge;
    ngtcp2_connection_close_error_code ccec;
    struct
    {
      ngtcp2_tstamp start_ts;
      uint64_t received;
    } rate;
  } rx;
  struct
  {
    ngtcp2_crypto_km *ckm;
    ngtcp2_crypto_cipher_ctx hp_ctx;
  } early;
  struct
  {
    ngtcp2_settings settings;
    struct
    {
      uint64_t max_streams;
      int64_t next_stream_id;
    } bidi;
    struct
    {
      uint64_t max_streams;
      int64_t next_stream_id;
    } uni;
  } local;
  struct
  {
    ngtcp2_transport_params transport_params;
    ngtcp2_transport_params pending_transport_params;
    struct
    {
      ngtcp2_idtr idtr;
      uint64_t unsent_max_streams;
      uint64_t max_streams;
    } bidi;
    struct
    {
      ngtcp2_idtr idtr;
      uint64_t unsent_max_streams;
      uint64_t max_streams;
    } uni;
  } remote;
  struct
  {
    struct
    {
      ngtcp2_crypto_km *new_tx_ckm;
      ngtcp2_crypto_km *new_rx_ckm;
      ngtcp2_crypto_km *old_rx_ckm;
      ngtcp2_tstamp confirmed_ts;
    } key_update;
    void *tls_native_handle;
    size_t aead_overhead;
    ngtcp2_vec decrypt_hp_buf;
    ngtcp2_vec decrypt_buf;
    ngtcp2_crypto_aead retry_aead;
    ngtcp2_crypto_aead_ctx retry_aead_ctx;
    int tls_error;
    uint64_t decryption_failure_count;
  } crypto;
  struct
  {
    ngtcp2_crypto_cc cc;
    ngtcp2_pkt_hd hd;
    ngtcp2_ppe ppe;
    ngtcp2_frame_chain **pfrc;
    int pkt_empty;
    int hd_logged;
    uint8_t rtb_entry_flags;
    int was_client_initial;
    ngtcp2_ssize hs_spktlen;
  } pkt;
  ngtcp2_map strms;
  ngtcp2_conn_stat cstat;
  ngtcp2_pv *pv;
  ngtcp2_log log;
  ngtcp2_qlog qlog;
  ngtcp2_rst rst;
  ngtcp2_cc_algo cc_algo;
  ngtcp2_cc cc;
  const ngtcp2_mem *mem;
  ngtcp2_tstamp idle_ts;
  void *user_data;
  uint32_t version;
  uint16_t flags;
  int server;
};
typedef enum ngtcp2_vmsg_type
{
  NGTCP2_VMSG_TYPE_STREAM,
} ngtcp2_vmsg_type;
typedef struct ngtcp2_vmsg_stream
{
  ngtcp2_strm *strm;
  uint32_t flags;
  const ngtcp2_vec *data;
  size_t datacnt;
  ngtcp2_ssize *pdatalen;
} ngtcp2_vmsg_stream;
typedef struct ngtcp2_vmsg
{
  ngtcp2_vmsg_type type;
  union
  {
    ngtcp2_vmsg_stream stream;
  };
} ngtcp2_vmsg;
int ngtcp2_conn_sched_ack(ngtcp2_conn *conn, ngtcp2_acktr *acktr,
                          int64_t pkt_num, int active_ack, ngtcp2_tstamp ts);
ngtcp2_strm *ngtcp2_conn_find_stream(ngtcp2_conn *conn, int64_t stream_id);
int ngtcp2_conn_init_stream(ngtcp2_conn *conn, ngtcp2_strm *strm,
                            int64_t stream_id, void *stream_user_data);
int ngtcp2_conn_close_stream(ngtcp2_conn *conn, ngtcp2_strm *strm,
                             uint64_t app_error_code);
int ngtcp2_conn_close_stream_if_shut_rdwr(ngtcp2_conn *conn, ngtcp2_strm *strm,
                                          uint64_t app_error_code);
void ngtcp2_conn_update_rtt(ngtcp2_conn *conn, ngtcp2_duration rtt,
                            ngtcp2_duration ack_delay, ngtcp2_tstamp ts);
void ngtcp2_conn_set_loss_detection_timer(ngtcp2_conn *conn, ngtcp2_tstamp ts);
int ngtcp2_conn_detect_lost_pkt(ngtcp2_conn *conn, ngtcp2_pktns *pktns,
                                ngtcp2_conn_stat *cstat, ngtcp2_tstamp ts);
ngtcp2_strm *ngtcp2_conn_tx_strmq_top(ngtcp2_conn *conn);
void ngtcp2_conn_tx_strmq_pop(ngtcp2_conn *conn);
int ngtcp2_conn_tx_strmq_push(ngtcp2_conn *conn, ngtcp2_strm *strm);
ngtcp2_tstamp ngtcp2_conn_internal_expiry(ngtcp2_conn *conn);
ngtcp2_ssize ngtcp2_conn_write_vmsg(ngtcp2_conn *conn, ngtcp2_path *path,
                                    ngtcp2_pkt_info *pi, uint8_t *dest,
                                    size_t destlen, ngtcp2_vmsg *vmsg,
                                    ngtcp2_tstamp ts);
ngtcp2_ssize ngtcp2_conn_write_single_frame_pkt(
    ngtcp2_conn *conn, ngtcp2_pkt_info *pi, uint8_t *dest, size_t destlen,
    uint8_t type, const ngtcp2_cid *dcid, ngtcp2_frame *fr, uint8_t rtb_flags,
    const ngtcp2_path *path, ngtcp2_tstamp ts);
int ngtcp2_conn_commit_local_transport_params(ngtcp2_conn *conn);
ngtcp2_tstamp ngtcp2_conn_lost_pkt_expiry(ngtcp2_conn *conn);
void ngtcp2_conn_remove_lost_pkt(ngtcp2_conn *conn, ngtcp2_tstamp ts);
int ngtcp2_conn_resched_frames(ngtcp2_conn *conn, ngtcp2_pktns *pktns,
                               ngtcp2_frame_chain **pfrc);
uint64_t ngtcp2_conn_tx_strmq_first_cycle(ngtcp2_conn *conn);
extern "C"
{
  typedef ptrdiff_t nghttp3_ssize;
  typedef enum
  {
    NGHTTP3_ERR_INVALID_ARGUMENT = -101,
    NGHTTP3_ERR_NOBUF = -102,
    NGHTTP3_ERR_INVALID_STATE = -103,
    NGHTTP3_ERR_WOULDBLOCK = -104,
    NGHTTP3_ERR_STREAM_IN_USE = -105,
    NGHTTP3_ERR_PUSH_ID_BLOCKED = -106,
    NGHTTP3_ERR_MALFORMED_HTTP_HEADER = -107,
    NGHTTP3_ERR_REMOVE_HTTP_HEADER = -108,
    NGHTTP3_ERR_MALFORMED_HTTP_MESSAGING = -109,
    NGHTTP3_ERR_QPACK_FATAL = -111,
    NGHTTP3_ERR_QPACK_HEADER_TOO_LARGE = -112,
    NGHTTP3_ERR_IGNORE_STREAM = -113,
    NGHTTP3_ERR_STREAM_NOT_FOUND = -114,
    NGHTTP3_ERR_IGNORE_PUSH_PROMISE = -115,
    NGHTTP3_ERR_CONN_CLOSING = -116,
    NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED = -402,
    NGHTTP3_ERR_QPACK_ENCODER_STREAM_ERROR = -403,
    NGHTTP3_ERR_QPACK_DECODER_STREAM_ERROR = -404,
    NGHTTP3_ERR_H3_FRAME_UNEXPECTED = -408,
    NGHTTP3_ERR_H3_FRAME_ERROR = -409,
    NGHTTP3_ERR_H3_MISSING_SETTINGS = -665,
    NGHTTP3_ERR_H3_INTERNAL_ERROR = -667,
    NGHTTP3_ERR_H3_CLOSED_CRITICAL_STREAM = -668,
    NGHTTP3_ERR_H3_GENERAL_PROTOCOL_ERROR = -669,
    NGHTTP3_ERR_H3_ID_ERROR = -670,
    NGHTTP3_ERR_H3_SETTINGS_ERROR = -671,
    NGHTTP3_ERR_H3_STREAM_CREATION_ERROR = -672,
    NGHTTP3_ERR_FATAL = -900,
    NGHTTP3_ERR_NOMEM = -901,
    NGHTTP3_ERR_CALLBACK_FAILURE = -902
  } nghttp3_lib_error;
  typedef void *(*nghttp3_malloc)(size_t size, void *mem_user_data);
  typedef void (*nghttp3_free)(void *ptr, void *mem_user_data);
  typedef void *(*nghttp3_calloc)(size_t nmemb, size_t size, void *mem_user_data);
  typedef void *(*nghttp3_realloc)(void *ptr, size_t size, void *mem_user_data);
  typedef struct
  {
    void *mem_user_data;
    nghttp3_malloc malloc;
    nghttp3_free free;
    nghttp3_calloc calloc;
    nghttp3_realloc realloc;
  } nghttp3_mem;
  const nghttp3_mem *nghttp3_mem_default(void);
  typedef struct
  {
    uint8_t *base;
    size_t len;
  } nghttp3_vec;
  struct nghttp3_rcbuf;
  typedef struct nghttp3_rcbuf nghttp3_rcbuf;
  void nghttp3_rcbuf_incref(nghttp3_rcbuf *rcbuf);
  void nghttp3_rcbuf_decref(nghttp3_rcbuf *rcbuf);
  nghttp3_vec nghttp3_rcbuf_get_buf(const nghttp3_rcbuf *rcbuf);
  int nghttp3_rcbuf_is_static(const nghttp3_rcbuf *rcbuf);
  typedef struct
  {
    uint8_t *begin;
    uint8_t *end;
    uint8_t *pos;
    uint8_t *last;
  } nghttp3_buf;
  void nghttp3_buf_init(nghttp3_buf *buf);
  void nghttp3_buf_free(nghttp3_buf *buf, const nghttp3_mem *mem);
  size_t nghttp3_buf_left(const nghttp3_buf *buf);
  size_t nghttp3_buf_len(const nghttp3_buf *buf);
  void nghttp3_buf_reset(nghttp3_buf *buf);
  typedef enum
  {
    NGHTTP3_NV_FLAG_NONE = 0,
    NGHTTP3_NV_FLAG_NEVER_INDEX = 0x01,
    NGHTTP3_NV_FLAG_NO_COPY_NAME = 0x02,
    NGHTTP3_NV_FLAG_NO_COPY_VALUE = 0x04
  } nghttp3_nv_flag;
  typedef struct
  {
    uint8_t *name;
    uint8_t *value;
    size_t namelen;
    size_t valuelen;
    uint8_t flags;
  } nghttp3_nv;
  typedef enum
  {
    NGHTTP3_QPACK_TOKEN__AUTHORITY = 0,
    NGHTTP3_QPACK_TOKEN__PATH = 8,
    NGHTTP3_QPACK_TOKEN_AGE = 43,
    NGHTTP3_QPACK_TOKEN_CONTENT_DISPOSITION = 52,
    NGHTTP3_QPACK_TOKEN_CONTENT_LENGTH = 55,
    NGHTTP3_QPACK_TOKEN_COOKIE = 68,
    NGHTTP3_QPACK_TOKEN_DATE = 69,
    NGHTTP3_QPACK_TOKEN_ETAG = 71,
    NGHTTP3_QPACK_TOKEN_IF_MODIFIED_SINCE = 74,
    NGHTTP3_QPACK_TOKEN_IF_NONE_MATCH = 75,
    NGHTTP3_QPACK_TOKEN_LAST_MODIFIED = 77,
    NGHTTP3_QPACK_TOKEN_LINK = 78,
    NGHTTP3_QPACK_TOKEN_LOCATION = 79,
    NGHTTP3_QPACK_TOKEN_REFERER = 83,
    NGHTTP3_QPACK_TOKEN_SET_COOKIE = 85,
    NGHTTP3_QPACK_TOKEN__METHOD = 1,
    NGHTTP3_QPACK_TOKEN__SCHEME = 9,
    NGHTTP3_QPACK_TOKEN__STATUS = 11,
    NGHTTP3_QPACK_TOKEN_ACCEPT = 25,
    NGHTTP3_QPACK_TOKEN_ACCEPT_ENCODING = 27,
    NGHTTP3_QPACK_TOKEN_ACCEPT_RANGES = 29,
    NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_HEADERS = 32,
    NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_ORIGIN = 38,
    NGHTTP3_QPACK_TOKEN_CACHE_CONTROL = 46,
    NGHTTP3_QPACK_TOKEN_CONTENT_ENCODING = 53,
    NGHTTP3_QPACK_TOKEN_CONTENT_TYPE = 57,
    NGHTTP3_QPACK_TOKEN_RANGE = 82,
    NGHTTP3_QPACK_TOKEN_STRICT_TRANSPORT_SECURITY = 86,
    NGHTTP3_QPACK_TOKEN_VARY = 92,
    NGHTTP3_QPACK_TOKEN_X_CONTENT_TYPE_OPTIONS = 94,
    NGHTTP3_QPACK_TOKEN_X_XSS_PROTECTION = 98,
    NGHTTP3_QPACK_TOKEN_ACCEPT_LANGUAGE = 28,
    NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_CREDENTIALS = 30,
    NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_METHODS = 35,
    NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_EXPOSE_HEADERS = 39,
    NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_REQUEST_HEADERS = 40,
    NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_REQUEST_METHOD = 41,
    NGHTTP3_QPACK_TOKEN_ALT_SVC = 44,
    NGHTTP3_QPACK_TOKEN_AUTHORIZATION = 45,
    NGHTTP3_QPACK_TOKEN_CONTENT_SECURITY_POLICY = 56,
    NGHTTP3_QPACK_TOKEN_EARLY_DATA = 70,
    NGHTTP3_QPACK_TOKEN_EXPECT_CT = 72,
    NGHTTP3_QPACK_TOKEN_FORWARDED = 73,
    NGHTTP3_QPACK_TOKEN_IF_RANGE = 76,
    NGHTTP3_QPACK_TOKEN_ORIGIN = 80,
    NGHTTP3_QPACK_TOKEN_PURPOSE = 81,
    NGHTTP3_QPACK_TOKEN_SERVER = 84,
    NGHTTP3_QPACK_TOKEN_TIMING_ALLOW_ORIGIN = 89,
    NGHTTP3_QPACK_TOKEN_UPGRADE_INSECURE_REQUESTS = 90,
    NGHTTP3_QPACK_TOKEN_USER_AGENT = 91,
    NGHTTP3_QPACK_TOKEN_X_FORWARDED_FOR = 95,
    NGHTTP3_QPACK_TOKEN_X_FRAME_OPTIONS = 96,
    NGHTTP3_QPACK_TOKEN_HOST = 1000,
    NGHTTP3_QPACK_TOKEN_CONNECTION,
    NGHTTP3_QPACK_TOKEN_KEEP_ALIVE,
    NGHTTP3_QPACK_TOKEN_PROXY_CONNECTION,
    NGHTTP3_QPACK_TOKEN_TRANSFER_ENCODING,
    NGHTTP3_QPACK_TOKEN_UPGRADE,
    NGHTTP3_QPACK_TOKEN_TE,
    NGHTTP3_QPACK_TOKEN__PROTOCOL,
    NGHTTP3_QPACK_TOKEN_PRIORITY
  } nghttp3_qpack_token;
  typedef struct
  {
    nghttp3_rcbuf *name;
    nghttp3_rcbuf *value;
    int32_t token;
    uint8_t flags;
  } nghttp3_qpack_nv;
  struct nghttp3_qpack_encoder;
  typedef struct nghttp3_qpack_encoder nghttp3_qpack_encoder;
  int nghttp3_qpack_encoder_new(nghttp3_qpack_encoder **pencoder,
                                size_t max_dtable_size,
                                size_t max_blocked,
                                const nghttp3_mem *mem);
  void nghttp3_qpack_encoder_del(nghttp3_qpack_encoder *encoder);
  int nghttp3_qpack_encoder_encode(
      nghttp3_qpack_encoder *encoder, nghttp3_buf *pbuf, nghttp3_buf *rbuf,
      nghttp3_buf *ebuf, int64_t stream_id, const nghttp3_nv *nva, size_t nvlen);
  nghttp3_ssize nghttp3_qpack_encoder_read_decoder(
      nghttp3_qpack_encoder *encoder, const uint8_t *src, size_t srclen);
  int nghttp3_qpack_encoder_set_max_dtable_size(nghttp3_qpack_encoder *encoder,
                                                size_t max_dtable_size);
  int nghttp3_qpack_encoder_set_hard_max_dtable_size(nghttp3_qpack_encoder *encoder,
                                                     size_t hard_max_dtable_size);
  int nghttp3_qpack_encoder_set_max_blocked(nghttp3_qpack_encoder *encoder,
                                            size_t max_blocked);
  void
  nghttp3_qpack_encoder_ack_header(nghttp3_qpack_encoder *encoder,
                                   int64_t stream_id);
  int nghttp3_qpack_encoder_add_insert_count(nghttp3_qpack_encoder *encoder,
                                             uint64_t n);
  void
  nghttp3_qpack_encoder_ack_everything(nghttp3_qpack_encoder *encoder);
  void
  nghttp3_qpack_encoder_cancel_stream(nghttp3_qpack_encoder *encoder,
                                      int64_t stream_id);
  size_t
  nghttp3_qpack_encoder_get_num_blocked(nghttp3_qpack_encoder *encoder);
  struct nghttp3_qpack_stream_context;
  typedef struct nghttp3_qpack_stream_context nghttp3_qpack_stream_context;
  int nghttp3_qpack_stream_context_new(nghttp3_qpack_stream_context **psctx,
                                       int64_t stream_id, const nghttp3_mem *mem);
  void
  nghttp3_qpack_stream_context_del(nghttp3_qpack_stream_context *sctx);
  uint64_t
  nghttp3_qpack_stream_context_get_ricnt(nghttp3_qpack_stream_context *sctx);
  struct nghttp3_qpack_decoder;
  typedef struct nghttp3_qpack_decoder nghttp3_qpack_decoder;
  int nghttp3_qpack_decoder_new(nghttp3_qpack_decoder **pdecoder,
                                size_t max_dtable_size,
                                size_t max_blocked,
                                const nghttp3_mem *mem);
  void nghttp3_qpack_decoder_del(nghttp3_qpack_decoder *decoder);
  nghttp3_ssize nghttp3_qpack_decoder_read_encoder(
      nghttp3_qpack_decoder *decoder, const uint8_t *src, size_t srclen);
  uint64_t
  nghttp3_qpack_decoder_get_icnt(const nghttp3_qpack_decoder *decoder);
  typedef enum
  {
    NGHTTP3_QPACK_DECODE_FLAG_NONE,
    NGHTTP3_QPACK_DECODE_FLAG_EMIT = 0x01,
    NGHTTP3_QPACK_DECODE_FLAG_FINAL = 0x02,
    NGHTTP3_QPACK_DECODE_FLAG_BLOCKED = 0x04
  } nghttp3_qpack_decode_flag;
  nghttp3_ssize nghttp3_qpack_decoder_read_request(
      nghttp3_qpack_decoder *decoder, nghttp3_qpack_stream_context *sctx,
      nghttp3_qpack_nv *nv, uint8_t *pflags, const uint8_t *src, size_t srclen,
      int fin);
  void
  nghttp3_qpack_decoder_write_decoder(nghttp3_qpack_decoder *decoder,
                                      nghttp3_buf *dbuf);
  size_t
  nghttp3_qpack_decoder_get_decoder_streamlen(nghttp3_qpack_decoder *decoder);
  int nghttp3_qpack_decoder_cancel_stream(nghttp3_qpack_decoder *decoder,
                                          int64_t stream_id);
  void
  nghttp3_qpack_decoder_set_dtable_cap(nghttp3_qpack_decoder *decoder,
                                       size_t cap);
  void
  nghttp3_qpack_decoder_set_max_concurrent_streams(nghttp3_qpack_decoder *decoder,
                                                   size_t max_concurrent_streams);
  const char *nghttp3_strerror(int liberr);
  uint64_t nghttp3_err_infer_quic_app_error_code(int liberr);
  typedef void (*nghttp3_debug_vprintf_callback)(const char *format,
                                                 va_list args);
  void nghttp3_set_debug_vprintf_callback(
      nghttp3_debug_vprintf_callback debug_vprintf_callback);
  struct nghttp3_conn;
  typedef struct nghttp3_conn nghttp3_conn;
  typedef int (*nghttp3_acked_stream_data)(nghttp3_conn *conn, int64_t stream_id,
                                           size_t datalen, void *conn_user_data,
                                           void *stream_user_data);
  typedef int (*nghttp3_stream_close)(nghttp3_conn *conn, int64_t stream_id,
                                      uint64_t app_error_code,
                                      void *conn_user_data,
                                      void *stream_user_data);
  typedef int (*nghttp3_recv_data)(nghttp3_conn *conn, int64_t stream_id,
                                   const uint8_t *data, size_t datalen,
                                   void *conn_user_data, void *stream_user_data);
  typedef int (*nghttp3_deferred_consume)(nghttp3_conn *conn, int64_t stream_id,
                                          size_t consumed, void *conn_user_data,
                                          void *stream_user_data);
  typedef int (*nghttp3_begin_headers)(nghttp3_conn *conn, int64_t stream_id,
                                       void *conn_user_data,
                                       void *stream_user_data);
  typedef int (*nghttp3_recv_header)(nghttp3_conn *conn, int64_t stream_id,
                                     int32_t token, nghttp3_rcbuf *name,
                                     nghttp3_rcbuf *value, uint8_t flags,
                                     void *conn_user_data,
                                     void *stream_user_data);
  typedef int (*nghttp3_end_headers)(nghttp3_conn *conn, int64_t stream_id,
                                     void *conn_user_data,
                                     void *stream_user_data);
  typedef int (*nghttp3_begin_push_promise)(nghttp3_conn *conn, int64_t stream_id,
                                            int64_t push_id, void *conn_user_data,
                                            void *stream_user_data);
  typedef int (*nghttp3_recv_push_promise)(nghttp3_conn *conn, int64_t stream_id,
                                           int64_t push_id, int32_t token,
                                           nghttp3_rcbuf *name,
                                           nghttp3_rcbuf *value, uint8_t flags,
                                           void *conn_user_data,
                                           void *stream_user_data);
  typedef int (*nghttp3_end_push_promise)(nghttp3_conn *conn, int64_t stream_id,
                                          int64_t push_id, void *conn_user_data,
                                          void *stream_user_data);
  typedef int (*nghttp3_end_stream)(nghttp3_conn *conn, int64_t stream_id,
                                    void *conn_user_data, void *stream_user_data);
  typedef int (*nghttp3_cancel_push)(nghttp3_conn *conn, int64_t push_id,
                                     int64_t stream_id, void *conn_user_data,
                                     void *stream_user_data);
  typedef int (*nghttp3_send_stop_sending)(nghttp3_conn *conn, int64_t stream_id,
                                           uint64_t app_error_code,
                                           void *conn_user_data,
                                           void *stream_user_data);
  typedef int (*nghttp3_push_stream)(nghttp3_conn *conn, int64_t push_id,
                                     int64_t stream_id, void *conn_user_data);
  typedef int (*nghttp3_reset_stream)(nghttp3_conn *conn, int64_t stream_id,
                                      uint64_t app_error_code,
                                      void *conn_user_data,
                                      void *stream_user_data);
  typedef struct
  {
    nghttp3_acked_stream_data acked_stream_data;
    nghttp3_stream_close stream_close;
    nghttp3_recv_data recv_data;
    nghttp3_deferred_consume deferred_consume;
    nghttp3_begin_headers begin_headers;
    nghttp3_recv_header recv_header;
    nghttp3_end_headers end_headers;
    nghttp3_begin_headers begin_trailers;
    nghttp3_recv_header recv_trailer;
    nghttp3_end_headers end_trailers;
    nghttp3_begin_push_promise begin_push_promise;
    nghttp3_recv_push_promise recv_push_promise;
    nghttp3_end_push_promise end_push_promise;
    nghttp3_cancel_push cancel_push;
    nghttp3_send_stop_sending send_stop_sending;
    nghttp3_push_stream push_stream;
    nghttp3_end_stream end_stream;
    nghttp3_reset_stream reset_stream;
  } nghttp3_conn_callbacks;
  typedef struct
  {
    uint64_t max_field_section_size;
    uint64_t max_pushes;
    size_t qpack_max_table_capacity;
    size_t qpack_blocked_streams;
  } nghttp3_conn_settings;
  void
  nghttp3_conn_settings_default(nghttp3_conn_settings *settings);
  int nghttp3_conn_client_new(nghttp3_conn **pconn,
                              const nghttp3_conn_callbacks *callbacks,
                              const nghttp3_conn_settings *settings,
                              const nghttp3_mem *mem, void *conn_user_data);
  int nghttp3_conn_server_new(nghttp3_conn **pconn,
                              const nghttp3_conn_callbacks *callbacks,
                              const nghttp3_conn_settings *settings,
                              const nghttp3_mem *mem, void *conn_user_data);
  void nghttp3_conn_del(nghttp3_conn *conn);
  int nghttp3_conn_bind_control_stream(nghttp3_conn *conn,
                                       int64_t stream_id);
  int nghttp3_conn_bind_qpack_streams(nghttp3_conn *conn,
                                      int64_t qenc_stream_id,
                                      int64_t qdec_stream_id);
  nghttp3_ssize nghttp3_conn_read_stream(nghttp3_conn *conn,
                                         int64_t stream_id,
                                         const uint8_t *src,
                                         size_t srclen, int fin);
  nghttp3_ssize nghttp3_conn_writev_stream(nghttp3_conn *conn,
                                           int64_t *pstream_id,
                                           int *pfin,
                                           nghttp3_vec *vec,
                                           size_t veccnt);
  int nghttp3_conn_add_write_offset(nghttp3_conn *conn,
                                    int64_t stream_id, size_t n);
  int nghttp3_conn_add_ack_offset(nghttp3_conn *conn,
                                  int64_t stream_id, uint64_t n);
  int nghttp3_conn_block_stream(nghttp3_conn *conn,
                                int64_t stream_id);
  int nghttp3_conn_unblock_stream(nghttp3_conn *conn,
                                  int64_t stream_id);
  int nghttp3_conn_resume_stream(nghttp3_conn *conn,
                                 int64_t stream_id);
  int nghttp3_conn_close_stream(nghttp3_conn *conn,
                                int64_t stream_id,
                                uint64_t app_error_code);
  int nghttp3_conn_reset_stream(nghttp3_conn *conn,
                                int64_t stream_id);
  typedef enum
  {
    NGHTTP3_DATA_FLAG_NONE = 0x00,
    NGHTTP3_DATA_FLAG_EOF = 0x01,
    NGHTTP3_DATA_FLAG_NO_END_STREAM = 0x02
  } nghttp3_data_flag;
  void
  nghttp3_conn_set_max_client_streams_bidi(nghttp3_conn *conn,
                                           uint64_t max_streams);
  void
  nghttp3_conn_set_max_concurrent_streams(nghttp3_conn *conn,
                                          size_t max_concurrent_streams);
  typedef nghttp3_ssize (*nghttp3_read_data_callback)(
      nghttp3_conn *conn, int64_t stream_id, nghttp3_vec *vec, size_t veccnt,
      uint32_t *pflags, void *conn_user_data, void *stream_user_data);
  typedef struct
  {
    nghttp3_read_data_callback read_data;
  } nghttp3_data_reader;
  int nghttp3_conn_submit_request(
      nghttp3_conn *conn, int64_t stream_id, const nghttp3_nv *nva, size_t nvlen,
      const nghttp3_data_reader *dr, void *stream_user_data);
  int nghttp3_conn_submit_push_promise(nghttp3_conn *conn,
                                       int64_t *ppush_id,
                                       int64_t stream_id,
                                       const nghttp3_nv *nva,
                                       size_t nvlen);
  int nghttp3_conn_submit_info(nghttp3_conn *conn,
                               int64_t stream_id,
                               const nghttp3_nv *nva,
                               size_t nvlen);
  int nghttp3_conn_submit_response(nghttp3_conn *conn,
                                   int64_t stream_id,
                                   const nghttp3_nv *nva,
                                   size_t nvlen,
                                   const nghttp3_data_reader *dr);
  int nghttp3_conn_submit_trailers(nghttp3_conn *conn,
                                   int64_t stream_id,
                                   const nghttp3_nv *nva,
                                   size_t nvlen);
  int nghttp3_conn_bind_push_stream(nghttp3_conn *conn,
                                    int64_t push_id,
                                    int64_t stream_id);
  int nghttp3_conn_cancel_push(nghttp3_conn *conn,
                               int64_t push_id);
  int nghttp3_conn_submit_shutdown_notice(nghttp3_conn *conn);
  int nghttp3_conn_shutdown(nghttp3_conn *conn);
  int nghttp3_conn_set_stream_user_data(nghttp3_conn *conn,
                                        int64_t stream_id,
                                        void *stream_user_data);
  int64_t nghttp3_conn_get_frame_payload_left(nghttp3_conn *conn,
                                              int64_t stream_id);
  typedef struct nghttp3_pri
  {
    uint32_t urgency;
    int inc;
  } nghttp3_pri;
  int nghttp3_conn_get_stream_priority(nghttp3_conn *conn,
                                       nghttp3_pri *dest,
                                       int64_t stream_id);
  int nghttp3_conn_set_stream_priority(nghttp3_conn *conn,
                                       int64_t stream_id,
                                       const nghttp3_pri *pri);
  int nghttp3_conn_is_remote_qpack_encoder_stream(nghttp3_conn *conn,
                                                  int64_t stream_id);
  size_t nghttp3_vec_len(const nghttp3_vec *vec, size_t cnt);
  int nghttp3_vec_empty(const nghttp3_vec *vec, size_t cnt);
  void nghttp3_vec_consume(nghttp3_vec **pvec, size_t *pcnt,
                           size_t len);
  int nghttp3_check_header_name(const uint8_t *name, size_t len);
  int nghttp3_check_header_value(const uint8_t *value, size_t len);
  int nghttp3_http_parse_priority(nghttp3_pri *dest,
                                  const uint8_t *value,
                                  size_t len);
  typedef struct
  {
    int age;
    int version_num;
    const char *version_str;
  } nghttp3_info;
  nghttp3_info *nghttp3_version(int least_version);
}
void *nghttp3_mem_malloc(const nghttp3_mem *mem, size_t size);
void nghttp3_mem_free(const nghttp3_mem *mem, void *ptr);
void nghttp3_mem_free2(const nghttp3_free free_func, void *ptr,
                       void *mem_user_data);
void *nghttp3_mem_calloc(const nghttp3_mem *mem, size_t nmemb, size_t size);
void *nghttp3_mem_realloc(const nghttp3_mem *mem, void *ptr, size_t size);
void nghttp3_buf_wrap_init(nghttp3_buf *buf, uint8_t *src, size_t len);
size_t nghttp3_buf_cap(const nghttp3_buf *buf);
int nghttp3_buf_reserve(nghttp3_buf *buf, size_t size, const nghttp3_mem *mem);
void nghttp3_buf_swap(nghttp3_buf *a, nghttp3_buf *b);
typedef enum
{
  NGHTTP3_BUF_TYPE_PRIVATE,
  NGHTTP3_BUF_TYPE_SHARED,
  NGHTTP3_BUF_TYPE_ALIEN,
} nghttp3_buf_type;
typedef struct
{
  nghttp3_buf buf;
  nghttp3_buf_type type;
} nghttp3_typed_buf;
void nghttp3_typed_buf_init(nghttp3_typed_buf *tbuf, const nghttp3_buf *buf,
                            nghttp3_buf_type type);
void nghttp3_typed_buf_free(nghttp3_typed_buf *tbuf);
typedef void nghttp3_ksl_key;
struct nghttp3_ksl_node;
typedef struct nghttp3_ksl_node nghttp3_ksl_node;
struct nghttp3_ksl_blk;
typedef struct nghttp3_ksl_blk nghttp3_ksl_blk;
struct nghttp3_ksl_node
{
  union
  {
    nghttp3_ksl_blk *blk;
    void *data;
  };
  union
  {
    uint64_t align;
    uint8_t key[1];
  };
};
struct nghttp3_ksl_blk
{
  nghttp3_ksl_blk *next;
  nghttp3_ksl_blk *prev;
  size_t n;
  int leaf;
  union
  {
    uint64_t align;
    uint8_t nodes[1];
  };
};
typedef int (*nghttp3_ksl_compar)(const nghttp3_ksl_key *lhs,
                                  const nghttp3_ksl_key *rhs);
struct nghttp3_ksl;
typedef struct nghttp3_ksl nghttp3_ksl;
struct nghttp3_ksl_it;
typedef struct nghttp3_ksl_it nghttp3_ksl_it;
struct nghttp3_ksl_it
{
  const nghttp3_ksl *ksl;
  nghttp3_ksl_blk *blk;
  size_t i;
};
struct nghttp3_ksl
{
  nghttp3_ksl_blk *head;
  nghttp3_ksl_blk *front;
  nghttp3_ksl_blk *back;
  nghttp3_ksl_compar compar;
  size_t n;
  size_t keylen;
  size_t nodelen;
  const nghttp3_mem *mem;
};
int nghttp3_ksl_init(nghttp3_ksl *ksl, nghttp3_ksl_compar compar, size_t keylen,
                     const nghttp3_mem *mem);
void nghttp3_ksl_free(nghttp3_ksl *ksl);
int nghttp3_ksl_insert(nghttp3_ksl *ksl, nghttp3_ksl_it *it,
                       const nghttp3_ksl_key *key, void *data);
int nghttp3_ksl_remove(nghttp3_ksl *ksl, nghttp3_ksl_it *it,
                       const nghttp3_ksl_key *key);
nghttp3_ksl_it nghttp3_ksl_lower_bound(nghttp3_ksl *ksl,
                                       const nghttp3_ksl_key *key);
nghttp3_ksl_it nghttp3_ksl_lower_bound_compar(nghttp3_ksl *ksl,
                                              const nghttp3_ksl_key *key,
                                              nghttp3_ksl_compar compar);
void nghttp3_ksl_update_key(nghttp3_ksl *ksl, const nghttp3_ksl_key *old_key,
                            const nghttp3_ksl_key *new_key);
nghttp3_ksl_it nghttp3_ksl_begin(const nghttp3_ksl *ksl);
nghttp3_ksl_it nghttp3_ksl_end(const nghttp3_ksl *ksl);
size_t nghttp3_ksl_len(nghttp3_ksl *ksl);
void nghttp3_ksl_clear(nghttp3_ksl *ksl);
void nghttp3_ksl_print(nghttp3_ksl *ksl);
void nghttp3_ksl_it_init(nghttp3_ksl_it *it, const nghttp3_ksl *ksl,
                         nghttp3_ksl_blk *blk, size_t i);
void *nghttp3_ksl_it_get(const nghttp3_ksl_it *it);
void nghttp3_ksl_it_prev(nghttp3_ksl_it *it);
int nghttp3_ksl_it_begin(const nghttp3_ksl_it *it);
int nghttp3_ksl_range_compar(const nghttp3_ksl_key *lhs,
                             const nghttp3_ksl_key *rhs);
int nghttp3_ksl_range_exclusive_compar(const nghttp3_ksl_key *lhs,
                                       const nghttp3_ksl_key *rhs);
typedef uint64_t key_type;
typedef struct nghttp3_map_entry
{
  struct nghttp3_map_entry *next;
  key_type key;
} nghttp3_map_entry;
typedef struct nghttp3_map_bucket
{
  nghttp3_map_entry *ptr;
  nghttp3_ksl *ksl;
} nghttp3_map_bucket;
typedef struct
{
  nghttp3_map_bucket *table;
  const nghttp3_mem *mem;
  size_t size;
  uint32_t tablelen;
} nghttp3_map;
int nghttp3_map_init(nghttp3_map *map, const nghttp3_mem *mem);
void nghttp3_map_free(nghttp3_map *map);
void nghttp3_map_each_free(nghttp3_map *map,
                           int (*func)(nghttp3_map_entry *entry, void *ptr),
                           void *ptr);
void nghttp3_map_entry_init(nghttp3_map_entry *entry, key_type key);
int nghttp3_map_insert(nghttp3_map *map, nghttp3_map_entry *entry);
nghttp3_map_entry *nghttp3_map_find(nghttp3_map *map, key_type key);
int nghttp3_map_remove(nghttp3_map *map, key_type key);
void nghttp3_map_clear(nghttp3_map *map);
size_t nghttp3_map_size(nghttp3_map *map);
int nghttp3_map_each(nghttp3_map *map,
                     int (*func)(nghttp3_map_entry *entry, void *ptr),
                     void *ptr);
typedef struct
{
  size_t index;
} nghttp3_pq_entry;
typedef int (*nghttp3_less)(const nghttp3_pq_entry *lhs,
                            const nghttp3_pq_entry *rhs);
typedef struct
{
  nghttp3_pq_entry **q;
  const nghttp3_mem *mem;
  size_t length;
  size_t capacity;
  nghttp3_less less;
} nghttp3_pq;
void nghttp3_pq_init(nghttp3_pq *pq, nghttp3_less less, const nghttp3_mem *mem);
void nghttp3_pq_free(nghttp3_pq *pq);
int nghttp3_pq_push(nghttp3_pq *pq, nghttp3_pq_entry *item);
nghttp3_pq_entry *nghttp3_pq_top(const nghttp3_pq *pq);
void nghttp3_pq_pop(nghttp3_pq *pq);
int nghttp3_pq_empty(const nghttp3_pq *pq);
size_t nghttp3_pq_size(const nghttp3_pq *pq);
typedef int (*nghttp3_pq_item_cb)(nghttp3_pq_entry *item, void *arg);
int nghttp3_pq_each(const nghttp3_pq *pq, nghttp3_pq_item_cb fun, void *arg);
void nghttp3_pq_remove(nghttp3_pq *pq, nghttp3_pq_entry *item);
void nghttp3_pq_clear(nghttp3_pq *pq);
typedef enum
{
  NGHTTP3_NODE_ID_TYPE_STREAM = 0x00,
  NGHTTP3_NODE_ID_TYPE_PUSH = 0x01,
} nghttp3_node_id_type;
typedef struct
{
  nghttp3_node_id_type type;
  int64_t id;
} nghttp3_node_id;
nghttp3_node_id *nghttp3_node_id_init(nghttp3_node_id *nid,
                                      nghttp3_node_id_type type, int64_t id);
int nghttp3_node_id_eq(const nghttp3_node_id *a, const nghttp3_node_id *b);
struct nghttp3_tnode;
typedef struct nghttp3_tnode nghttp3_tnode;
struct nghttp3_tnode
{
  nghttp3_pq_entry pe;
  size_t num_children;
  nghttp3_node_id nid;
  uint64_t seq;
  uint64_t cycle;
  uint8_t pri;
};
void nghttp3_tnode_init(nghttp3_tnode *tnode, const nghttp3_node_id *nid,
                        uint64_t seq, uint8_t pri);
void nghttp3_tnode_free(nghttp3_tnode *tnode);
void nghttp3_tnode_unschedule(nghttp3_tnode *tnode, nghttp3_pq *pq);
int nghttp3_tnode_schedule(nghttp3_tnode *tnode, nghttp3_pq *pq, size_t nwrite);
int nghttp3_tnode_is_scheduled(nghttp3_tnode *tnode);
typedef struct
{
  uint8_t *buf;
  const nghttp3_mem *mem;
  size_t nmemb;
  size_t size;
  size_t first;
  size_t len;
} nghttp3_ringbuf;
int nghttp3_ringbuf_init(nghttp3_ringbuf *rb, size_t nmemb, size_t size,
                         const nghttp3_mem *mem);
void nghttp3_ringbuf_free(nghttp3_ringbuf *rb);
void *nghttp3_ringbuf_push_front(nghttp3_ringbuf *rb);
void *nghttp3_ringbuf_push_back(nghttp3_ringbuf *rb);
void nghttp3_ringbuf_pop_front(nghttp3_ringbuf *rb);
void nghttp3_ringbuf_pop_back(nghttp3_ringbuf *rb);
void nghttp3_ringbuf_resize(nghttp3_ringbuf *rb, size_t len);
void *nghttp3_ringbuf_get(nghttp3_ringbuf *rb, size_t offset);
int nghttp3_ringbuf_full(nghttp3_ringbuf *rb);
int nghttp3_ringbuf_reserve(nghttp3_ringbuf *rb, size_t nmemb);
typedef enum
{
  NGHTTP3_FRAME_DATA = 0x00,
  NGHTTP3_FRAME_HEADERS = 0x01,
  NGHTTP3_FRAME_CANCEL_PUSH = 0x03,
  NGHTTP3_FRAME_SETTINGS = 0x04,
  NGHTTP3_FRAME_PUSH_PROMISE = 0x05,
  NGHTTP3_FRAME_GOAWAY = 0x07,
  NGHTTP3_FRAME_MAX_PUSH_ID = 0x0d,
} nghttp3_frame_type;
typedef enum
{
  NGHTTP3_H2_FRAME_PRIORITY = 0x02,
  NGHTTP3_H2_FRAME_PING = 0x06,
  NGHTTP3_H2_FRAME_WINDOW_UPDATE = 0x08,
  NGHTTP3_H2_FRAME_CONTINUATION = 0x9,
} nghttp3_h2_reserved_type;
typedef struct
{
  int64_t type;
  int64_t length;
} nghttp3_frame_hd;
typedef struct
{
  nghttp3_frame_hd hd;
} nghttp3_frame_data;
typedef struct
{
  nghttp3_frame_hd hd;
  nghttp3_nv *nva;
  size_t nvlen;
} nghttp3_frame_headers;
typedef struct
{
  nghttp3_frame_hd hd;
  int64_t push_id;
} nghttp3_frame_cancel_push;
typedef struct
{
  uint64_t id;
  uint64_t value;
} nghttp3_settings_entry;
typedef struct
{
  nghttp3_frame_hd hd;
  size_t niv;
  nghttp3_settings_entry iv[1];
} nghttp3_frame_settings;
typedef struct
{
  nghttp3_frame_hd hd;
  nghttp3_nv *nva;
  size_t nvlen;
  int64_t push_id;
} nghttp3_frame_push_promise;
typedef struct
{
  nghttp3_frame_hd hd;
  int64_t id;
} nghttp3_frame_goaway;
typedef struct
{
  nghttp3_frame_hd hd;
  int64_t push_id;
} nghttp3_frame_max_push_id;
typedef union
{
  nghttp3_frame_hd hd;
  nghttp3_frame_data data;
  nghttp3_frame_headers headers;
  nghttp3_frame_cancel_push cancel_push;
  nghttp3_frame_settings settings;
  nghttp3_frame_push_promise push_promise;
  nghttp3_frame_goaway goaway;
  nghttp3_frame_max_push_id max_push_id;
} nghttp3_frame;
uint8_t *nghttp3_frame_write_hd(uint8_t *dest, const nghttp3_frame_hd *hd);
size_t nghttp3_frame_write_hd_len(const nghttp3_frame_hd *hd);
uint8_t *nghttp3_frame_write_settings(uint8_t *dest,
                                      const nghttp3_frame_settings *fr);
size_t nghttp3_frame_write_settings_len(int64_t *pppayloadlen,
                                        const nghttp3_frame_settings *fr);
uint8_t *nghttp3_frame_write_cancel_push(uint8_t *dest,
                                         const nghttp3_frame_cancel_push *fr);
size_t nghttp3_frame_write_cancel_push_len(int64_t *ppayloadlen,
                                           const nghttp3_frame_cancel_push *fr);
uint8_t *nghttp3_frame_write_max_push_id(uint8_t *dest,
                                         const nghttp3_frame_max_push_id *fr);
size_t nghttp3_frame_write_max_push_id_len(int64_t *ppayloadlen,
                                           const nghttp3_frame_max_push_id *fr);
uint8_t *nghttp3_frame_write_goaway(uint8_t *dest,
                                    const nghttp3_frame_goaway *fr);
size_t nghttp3_frame_write_goaway_len(int64_t *ppayloadlen,
                                      const nghttp3_frame_goaway *fr);
int nghttp3_nva_copy(nghttp3_nv **pnva, const nghttp3_nv *nva, size_t nvlen,
                     const nghttp3_mem *mem);
void nghttp3_nva_del(nghttp3_nv *nva, const nghttp3_mem *mem);
void nghttp3_frame_headers_free(nghttp3_frame_headers *fr,
                                const nghttp3_mem *mem);
void nghttp3_frame_push_promise_free(nghttp3_frame_push_promise *fr,
                                     const nghttp3_mem *mem);
struct nghttp3_rcbuf
{
  void *mem_user_data;
  nghttp3_free free;
  uint8_t *base;
  size_t len;
  int32_t ref;
};
int nghttp3_rcbuf_new(nghttp3_rcbuf **rcbuf_ptr, size_t size,
                      const nghttp3_mem *mem);
int nghttp3_rcbuf_new2(nghttp3_rcbuf **rcbuf_ptr, const uint8_t *src,
                       size_t srclen, const nghttp3_mem *mem);
void nghttp3_rcbuf_del(nghttp3_rcbuf *rcbuf);
typedef struct
{
  uint32_t nbits;
  uint32_t code;
} nghttp3_qpack_huffman_sym;
extern const nghttp3_qpack_huffman_sym huffman_sym_table[];
size_t nghttp3_qpack_huffman_encode_count(const uint8_t *src, size_t len);
uint8_t *nghttp3_qpack_huffman_encode(uint8_t *dest, const uint8_t *src,
                                      size_t srclen);
typedef enum
{
  NGHTTP3_QPACK_HUFFMAN_ACCEPTED = 1 << 14,
  NGHTTP3_QPACK_HUFFMAN_SYM = 1 << 15,
} nghttp3_qpack_huffman_decode_flag;
typedef struct
{
  uint16_t fstate;
  uint8_t sym;
} nghttp3_qpack_huffman_decode_node;
typedef struct
{
  uint16_t fstate;
} nghttp3_qpack_huffman_decode_context;
extern const nghttp3_qpack_huffman_decode_node qpack_huffman_decode_table[][16];
void nghttp3_qpack_huffman_decode_context_init(
    nghttp3_qpack_huffman_decode_context *ctx);
nghttp3_ssize
nghttp3_qpack_huffman_decode(nghttp3_qpack_huffman_decode_context *ctx,
                             uint8_t *dest, const uint8_t *src, size_t srclen,
                             int fin);
int nghttp3_qpack_huffman_decode_failure_state(
    nghttp3_qpack_huffman_decode_context *ctx);
typedef enum
{
  NGHTTP3_QPACK_INDEXING_MODE_LITERAL,
  NGHTTP3_QPACK_INDEXING_MODE_STORE,
  NGHTTP3_QPACK_INDEXING_MODE_NEVER,
} nghttp3_qpack_indexing_mode;
struct nghttp3_qpack_entry;
typedef struct nghttp3_qpack_entry nghttp3_qpack_entry;
struct nghttp3_qpack_entry
{
  nghttp3_qpack_nv nv;
  nghttp3_qpack_entry *map_next;
  size_t sum;
  uint64_t absidx;
  uint32_t hash;
};
typedef struct
{
  uint64_t absidx;
  int32_t token;
  uint32_t hash;
} nghttp3_qpack_static_entry;
typedef struct
{
  nghttp3_rcbuf name;
  nghttp3_rcbuf value;
  int32_t token;
} nghttp3_qpack_static_header;
typedef struct
{
  nghttp3_pq_entry max_cnts_pe;
  nghttp3_pq_entry min_cnts_pe;
  uint64_t max_cnt;
  uint64_t min_cnt;
} nghttp3_qpack_header_block_ref;
int nghttp3_qpack_header_block_ref_new(nghttp3_qpack_header_block_ref **pref,
                                       uint64_t max_cnt, uint64_t min_cnt,
                                       const nghttp3_mem *mem);
void nghttp3_qpack_header_block_ref_del(nghttp3_qpack_header_block_ref *ref,
                                        const nghttp3_mem *mem);
typedef struct
{
  nghttp3_map_entry me;
  nghttp3_ringbuf refs;
  nghttp3_pq max_cnts;
} nghttp3_qpack_stream;
int nghttp3_qpack_stream_new(nghttp3_qpack_stream **pstream, int64_t stream_id,
                             const nghttp3_mem *mem);
void nghttp3_qpack_stream_del(nghttp3_qpack_stream *stream,
                              const nghttp3_mem *mem);
uint64_t nghttp3_qpack_stream_get_max_cnt(const nghttp3_qpack_stream *stream);
int nghttp3_qpack_stream_add_ref(nghttp3_qpack_stream *stream,
                                 nghttp3_qpack_header_block_ref *ref);
void nghttp3_qpack_stream_pop_ref(nghttp3_qpack_stream *stream);
typedef struct
{
  nghttp3_ringbuf dtable;
  const nghttp3_mem *mem;
  size_t dtable_size;
  size_t dtable_sum;
  size_t hard_max_dtable_size;
  size_t max_dtable_size;
  size_t max_blocked;
  uint64_t next_absidx;
  uint8_t bad;
} nghttp3_qpack_context;
typedef struct
{
  nghttp3_qpack_huffman_decode_context huffman_ctx;
  nghttp3_buf namebuf;
  nghttp3_buf valuebuf;
  nghttp3_rcbuf *name;
  nghttp3_rcbuf *value;
  uint64_t left;
  size_t prefix;
  size_t shift;
  uint64_t absidx;
  int never;
  int dynamic;
  int huffman_encoded;
} nghttp3_qpack_read_state;
void nghttp3_qpack_read_state_free(nghttp3_qpack_read_state *rstate);
void nghttp3_qpack_read_state_reset(nghttp3_qpack_read_state *rstate);
typedef struct
{
  nghttp3_qpack_entry *table[64];
} nghttp3_qpack_map;
typedef enum
{
  NGHTTP3_QPACK_DS_STATE_OPCODE,
  NGHTTP3_QPACK_DS_STATE_READ_NUMBER,
} nghttp3_qpack_decoder_stream_state;
typedef enum
{
  NGHTTP3_QPACK_DS_OPCODE_ICNT_INCREMENT,
  NGHTTP3_QPACK_DS_OPCODE_SECTION_ACK,
  NGHTTP3_QPACK_DS_OPCODE_STREAM_CANCEL,
} nghttp3_qpack_decoder_stream_opcode;
typedef enum
{
  NGHTTP3_QPACK_ENCODER_FLAG_NONE = 0x00,
  NGHTTP3_QPACK_ENCODER_FLAG_PENDING_SET_DTABLE_CAP = 0x01,
} nghttp3_qpack_encoder_flag;
struct nghttp3_qpack_encoder
{
  nghttp3_qpack_context ctx;
  nghttp3_qpack_map dtable_map;
  nghttp3_map streams;
  nghttp3_ksl blocked_streams;
  nghttp3_pq min_cnts;
  uint64_t krcnt;
  nghttp3_qpack_decoder_stream_state state;
  nghttp3_qpack_decoder_stream_opcode opcode;
  nghttp3_qpack_read_state rstate;
  size_t min_dtable_update;
  size_t last_max_dtable_update;
  uint8_t flags;
};
int nghttp3_qpack_encoder_init(nghttp3_qpack_encoder *encoder,
                               size_t max_dtable_size, size_t max_blocked,
                               const nghttp3_mem *mem);
void nghttp3_qpack_encoder_free(nghttp3_qpack_encoder *encoder);
int nghttp3_qpack_encoder_encode_nv(nghttp3_qpack_encoder *encoder,
                                    uint64_t *pmax_cnt, uint64_t *pmin_cnt,
                                    nghttp3_buf *rbuf, nghttp3_buf *ebuf,
                                    const nghttp3_nv *nv, uint64_t base,
                                    int allow_blocking);
typedef struct
{
  nghttp3_ssize index;
  int name_value_match;
  nghttp3_ssize pb_index;
} nghttp3_qpack_lookup_result;
nghttp3_qpack_lookup_result
nghttp3_qpack_lookup_stable(const nghttp3_nv *nv, int32_t token,
                            nghttp3_qpack_indexing_mode indexing_mode);
nghttp3_qpack_lookup_result nghttp3_qpack_encoder_lookup_dtable(
    nghttp3_qpack_encoder *encoder, const nghttp3_nv *nv, int32_t token,
    uint32_t hash, nghttp3_qpack_indexing_mode indexing_mode, uint64_t krcnt,
    int allow_blocking);
int nghttp3_qpack_encoder_write_field_section_prefix(
    nghttp3_qpack_encoder *encoder, nghttp3_buf *pbuf, uint64_t ricnt,
    uint64_t base);
int nghttp3_qpack_encoder_write_static_indexed(nghttp3_qpack_encoder *encoder,
                                               nghttp3_buf *rbuf,
                                               uint64_t absidx);
int nghttp3_qpack_encoder_write_dynamic_indexed(nghttp3_qpack_encoder *encoder,
                                                nghttp3_buf *rbuf,
                                                uint64_t absidx, uint64_t base);
int nghttp3_qpack_encoder_write_static_indexed_name(
    nghttp3_qpack_encoder *encoder, nghttp3_buf *rbuf, uint64_t absidx,
    const nghttp3_nv *nv);
int nghttp3_qpack_encoder_write_dynamic_indexed_name(
    nghttp3_qpack_encoder *encoder, nghttp3_buf *rbuf, uint64_t absidx,
    uint64_t base, const nghttp3_nv *nv);
int nghttp3_qpack_encoder_write_literal(nghttp3_qpack_encoder *encoder,
                                        nghttp3_buf *rbuf,
                                        const nghttp3_nv *nv);
int nghttp3_qpack_encoder_write_static_insert(nghttp3_qpack_encoder *encoder,
                                              nghttp3_buf *ebuf,
                                              uint64_t absidx,
                                              const nghttp3_nv *nv);
int nghttp3_qpack_encoder_write_dynamic_insert(nghttp3_qpack_encoder *encoder,
                                               nghttp3_buf *ebuf,
                                               uint64_t absidx,
                                               const nghttp3_nv *nv);
int nghttp3_qpack_encoder_write_duplicate_insert(nghttp3_qpack_encoder *encoder,
                                                 nghttp3_buf *ebuf,
                                                 uint64_t absidx);
int nghttp3_qpack_encoder_write_literal_insert(nghttp3_qpack_encoder *encoder,
                                               nghttp3_buf *ebuf,
                                               const nghttp3_nv *nv);
int nghttp3_qpack_encoder_stream_is_blocked(nghttp3_qpack_encoder *encoder,
                                            nghttp3_qpack_stream *stream);
int nghttp3_qpack_encoder_block_stream(nghttp3_qpack_encoder *encoder,
                                       nghttp3_qpack_stream *stream);
void nghttp3_qpack_encoder_unblock_stream(nghttp3_qpack_encoder *encoder,
                                          nghttp3_qpack_stream *stream);
void nghttp3_qpack_encoder_unblock(nghttp3_qpack_encoder *encoder,
                                   uint64_t max_cnt);
nghttp3_qpack_stream *
nghttp3_qpack_encoder_find_stream(nghttp3_qpack_encoder *encoder,
                                  int64_t stream_id);
uint64_t nghttp3_qpack_encoder_get_min_cnt(nghttp3_qpack_encoder *encoder);
void nghttp3_qpack_encoder_shrink_dtable(nghttp3_qpack_encoder *encoder);
int nghttp3_qpack_encoder_process_dtable_update(nghttp3_qpack_encoder *encoder,
                                                nghttp3_buf *ebuf);
int nghttp3_qpack_encoder_write_set_dtable_cap(nghttp3_qpack_encoder *encoder,
                                               nghttp3_buf *ebuf, size_t cap);
int nghttp3_qpack_context_dtable_add(nghttp3_qpack_context *ctx,
                                     nghttp3_qpack_nv *qnv,
                                     nghttp3_qpack_map *dtable_map,
                                     uint32_t hash);
int nghttp3_qpack_encoder_dtable_static_add(nghttp3_qpack_encoder *encoder,
                                            uint64_t absidx,
                                            const nghttp3_nv *nv,
                                            uint32_t hash);
int nghttp3_qpack_encoder_dtable_dynamic_add(nghttp3_qpack_encoder *encoder,
                                             uint64_t absidx,
                                             const nghttp3_nv *nv,
                                             uint32_t hash);
int nghttp3_qpack_encoder_dtable_duplicate_add(nghttp3_qpack_encoder *encoder,
                                               uint64_t absidx);
int nghttp3_qpack_encoder_dtable_literal_add(nghttp3_qpack_encoder *encoder,
                                             const nghttp3_nv *nv,
                                             int32_t token, uint32_t hash);
nghttp3_qpack_entry *
nghttp3_qpack_context_dtable_get(nghttp3_qpack_context *ctx, uint64_t absidx);
nghttp3_qpack_entry *
nghttp3_qpack_context_dtable_top(nghttp3_qpack_context *ctx);
void nghttp3_qpack_entry_init(nghttp3_qpack_entry *ent, nghttp3_qpack_nv *qnv,
                              size_t sum, uint64_t absidx, uint32_t hash);
void nghttp3_qpack_entry_free(nghttp3_qpack_entry *ent);
size_t nghttp3_qpack_put_varint_len(uint64_t n, size_t prefix);
uint8_t *nghttp3_qpack_put_varint(uint8_t *buf, uint64_t n, size_t prefix);
typedef enum
{
  NGHTTP3_QPACK_ES_STATE_OPCODE,
  NGHTTP3_QPACK_ES_STATE_READ_INDEX,
  NGHTTP3_QPACK_ES_STATE_CHECK_NAME_HUFFMAN,
  NGHTTP3_QPACK_ES_STATE_READ_NAMELEN,
  NGHTTP3_QPACK_ES_STATE_READ_NAME_HUFFMAN,
  NGHTTP3_QPACK_ES_STATE_READ_NAME,
  NGHTTP3_QPACK_ES_STATE_CHECK_VALUE_HUFFMAN,
  NGHTTP3_QPACK_ES_STATE_READ_VALUELEN,
  NGHTTP3_QPACK_ES_STATE_READ_VALUE_HUFFMAN,
  NGHTTP3_QPACK_ES_STATE_READ_VALUE,
} nghttp3_qpack_encoder_stream_state;
typedef enum
{
  NGHTTP3_QPACK_ES_OPCODE_INSERT_INDEXED,
  NGHTTP3_QPACK_ES_OPCODE_INSERT,
  NGHTTP3_QPACK_ES_OPCODE_DUPLICATE,
  NGHTTP3_QPACK_ES_OPCODE_SET_DTABLE_CAP,
} nghttp3_qpack_encoder_stream_opcode;
typedef enum
{
  NGHTTP3_QPACK_RS_STATE_RICNT,
  NGHTTP3_QPACK_RS_STATE_DBASE_SIGN,
  NGHTTP3_QPACK_RS_STATE_DBASE,
  NGHTTP3_QPACK_RS_STATE_OPCODE,
  NGHTTP3_QPACK_RS_STATE_READ_INDEX,
  NGHTTP3_QPACK_RS_STATE_CHECK_NAME_HUFFMAN,
  NGHTTP3_QPACK_RS_STATE_READ_NAMELEN,
  NGHTTP3_QPACK_RS_STATE_READ_NAME_HUFFMAN,
  NGHTTP3_QPACK_RS_STATE_READ_NAME,
  NGHTTP3_QPACK_RS_STATE_CHECK_VALUE_HUFFMAN,
  NGHTTP3_QPACK_RS_STATE_READ_VALUELEN,
  NGHTTP3_QPACK_RS_STATE_READ_VALUE_HUFFMAN,
  NGHTTP3_QPACK_RS_STATE_READ_VALUE,
  NGHTTP3_QPACK_RS_STATE_BLOCKED,
} nghttp3_qpack_request_stream_state;
typedef enum
{
  NGHTTP3_QPACK_RS_OPCODE_INDEXED,
  NGHTTP3_QPACK_RS_OPCODE_INDEXED_PB,
  NGHTTP3_QPACK_RS_OPCODE_INDEXED_NAME,
  NGHTTP3_QPACK_RS_OPCODE_INDEXED_NAME_PB,
  NGHTTP3_QPACK_RS_OPCODE_LITERAL,
} nghttp3_qpack_request_stream_opcode;
struct nghttp3_qpack_decoder
{
  nghttp3_qpack_context ctx;
  nghttp3_qpack_encoder_stream_state state;
  nghttp3_qpack_encoder_stream_opcode opcode;
  nghttp3_qpack_read_state rstate;
  nghttp3_buf dbuf;
  uint64_t written_icnt;
  size_t max_concurrent_streams;
};
int nghttp3_qpack_decoder_init(nghttp3_qpack_decoder *decoder,
                               size_t max_dtable_size, size_t max_blocked,
                               const nghttp3_mem *mem);
void nghttp3_qpack_decoder_free(nghttp3_qpack_decoder *decoder);
int nghttp3_qpack_decoder_dtable_indexed_add(nghttp3_qpack_decoder *decoder);
int nghttp3_qpack_decoder_dtable_static_add(nghttp3_qpack_decoder *decoder);
int nghttp3_qpack_decoder_dtable_dynamic_add(nghttp3_qpack_decoder *decoder);
int nghttp3_qpack_decoder_dtable_duplicate_add(nghttp3_qpack_decoder *decoder);
int nghttp3_qpack_decoder_dtable_literal_add(nghttp3_qpack_decoder *decoder);
struct nghttp3_qpack_stream_context
{
  nghttp3_qpack_request_stream_state state;
  nghttp3_qpack_read_state rstate;
  const nghttp3_mem *mem;
  nghttp3_qpack_request_stream_opcode opcode;
  int64_t stream_id;
  uint64_t ricnt;
  uint64_t base;
  int dbase_sign;
};
void nghttp3_qpack_stream_context_init(nghttp3_qpack_stream_context *sctx,
                                       int64_t stream_id,
                                       const nghttp3_mem *mem);
void nghttp3_qpack_stream_context_free(nghttp3_qpack_stream_context *sctx);
void nghttp3_qpack_stream_context_reset(nghttp3_qpack_stream_context *sctx);
int nghttp3_qpack_decoder_reconstruct_ricnt(nghttp3_qpack_decoder *decoder,
                                            uint64_t *dest, uint64_t encricnt);
int nghttp3_qpack_decoder_rel2abs(nghttp3_qpack_decoder *decoder,
                                  nghttp3_qpack_read_state *rstate);
int nghttp3_qpack_decoder_brel2abs(nghttp3_qpack_decoder *decoder,
                                   nghttp3_qpack_stream_context *sctx);
int nghttp3_qpack_decoder_pbrel2abs(nghttp3_qpack_decoder *decoder,
                                    nghttp3_qpack_stream_context *sctx);
void nghttp3_qpack_decoder_emit_indexed(nghttp3_qpack_decoder *decoder,
                                        nghttp3_qpack_stream_context *sctx,
                                        nghttp3_qpack_nv *nv);
void nghttp3_qpack_decoder_emit_indexed_name(nghttp3_qpack_decoder *decoder,
                                             nghttp3_qpack_stream_context *sctx,
                                             nghttp3_qpack_nv *nv);
void nghttp3_qpack_decoder_emit_literal(nghttp3_qpack_decoder *decoder,
                                        nghttp3_qpack_stream_context *sctx,
                                        nghttp3_qpack_nv *nv);
int nghttp3_qpack_decoder_write_section_ack(
    nghttp3_qpack_decoder *decoder, const nghttp3_qpack_stream_context *sctx);
typedef enum
{
  NGHTTP3_STREAM_TYPE_CONTROL = 0x00,
  NGHTTP3_STREAM_TYPE_PUSH = 0x01,
  NGHTTP3_STREAM_TYPE_QPACK_ENCODER = 0x02,
  NGHTTP3_STREAM_TYPE_QPACK_DECODER = 0x03,
  NGHTTP3_STREAM_TYPE_UNKNOWN =
      (18446744073709551615UL),
} nghttp3_stream_type;
typedef enum
{
  NGHTTP3_CTRL_STREAM_STATE_FRAME_TYPE,
  NGHTTP3_CTRL_STREAM_STATE_FRAME_LENGTH,
  NGHTTP3_CTRL_STREAM_STATE_CANCEL_PUSH,
  NGHTTP3_CTRL_STREAM_STATE_SETTINGS,
  NGHTTP3_CTRL_STREAM_STATE_GOAWAY,
  NGHTTP3_CTRL_STREAM_STATE_MAX_PUSH_ID,
  NGHTTP3_CTRL_STREAM_STATE_IGN_FRAME,
  NGHTTP3_CTRL_STREAM_STATE_SETTINGS_ID,
  NGHTTP3_CTRL_STREAM_STATE_SETTINGS_VALUE,
} nghttp3_ctrl_stream_state;
typedef enum
{
  NGHTTP3_REQ_STREAM_STATE_FRAME_TYPE,
  NGHTTP3_REQ_STREAM_STATE_FRAME_LENGTH,
  NGHTTP3_REQ_STREAM_STATE_DATA,
  NGHTTP3_REQ_STREAM_STATE_HEADERS,
  NGHTTP3_REQ_STREAM_STATE_PUSH_PROMISE_PUSH_ID,
  NGHTTP3_REQ_STREAM_STATE_PUSH_PROMISE,
  NGHTTP3_REQ_STREAM_STATE_IGN_PUSH_PROMISE,
  NGHTTP3_REQ_STREAM_STATE_IGN_FRAME,
  NGHTTP3_REQ_STREAM_STATE_IGN_REST,
} nghttp3_req_stream_state;
typedef enum
{
  NGHTTP3_PUSH_STREAM_STATE_FRAME_TYPE,
  NGHTTP3_PUSH_STREAM_STATE_FRAME_LENGTH,
  NGHTTP3_PUSH_STREAM_STATE_DATA,
  NGHTTP3_PUSH_STREAM_STATE_HEADERS,
  NGHTTP3_PUSH_STREAM_STATE_IGN_FRAME,
  NGHTTP3_PUSH_STREAM_STATE_PUSH_ID,
  NGHTTP3_PUSH_STREAM_STATE_IGN_REST,
} nghttp3_push_stream_state;
typedef struct
{
  int64_t acc;
  size_t left;
} nghttp3_varint_read_state;
typedef struct
{
  nghttp3_varint_read_state rvint;
  nghttp3_frame fr;
  int state;
  int64_t left;
} nghttp3_stream_read_state;
typedef enum
{
  NGHTTP3_STREAM_FLAG_NONE = 0x0000,
  NGHTTP3_STREAM_FLAG_TYPE_IDENTIFIED = 0x0001,
  NGHTTP3_STREAM_FLAG_FC_BLOCKED = 0x0002,
  NGHTTP3_STREAM_FLAG_READ_DATA_BLOCKED = 0x0004,
  NGHTTP3_STREAM_FLAG_WRITE_END_STREAM = 0x0008,
  NGHTTP3_STREAM_FLAG_QPACK_DECODE_BLOCKED = 0x0010,
  NGHTTP3_STREAM_FLAG_READ_EOF = 0x0020,
  NGHTTP3_STREAM_FLAG_CLOSED = 0x0040,
  NGHTTP3_STREAM_FLAG_PUSH_PROMISE_BLOCKED = 0x0080,
  NGHTTP3_STREAM_FLAG_RESET = 0x0200,
} nghttp3_stream_flag;
typedef enum
{
  NGHTTP3_HTTP_STATE_NONE,
  NGHTTP3_HTTP_STATE_REQ_INITIAL,
  NGHTTP3_HTTP_STATE_REQ_BEGIN,
  NGHTTP3_HTTP_STATE_REQ_HEADERS_BEGIN,
  NGHTTP3_HTTP_STATE_REQ_HEADERS_END,
  NGHTTP3_HTTP_STATE_REQ_DATA_BEGIN,
  NGHTTP3_HTTP_STATE_REQ_DATA_END,
  NGHTTP3_HTTP_STATE_REQ_TRAILERS_BEGIN,
  NGHTTP3_HTTP_STATE_REQ_TRAILERS_END,
  NGHTTP3_HTTP_STATE_REQ_END,
  NGHTTP3_HTTP_STATE_RESP_INITIAL,
  NGHTTP3_HTTP_STATE_RESP_BEGIN,
  NGHTTP3_HTTP_STATE_RESP_HEADERS_BEGIN,
  NGHTTP3_HTTP_STATE_RESP_HEADERS_END,
  NGHTTP3_HTTP_STATE_RESP_DATA_BEGIN,
  NGHTTP3_HTTP_STATE_RESP_DATA_END,
  NGHTTP3_HTTP_STATE_RESP_TRAILERS_BEGIN,
  NGHTTP3_HTTP_STATE_RESP_TRAILERS_END,
  NGHTTP3_HTTP_STATE_RESP_END,
} nghttp3_stream_http_state;
typedef enum
{
  NGHTTP3_HTTP_EVENT_DATA_BEGIN,
  NGHTTP3_HTTP_EVENT_DATA_END,
  NGHTTP3_HTTP_EVENT_HEADERS_BEGIN,
  NGHTTP3_HTTP_EVENT_HEADERS_END,
  NGHTTP3_HTTP_EVENT_PUSH_PROMISE_BEGIN,
  NGHTTP3_HTTP_EVENT_PUSH_PROMISE_END,
  NGHTTP3_HTTP_EVENT_MSG_END,
} nghttp3_stream_http_event;
struct nghttp3_stream;
typedef struct nghttp3_stream nghttp3_stream;
struct nghttp3_push_promise;
typedef struct nghttp3_push_promise nghttp3_push_promise;
typedef int (*nghttp3_stream_acked_data)(nghttp3_stream *stream,
                                         int64_t stream_id, size_t datalen,
                                         void *user_data);
typedef struct
{
  nghttp3_stream_acked_data acked_data;
} nghttp3_stream_callbacks;
struct nghttp3_http_state
{
  int32_t status_code;
  int64_t content_length;
  int64_t recv_content_length;
  uint16_t flags;
  uint8_t pri;
};
typedef struct nghttp3_http_state nghttp3_http_state;
struct nghttp3_stream
{
  const nghttp3_mem *mem;
  nghttp3_map_entry me;
  nghttp3_tnode node;
  nghttp3_pq_entry qpack_blocked_pe;
  nghttp3_stream_callbacks callbacks;
  nghttp3_ringbuf frq;
  nghttp3_ringbuf chunks;
  nghttp3_ringbuf outq;
  nghttp3_ringbuf inq;
  nghttp3_qpack_stream_context qpack_sctx;
  nghttp3_conn *conn;
  void *user_data;
  size_t unsent_bytes;
  size_t outq_idx;
  size_t outq_offset;
  uint64_t ack_offset;
  size_t ack_done;
  size_t unscheduled_nwrite;
  nghttp3_stream_type type;
  nghttp3_stream_read_state rstate;
  nghttp3_push_promise *pp;
  uint64_t error_code;
  struct
  {
    nghttp3_stream_http_state hstate;
  } tx;
  struct
  {
    nghttp3_stream_http_state hstate;
    nghttp3_http_state http;
  } rx;
  uint16_t flags;
};
typedef struct
{
  nghttp3_frame fr;
  union
  {
    struct
    {
      nghttp3_conn_settings *local_settings;
    } settings;
    struct
    {
      nghttp3_data_reader dr;
    } data;
  } aux;
} nghttp3_frame_entry;
int nghttp3_stream_new(nghttp3_stream **pstream, int64_t stream_id,
                       uint64_t seq, const nghttp3_stream_callbacks *callbacks,
                       const nghttp3_mem *mem);
void nghttp3_stream_del(nghttp3_stream *stream);
void nghttp3_varint_read_state_reset(nghttp3_varint_read_state *rvint);
void nghttp3_stream_read_state_reset(nghttp3_stream_read_state *rstate);
nghttp3_ssize nghttp3_read_varint(nghttp3_varint_read_state *rvint,
                                  const uint8_t *src, size_t srclen, int fin);
int nghttp3_stream_frq_add(nghttp3_stream *stream,
                           const nghttp3_frame_entry *frent);
int nghttp3_stream_fill_outq(nghttp3_stream *stream);
int nghttp3_stream_write_stream_type(nghttp3_stream *stream);
int nghttp3_stream_write_stream_type_push_id(nghttp3_stream *stream);
nghttp3_ssize nghttp3_stream_writev(nghttp3_stream *stream, int *pfin,
                                    nghttp3_vec *vec, size_t veccnt);
int nghttp3_stream_write_qpack_decoder_stream(nghttp3_stream *stream);
int nghttp3_stream_outq_is_full(nghttp3_stream *stream);
int nghttp3_stream_outq_add(nghttp3_stream *stream,
                            const nghttp3_typed_buf *tbuf);
int nghttp3_stream_write_headers(nghttp3_stream *stream,
                                 nghttp3_frame_entry *frent);
int nghttp3_stream_write_push_promise(nghttp3_stream *stream,
                                      nghttp3_frame_entry *frent);
int nghttp3_stream_write_header_block(nghttp3_stream *stream,
                                      nghttp3_qpack_encoder *qenc,
                                      nghttp3_stream *qenc_stream,
                                      nghttp3_buf *rbuf, nghttp3_buf *ebuf,
                                      int64_t frame_type, int64_t push_id,
                                      const nghttp3_nv *nva, size_t nvlen);
int nghttp3_stream_write_data(nghttp3_stream *stream, int *peof,
                              nghttp3_frame_entry *frent);
int nghttp3_stream_write_settings(nghttp3_stream *stream,
                                  nghttp3_frame_entry *frent);
int nghttp3_stream_write_cancel_push(nghttp3_stream *stream,
                                     nghttp3_frame_entry *frent);
int nghttp3_stream_write_max_push_id(nghttp3_stream *stream,
                                     nghttp3_frame_entry *frent);
int nghttp3_stream_ensure_chunk(nghttp3_stream *stream, size_t need);
nghttp3_buf *nghttp3_stream_get_chunk(nghttp3_stream *stream);
int nghttp3_stream_is_blocked(nghttp3_stream *stream);
int nghttp3_stream_add_outq_offset(nghttp3_stream *stream, size_t n);
int nghttp3_stream_outq_write_done(nghttp3_stream *stream);
int nghttp3_stream_add_ack_offset(nghttp3_stream *stream, uint64_t n);
int nghttp3_stream_is_active(nghttp3_stream *stream);
int nghttp3_stream_require_schedule(nghttp3_stream *stream);
int nghttp3_stream_buffer_data(nghttp3_stream *stream, const uint8_t *src,
                               size_t srclen);
size_t nghttp3_stream_get_buffered_datalen(nghttp3_stream *stream);
int nghttp3_stream_ensure_qpack_stream_context(nghttp3_stream *stream);
void nghttp3_stream_delete_qpack_stream_context(nghttp3_stream *stream);
int nghttp3_stream_transit_rx_http_state(nghttp3_stream *stream,
                                         nghttp3_stream_http_event event);
int nghttp3_stream_empty_headers_allowed(nghttp3_stream *stream);
int nghttp3_stream_bidi_or_push(nghttp3_stream *stream);
int nghttp3_stream_uni(int64_t stream_id);
int nghttp3_client_stream_bidi(int64_t stream_id);
int nghttp3_client_stream_uni(int64_t stream_id);
int nghttp3_server_stream_uni(int64_t stream_id);
typedef struct
{
  uint64_t begin;
  uint64_t end;
} nghttp3_range;
void nghttp3_range_init(nghttp3_range *r, uint64_t begin, uint64_t end);
nghttp3_range nghttp3_range_intersect(const nghttp3_range *a,
                                      const nghttp3_range *b);
uint64_t nghttp3_range_len(const nghttp3_range *r);
int nghttp3_range_eq(const nghttp3_range *a, const nghttp3_range *b);
void nghttp3_range_cut(nghttp3_range *left, nghttp3_range *right,
                       const nghttp3_range *a, const nghttp3_range *b);
int nghttp3_range_not_after(const nghttp3_range *a, const nghttp3_range *b);
typedef struct
{
  nghttp3_ksl gap;
  const nghttp3_mem *mem;
} nghttp3_gaptr;
int nghttp3_gaptr_init(nghttp3_gaptr *gaptr, const nghttp3_mem *mem);
void nghttp3_gaptr_free(nghttp3_gaptr *gaptr);
int nghttp3_gaptr_push(nghttp3_gaptr *gaptr, uint64_t offset, size_t datalen);
uint64_t nghttp3_gaptr_first_gap_offset(nghttp3_gaptr *gaptr);
nghttp3_ksl_it nghttp3_gaptr_get_first_gap_after(nghttp3_gaptr *gaptr,
                                                 uint64_t offset);
int nghttp3_gaptr_is_pushed(nghttp3_gaptr *gaptr, uint64_t offset,
                            size_t datalen);
typedef struct
{
  nghttp3_gaptr gap;
  int server;
  const nghttp3_mem *mem;
} nghttp3_idtr;
int nghttp3_idtr_init(nghttp3_idtr *idtr, int server, const nghttp3_mem *mem);
void nghttp3_idtr_free(nghttp3_idtr *idtr);
int nghttp3_idtr_open(nghttp3_idtr *idtr, int64_t stream_id);
int nghttp3_idtr_is_open(nghttp3_idtr *idtr, int64_t stream_id);
uint64_t nghttp3_idtr_first_gap(nghttp3_idtr *idtr);
typedef enum
{
  NGHTTP3_PUSH_PROMISE_FLAG_NONE = 0x00,
  NGHTTP3_PUSH_PROMISE_FLAG_RECVED = 0x01,
  NGHTTP3_PUSH_PROMISE_FLAG_RECV_CANCEL = 0x02,
  NGHTTP3_PUSH_PROMISE_FLAG_SENT_CANCEL = 0x04,
  NGHTTP3_PUSH_PROMISE_FLAG_CANCELLED = NGHTTP3_PUSH_PROMISE_FLAG_RECV_CANCEL |
                                        NGHTTP3_PUSH_PROMISE_FLAG_SENT_CANCEL,
  NGHTTP3_PUSH_PROMISE_FLAG_PUSH_ID_RECLAIMED = 0x08,
  NGHTTP3_PUSH_PROMISE_FLAG_BOUND = 0x10,
} nghttp3_push_promise_flag;
struct nghttp3_push_promise;
typedef struct nghttp3_push_promise nghttp3_push_promise;
struct nghttp3_push_promise
{
  nghttp3_map_entry me;
  nghttp3_tnode node;
  nghttp3_http_state http;
  nghttp3_stream *stream;
  int64_t stream_id;
  uint16_t flags;
};
typedef enum
{
  NGHTTP3_CONN_FLAG_NONE = 0x0000,
  NGHTTP3_CONN_FLAG_SETTINGS_RECVED = 0x0001,
  NGHTTP3_CONN_FLAG_CONTROL_OPENED = 0x0002,
  NGHTTP3_CONN_FLAG_QPACK_ENCODER_OPENED = 0x0004,
  NGHTTP3_CONN_FLAG_QPACK_DECODER_OPENED = 0x0008,
  NGHTTP3_CONN_FLAG_MAX_PUSH_ID_QUEUED = 0x0010,
  NGHTTP3_CONN_FLAG_GOAWAY_RECVED = 0x0020,
  NGHTTP3_CONN_FLAG_GOAWAY_QUEUED = 0x0040,
} nghttp3_conn_flag;
struct nghttp3_conn
{
  nghttp3_conn_callbacks callbacks;
  nghttp3_map streams;
  nghttp3_map pushes;
  nghttp3_qpack_decoder qdec;
  nghttp3_qpack_encoder qenc;
  nghttp3_pq qpack_blocked_streams;
  struct
  {
    nghttp3_pq spq;
  } sched[(7 + 1)];
  const nghttp3_mem *mem;
  void *user_data;
  int server;
  uint16_t flags;
  uint64_t next_seq;
  struct
  {
    nghttp3_conn_settings settings;
    struct
    {
      uint64_t max_pushes;
      int64_t next_push_id;
    } uni;
  } local;
  struct
  {
    struct
    {
      nghttp3_idtr idtr;
      uint64_t max_client_streams;
    } bidi;
    struct
    {
      nghttp3_gaptr push_idtr;
      uint64_t unsent_max_pushes;
      uint64_t max_pushes;
    } uni;
    nghttp3_conn_settings settings;
  } remote;
  struct
  {
    int64_t goaway_id;
    int64_t max_stream_id_bidi;
    int64_t max_push_id;
  } rx;
  struct
  {
    struct
    {
      nghttp3_buf rbuf;
      nghttp3_buf ebuf;
    } qpack;
    nghttp3_stream *ctrl;
    nghttp3_stream *qenc;
    nghttp3_stream *qdec;
    int64_t goaway_id;
  } tx;
};
nghttp3_stream *nghttp3_conn_find_stream(nghttp3_conn *conn, int64_t stream_id);
nghttp3_push_promise *nghttp3_conn_find_push_promise(nghttp3_conn *conn,
                                                     int64_t push_id);
int nghttp3_conn_create_stream(nghttp3_conn *conn, nghttp3_stream **pstream,
                               int64_t stream_id);
int nghttp3_conn_create_push_promise(nghttp3_conn *conn,
                                     nghttp3_push_promise **ppp,
                                     int64_t push_id,
                                     nghttp3_tnode *assoc_tnode);
nghttp3_ssize nghttp3_conn_read_bidi(nghttp3_conn *conn, size_t *pnproc,
                                     nghttp3_stream *stream, const uint8_t *src,
                                     size_t srclen, int fin);
nghttp3_ssize nghttp3_conn_read_uni(nghttp3_conn *conn, nghttp3_stream *stream,
                                    const uint8_t *src, size_t srclen, int fin);
nghttp3_ssize nghttp3_conn_read_control(nghttp3_conn *conn,
                                        nghttp3_stream *stream,
                                        const uint8_t *src, size_t srclen);
nghttp3_ssize nghttp3_conn_read_push(nghttp3_conn *conn, size_t *pnproc,
                                     nghttp3_stream *stream, const uint8_t *src,
                                     size_t srclen, int fin);
nghttp3_ssize nghttp3_conn_read_qpack_encoder(nghttp3_conn *conn,
                                              const uint8_t *src,
                                              size_t srclen);
nghttp3_ssize nghttp3_conn_read_qpack_decoder(nghttp3_conn *conn,
                                              const uint8_t *src,
                                              size_t srclen);
int nghttp3_conn_on_push_promise_push_id(nghttp3_conn *conn, int64_t push_id,
                                         nghttp3_stream *stream);
int nghttp3_conn_on_client_cancel_push(nghttp3_conn *conn,
                                       const nghttp3_frame_cancel_push *fr);
int nghttp3_conn_on_server_cancel_push(nghttp3_conn *conn,
                                       const nghttp3_frame_cancel_push *fr);
int nghttp3_conn_on_stream_push_id(nghttp3_conn *conn, nghttp3_stream *stream,
                                   int64_t push_id);
int nghttp3_conn_on_data(nghttp3_conn *conn, nghttp3_stream *stream,
                         const uint8_t *data, size_t datalen);
nghttp3_ssize nghttp3_conn_on_headers(nghttp3_conn *conn,
                                      nghttp3_stream *stream,
                                      nghttp3_push_promise *pp,
                                      const uint8_t *data, size_t datalen,
                                      int fin);
int nghttp3_conn_on_settings_entry_received(nghttp3_conn *conn,
                                            const nghttp3_frame_settings *fr);
int nghttp3_conn_qpack_blocked_streams_push(nghttp3_conn *conn,
                                            nghttp3_stream *stream);
void nghttp3_conn_qpack_blocked_streams_pop(nghttp3_conn *conn);
int nghttp3_conn_server_cancel_push(nghttp3_conn *conn, int64_t push_id);
int nghttp3_conn_client_cancel_push(nghttp3_conn *conn, int64_t push_id);
int nghttp3_conn_submit_max_push_id(nghttp3_conn *conn);
int nghttp3_conn_schedule_stream(nghttp3_conn *conn, nghttp3_stream *stream);
int nghttp3_conn_ensure_stream_scheduled(nghttp3_conn *conn,
                                         nghttp3_stream *stream);
void nghttp3_conn_unschedule_stream(nghttp3_conn *conn, nghttp3_stream *stream);
int nghttp3_conn_reject_stream(nghttp3_conn *conn, nghttp3_stream *stream);
int nghttp3_conn_reject_push_stream(nghttp3_conn *conn, nghttp3_stream *stream);
int nghttp3_conn_cancel_push_stream(nghttp3_conn *conn, nghttp3_stream *stream);
nghttp3_stream *nghttp3_conn_get_next_tx_stream(nghttp3_conn *conn);
int nghttp3_push_promise_new(nghttp3_push_promise **ppp, int64_t push_id,
                             uint64_t seq, nghttp3_tnode *assoc_tnode,
                             const nghttp3_mem *mem);
void nghttp3_push_promise_del(nghttp3_push_promise *pp, const nghttp3_mem *mem);
int64_t nghttp3_get_varint(size_t *plen, const uint8_t *p);
int64_t nghttp3_get_varint_fb(const uint8_t *p);
size_t nghttp3_get_varint_len(const uint8_t *p);
uint8_t *nghttp3_put_uint64be(uint8_t *p, uint64_t n);
uint8_t *nghttp3_put_uint48be(uint8_t *p, uint64_t n);
uint8_t *nghttp3_put_uint32be(uint8_t *p, uint32_t n);
uint8_t *nghttp3_put_uint24be(uint8_t *p, uint32_t n);
uint8_t *nghttp3_put_uint16be(uint8_t *p, uint16_t n);
uint8_t *nghttp3_put_varint(uint8_t *p, int64_t n);
size_t nghttp3_put_varint_len(int64_t n);
uint64_t nghttp3_ord_stream_id(int64_t stream_id);
uint8_t nghttp3_pri_to_uint8(const nghttp3_pri *pri);
struct nghttp3_stream;
typedef struct nghttp3_stream nghttp3_stream;
struct nghttp3_http_state;
typedef struct nghttp3_http_state nghttp3_http_state;
typedef enum
{
  NGHTTP3_HTTP_FLAG_NONE = 0,
  NGHTTP3_HTTP_FLAG__AUTHORITY = 1,
  NGHTTP3_HTTP_FLAG__PATH = 1 << 1,
  NGHTTP3_HTTP_FLAG__METHOD = 1 << 2,
  NGHTTP3_HTTP_FLAG__SCHEME = 1 << 3,
  NGHTTP3_HTTP_FLAG_HOST = 1 << 4,
  NGHTTP3_HTTP_FLAG__STATUS = 1 << 5,
  NGHTTP3_HTTP_FLAG_REQ_HEADERS = NGHTTP3_HTTP_FLAG__METHOD |
                                  NGHTTP3_HTTP_FLAG__PATH |
                                  NGHTTP3_HTTP_FLAG__SCHEME,
  NGHTTP3_HTTP_FLAG_PSEUDO_HEADER_DISALLOWED = 1 << 6,
  NGHTTP3_HTTP_FLAG_METH_CONNECT = 1 << 7,
  NGHTTP3_HTTP_FLAG_METH_HEAD = 1 << 8,
  NGHTTP3_HTTP_FLAG_METH_OPTIONS = 1 << 9,
  NGHTTP3_HTTP_FLAG_METH_ALL = NGHTTP3_HTTP_FLAG_METH_CONNECT |
                               NGHTTP3_HTTP_FLAG_METH_HEAD |
                               NGHTTP3_HTTP_FLAG_METH_OPTIONS,
  NGHTTP3_HTTP_FLAG_PATH_REGULAR = 1 << 11,
  NGHTTP3_HTTP_FLAG_PATH_ASTERISK = 1 << 12,
  NGHTTP3_HTTP_FLAG_SCHEME_HTTP = 1 << 13,
  NGHTTP3_HTTP_FLAG_EXPECT_FINAL_RESPONSE = 1 << 14,
  NGHTTP3_HTTP_FLAG__PROTOCOL = 1 << 15,
} nghttp3_http_flag;
int nghttp3_http_on_header(nghttp3_http_state *http, int64_t frame_type,
                           nghttp3_qpack_nv *nv, int request, int trailers);
int nghttp3_http_on_request_headers(nghttp3_http_state *http);
int nghttp3_http_on_response_headers(nghttp3_http_state *http);
int nghttp3_http_on_remote_end_stream(nghttp3_stream *stream);
int nghttp3_http_on_data_chunk(nghttp3_stream *stream, size_t n);
void nghttp3_http_record_request_method(nghttp3_stream *stream,
                                        const nghttp3_nv *nva, size_t nvlen);
uint8_t *nghttp3_cpymem(uint8_t *dest, const uint8_t *src, size_t n);
void nghttp3_downcase(uint8_t *s, size_t len);

extern "C"
{
  typedef struct stack_st OPENSSL_STACK;
  typedef int (*OPENSSL_sk_compfunc)(const void *, const void *);
  typedef void (*OPENSSL_sk_freefunc)(void *);
  typedef void *(*OPENSSL_sk_copyfunc)(const void *);
  int OPENSSL_sk_num(const OPENSSL_STACK *);
  void *OPENSSL_sk_value(const OPENSSL_STACK *, int);
  void *OPENSSL_sk_set(OPENSSL_STACK *st, int i, const void *data);
  OPENSSL_STACK *OPENSSL_sk_new(OPENSSL_sk_compfunc cmp);
  OPENSSL_STACK *OPENSSL_sk_new_null(void);
  OPENSSL_STACK *OPENSSL_sk_new_reserve(OPENSSL_sk_compfunc c, int n);
  int OPENSSL_sk_reserve(OPENSSL_STACK *st, int n);
  void OPENSSL_sk_free(OPENSSL_STACK *);
  void OPENSSL_sk_pop_free(OPENSSL_STACK *st, void (*func)(void *));
  OPENSSL_STACK *OPENSSL_sk_deep_copy(const OPENSSL_STACK *,
                                      OPENSSL_sk_copyfunc c,
                                      OPENSSL_sk_freefunc f);
  int OPENSSL_sk_insert(OPENSSL_STACK *sk, const void *data, int where);
  void *OPENSSL_sk_delete(OPENSSL_STACK *st, int loc);
  void *OPENSSL_sk_delete_ptr(OPENSSL_STACK *st, const void *p);
  int OPENSSL_sk_find(OPENSSL_STACK *st, const void *data);
  int OPENSSL_sk_find_ex(OPENSSL_STACK *st, const void *data);
  int OPENSSL_sk_push(OPENSSL_STACK *st, const void *data);
  int OPENSSL_sk_unshift(OPENSSL_STACK *st, const void *data);
  void *OPENSSL_sk_shift(OPENSSL_STACK *st);
  void *OPENSSL_sk_pop(OPENSSL_STACK *st);
  void OPENSSL_sk_zero(OPENSSL_STACK *st);
  OPENSSL_sk_compfunc OPENSSL_sk_set_cmp_func(OPENSSL_STACK *sk,
                                              OPENSSL_sk_compfunc cmp);
  OPENSSL_STACK *OPENSSL_sk_dup(const OPENSSL_STACK *st);
  void OPENSSL_sk_sort(OPENSSL_STACK *st);
  int OPENSSL_sk_is_sorted(const OPENSSL_STACK *st);
}
extern "C"
{
  typedef char *OPENSSL_STRING;
  typedef const char *OPENSSL_CSTRING;
  struct stack_st_OPENSSL_STRING;
  typedef int (*sk_OPENSSL_STRING_compfunc)(const char *const *a, const char *const *b);
  typedef void (*sk_OPENSSL_STRING_freefunc)(char *a);
  typedef char *(*sk_OPENSSL_STRING_copyfunc)(const char *a);
  static __attribute__((unused)) inline int sk_OPENSSL_STRING_num(const struct stack_st_OPENSSL_STRING *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline char *sk_OPENSSL_STRING_value(const struct stack_st_OPENSSL_STRING *sk, int idx) { return (char *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_OPENSSL_STRING *sk_OPENSSL_STRING_new(sk_OPENSSL_STRING_compfunc compare) { return (struct stack_st_OPENSSL_STRING *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_OPENSSL_STRING *sk_OPENSSL_STRING_new_null(void) { return (struct stack_st_OPENSSL_STRING *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_OPENSSL_STRING *sk_OPENSSL_STRING_new_reserve(sk_OPENSSL_STRING_compfunc compare, int n) { return (struct stack_st_OPENSSL_STRING *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_OPENSSL_STRING_reserve(struct stack_st_OPENSSL_STRING *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_OPENSSL_STRING_free(struct stack_st_OPENSSL_STRING *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_OPENSSL_STRING_zero(struct stack_st_OPENSSL_STRING *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline char *sk_OPENSSL_STRING_delete(struct stack_st_OPENSSL_STRING *sk, int i) { return (char *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline char *sk_OPENSSL_STRING_delete_ptr(struct stack_st_OPENSSL_STRING *sk, char *ptr) { return (char *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_OPENSSL_STRING_push(struct stack_st_OPENSSL_STRING *sk, char *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_OPENSSL_STRING_unshift(struct stack_st_OPENSSL_STRING *sk, char *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline char *sk_OPENSSL_STRING_pop(struct stack_st_OPENSSL_STRING *sk) { return (char *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline char *sk_OPENSSL_STRING_shift(struct stack_st_OPENSSL_STRING *sk) { return (char *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_OPENSSL_STRING_pop_free(struct stack_st_OPENSSL_STRING *sk, sk_OPENSSL_STRING_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_OPENSSL_STRING_insert(struct stack_st_OPENSSL_STRING *sk, char *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline char *sk_OPENSSL_STRING_set(struct stack_st_OPENSSL_STRING *sk, int idx, char *ptr) { return (char *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_OPENSSL_STRING_find(struct stack_st_OPENSSL_STRING *sk, char *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_OPENSSL_STRING_find_ex(struct stack_st_OPENSSL_STRING *sk, char *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_OPENSSL_STRING_sort(struct stack_st_OPENSSL_STRING *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_OPENSSL_STRING_is_sorted(const struct stack_st_OPENSSL_STRING *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_OPENSSL_STRING *sk_OPENSSL_STRING_dup(const struct stack_st_OPENSSL_STRING *sk) { return (struct stack_st_OPENSSL_STRING *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_OPENSSL_STRING *sk_OPENSSL_STRING_deep_copy(const struct stack_st_OPENSSL_STRING *sk, sk_OPENSSL_STRING_copyfunc copyfunc, sk_OPENSSL_STRING_freefunc freefunc) { return (struct stack_st_OPENSSL_STRING *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_OPENSSL_STRING_compfunc sk_OPENSSL_STRING_set_cmp_func(struct stack_st_OPENSSL_STRING *sk, sk_OPENSSL_STRING_compfunc compare) { return (sk_OPENSSL_STRING_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  struct stack_st_OPENSSL_CSTRING;
  typedef int (*sk_OPENSSL_CSTRING_compfunc)(const char *const *a, const char *const *b);
  typedef void (*sk_OPENSSL_CSTRING_freefunc)(char *a);
  typedef char *(*sk_OPENSSL_CSTRING_copyfunc)(const char *a);
  static __attribute__((unused)) inline int sk_OPENSSL_CSTRING_num(const struct stack_st_OPENSSL_CSTRING *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline const char *sk_OPENSSL_CSTRING_value(const struct stack_st_OPENSSL_CSTRING *sk, int idx) { return (const char *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_OPENSSL_CSTRING *sk_OPENSSL_CSTRING_new(sk_OPENSSL_CSTRING_compfunc compare) { return (struct stack_st_OPENSSL_CSTRING *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_OPENSSL_CSTRING *sk_OPENSSL_CSTRING_new_null(void) { return (struct stack_st_OPENSSL_CSTRING *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_OPENSSL_CSTRING *sk_OPENSSL_CSTRING_new_reserve(sk_OPENSSL_CSTRING_compfunc compare, int n) { return (struct stack_st_OPENSSL_CSTRING *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_OPENSSL_CSTRING_reserve(struct stack_st_OPENSSL_CSTRING *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_OPENSSL_CSTRING_free(struct stack_st_OPENSSL_CSTRING *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_OPENSSL_CSTRING_zero(struct stack_st_OPENSSL_CSTRING *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline const char *sk_OPENSSL_CSTRING_delete(struct stack_st_OPENSSL_CSTRING *sk, int i) { return (const char *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline const char *sk_OPENSSL_CSTRING_delete_ptr(struct stack_st_OPENSSL_CSTRING *sk, const char *ptr) { return (const char *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_OPENSSL_CSTRING_push(struct stack_st_OPENSSL_CSTRING *sk, const char *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_OPENSSL_CSTRING_unshift(struct stack_st_OPENSSL_CSTRING *sk, const char *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline const char *sk_OPENSSL_CSTRING_pop(struct stack_st_OPENSSL_CSTRING *sk) { return (const char *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline const char *sk_OPENSSL_CSTRING_shift(struct stack_st_OPENSSL_CSTRING *sk) { return (const char *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_OPENSSL_CSTRING_pop_free(struct stack_st_OPENSSL_CSTRING *sk, sk_OPENSSL_CSTRING_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_OPENSSL_CSTRING_insert(struct stack_st_OPENSSL_CSTRING *sk, const char *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline const char *sk_OPENSSL_CSTRING_set(struct stack_st_OPENSSL_CSTRING *sk, int idx, const char *ptr) { return (const char *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_OPENSSL_CSTRING_find(struct stack_st_OPENSSL_CSTRING *sk, const char *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_OPENSSL_CSTRING_find_ex(struct stack_st_OPENSSL_CSTRING *sk, const char *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_OPENSSL_CSTRING_sort(struct stack_st_OPENSSL_CSTRING *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_OPENSSL_CSTRING_is_sorted(const struct stack_st_OPENSSL_CSTRING *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_OPENSSL_CSTRING *sk_OPENSSL_CSTRING_dup(const struct stack_st_OPENSSL_CSTRING *sk) { return (struct stack_st_OPENSSL_CSTRING *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_OPENSSL_CSTRING *sk_OPENSSL_CSTRING_deep_copy(const struct stack_st_OPENSSL_CSTRING *sk, sk_OPENSSL_CSTRING_copyfunc copyfunc, sk_OPENSSL_CSTRING_freefunc freefunc) { return (struct stack_st_OPENSSL_CSTRING *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_OPENSSL_CSTRING_compfunc sk_OPENSSL_CSTRING_set_cmp_func(struct stack_st_OPENSSL_CSTRING *sk, sk_OPENSSL_CSTRING_compfunc compare) { return (sk_OPENSSL_CSTRING_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  typedef void *OPENSSL_BLOCK;
  struct stack_st_OPENSSL_BLOCK;
  typedef int (*sk_OPENSSL_BLOCK_compfunc)(const void *const *a, const void *const *b);
  typedef void (*sk_OPENSSL_BLOCK_freefunc)(void *a);
  typedef void *(*sk_OPENSSL_BLOCK_copyfunc)(const void *a);
  static __attribute__((unused)) inline int sk_OPENSSL_BLOCK_num(const struct stack_st_OPENSSL_BLOCK *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void *sk_OPENSSL_BLOCK_value(const struct stack_st_OPENSSL_BLOCK *sk, int idx) { return (void *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_OPENSSL_BLOCK *sk_OPENSSL_BLOCK_new(sk_OPENSSL_BLOCK_compfunc compare) { return (struct stack_st_OPENSSL_BLOCK *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_OPENSSL_BLOCK *sk_OPENSSL_BLOCK_new_null(void) { return (struct stack_st_OPENSSL_BLOCK *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_OPENSSL_BLOCK *sk_OPENSSL_BLOCK_new_reserve(sk_OPENSSL_BLOCK_compfunc compare, int n) { return (struct stack_st_OPENSSL_BLOCK *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_OPENSSL_BLOCK_reserve(struct stack_st_OPENSSL_BLOCK *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_OPENSSL_BLOCK_free(struct stack_st_OPENSSL_BLOCK *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_OPENSSL_BLOCK_zero(struct stack_st_OPENSSL_BLOCK *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void *sk_OPENSSL_BLOCK_delete(struct stack_st_OPENSSL_BLOCK *sk, int i) { return (void *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline void *sk_OPENSSL_BLOCK_delete_ptr(struct stack_st_OPENSSL_BLOCK *sk, void *ptr) { return (void *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_OPENSSL_BLOCK_push(struct stack_st_OPENSSL_BLOCK *sk, void *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_OPENSSL_BLOCK_unshift(struct stack_st_OPENSSL_BLOCK *sk, void *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void *sk_OPENSSL_BLOCK_pop(struct stack_st_OPENSSL_BLOCK *sk) { return (void *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void *sk_OPENSSL_BLOCK_shift(struct stack_st_OPENSSL_BLOCK *sk) { return (void *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_OPENSSL_BLOCK_pop_free(struct stack_st_OPENSSL_BLOCK *sk, sk_OPENSSL_BLOCK_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_OPENSSL_BLOCK_insert(struct stack_st_OPENSSL_BLOCK *sk, void *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline void *sk_OPENSSL_BLOCK_set(struct stack_st_OPENSSL_BLOCK *sk, int idx, void *ptr) { return (void *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_OPENSSL_BLOCK_find(struct stack_st_OPENSSL_BLOCK *sk, void *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_OPENSSL_BLOCK_find_ex(struct stack_st_OPENSSL_BLOCK *sk, void *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_OPENSSL_BLOCK_sort(struct stack_st_OPENSSL_BLOCK *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_OPENSSL_BLOCK_is_sorted(const struct stack_st_OPENSSL_BLOCK *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_OPENSSL_BLOCK *sk_OPENSSL_BLOCK_dup(const struct stack_st_OPENSSL_BLOCK *sk) { return (struct stack_st_OPENSSL_BLOCK *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_OPENSSL_BLOCK *sk_OPENSSL_BLOCK_deep_copy(const struct stack_st_OPENSSL_BLOCK *sk, sk_OPENSSL_BLOCK_copyfunc copyfunc, sk_OPENSSL_BLOCK_freefunc freefunc) { return (struct stack_st_OPENSSL_BLOCK *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_OPENSSL_BLOCK_compfunc sk_OPENSSL_BLOCK_set_cmp_func(struct stack_st_OPENSSL_BLOCK *sk, sk_OPENSSL_BLOCK_compfunc compare) { return (sk_OPENSSL_BLOCK_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
}
extern "C"
{
  typedef struct asn1_string_st ASN1_INTEGER;
  typedef struct asn1_string_st ASN1_ENUMERATED;
  typedef struct asn1_string_st ASN1_BIT_STRING;
  typedef struct asn1_string_st ASN1_OCTET_STRING;
  typedef struct asn1_string_st ASN1_PRINTABLESTRING;
  typedef struct asn1_string_st ASN1_T61STRING;
  typedef struct asn1_string_st ASN1_IA5STRING;
  typedef struct asn1_string_st ASN1_GENERALSTRING;
  typedef struct asn1_string_st ASN1_UNIVERSALSTRING;
  typedef struct asn1_string_st ASN1_BMPSTRING;
  typedef struct asn1_string_st ASN1_UTCTIME;
  typedef struct asn1_string_st ASN1_TIME;
  typedef struct asn1_string_st ASN1_GENERALIZEDTIME;
  typedef struct asn1_string_st ASN1_VISIBLESTRING;
  typedef struct asn1_string_st ASN1_UTF8STRING;
  typedef struct asn1_string_st ASN1_STRING;
  typedef int ASN1_BOOLEAN;
  typedef int ASN1_NULL;
  typedef struct asn1_object_st ASN1_OBJECT;
  typedef struct ASN1_ITEM_st ASN1_ITEM;
  typedef struct asn1_pctx_st ASN1_PCTX;
  typedef struct asn1_sctx_st ASN1_SCTX;
  struct dane_st;
  typedef struct bio_st BIO;
  typedef struct bignum_st BIGNUM;
  typedef struct bignum_ctx BN_CTX;
  typedef struct bn_blinding_st BN_BLINDING;
  typedef struct bn_mont_ctx_st BN_MONT_CTX;
  typedef struct bn_recp_ctx_st BN_RECP_CTX;
  typedef struct bn_gencb_st BN_GENCB;
  typedef struct buf_mem_st BUF_MEM;
  typedef struct evp_cipher_st EVP_CIPHER;
  typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;
  typedef struct evp_md_st EVP_MD;
  typedef struct evp_md_ctx_st EVP_MD_CTX;
  typedef struct evp_pkey_st EVP_PKEY;
  typedef struct evp_pkey_asn1_method_st EVP_PKEY_ASN1_METHOD;
  typedef struct evp_pkey_method_st EVP_PKEY_METHOD;
  typedef struct evp_pkey_ctx_st EVP_PKEY_CTX;
  typedef struct evp_Encode_Ctx_st EVP_ENCODE_CTX;
  typedef struct hmac_ctx_st HMAC_CTX;
  typedef struct dh_st DH;
  typedef struct dh_method DH_METHOD;
  typedef struct dsa_st DSA;
  typedef struct dsa_method DSA_METHOD;
  typedef struct rsa_st RSA;
  typedef struct rsa_meth_st RSA_METHOD;
  typedef struct rsa_pss_params_st RSA_PSS_PARAMS;
  typedef struct ec_key_st EC_KEY;
  typedef struct ec_key_method_st EC_KEY_METHOD;
  typedef struct rand_meth_st RAND_METHOD;
  typedef struct rand_drbg_st RAND_DRBG;
  typedef struct ssl_dane_st SSL_DANE;
  typedef struct x509_st X509;
  typedef struct X509_algor_st X509_ALGOR;
  typedef struct X509_crl_st X509_CRL;
  typedef struct x509_crl_method_st X509_CRL_METHOD;
  typedef struct x509_revoked_st X509_REVOKED;
  typedef struct X509_name_st X509_NAME;
  typedef struct X509_pubkey_st X509_PUBKEY;
  typedef struct x509_store_st X509_STORE;
  typedef struct x509_store_ctx_st X509_STORE_CTX;
  typedef struct x509_object_st X509_OBJECT;
  typedef struct x509_lookup_st X509_LOOKUP;
  typedef struct x509_lookup_method_st X509_LOOKUP_METHOD;
  typedef struct X509_VERIFY_PARAM_st X509_VERIFY_PARAM;
  typedef struct x509_sig_info_st X509_SIG_INFO;
  typedef struct pkcs8_priv_key_info_st PKCS8_PRIV_KEY_INFO;
  typedef struct v3_ext_ctx X509V3_CTX;
  typedef struct conf_st CONF;
  typedef struct ossl_init_settings_st OPENSSL_INIT_SETTINGS;
  typedef struct ui_st UI;
  typedef struct ui_method_st UI_METHOD;
  typedef struct engine_st ENGINE;
  typedef struct ssl_st SSL;
  typedef struct ssl_ctx_st SSL_CTX;
  typedef struct comp_ctx_st COMP_CTX;
  typedef struct comp_method_st COMP_METHOD;
  typedef struct X509_POLICY_NODE_st X509_POLICY_NODE;
  typedef struct X509_POLICY_LEVEL_st X509_POLICY_LEVEL;
  typedef struct X509_POLICY_TREE_st X509_POLICY_TREE;
  typedef struct X509_POLICY_CACHE_st X509_POLICY_CACHE;
  typedef struct AUTHORITY_KEYID_st AUTHORITY_KEYID;
  typedef struct DIST_POINT_st DIST_POINT;
  typedef struct ISSUING_DIST_POINT_st ISSUING_DIST_POINT;
  typedef struct NAME_CONSTRAINTS_st NAME_CONSTRAINTS;
  typedef struct crypto_ex_data_st CRYPTO_EX_DATA;
  typedef struct ocsp_req_ctx_st OCSP_REQ_CTX;
  typedef struct ocsp_response_st OCSP_RESPONSE;
  typedef struct ocsp_responder_id_st OCSP_RESPID;
  typedef struct sct_st SCT;
  typedef struct sct_ctx_st SCT_CTX;
  typedef struct ctlog_st CTLOG;
  typedef struct ctlog_store_st CTLOG_STORE;
  typedef struct ct_policy_eval_ctx_st CT_POLICY_EVAL_CTX;
  typedef struct ossl_store_info_st OSSL_STORE_INFO;
  typedef struct ossl_store_search_st OSSL_STORE_SEARCH;
  typedef struct ssl_quic_method_st SSL_QUIC_METHOD;
  typedef long ossl_intmax_t;
  typedef unsigned long ossl_uintmax_t;
}
extern "C"
{
}
extern "C" int ERR_load_CRYPTO_strings(void);
extern "C"
{
  typedef struct
  {
    int dummy;
  } CRYPTO_dynlock;
  typedef void CRYPTO_RWLOCK;
  CRYPTO_RWLOCK *CRYPTO_THREAD_lock_new(void);
  int CRYPTO_THREAD_read_lock(CRYPTO_RWLOCK *lock);
  int CRYPTO_THREAD_write_lock(CRYPTO_RWLOCK *lock);
  int CRYPTO_THREAD_unlock(CRYPTO_RWLOCK *lock);
  void CRYPTO_THREAD_lock_free(CRYPTO_RWLOCK *lock);
  int CRYPTO_atomic_add(int *val, int amount, int *ret, CRYPTO_RWLOCK *lock);
  struct crypto_ex_data_st
  {
    struct stack_st_void *sk;
  };
  struct stack_st_void;
  typedef int (*sk_void_compfunc)(const void *const *a, const void *const *b);
  typedef void (*sk_void_freefunc)(void *a);
  typedef void *(*sk_void_copyfunc)(const void *a);
  static __attribute__((unused)) inline int sk_void_num(const struct stack_st_void *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void *sk_void_value(const struct stack_st_void *sk, int idx) { return (void *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_void *sk_void_new(sk_void_compfunc compare) { return (struct stack_st_void *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_void *sk_void_new_null(void) { return (struct stack_st_void *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_void *sk_void_new_reserve(sk_void_compfunc compare, int n) { return (struct stack_st_void *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_void_reserve(struct stack_st_void *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_void_free(struct stack_st_void *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_void_zero(struct stack_st_void *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void *sk_void_delete(struct stack_st_void *sk, int i) { return (void *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline void *sk_void_delete_ptr(struct stack_st_void *sk, void *ptr) { return (void *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_void_push(struct stack_st_void *sk, void *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_void_unshift(struct stack_st_void *sk, void *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void *sk_void_pop(struct stack_st_void *sk) { return (void *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void *sk_void_shift(struct stack_st_void *sk) { return (void *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_void_pop_free(struct stack_st_void *sk, sk_void_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_void_insert(struct stack_st_void *sk, void *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline void *sk_void_set(struct stack_st_void *sk, int idx, void *ptr) { return (void *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_void_find(struct stack_st_void *sk, void *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_void_find_ex(struct stack_st_void *sk, void *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_void_sort(struct stack_st_void *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_void_is_sorted(const struct stack_st_void *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_void *sk_void_dup(const struct stack_st_void *sk) { return (struct stack_st_void *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_void *sk_void_deep_copy(const struct stack_st_void *sk, sk_void_copyfunc copyfunc, sk_void_freefunc freefunc) { return (struct stack_st_void *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_void_compfunc sk_void_set_cmp_func(struct stack_st_void *sk, sk_void_compfunc compare) { return (sk_void_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  int CRYPTO_mem_ctrl(int mode);
  size_t OPENSSL_strlcpy(char *dst, const char *src, size_t siz);
  size_t OPENSSL_strlcat(char *dst, const char *src, size_t siz);
  size_t OPENSSL_strnlen(const char *str, size_t maxlen);
  char *OPENSSL_buf2hexstr(const unsigned char *buffer, long len);
  unsigned char *OPENSSL_hexstr2buf(const char *str, long *len);
  int OPENSSL_hexchar2int(unsigned char c);
  unsigned long OpenSSL_version_num(void);
  const char *OpenSSL_version(int type);
  int OPENSSL_issetugid(void);
  typedef void CRYPTO_EX_new(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
                             int idx, long argl, void *argp);
  typedef void CRYPTO_EX_free(void *parent, void *ptr, CRYPTO_EX_DATA *ad,
                              int idx, long argl, void *argp);
  typedef int CRYPTO_EX_dup(CRYPTO_EX_DATA *to, const CRYPTO_EX_DATA *from,
                            void *from_d, int idx, long argl, void *argp);
  int CRYPTO_get_ex_new_index(int class_index, long argl, void *argp,
                              CRYPTO_EX_new *new_func, CRYPTO_EX_dup *dup_func,
                              CRYPTO_EX_free *free_func);
  int CRYPTO_free_ex_index(int class_index, int idx);
  int CRYPTO_new_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad);
  int CRYPTO_dup_ex_data(int class_index, CRYPTO_EX_DATA *to,
                         const CRYPTO_EX_DATA *from);
  void CRYPTO_free_ex_data(int class_index, void *obj, CRYPTO_EX_DATA *ad);
  int CRYPTO_set_ex_data(CRYPTO_EX_DATA *ad, int idx, void *val);
  void *CRYPTO_get_ex_data(const CRYPTO_EX_DATA *ad, int idx);
  typedef struct crypto_threadid_st
  {
    int dummy;
  } CRYPTO_THREADID;
  int CRYPTO_set_mem_functions(
      void *(*m)(size_t, const char *, int),
      void *(*r)(void *, size_t, const char *, int),
      void (*f)(void *, const char *, int));
  int CRYPTO_set_mem_debug(int flag);
  void CRYPTO_get_mem_functions(
      void *(**m)(size_t, const char *, int),
      void *(**r)(void *, size_t, const char *, int),
      void (**f)(void *, const char *, int));
  void *CRYPTO_malloc(size_t num, const char *file, int line);
  void *CRYPTO_zalloc(size_t num, const char *file, int line);
  void *CRYPTO_memdup(const void *str, size_t siz, const char *file, int line);
  char *CRYPTO_strdup(const char *str, const char *file, int line);
  char *CRYPTO_strndup(const char *str, size_t s, const char *file, int line);
  void CRYPTO_free(void *ptr, const char *file, int line);
  void CRYPTO_clear_free(void *ptr, size_t num, const char *file, int line);
  void *CRYPTO_realloc(void *addr, size_t num, const char *file, int line);
  void *CRYPTO_clear_realloc(void *addr, size_t old_num, size_t num,
                             const char *file, int line);
  int CRYPTO_secure_malloc_init(size_t sz, int minsize);
  int CRYPTO_secure_malloc_done(void);
  void *CRYPTO_secure_malloc(size_t num, const char *file, int line);
  void *CRYPTO_secure_zalloc(size_t num, const char *file, int line);
  void CRYPTO_secure_free(void *ptr, const char *file, int line);
  void CRYPTO_secure_clear_free(void *ptr, size_t num,
                                const char *file, int line);
  int CRYPTO_secure_allocated(const void *ptr);
  int CRYPTO_secure_malloc_initialized(void);
  size_t CRYPTO_secure_actual_size(void *ptr);
  size_t CRYPTO_secure_used(void);
  void OPENSSL_cleanse(void *ptr, size_t len);
  __attribute__((noreturn)) void OPENSSL_die(const char *assertion, const char *file, int line);
  int OPENSSL_isservice(void);
  int FIPS_mode(void);
  int FIPS_mode_set(int r);
  void OPENSSL_init(void);
  void OPENSSL_fork_prepare(void);
  void OPENSSL_fork_parent(void);
  void OPENSSL_fork_child(void);
  struct tm *OPENSSL_gmtime(const time_t *timer, struct tm *result);
  int OPENSSL_gmtime_adj(struct tm *tm, int offset_day, long offset_sec);
  int OPENSSL_gmtime_diff(int *pday, int *psec,
                          const struct tm *from, const struct tm *to);
  int CRYPTO_memcmp(const void *in_a, const void *in_b, size_t len);
  void OPENSSL_cleanup(void);
  int OPENSSL_init_crypto(uint64_t opts, const OPENSSL_INIT_SETTINGS *settings);
  int OPENSSL_atexit(void (*handler)(void));
  void OPENSSL_thread_stop(void);
  OPENSSL_INIT_SETTINGS *OPENSSL_INIT_new(void);
  int OPENSSL_INIT_set_config_filename(OPENSSL_INIT_SETTINGS *settings,
                                       const char *config_filename);
  void OPENSSL_INIT_set_config_file_flags(OPENSSL_INIT_SETTINGS *settings,
                                          unsigned long flags);
  int OPENSSL_INIT_set_config_appname(OPENSSL_INIT_SETTINGS *settings,
                                      const char *config_appname);
  void OPENSSL_INIT_free(OPENSSL_INIT_SETTINGS *settings);

  typedef pthread_once_t CRYPTO_ONCE;
  typedef pthread_key_t CRYPTO_THREAD_LOCAL;
  typedef pthread_t CRYPTO_THREAD_ID;
  int CRYPTO_THREAD_run_once(CRYPTO_ONCE *once, void (*init)(void));
  int CRYPTO_THREAD_init_local(CRYPTO_THREAD_LOCAL *key, void (*cleanup)(void *));
  void *CRYPTO_THREAD_get_local(CRYPTO_THREAD_LOCAL *key);
  int CRYPTO_THREAD_set_local(CRYPTO_THREAD_LOCAL *key, void *val);
  int CRYPTO_THREAD_cleanup_local(CRYPTO_THREAD_LOCAL *key);
  CRYPTO_THREAD_ID CRYPTO_THREAD_get_current_id(void);
  int CRYPTO_THREAD_compare_id(CRYPTO_THREAD_ID a, CRYPTO_THREAD_ID b);
}
extern "C"
{
}
extern "C" int ERR_load_COMP_strings(void);
extern "C"
{
  COMP_CTX *COMP_CTX_new(COMP_METHOD *meth);
  const COMP_METHOD *COMP_CTX_get_method(const COMP_CTX *ctx);
  int COMP_CTX_get_type(const COMP_CTX *comp);
  int COMP_get_type(const COMP_METHOD *meth);
  const char *COMP_get_name(const COMP_METHOD *meth);
  void COMP_CTX_free(COMP_CTX *ctx);
  int COMP_compress_block(COMP_CTX *ctx, unsigned char *out, int olen,
                          unsigned char *in, int ilen);
  int COMP_expand_block(COMP_CTX *ctx, unsigned char *out, int olen,
                        unsigned char *in, int ilen);
  COMP_METHOD *COMP_zlib(void);
}
extern "C" int ERR_load_BIO_strings(void);
extern "C"
{
  typedef union bio_addr_st BIO_ADDR;
  typedef struct bio_addrinfo_st BIO_ADDRINFO;
  int BIO_get_new_index(void);
  void BIO_set_flags(BIO *b, int flags);
  int BIO_test_flags(const BIO *b, int flags);
  void BIO_clear_flags(BIO *b, int flags);
  typedef long (*BIO_callback_fn)(BIO *b, int oper, const char *argp, int argi,
                                  long argl, long ret);
  typedef long (*BIO_callback_fn_ex)(BIO *b, int oper, const char *argp,
                                     size_t len, int argi,
                                     long argl, int ret, size_t *processed);
  BIO_callback_fn BIO_get_callback(const BIO *b);
  void BIO_set_callback(BIO *b, BIO_callback_fn callback);
  BIO_callback_fn_ex BIO_get_callback_ex(const BIO *b);
  void BIO_set_callback_ex(BIO *b, BIO_callback_fn_ex callback);
  char *BIO_get_callback_arg(const BIO *b);
  void BIO_set_callback_arg(BIO *b, char *arg);
  typedef struct bio_method_st BIO_METHOD;
  const char *BIO_method_name(const BIO *b);
  int BIO_method_type(const BIO *b);
  typedef int BIO_info_cb(BIO *, int, int);
  typedef BIO_info_cb bio_info_cb;
  struct stack_st_BIO;
  typedef int (*sk_BIO_compfunc)(const BIO *const *a, const BIO *const *b);
  typedef void (*sk_BIO_freefunc)(BIO *a);
  typedef BIO *(*sk_BIO_copyfunc)(const BIO *a);
  static __attribute__((unused)) inline int sk_BIO_num(const struct stack_st_BIO *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline BIO *sk_BIO_value(const struct stack_st_BIO *sk, int idx) { return (BIO *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_BIO *sk_BIO_new(sk_BIO_compfunc compare) { return (struct stack_st_BIO *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_BIO *sk_BIO_new_null(void) { return (struct stack_st_BIO *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_BIO *sk_BIO_new_reserve(sk_BIO_compfunc compare, int n) { return (struct stack_st_BIO *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_BIO_reserve(struct stack_st_BIO *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_BIO_free(struct stack_st_BIO *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_BIO_zero(struct stack_st_BIO *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline BIO *sk_BIO_delete(struct stack_st_BIO *sk, int i) { return (BIO *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline BIO *sk_BIO_delete_ptr(struct stack_st_BIO *sk, BIO *ptr) { return (BIO *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_BIO_push(struct stack_st_BIO *sk, BIO *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_BIO_unshift(struct stack_st_BIO *sk, BIO *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline BIO *sk_BIO_pop(struct stack_st_BIO *sk) { return (BIO *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline BIO *sk_BIO_shift(struct stack_st_BIO *sk) { return (BIO *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_BIO_pop_free(struct stack_st_BIO *sk, sk_BIO_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_BIO_insert(struct stack_st_BIO *sk, BIO *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline BIO *sk_BIO_set(struct stack_st_BIO *sk, int idx, BIO *ptr) { return (BIO *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_BIO_find(struct stack_st_BIO *sk, BIO *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_BIO_find_ex(struct stack_st_BIO *sk, BIO *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_BIO_sort(struct stack_st_BIO *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_BIO_is_sorted(const struct stack_st_BIO *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_BIO *sk_BIO_dup(const struct stack_st_BIO *sk) { return (struct stack_st_BIO *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_BIO *sk_BIO_deep_copy(const struct stack_st_BIO *sk, sk_BIO_copyfunc copyfunc, sk_BIO_freefunc freefunc) { return (struct stack_st_BIO *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_BIO_compfunc sk_BIO_set_cmp_func(struct stack_st_BIO *sk, sk_BIO_compfunc compare) { return (sk_BIO_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  typedef int asn1_ps_func(BIO *b, unsigned char **pbuf, int *plen,
                           void *parg);
  size_t BIO_ctrl_pending(BIO *b);
  size_t BIO_ctrl_wpending(BIO *b);
  size_t BIO_ctrl_get_write_guarantee(BIO *b);
  size_t BIO_ctrl_get_read_request(BIO *b);
  int BIO_ctrl_reset_read_request(BIO *b);
  int BIO_set_ex_data(BIO *bio, int idx, void *data);
  void *BIO_get_ex_data(BIO *bio, int idx);
  uint64_t BIO_number_read(BIO *bio);
  uint64_t BIO_number_written(BIO *bio);
  int BIO_asn1_set_prefix(BIO *b, asn1_ps_func *prefix,
                          asn1_ps_func *prefix_free);
  int BIO_asn1_get_prefix(BIO *b, asn1_ps_func **pprefix,
                          asn1_ps_func **pprefix_free);
  int BIO_asn1_set_suffix(BIO *b, asn1_ps_func *suffix,
                          asn1_ps_func *suffix_free);
  int BIO_asn1_get_suffix(BIO *b, asn1_ps_func **psuffix,
                          asn1_ps_func **psuffix_free);
  const BIO_METHOD *BIO_s_file(void);
  BIO *BIO_new_file(const char *filename, const char *mode);
  BIO *BIO_new_fp(FILE *stream, int close_flag);
  BIO *BIO_new(const BIO_METHOD *type);
  int BIO_free(BIO *a);
  void BIO_set_data(BIO *a, void *ptr);
  void *BIO_get_data(BIO *a);
  void BIO_set_init(BIO *a, int init);
  int BIO_get_init(BIO *a);
  void BIO_set_shutdown(BIO *a, int shut);
  int BIO_get_shutdown(BIO *a);
  void BIO_vfree(BIO *a);
  int BIO_up_ref(BIO *a);
  int BIO_read(BIO *b, void *data, int dlen);
  int BIO_read_ex(BIO *b, void *data, size_t dlen, size_t *readbytes);
  int BIO_gets(BIO *bp, char *buf, int size);
  int BIO_write(BIO *b, const void *data, int dlen);
  int BIO_write_ex(BIO *b, const void *data, size_t dlen, size_t *written);
  int BIO_puts(BIO *bp, const char *buf);
  int BIO_indent(BIO *b, int indent, int max);
  long BIO_ctrl(BIO *bp, int cmd, long larg, void *parg);
  long BIO_callback_ctrl(BIO *b, int cmd, BIO_info_cb *fp);
  void *BIO_ptr_ctrl(BIO *bp, int cmd, long larg);
  long BIO_int_ctrl(BIO *bp, int cmd, long larg, int iarg);
  BIO *BIO_push(BIO *b, BIO *append);
  BIO *BIO_pop(BIO *b);
  void BIO_free_all(BIO *a);
  BIO *BIO_find_type(BIO *b, int bio_type);
  BIO *BIO_next(BIO *b);
  void BIO_set_next(BIO *b, BIO *next);
  BIO *BIO_get_retry_BIO(BIO *bio, int *reason);
  int BIO_get_retry_reason(BIO *bio);
  void BIO_set_retry_reason(BIO *bio, int reason);
  BIO *BIO_dup_chain(BIO *in);
  int BIO_nread0(BIO *bio, char **buf);
  int BIO_nread(BIO *bio, char **buf, int num);
  int BIO_nwrite0(BIO *bio, char **buf);
  int BIO_nwrite(BIO *bio, char **buf, int num);
  long BIO_debug_callback(BIO *bio, int cmd, const char *argp, int argi,
                          long argl, long ret);
  const BIO_METHOD *BIO_s_mem(void);
  const BIO_METHOD *BIO_s_secmem(void);
  BIO *BIO_new_mem_buf(const void *buf, int len);
  const BIO_METHOD *BIO_s_socket(void);
  const BIO_METHOD *BIO_s_connect(void);
  const BIO_METHOD *BIO_s_accept(void);
  const BIO_METHOD *BIO_s_fd(void);
  const BIO_METHOD *BIO_s_log(void);
  const BIO_METHOD *BIO_s_bio(void);
  const BIO_METHOD *BIO_s_null(void);
  const BIO_METHOD *BIO_f_null(void);
  const BIO_METHOD *BIO_f_buffer(void);
  const BIO_METHOD *BIO_f_linebuffer(void);
  const BIO_METHOD *BIO_f_nbio_test(void);
  const BIO_METHOD *BIO_s_datagram(void);
  int BIO_dgram_non_fatal_error(int error);
  BIO *BIO_new_dgram(int fd, int close_flag);
  int BIO_sock_should_retry(int i);
  int BIO_sock_non_fatal_error(int error);
  int BIO_fd_should_retry(int i);
  int BIO_fd_non_fatal_error(int error);
  int BIO_dump_cb(int (*cb)(const void *data, size_t len, void *u),
                  void *u, const char *s, int len);
  int BIO_dump_indent_cb(int (*cb)(const void *data, size_t len, void *u),
                         void *u, const char *s, int len, int indent);
  int BIO_dump(BIO *b, const char *bytes, int len);
  int BIO_dump_indent(BIO *b, const char *bytes, int len, int indent);
  int BIO_dump_fp(FILE *fp, const char *s, int len);
  int BIO_dump_indent_fp(FILE *fp, const char *s, int len, int indent);
  int BIO_hex_string(BIO *out, int indent, int width, unsigned char *data,
                     int datalen);
  BIO_ADDR *BIO_ADDR_new(void);
  int BIO_ADDR_rawmake(BIO_ADDR *ap, int family,
                       const void *where, size_t wherelen, unsigned short port);
  void BIO_ADDR_free(BIO_ADDR *);
  void BIO_ADDR_clear(BIO_ADDR *ap);
  int BIO_ADDR_family(const BIO_ADDR *ap);
  int BIO_ADDR_rawaddress(const BIO_ADDR *ap, void *p, size_t *l);
  unsigned short BIO_ADDR_rawport(const BIO_ADDR *ap);
  char *BIO_ADDR_hostname_string(const BIO_ADDR *ap, int numeric);
  char *BIO_ADDR_service_string(const BIO_ADDR *ap, int numeric);
  char *BIO_ADDR_path_string(const BIO_ADDR *ap);
  const BIO_ADDRINFO *BIO_ADDRINFO_next(const BIO_ADDRINFO *bai);
  int BIO_ADDRINFO_family(const BIO_ADDRINFO *bai);
  int BIO_ADDRINFO_socktype(const BIO_ADDRINFO *bai);
  int BIO_ADDRINFO_protocol(const BIO_ADDRINFO *bai);
  const BIO_ADDR *BIO_ADDRINFO_address(const BIO_ADDRINFO *bai);
  void BIO_ADDRINFO_free(BIO_ADDRINFO *bai);
  enum BIO_hostserv_priorities
  {
    BIO_PARSE_PRIO_HOST,
    BIO_PARSE_PRIO_SERV
  };
  int BIO_parse_hostserv(const char *hostserv, char **host, char **service,
                         enum BIO_hostserv_priorities hostserv_prio);
  enum BIO_lookup_type
  {
    BIO_LOOKUP_CLIENT,
    BIO_LOOKUP_SERVER
  };
  int BIO_lookup(const char *host, const char *service,
                 enum BIO_lookup_type lookup_type,
                 int family, int socktype, BIO_ADDRINFO **res);
  int BIO_lookup_ex(const char *host, const char *service,
                    int lookup_type, int family, int socktype, int protocol,
                    BIO_ADDRINFO **res);
  int BIO_sock_error(int sock);
  int BIO_socket_ioctl(int fd, long type, void *arg);
  int BIO_socket_nbio(int fd, int mode);
  int BIO_sock_init(void);
  int BIO_set_tcp_ndelay(int sock, int turn_on);
  struct hostent *BIO_gethostbyname(const char *name) __attribute__((deprecated));
  int BIO_get_port(const char *str, unsigned short *port_ptr) __attribute__((deprecated));
  int BIO_get_host_ip(const char *str, unsigned char *ip) __attribute__((deprecated));
  int BIO_get_accept_socket(char *host_port, int mode) __attribute__((deprecated));
  int BIO_accept(int sock, char **ip_port) __attribute__((deprecated));
  union BIO_sock_info_u
  {
    BIO_ADDR *addr;
  };
  enum BIO_sock_info_type
  {
    BIO_SOCK_INFO_ADDRESS
  };
  int BIO_sock_info(int sock,
                    enum BIO_sock_info_type type, union BIO_sock_info_u *info);
  int BIO_socket(int domain, int socktype, int protocol, int options);
  int BIO_connect(int sock, const BIO_ADDR *addr, int options);
  int BIO_bind(int sock, const BIO_ADDR *addr, int options);
  int BIO_listen(int sock, const BIO_ADDR *addr, int options);
  int BIO_accept_ex(int accept_sock, BIO_ADDR *addr, int options);
  int BIO_closesocket(int sock);
  BIO *BIO_new_socket(int sock, int close_flag);
  BIO *BIO_new_connect(const char *host_port);
  BIO *BIO_new_accept(const char *host_port);
  BIO *BIO_new_fd(int fd, int close_flag);
  int BIO_new_bio_pair(BIO **bio1, size_t writebuf1,
                       BIO **bio2, size_t writebuf2);
  void BIO_copy_next_retry(BIO *b);
  int BIO_printf(BIO *bio, const char *format, ...);
  int BIO_vprintf(BIO *bio, const char *format, va_list args);
  int BIO_snprintf(char *buf, size_t n, const char *format, ...);
  int BIO_vsnprintf(char *buf, size_t n, const char *format, va_list args);
  BIO_METHOD *BIO_meth_new(int type, const char *name);
  void BIO_meth_free(BIO_METHOD *biom);
  int (*BIO_meth_get_write(const BIO_METHOD *biom))(BIO *, const char *, int);
  int (*BIO_meth_get_write_ex(const BIO_METHOD *biom))(BIO *, const char *, size_t,
                                                       size_t *);
  int BIO_meth_set_write(BIO_METHOD *biom,
                         int (*write)(BIO *, const char *, int));
  int BIO_meth_set_write_ex(BIO_METHOD *biom,
                            int (*bwrite)(BIO *, const char *, size_t, size_t *));
  int (*BIO_meth_get_read(const BIO_METHOD *biom))(BIO *, char *, int);
  int (*BIO_meth_get_read_ex(const BIO_METHOD *biom))(BIO *, char *, size_t, size_t *);
  int BIO_meth_set_read(BIO_METHOD *biom,
                        int (*read)(BIO *, char *, int));
  int BIO_meth_set_read_ex(BIO_METHOD *biom,
                           int (*bread)(BIO *, char *, size_t, size_t *));
  int (*BIO_meth_get_puts(const BIO_METHOD *biom))(BIO *, const char *);
  int BIO_meth_set_puts(BIO_METHOD *biom,
                        int (*puts)(BIO *, const char *));
  int (*BIO_meth_get_gets(const BIO_METHOD *biom))(BIO *, char *, int);
  int BIO_meth_set_gets(BIO_METHOD *biom,
                        int (*gets)(BIO *, char *, int));
  long (*BIO_meth_get_ctrl(const BIO_METHOD *biom))(BIO *, int, long, void *);
  int BIO_meth_set_ctrl(BIO_METHOD *biom,
                        long (*ctrl)(BIO *, int, long, void *));
  int (*BIO_meth_get_create(const BIO_METHOD *bion))(BIO *);
  int BIO_meth_set_create(BIO_METHOD *biom, int (*create)(BIO *));
  int (*BIO_meth_get_destroy(const BIO_METHOD *biom))(BIO *);
  int BIO_meth_set_destroy(BIO_METHOD *biom, int (*destroy)(BIO *));
  long (*BIO_meth_get_callback_ctrl(const BIO_METHOD *biom))(BIO *, int, BIO_info_cb *);
  int BIO_meth_set_callback_ctrl(BIO_METHOD *biom,
                                 long (*callback_ctrl)(BIO *, int,
                                                       BIO_info_cb *));
}
extern "C" int ERR_load_BUF_strings(void);
extern "C"
{
  struct buf_mem_st
  {
    size_t length;
    char *data;
    size_t max;
    unsigned long flags;
  };
  BUF_MEM *BUF_MEM_new(void);
  BUF_MEM *BUF_MEM_new_ex(unsigned long flags);
  void BUF_MEM_free(BUF_MEM *a);
  size_t BUF_MEM_grow(BUF_MEM *str, size_t len);
  size_t BUF_MEM_grow_clean(BUF_MEM *str, size_t len);
  void BUF_reverse(unsigned char *out, const unsigned char *in, size_t siz);
}
extern "C"
{
}
extern "C" int ERR_load_EVP_strings(void);
extern "C"
{
}
extern "C" int ERR_load_ASN1_strings(void);
extern "C"
{
}
extern "C" int ERR_load_BN_strings(void);
extern "C"
{
  void BN_set_flags(BIGNUM *b, int n);
  int BN_get_flags(const BIGNUM *b, int n);
  void BN_with_flags(BIGNUM *dest, const BIGNUM *b, int flags);
  int BN_GENCB_call(BN_GENCB *cb, int a, int b);
  BN_GENCB *BN_GENCB_new(void);
  void BN_GENCB_free(BN_GENCB *cb);
  void BN_GENCB_set_old(BN_GENCB *gencb, void (*callback)(int, int, void *),
                        void *cb_arg);
  void BN_GENCB_set(BN_GENCB *gencb, int (*callback)(int, int, BN_GENCB *),
                    void *cb_arg);
  void *BN_GENCB_get_arg(BN_GENCB *cb);
  int BN_abs_is_word(const BIGNUM *a, const unsigned long w);
  int BN_is_zero(const BIGNUM *a);
  int BN_is_one(const BIGNUM *a);
  int BN_is_word(const BIGNUM *a, const unsigned long w);
  int BN_is_odd(const BIGNUM *a);
  void BN_zero_ex(BIGNUM *a);
  const BIGNUM *BN_value_one(void);
  char *BN_options(void);
  BN_CTX *BN_CTX_new(void);
  BN_CTX *BN_CTX_secure_new(void);
  void BN_CTX_free(BN_CTX *c);
  void BN_CTX_start(BN_CTX *ctx);
  BIGNUM *BN_CTX_get(BN_CTX *ctx);
  void BN_CTX_end(BN_CTX *ctx);
  int BN_rand(BIGNUM *rnd, int bits, int top, int bottom);
  int BN_priv_rand(BIGNUM *rnd, int bits, int top, int bottom);
  int BN_rand_range(BIGNUM *rnd, const BIGNUM *range);
  int BN_priv_rand_range(BIGNUM *rnd, const BIGNUM *range);
  int BN_pseudo_rand(BIGNUM *rnd, int bits, int top, int bottom);
  int BN_pseudo_rand_range(BIGNUM *rnd, const BIGNUM *range);
  int BN_num_bits(const BIGNUM *a);
  int BN_num_bits_word(unsigned long l);
  int BN_security_bits(int L, int N);
  BIGNUM *BN_new(void);
  BIGNUM *BN_secure_new(void);
  void BN_clear_free(BIGNUM *a);
  BIGNUM *BN_copy(BIGNUM *a, const BIGNUM *b);
  void BN_swap(BIGNUM *a, BIGNUM *b);
  BIGNUM *BN_bin2bn(const unsigned char *s, int len, BIGNUM *ret);
  int BN_bn2bin(const BIGNUM *a, unsigned char *to);
  int BN_bn2binpad(const BIGNUM *a, unsigned char *to, int tolen);
  BIGNUM *BN_lebin2bn(const unsigned char *s, int len, BIGNUM *ret);
  int BN_bn2lebinpad(const BIGNUM *a, unsigned char *to, int tolen);
  BIGNUM *BN_mpi2bn(const unsigned char *s, int len, BIGNUM *ret);
  int BN_bn2mpi(const BIGNUM *a, unsigned char *to);
  int BN_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
  int BN_usub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
  int BN_uadd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
  int BN_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
  int BN_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);
  int BN_sqr(BIGNUM *r, const BIGNUM *a, BN_CTX *ctx);
  void BN_set_negative(BIGNUM *b, int n);
  int BN_is_negative(const BIGNUM *b);
  int BN_div(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m, const BIGNUM *d,
             BN_CTX *ctx);
  int BN_nnmod(BIGNUM *r, const BIGNUM *m, const BIGNUM *d, BN_CTX *ctx);
  int BN_mod_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m,
                 BN_CTX *ctx);
  int BN_mod_add_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                       const BIGNUM *m);
  int BN_mod_sub(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m,
                 BN_CTX *ctx);
  int BN_mod_sub_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                       const BIGNUM *m);
  int BN_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, const BIGNUM *m,
                 BN_CTX *ctx);
  int BN_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);
  int BN_mod_lshift1(BIGNUM *r, const BIGNUM *a, const BIGNUM *m, BN_CTX *ctx);
  int BN_mod_lshift1_quick(BIGNUM *r, const BIGNUM *a, const BIGNUM *m);
  int BN_mod_lshift(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m,
                    BN_CTX *ctx);
  int BN_mod_lshift_quick(BIGNUM *r, const BIGNUM *a, int n, const BIGNUM *m);
  unsigned long BN_mod_word(const BIGNUM *a, unsigned long w);
  unsigned long BN_div_word(BIGNUM *a, unsigned long w);
  int BN_mul_word(BIGNUM *a, unsigned long w);
  int BN_add_word(BIGNUM *a, unsigned long w);
  int BN_sub_word(BIGNUM *a, unsigned long w);
  int BN_set_word(BIGNUM *a, unsigned long w);
  unsigned long BN_get_word(const BIGNUM *a);
  int BN_cmp(const BIGNUM *a, const BIGNUM *b);
  void BN_free(BIGNUM *a);
  int BN_is_bit_set(const BIGNUM *a, int n);
  int BN_lshift(BIGNUM *r, const BIGNUM *a, int n);
  int BN_lshift1(BIGNUM *r, const BIGNUM *a);
  int BN_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);
  int BN_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
                 const BIGNUM *m, BN_CTX *ctx);
  int BN_mod_exp_mont(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
                      const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);
  int BN_mod_exp_mont_consttime(BIGNUM *rr, const BIGNUM *a, const BIGNUM *p,
                                const BIGNUM *m, BN_CTX *ctx,
                                BN_MONT_CTX *in_mont);
  int BN_mod_exp_mont_word(BIGNUM *r, unsigned long a, const BIGNUM *p,
                           const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);
  int BN_mod_exp2_mont(BIGNUM *r, const BIGNUM *a1, const BIGNUM *p1,
                       const BIGNUM *a2, const BIGNUM *p2, const BIGNUM *m,
                       BN_CTX *ctx, BN_MONT_CTX *m_ctx);
  int BN_mod_exp_simple(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
                        const BIGNUM *m, BN_CTX *ctx);
  int BN_mask_bits(BIGNUM *a, int n);
  int BN_print_fp(FILE *fp, const BIGNUM *a);
  int BN_print(BIO *bio, const BIGNUM *a);
  int BN_reciprocal(BIGNUM *r, const BIGNUM *m, int len, BN_CTX *ctx);
  int BN_rshift(BIGNUM *r, const BIGNUM *a, int n);
  int BN_rshift1(BIGNUM *r, const BIGNUM *a);
  void BN_clear(BIGNUM *a);
  BIGNUM *BN_dup(const BIGNUM *a);
  int BN_ucmp(const BIGNUM *a, const BIGNUM *b);
  int BN_set_bit(BIGNUM *a, int n);
  int BN_clear_bit(BIGNUM *a, int n);
  char *BN_bn2hex(const BIGNUM *a);
  char *BN_bn2dec(const BIGNUM *a);
  int BN_hex2bn(BIGNUM **a, const char *str);
  int BN_dec2bn(BIGNUM **a, const char *str);
  int BN_asc2bn(BIGNUM **a, const char *str);
  int BN_gcd(BIGNUM *r, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);
  int BN_kronecker(const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);
  BIGNUM *BN_mod_inverse(BIGNUM *ret,
                         const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx);
  BIGNUM *BN_mod_sqrt(BIGNUM *ret,
                      const BIGNUM *a, const BIGNUM *n, BN_CTX *ctx);
  void BN_consttime_swap(unsigned long swap, BIGNUM *a, BIGNUM *b, int nwords);
  BIGNUM *BN_generate_prime(BIGNUM *ret, int bits, int safe, const BIGNUM *add, const BIGNUM *rem, void (*callback)(int, int, void *), void *cb_arg) __attribute__((deprecated));
  int BN_is_prime(const BIGNUM *p, int nchecks, void (*callback)(int, int, void *), BN_CTX *ctx, void *cb_arg) __attribute__((deprecated));
  int BN_is_prime_fasttest(const BIGNUM *p, int nchecks, void (*callback)(int, int, void *), BN_CTX *ctx, void *cb_arg, int do_trial_division) __attribute__((deprecated));
  int BN_generate_prime_ex(BIGNUM *ret, int bits, int safe, const BIGNUM *add,
                           const BIGNUM *rem, BN_GENCB *cb);
  int BN_is_prime_ex(const BIGNUM *p, int nchecks, BN_CTX *ctx, BN_GENCB *cb);
  int BN_is_prime_fasttest_ex(const BIGNUM *p, int nchecks, BN_CTX *ctx,
                              int do_trial_division, BN_GENCB *cb);
  int BN_X931_generate_Xpq(BIGNUM *Xp, BIGNUM *Xq, int nbits, BN_CTX *ctx);
  int BN_X931_derive_prime_ex(BIGNUM *p, BIGNUM *p1, BIGNUM *p2,
                              const BIGNUM *Xp, const BIGNUM *Xp1,
                              const BIGNUM *Xp2, const BIGNUM *e, BN_CTX *ctx,
                              BN_GENCB *cb);
  int BN_X931_generate_prime_ex(BIGNUM *p, BIGNUM *p1, BIGNUM *p2, BIGNUM *Xp1,
                                BIGNUM *Xp2, const BIGNUM *Xp, const BIGNUM *e,
                                BN_CTX *ctx, BN_GENCB *cb);
  BN_MONT_CTX *BN_MONT_CTX_new(void);
  int BN_mod_mul_montgomery(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                            BN_MONT_CTX *mont, BN_CTX *ctx);
  int BN_to_montgomery(BIGNUM *r, const BIGNUM *a, BN_MONT_CTX *mont,
                       BN_CTX *ctx);
  int BN_from_montgomery(BIGNUM *r, const BIGNUM *a, BN_MONT_CTX *mont,
                         BN_CTX *ctx);
  void BN_MONT_CTX_free(BN_MONT_CTX *mont);
  int BN_MONT_CTX_set(BN_MONT_CTX *mont, const BIGNUM *mod, BN_CTX *ctx);
  BN_MONT_CTX *BN_MONT_CTX_copy(BN_MONT_CTX *to, BN_MONT_CTX *from);
  BN_MONT_CTX *BN_MONT_CTX_set_locked(BN_MONT_CTX **pmont, CRYPTO_RWLOCK *lock,
                                      const BIGNUM *mod, BN_CTX *ctx);
  BN_BLINDING *BN_BLINDING_new(const BIGNUM *A, const BIGNUM *Ai, BIGNUM *mod);
  void BN_BLINDING_free(BN_BLINDING *b);
  int BN_BLINDING_update(BN_BLINDING *b, BN_CTX *ctx);
  int BN_BLINDING_convert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);
  int BN_BLINDING_invert(BIGNUM *n, BN_BLINDING *b, BN_CTX *ctx);
  int BN_BLINDING_convert_ex(BIGNUM *n, BIGNUM *r, BN_BLINDING *b, BN_CTX *);
  int BN_BLINDING_invert_ex(BIGNUM *n, const BIGNUM *r, BN_BLINDING *b,
                            BN_CTX *);
  int BN_BLINDING_is_current_thread(BN_BLINDING *b);
  void BN_BLINDING_set_current_thread(BN_BLINDING *b);
  int BN_BLINDING_lock(BN_BLINDING *b);
  int BN_BLINDING_unlock(BN_BLINDING *b);
  unsigned long BN_BLINDING_get_flags(const BN_BLINDING *);
  void BN_BLINDING_set_flags(BN_BLINDING *, unsigned long);
  BN_BLINDING *BN_BLINDING_create_param(BN_BLINDING *b,
                                        const BIGNUM *e, BIGNUM *m, BN_CTX *ctx,
                                        int (*bn_mod_exp)(BIGNUM *r,
                                                          const BIGNUM *a,
                                                          const BIGNUM *p,
                                                          const BIGNUM *m,
                                                          BN_CTX *ctx,
                                                          BN_MONT_CTX *m_ctx),
                                        BN_MONT_CTX *m_ctx);
  void BN_set_params(int mul, int high, int low, int mont) __attribute__((deprecated));
  int BN_get_params(int which) __attribute__((deprecated));
  BN_RECP_CTX *BN_RECP_CTX_new(void);
  void BN_RECP_CTX_free(BN_RECP_CTX *recp);
  int BN_RECP_CTX_set(BN_RECP_CTX *recp, const BIGNUM *rdiv, BN_CTX *ctx);
  int BN_mod_mul_reciprocal(BIGNUM *r, const BIGNUM *x, const BIGNUM *y,
                            BN_RECP_CTX *recp, BN_CTX *ctx);
  int BN_mod_exp_recp(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
                      const BIGNUM *m, BN_CTX *ctx);
  int BN_div_recp(BIGNUM *dv, BIGNUM *rem, const BIGNUM *m,
                  BN_RECP_CTX *recp, BN_CTX *ctx);
  int BN_GF2m_add(BIGNUM *r, const BIGNUM *a, const BIGNUM *b);
  int BN_GF2m_mod(BIGNUM *r, const BIGNUM *a, const BIGNUM *p);
  int BN_GF2m_mod_mul(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                      const BIGNUM *p, BN_CTX *ctx);
  int BN_GF2m_mod_sqr(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);
  int BN_GF2m_mod_inv(BIGNUM *r, const BIGNUM *b, const BIGNUM *p, BN_CTX *ctx);
  int BN_GF2m_mod_div(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                      const BIGNUM *p, BN_CTX *ctx);
  int BN_GF2m_mod_exp(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                      const BIGNUM *p, BN_CTX *ctx);
  int BN_GF2m_mod_sqrt(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
                       BN_CTX *ctx);
  int BN_GF2m_mod_solve_quad(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
                             BN_CTX *ctx);
  int BN_GF2m_mod_arr(BIGNUM *r, const BIGNUM *a, const int p[]);
  int BN_GF2m_mod_mul_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                          const int p[], BN_CTX *ctx);
  int BN_GF2m_mod_sqr_arr(BIGNUM *r, const BIGNUM *a, const int p[],
                          BN_CTX *ctx);
  int BN_GF2m_mod_inv_arr(BIGNUM *r, const BIGNUM *b, const int p[],
                          BN_CTX *ctx);
  int BN_GF2m_mod_div_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                          const int p[], BN_CTX *ctx);
  int BN_GF2m_mod_exp_arr(BIGNUM *r, const BIGNUM *a, const BIGNUM *b,
                          const int p[], BN_CTX *ctx);
  int BN_GF2m_mod_sqrt_arr(BIGNUM *r, const BIGNUM *a,
                           const int p[], BN_CTX *ctx);
  int BN_GF2m_mod_solve_quad_arr(BIGNUM *r, const BIGNUM *a,
                                 const int p[], BN_CTX *ctx);
  int BN_GF2m_poly2arr(const BIGNUM *a, int p[], int max);
  int BN_GF2m_arr2poly(const int p[], BIGNUM *a);
  int BN_nist_mod_192(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);
  int BN_nist_mod_224(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);
  int BN_nist_mod_256(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);
  int BN_nist_mod_384(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);
  int BN_nist_mod_521(BIGNUM *r, const BIGNUM *a, const BIGNUM *p, BN_CTX *ctx);
  const BIGNUM *BN_get0_nist_prime_192(void);
  const BIGNUM *BN_get0_nist_prime_224(void);
  const BIGNUM *BN_get0_nist_prime_256(void);
  const BIGNUM *BN_get0_nist_prime_384(void);
  const BIGNUM *BN_get0_nist_prime_521(void);
  int (*BN_nist_mod_func(const BIGNUM *p))(BIGNUM *r, const BIGNUM *a,
                                           const BIGNUM *field, BN_CTX *ctx);
  int BN_generate_dsa_nonce(BIGNUM *out, const BIGNUM *range,
                            const BIGNUM *priv, const unsigned char *message,
                            size_t message_len, BN_CTX *ctx);
  BIGNUM *BN_get_rfc2409_prime_768(BIGNUM *bn);
  BIGNUM *BN_get_rfc2409_prime_1024(BIGNUM *bn);
  BIGNUM *BN_get_rfc3526_prime_1536(BIGNUM *bn);
  BIGNUM *BN_get_rfc3526_prime_2048(BIGNUM *bn);
  BIGNUM *BN_get_rfc3526_prime_3072(BIGNUM *bn);
  BIGNUM *BN_get_rfc3526_prime_4096(BIGNUM *bn);
  BIGNUM *BN_get_rfc3526_prime_6144(BIGNUM *bn);
  BIGNUM *BN_get_rfc3526_prime_8192(BIGNUM *bn);
  int BN_bntest_rand(BIGNUM *rnd, int bits, int top, int bottom);
}
extern "C"
{
  struct X509_algor_st;
  struct stack_st_X509_ALGOR;
  typedef int (*sk_X509_ALGOR_compfunc)(const X509_ALGOR *const *a, const X509_ALGOR *const *b);
  typedef void (*sk_X509_ALGOR_freefunc)(X509_ALGOR *a);
  typedef X509_ALGOR *(*sk_X509_ALGOR_copyfunc)(const X509_ALGOR *a);
  static __attribute__((unused)) inline int sk_X509_ALGOR_num(const struct stack_st_X509_ALGOR *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_ALGOR *sk_X509_ALGOR_value(const struct stack_st_X509_ALGOR *sk, int idx) { return (X509_ALGOR *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_X509_ALGOR *sk_X509_ALGOR_new(sk_X509_ALGOR_compfunc compare) { return (struct stack_st_X509_ALGOR *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_X509_ALGOR *sk_X509_ALGOR_new_null(void) { return (struct stack_st_X509_ALGOR *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_X509_ALGOR *sk_X509_ALGOR_new_reserve(sk_X509_ALGOR_compfunc compare, int n) { return (struct stack_st_X509_ALGOR *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_X509_ALGOR_reserve(struct stack_st_X509_ALGOR *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_X509_ALGOR_free(struct stack_st_X509_ALGOR *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_ALGOR_zero(struct stack_st_X509_ALGOR *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_ALGOR *sk_X509_ALGOR_delete(struct stack_st_X509_ALGOR *sk, int i) { return (X509_ALGOR *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline X509_ALGOR *sk_X509_ALGOR_delete_ptr(struct stack_st_X509_ALGOR *sk, X509_ALGOR *ptr) { return (X509_ALGOR *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_ALGOR_push(struct stack_st_X509_ALGOR *sk, X509_ALGOR *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_ALGOR_unshift(struct stack_st_X509_ALGOR *sk, X509_ALGOR *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline X509_ALGOR *sk_X509_ALGOR_pop(struct stack_st_X509_ALGOR *sk) { return (X509_ALGOR *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_ALGOR *sk_X509_ALGOR_shift(struct stack_st_X509_ALGOR *sk) { return (X509_ALGOR *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_ALGOR_pop_free(struct stack_st_X509_ALGOR *sk, sk_X509_ALGOR_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_X509_ALGOR_insert(struct stack_st_X509_ALGOR *sk, X509_ALGOR *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline X509_ALGOR *sk_X509_ALGOR_set(struct stack_st_X509_ALGOR *sk, int idx, X509_ALGOR *ptr) { return (X509_ALGOR *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_ALGOR_find(struct stack_st_X509_ALGOR *sk, X509_ALGOR *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_ALGOR_find_ex(struct stack_st_X509_ALGOR *sk, X509_ALGOR *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_X509_ALGOR_sort(struct stack_st_X509_ALGOR *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_X509_ALGOR_is_sorted(const struct stack_st_X509_ALGOR *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_ALGOR *sk_X509_ALGOR_dup(const struct stack_st_X509_ALGOR *sk) { return (struct stack_st_X509_ALGOR *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_ALGOR *sk_X509_ALGOR_deep_copy(const struct stack_st_X509_ALGOR *sk, sk_X509_ALGOR_copyfunc copyfunc, sk_X509_ALGOR_freefunc freefunc) { return (struct stack_st_X509_ALGOR *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_X509_ALGOR_compfunc sk_X509_ALGOR_set_cmp_func(struct stack_st_X509_ALGOR *sk, sk_X509_ALGOR_compfunc compare) { return (sk_X509_ALGOR_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  struct asn1_string_st
  {
    int length;
    int type;
    unsigned char *data;
    long flags;
  };
  typedef struct ASN1_ENCODING_st
  {
    unsigned char *enc;
    long len;
    int modified;
  } ASN1_ENCODING;
  typedef struct asn1_string_table_st
  {
    int nid;
    long minsize;
    long maxsize;
    unsigned long mask;
    unsigned long flags;
  } ASN1_STRING_TABLE;
  struct stack_st_ASN1_STRING_TABLE;
  typedef int (*sk_ASN1_STRING_TABLE_compfunc)(const ASN1_STRING_TABLE *const *a, const ASN1_STRING_TABLE *const *b);
  typedef void (*sk_ASN1_STRING_TABLE_freefunc)(ASN1_STRING_TABLE *a);
  typedef ASN1_STRING_TABLE *(*sk_ASN1_STRING_TABLE_copyfunc)(const ASN1_STRING_TABLE *a);
  static __attribute__((unused)) inline int sk_ASN1_STRING_TABLE_num(const struct stack_st_ASN1_STRING_TABLE *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline ASN1_STRING_TABLE *sk_ASN1_STRING_TABLE_value(const struct stack_st_ASN1_STRING_TABLE *sk, int idx) { return (ASN1_STRING_TABLE *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_ASN1_STRING_TABLE *sk_ASN1_STRING_TABLE_new(sk_ASN1_STRING_TABLE_compfunc compare) { return (struct stack_st_ASN1_STRING_TABLE *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_ASN1_STRING_TABLE *sk_ASN1_STRING_TABLE_new_null(void) { return (struct stack_st_ASN1_STRING_TABLE *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_ASN1_STRING_TABLE *sk_ASN1_STRING_TABLE_new_reserve(sk_ASN1_STRING_TABLE_compfunc compare, int n) { return (struct stack_st_ASN1_STRING_TABLE *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_ASN1_STRING_TABLE_reserve(struct stack_st_ASN1_STRING_TABLE *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_ASN1_STRING_TABLE_free(struct stack_st_ASN1_STRING_TABLE *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_ASN1_STRING_TABLE_zero(struct stack_st_ASN1_STRING_TABLE *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline ASN1_STRING_TABLE *sk_ASN1_STRING_TABLE_delete(struct stack_st_ASN1_STRING_TABLE *sk, int i) { return (ASN1_STRING_TABLE *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline ASN1_STRING_TABLE *sk_ASN1_STRING_TABLE_delete_ptr(struct stack_st_ASN1_STRING_TABLE *sk, ASN1_STRING_TABLE *ptr) { return (ASN1_STRING_TABLE *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_STRING_TABLE_push(struct stack_st_ASN1_STRING_TABLE *sk, ASN1_STRING_TABLE *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_STRING_TABLE_unshift(struct stack_st_ASN1_STRING_TABLE *sk, ASN1_STRING_TABLE *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline ASN1_STRING_TABLE *sk_ASN1_STRING_TABLE_pop(struct stack_st_ASN1_STRING_TABLE *sk) { return (ASN1_STRING_TABLE *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline ASN1_STRING_TABLE *sk_ASN1_STRING_TABLE_shift(struct stack_st_ASN1_STRING_TABLE *sk) { return (ASN1_STRING_TABLE *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_ASN1_STRING_TABLE_pop_free(struct stack_st_ASN1_STRING_TABLE *sk, sk_ASN1_STRING_TABLE_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_ASN1_STRING_TABLE_insert(struct stack_st_ASN1_STRING_TABLE *sk, ASN1_STRING_TABLE *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline ASN1_STRING_TABLE *sk_ASN1_STRING_TABLE_set(struct stack_st_ASN1_STRING_TABLE *sk, int idx, ASN1_STRING_TABLE *ptr) { return (ASN1_STRING_TABLE *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_STRING_TABLE_find(struct stack_st_ASN1_STRING_TABLE *sk, ASN1_STRING_TABLE *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_STRING_TABLE_find_ex(struct stack_st_ASN1_STRING_TABLE *sk, ASN1_STRING_TABLE *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_ASN1_STRING_TABLE_sort(struct stack_st_ASN1_STRING_TABLE *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_ASN1_STRING_TABLE_is_sorted(const struct stack_st_ASN1_STRING_TABLE *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_ASN1_STRING_TABLE *sk_ASN1_STRING_TABLE_dup(const struct stack_st_ASN1_STRING_TABLE *sk) { return (struct stack_st_ASN1_STRING_TABLE *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_ASN1_STRING_TABLE *sk_ASN1_STRING_TABLE_deep_copy(const struct stack_st_ASN1_STRING_TABLE *sk, sk_ASN1_STRING_TABLE_copyfunc copyfunc, sk_ASN1_STRING_TABLE_freefunc freefunc) { return (struct stack_st_ASN1_STRING_TABLE *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_ASN1_STRING_TABLE_compfunc sk_ASN1_STRING_TABLE_set_cmp_func(struct stack_st_ASN1_STRING_TABLE *sk, sk_ASN1_STRING_TABLE_compfunc compare) { return (sk_ASN1_STRING_TABLE_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  typedef struct ASN1_TEMPLATE_st ASN1_TEMPLATE;
  typedef struct ASN1_TLC_st ASN1_TLC;
  typedef struct ASN1_VALUE_st ASN1_VALUE;
  typedef void *d2i_of_void(void **, const unsigned char **, long);
  typedef int i2d_of_void(void *, unsigned char **);
  typedef const ASN1_ITEM ASN1_ITEM_EXP;
  struct stack_st_ASN1_INTEGER;
  typedef int (*sk_ASN1_INTEGER_compfunc)(const ASN1_INTEGER *const *a, const ASN1_INTEGER *const *b);
  typedef void (*sk_ASN1_INTEGER_freefunc)(ASN1_INTEGER *a);
  typedef ASN1_INTEGER *(*sk_ASN1_INTEGER_copyfunc)(const ASN1_INTEGER *a);
  static __attribute__((unused)) inline int sk_ASN1_INTEGER_num(const struct stack_st_ASN1_INTEGER *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline ASN1_INTEGER *sk_ASN1_INTEGER_value(const struct stack_st_ASN1_INTEGER *sk, int idx) { return (ASN1_INTEGER *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_ASN1_INTEGER *sk_ASN1_INTEGER_new(sk_ASN1_INTEGER_compfunc compare) { return (struct stack_st_ASN1_INTEGER *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_ASN1_INTEGER *sk_ASN1_INTEGER_new_null(void) { return (struct stack_st_ASN1_INTEGER *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_ASN1_INTEGER *sk_ASN1_INTEGER_new_reserve(sk_ASN1_INTEGER_compfunc compare, int n) { return (struct stack_st_ASN1_INTEGER *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_ASN1_INTEGER_reserve(struct stack_st_ASN1_INTEGER *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_ASN1_INTEGER_free(struct stack_st_ASN1_INTEGER *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_ASN1_INTEGER_zero(struct stack_st_ASN1_INTEGER *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline ASN1_INTEGER *sk_ASN1_INTEGER_delete(struct stack_st_ASN1_INTEGER *sk, int i) { return (ASN1_INTEGER *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline ASN1_INTEGER *sk_ASN1_INTEGER_delete_ptr(struct stack_st_ASN1_INTEGER *sk, ASN1_INTEGER *ptr) { return (ASN1_INTEGER *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_INTEGER_push(struct stack_st_ASN1_INTEGER *sk, ASN1_INTEGER *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_INTEGER_unshift(struct stack_st_ASN1_INTEGER *sk, ASN1_INTEGER *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline ASN1_INTEGER *sk_ASN1_INTEGER_pop(struct stack_st_ASN1_INTEGER *sk) { return (ASN1_INTEGER *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline ASN1_INTEGER *sk_ASN1_INTEGER_shift(struct stack_st_ASN1_INTEGER *sk) { return (ASN1_INTEGER *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_ASN1_INTEGER_pop_free(struct stack_st_ASN1_INTEGER *sk, sk_ASN1_INTEGER_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_ASN1_INTEGER_insert(struct stack_st_ASN1_INTEGER *sk, ASN1_INTEGER *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline ASN1_INTEGER *sk_ASN1_INTEGER_set(struct stack_st_ASN1_INTEGER *sk, int idx, ASN1_INTEGER *ptr) { return (ASN1_INTEGER *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_INTEGER_find(struct stack_st_ASN1_INTEGER *sk, ASN1_INTEGER *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_INTEGER_find_ex(struct stack_st_ASN1_INTEGER *sk, ASN1_INTEGER *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_ASN1_INTEGER_sort(struct stack_st_ASN1_INTEGER *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_ASN1_INTEGER_is_sorted(const struct stack_st_ASN1_INTEGER *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_ASN1_INTEGER *sk_ASN1_INTEGER_dup(const struct stack_st_ASN1_INTEGER *sk) { return (struct stack_st_ASN1_INTEGER *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_ASN1_INTEGER *sk_ASN1_INTEGER_deep_copy(const struct stack_st_ASN1_INTEGER *sk, sk_ASN1_INTEGER_copyfunc copyfunc, sk_ASN1_INTEGER_freefunc freefunc) { return (struct stack_st_ASN1_INTEGER *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_ASN1_INTEGER_compfunc sk_ASN1_INTEGER_set_cmp_func(struct stack_st_ASN1_INTEGER *sk, sk_ASN1_INTEGER_compfunc compare) { return (sk_ASN1_INTEGER_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  struct stack_st_ASN1_GENERALSTRING;
  typedef int (*sk_ASN1_GENERALSTRING_compfunc)(const ASN1_GENERALSTRING *const *a, const ASN1_GENERALSTRING *const *b);
  typedef void (*sk_ASN1_GENERALSTRING_freefunc)(ASN1_GENERALSTRING *a);
  typedef ASN1_GENERALSTRING *(*sk_ASN1_GENERALSTRING_copyfunc)(const ASN1_GENERALSTRING *a);
  static __attribute__((unused)) inline int sk_ASN1_GENERALSTRING_num(const struct stack_st_ASN1_GENERALSTRING *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline ASN1_GENERALSTRING *sk_ASN1_GENERALSTRING_value(const struct stack_st_ASN1_GENERALSTRING *sk, int idx) { return (ASN1_GENERALSTRING *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_ASN1_GENERALSTRING *sk_ASN1_GENERALSTRING_new(sk_ASN1_GENERALSTRING_compfunc compare) { return (struct stack_st_ASN1_GENERALSTRING *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_ASN1_GENERALSTRING *sk_ASN1_GENERALSTRING_new_null(void) { return (struct stack_st_ASN1_GENERALSTRING *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_ASN1_GENERALSTRING *sk_ASN1_GENERALSTRING_new_reserve(sk_ASN1_GENERALSTRING_compfunc compare, int n) { return (struct stack_st_ASN1_GENERALSTRING *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_ASN1_GENERALSTRING_reserve(struct stack_st_ASN1_GENERALSTRING *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_ASN1_GENERALSTRING_free(struct stack_st_ASN1_GENERALSTRING *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_ASN1_GENERALSTRING_zero(struct stack_st_ASN1_GENERALSTRING *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline ASN1_GENERALSTRING *sk_ASN1_GENERALSTRING_delete(struct stack_st_ASN1_GENERALSTRING *sk, int i) { return (ASN1_GENERALSTRING *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline ASN1_GENERALSTRING *sk_ASN1_GENERALSTRING_delete_ptr(struct stack_st_ASN1_GENERALSTRING *sk, ASN1_GENERALSTRING *ptr) { return (ASN1_GENERALSTRING *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_GENERALSTRING_push(struct stack_st_ASN1_GENERALSTRING *sk, ASN1_GENERALSTRING *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_GENERALSTRING_unshift(struct stack_st_ASN1_GENERALSTRING *sk, ASN1_GENERALSTRING *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline ASN1_GENERALSTRING *sk_ASN1_GENERALSTRING_pop(struct stack_st_ASN1_GENERALSTRING *sk) { return (ASN1_GENERALSTRING *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline ASN1_GENERALSTRING *sk_ASN1_GENERALSTRING_shift(struct stack_st_ASN1_GENERALSTRING *sk) { return (ASN1_GENERALSTRING *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_ASN1_GENERALSTRING_pop_free(struct stack_st_ASN1_GENERALSTRING *sk, sk_ASN1_GENERALSTRING_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_ASN1_GENERALSTRING_insert(struct stack_st_ASN1_GENERALSTRING *sk, ASN1_GENERALSTRING *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline ASN1_GENERALSTRING *sk_ASN1_GENERALSTRING_set(struct stack_st_ASN1_GENERALSTRING *sk, int idx, ASN1_GENERALSTRING *ptr) { return (ASN1_GENERALSTRING *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_GENERALSTRING_find(struct stack_st_ASN1_GENERALSTRING *sk, ASN1_GENERALSTRING *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_GENERALSTRING_find_ex(struct stack_st_ASN1_GENERALSTRING *sk, ASN1_GENERALSTRING *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_ASN1_GENERALSTRING_sort(struct stack_st_ASN1_GENERALSTRING *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_ASN1_GENERALSTRING_is_sorted(const struct stack_st_ASN1_GENERALSTRING *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_ASN1_GENERALSTRING *sk_ASN1_GENERALSTRING_dup(const struct stack_st_ASN1_GENERALSTRING *sk) { return (struct stack_st_ASN1_GENERALSTRING *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_ASN1_GENERALSTRING *sk_ASN1_GENERALSTRING_deep_copy(const struct stack_st_ASN1_GENERALSTRING *sk, sk_ASN1_GENERALSTRING_copyfunc copyfunc, sk_ASN1_GENERALSTRING_freefunc freefunc) { return (struct stack_st_ASN1_GENERALSTRING *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_ASN1_GENERALSTRING_compfunc sk_ASN1_GENERALSTRING_set_cmp_func(struct stack_st_ASN1_GENERALSTRING *sk, sk_ASN1_GENERALSTRING_compfunc compare) { return (sk_ASN1_GENERALSTRING_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  struct stack_st_ASN1_UTF8STRING;
  typedef int (*sk_ASN1_UTF8STRING_compfunc)(const ASN1_UTF8STRING *const *a, const ASN1_UTF8STRING *const *b);
  typedef void (*sk_ASN1_UTF8STRING_freefunc)(ASN1_UTF8STRING *a);
  typedef ASN1_UTF8STRING *(*sk_ASN1_UTF8STRING_copyfunc)(const ASN1_UTF8STRING *a);
  static __attribute__((unused)) inline int sk_ASN1_UTF8STRING_num(const struct stack_st_ASN1_UTF8STRING *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline ASN1_UTF8STRING *sk_ASN1_UTF8STRING_value(const struct stack_st_ASN1_UTF8STRING *sk, int idx) { return (ASN1_UTF8STRING *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_ASN1_UTF8STRING *sk_ASN1_UTF8STRING_new(sk_ASN1_UTF8STRING_compfunc compare) { return (struct stack_st_ASN1_UTF8STRING *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_ASN1_UTF8STRING *sk_ASN1_UTF8STRING_new_null(void) { return (struct stack_st_ASN1_UTF8STRING *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_ASN1_UTF8STRING *sk_ASN1_UTF8STRING_new_reserve(sk_ASN1_UTF8STRING_compfunc compare, int n) { return (struct stack_st_ASN1_UTF8STRING *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_ASN1_UTF8STRING_reserve(struct stack_st_ASN1_UTF8STRING *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_ASN1_UTF8STRING_free(struct stack_st_ASN1_UTF8STRING *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_ASN1_UTF8STRING_zero(struct stack_st_ASN1_UTF8STRING *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline ASN1_UTF8STRING *sk_ASN1_UTF8STRING_delete(struct stack_st_ASN1_UTF8STRING *sk, int i) { return (ASN1_UTF8STRING *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline ASN1_UTF8STRING *sk_ASN1_UTF8STRING_delete_ptr(struct stack_st_ASN1_UTF8STRING *sk, ASN1_UTF8STRING *ptr) { return (ASN1_UTF8STRING *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_UTF8STRING_push(struct stack_st_ASN1_UTF8STRING *sk, ASN1_UTF8STRING *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_UTF8STRING_unshift(struct stack_st_ASN1_UTF8STRING *sk, ASN1_UTF8STRING *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline ASN1_UTF8STRING *sk_ASN1_UTF8STRING_pop(struct stack_st_ASN1_UTF8STRING *sk) { return (ASN1_UTF8STRING *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline ASN1_UTF8STRING *sk_ASN1_UTF8STRING_shift(struct stack_st_ASN1_UTF8STRING *sk) { return (ASN1_UTF8STRING *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_ASN1_UTF8STRING_pop_free(struct stack_st_ASN1_UTF8STRING *sk, sk_ASN1_UTF8STRING_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_ASN1_UTF8STRING_insert(struct stack_st_ASN1_UTF8STRING *sk, ASN1_UTF8STRING *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline ASN1_UTF8STRING *sk_ASN1_UTF8STRING_set(struct stack_st_ASN1_UTF8STRING *sk, int idx, ASN1_UTF8STRING *ptr) { return (ASN1_UTF8STRING *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_UTF8STRING_find(struct stack_st_ASN1_UTF8STRING *sk, ASN1_UTF8STRING *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_UTF8STRING_find_ex(struct stack_st_ASN1_UTF8STRING *sk, ASN1_UTF8STRING *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_ASN1_UTF8STRING_sort(struct stack_st_ASN1_UTF8STRING *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_ASN1_UTF8STRING_is_sorted(const struct stack_st_ASN1_UTF8STRING *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_ASN1_UTF8STRING *sk_ASN1_UTF8STRING_dup(const struct stack_st_ASN1_UTF8STRING *sk) { return (struct stack_st_ASN1_UTF8STRING *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_ASN1_UTF8STRING *sk_ASN1_UTF8STRING_deep_copy(const struct stack_st_ASN1_UTF8STRING *sk, sk_ASN1_UTF8STRING_copyfunc copyfunc, sk_ASN1_UTF8STRING_freefunc freefunc) { return (struct stack_st_ASN1_UTF8STRING *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_ASN1_UTF8STRING_compfunc sk_ASN1_UTF8STRING_set_cmp_func(struct stack_st_ASN1_UTF8STRING *sk, sk_ASN1_UTF8STRING_compfunc compare) { return (sk_ASN1_UTF8STRING_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  typedef struct asn1_type_st
  {
    int type;
    union
    {
      char *ptr;
      ASN1_BOOLEAN boolean;
      ASN1_STRING *asn1_string;
      ASN1_OBJECT *object;
      ASN1_INTEGER *integer;
      ASN1_ENUMERATED *enumerated;
      ASN1_BIT_STRING *bit_string;
      ASN1_OCTET_STRING *octet_string;
      ASN1_PRINTABLESTRING *printablestring;
      ASN1_T61STRING *t61string;
      ASN1_IA5STRING *ia5string;
      ASN1_GENERALSTRING *generalstring;
      ASN1_BMPSTRING *bmpstring;
      ASN1_UNIVERSALSTRING *universalstring;
      ASN1_UTCTIME *utctime;
      ASN1_GENERALIZEDTIME *generalizedtime;
      ASN1_VISIBLESTRING *visiblestring;
      ASN1_UTF8STRING *utf8string;
      ASN1_STRING *set;
      ASN1_STRING *sequence;
      ASN1_VALUE *asn1_value;
    } value;
  } ASN1_TYPE;
  struct stack_st_ASN1_TYPE;
  typedef int (*sk_ASN1_TYPE_compfunc)(const ASN1_TYPE *const *a, const ASN1_TYPE *const *b);
  typedef void (*sk_ASN1_TYPE_freefunc)(ASN1_TYPE *a);
  typedef ASN1_TYPE *(*sk_ASN1_TYPE_copyfunc)(const ASN1_TYPE *a);
  static __attribute__((unused)) inline int sk_ASN1_TYPE_num(const struct stack_st_ASN1_TYPE *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline ASN1_TYPE *sk_ASN1_TYPE_value(const struct stack_st_ASN1_TYPE *sk, int idx) { return (ASN1_TYPE *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_ASN1_TYPE *sk_ASN1_TYPE_new(sk_ASN1_TYPE_compfunc compare) { return (struct stack_st_ASN1_TYPE *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_ASN1_TYPE *sk_ASN1_TYPE_new_null(void) { return (struct stack_st_ASN1_TYPE *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_ASN1_TYPE *sk_ASN1_TYPE_new_reserve(sk_ASN1_TYPE_compfunc compare, int n) { return (struct stack_st_ASN1_TYPE *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_ASN1_TYPE_reserve(struct stack_st_ASN1_TYPE *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_ASN1_TYPE_free(struct stack_st_ASN1_TYPE *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_ASN1_TYPE_zero(struct stack_st_ASN1_TYPE *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline ASN1_TYPE *sk_ASN1_TYPE_delete(struct stack_st_ASN1_TYPE *sk, int i) { return (ASN1_TYPE *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline ASN1_TYPE *sk_ASN1_TYPE_delete_ptr(struct stack_st_ASN1_TYPE *sk, ASN1_TYPE *ptr) { return (ASN1_TYPE *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_TYPE_push(struct stack_st_ASN1_TYPE *sk, ASN1_TYPE *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_TYPE_unshift(struct stack_st_ASN1_TYPE *sk, ASN1_TYPE *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline ASN1_TYPE *sk_ASN1_TYPE_pop(struct stack_st_ASN1_TYPE *sk) { return (ASN1_TYPE *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline ASN1_TYPE *sk_ASN1_TYPE_shift(struct stack_st_ASN1_TYPE *sk) { return (ASN1_TYPE *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_ASN1_TYPE_pop_free(struct stack_st_ASN1_TYPE *sk, sk_ASN1_TYPE_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_ASN1_TYPE_insert(struct stack_st_ASN1_TYPE *sk, ASN1_TYPE *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline ASN1_TYPE *sk_ASN1_TYPE_set(struct stack_st_ASN1_TYPE *sk, int idx, ASN1_TYPE *ptr) { return (ASN1_TYPE *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_TYPE_find(struct stack_st_ASN1_TYPE *sk, ASN1_TYPE *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_TYPE_find_ex(struct stack_st_ASN1_TYPE *sk, ASN1_TYPE *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_ASN1_TYPE_sort(struct stack_st_ASN1_TYPE *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_ASN1_TYPE_is_sorted(const struct stack_st_ASN1_TYPE *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_ASN1_TYPE *sk_ASN1_TYPE_dup(const struct stack_st_ASN1_TYPE *sk) { return (struct stack_st_ASN1_TYPE *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_ASN1_TYPE *sk_ASN1_TYPE_deep_copy(const struct stack_st_ASN1_TYPE *sk, sk_ASN1_TYPE_copyfunc copyfunc, sk_ASN1_TYPE_freefunc freefunc) { return (struct stack_st_ASN1_TYPE *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_ASN1_TYPE_compfunc sk_ASN1_TYPE_set_cmp_func(struct stack_st_ASN1_TYPE *sk, sk_ASN1_TYPE_compfunc compare) { return (sk_ASN1_TYPE_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  typedef struct stack_st_ASN1_TYPE ASN1_SEQUENCE_ANY;
  ASN1_SEQUENCE_ANY *d2i_ASN1_SEQUENCE_ANY(ASN1_SEQUENCE_ANY **a, const unsigned char **in, long len);
  int i2d_ASN1_SEQUENCE_ANY(const ASN1_SEQUENCE_ANY *a, unsigned char **out);
  extern const ASN1_ITEM ASN1_SEQUENCE_ANY_it;
  ASN1_SEQUENCE_ANY *d2i_ASN1_SET_ANY(ASN1_SEQUENCE_ANY **a, const unsigned char **in, long len);
  int i2d_ASN1_SET_ANY(const ASN1_SEQUENCE_ANY *a, unsigned char **out);
  extern const ASN1_ITEM ASN1_SET_ANY_it;
  typedef struct BIT_STRING_BITNAME_st
  {
    int bitnum;
    const char *lname;
    const char *sname;
  } BIT_STRING_BITNAME;
  ASN1_TYPE *ASN1_TYPE_new(void);
  void ASN1_TYPE_free(ASN1_TYPE *a);
  ASN1_TYPE *d2i_ASN1_TYPE(ASN1_TYPE **a, const unsigned char **in, long len);
  int i2d_ASN1_TYPE(ASN1_TYPE *a, unsigned char **out);
  extern const ASN1_ITEM ASN1_ANY_it;
  int ASN1_TYPE_get(const ASN1_TYPE *a);
  void ASN1_TYPE_set(ASN1_TYPE *a, int type, void *value);
  int ASN1_TYPE_set1(ASN1_TYPE *a, int type, const void *value);
  int ASN1_TYPE_cmp(const ASN1_TYPE *a, const ASN1_TYPE *b);
  ASN1_TYPE *ASN1_TYPE_pack_sequence(const ASN1_ITEM *it, void *s, ASN1_TYPE **t);
  void *ASN1_TYPE_unpack_sequence(const ASN1_ITEM *it, const ASN1_TYPE *t);
  ASN1_OBJECT *ASN1_OBJECT_new(void);
  void ASN1_OBJECT_free(ASN1_OBJECT *a);
  int i2d_ASN1_OBJECT(const ASN1_OBJECT *a, unsigned char **pp);
  ASN1_OBJECT *d2i_ASN1_OBJECT(ASN1_OBJECT **a, const unsigned char **pp,
                               long length);
  extern const ASN1_ITEM ASN1_OBJECT_it;
  struct stack_st_ASN1_OBJECT;
  typedef int (*sk_ASN1_OBJECT_compfunc)(const ASN1_OBJECT *const *a, const ASN1_OBJECT *const *b);
  typedef void (*sk_ASN1_OBJECT_freefunc)(ASN1_OBJECT *a);
  typedef ASN1_OBJECT *(*sk_ASN1_OBJECT_copyfunc)(const ASN1_OBJECT *a);
  static __attribute__((unused)) inline int sk_ASN1_OBJECT_num(const struct stack_st_ASN1_OBJECT *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline ASN1_OBJECT *sk_ASN1_OBJECT_value(const struct stack_st_ASN1_OBJECT *sk, int idx) { return (ASN1_OBJECT *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_ASN1_OBJECT *sk_ASN1_OBJECT_new(sk_ASN1_OBJECT_compfunc compare) { return (struct stack_st_ASN1_OBJECT *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_ASN1_OBJECT *sk_ASN1_OBJECT_new_null(void) { return (struct stack_st_ASN1_OBJECT *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_ASN1_OBJECT *sk_ASN1_OBJECT_new_reserve(sk_ASN1_OBJECT_compfunc compare, int n) { return (struct stack_st_ASN1_OBJECT *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_ASN1_OBJECT_reserve(struct stack_st_ASN1_OBJECT *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_ASN1_OBJECT_free(struct stack_st_ASN1_OBJECT *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_ASN1_OBJECT_zero(struct stack_st_ASN1_OBJECT *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline ASN1_OBJECT *sk_ASN1_OBJECT_delete(struct stack_st_ASN1_OBJECT *sk, int i) { return (ASN1_OBJECT *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline ASN1_OBJECT *sk_ASN1_OBJECT_delete_ptr(struct stack_st_ASN1_OBJECT *sk, ASN1_OBJECT *ptr) { return (ASN1_OBJECT *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_OBJECT_push(struct stack_st_ASN1_OBJECT *sk, ASN1_OBJECT *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_OBJECT_unshift(struct stack_st_ASN1_OBJECT *sk, ASN1_OBJECT *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline ASN1_OBJECT *sk_ASN1_OBJECT_pop(struct stack_st_ASN1_OBJECT *sk) { return (ASN1_OBJECT *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline ASN1_OBJECT *sk_ASN1_OBJECT_shift(struct stack_st_ASN1_OBJECT *sk) { return (ASN1_OBJECT *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_ASN1_OBJECT_pop_free(struct stack_st_ASN1_OBJECT *sk, sk_ASN1_OBJECT_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_ASN1_OBJECT_insert(struct stack_st_ASN1_OBJECT *sk, ASN1_OBJECT *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline ASN1_OBJECT *sk_ASN1_OBJECT_set(struct stack_st_ASN1_OBJECT *sk, int idx, ASN1_OBJECT *ptr) { return (ASN1_OBJECT *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_OBJECT_find(struct stack_st_ASN1_OBJECT *sk, ASN1_OBJECT *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_ASN1_OBJECT_find_ex(struct stack_st_ASN1_OBJECT *sk, ASN1_OBJECT *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_ASN1_OBJECT_sort(struct stack_st_ASN1_OBJECT *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_ASN1_OBJECT_is_sorted(const struct stack_st_ASN1_OBJECT *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_ASN1_OBJECT *sk_ASN1_OBJECT_dup(const struct stack_st_ASN1_OBJECT *sk) { return (struct stack_st_ASN1_OBJECT *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_ASN1_OBJECT *sk_ASN1_OBJECT_deep_copy(const struct stack_st_ASN1_OBJECT *sk, sk_ASN1_OBJECT_copyfunc copyfunc, sk_ASN1_OBJECT_freefunc freefunc) { return (struct stack_st_ASN1_OBJECT *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_ASN1_OBJECT_compfunc sk_ASN1_OBJECT_set_cmp_func(struct stack_st_ASN1_OBJECT *sk, sk_ASN1_OBJECT_compfunc compare) { return (sk_ASN1_OBJECT_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  ASN1_STRING *ASN1_STRING_new(void);
  void ASN1_STRING_free(ASN1_STRING *a);
  void ASN1_STRING_clear_free(ASN1_STRING *a);
  int ASN1_STRING_copy(ASN1_STRING *dst, const ASN1_STRING *str);
  ASN1_STRING *ASN1_STRING_dup(const ASN1_STRING *a);
  ASN1_STRING *ASN1_STRING_type_new(int type);
  int ASN1_STRING_cmp(const ASN1_STRING *a, const ASN1_STRING *b);
  int ASN1_STRING_set(ASN1_STRING *str, const void *data, int len);
  void ASN1_STRING_set0(ASN1_STRING *str, void *data, int len);
  int ASN1_STRING_length(const ASN1_STRING *x);
  void ASN1_STRING_length_set(ASN1_STRING *x, int n);
  int ASN1_STRING_type(const ASN1_STRING *x);
  unsigned char *ASN1_STRING_data(ASN1_STRING *x) __attribute__((deprecated));
  const unsigned char *ASN1_STRING_get0_data(const ASN1_STRING *x);
  ASN1_BIT_STRING *ASN1_BIT_STRING_new(void);
  void ASN1_BIT_STRING_free(ASN1_BIT_STRING *a);
  ASN1_BIT_STRING *d2i_ASN1_BIT_STRING(ASN1_BIT_STRING **a, const unsigned char **in, long len);
  int i2d_ASN1_BIT_STRING(ASN1_BIT_STRING *a, unsigned char **out);
  extern const ASN1_ITEM ASN1_BIT_STRING_it;
  int ASN1_BIT_STRING_set(ASN1_BIT_STRING *a, unsigned char *d, int length);
  int ASN1_BIT_STRING_set_bit(ASN1_BIT_STRING *a, int n, int value);
  int ASN1_BIT_STRING_get_bit(const ASN1_BIT_STRING *a, int n);
  int ASN1_BIT_STRING_check(const ASN1_BIT_STRING *a,
                            const unsigned char *flags, int flags_len);
  int ASN1_BIT_STRING_name_print(BIO *out, ASN1_BIT_STRING *bs,
                                 BIT_STRING_BITNAME *tbl, int indent);
  int ASN1_BIT_STRING_num_asc(const char *name, BIT_STRING_BITNAME *tbl);
  int ASN1_BIT_STRING_set_asc(ASN1_BIT_STRING *bs, const char *name, int value,
                              BIT_STRING_BITNAME *tbl);
  ASN1_INTEGER *ASN1_INTEGER_new(void);
  void ASN1_INTEGER_free(ASN1_INTEGER *a);
  ASN1_INTEGER *d2i_ASN1_INTEGER(ASN1_INTEGER **a, const unsigned char **in, long len);
  int i2d_ASN1_INTEGER(ASN1_INTEGER *a, unsigned char **out);
  extern const ASN1_ITEM ASN1_INTEGER_it;
  ASN1_INTEGER *d2i_ASN1_UINTEGER(ASN1_INTEGER **a, const unsigned char **pp,
                                  long length);
  ASN1_INTEGER *ASN1_INTEGER_dup(const ASN1_INTEGER *x);
  int ASN1_INTEGER_cmp(const ASN1_INTEGER *x, const ASN1_INTEGER *y);
  ASN1_ENUMERATED *ASN1_ENUMERATED_new(void);
  void ASN1_ENUMERATED_free(ASN1_ENUMERATED *a);
  ASN1_ENUMERATED *d2i_ASN1_ENUMERATED(ASN1_ENUMERATED **a, const unsigned char **in, long len);
  int i2d_ASN1_ENUMERATED(ASN1_ENUMERATED *a, unsigned char **out);
  extern const ASN1_ITEM ASN1_ENUMERATED_it;
  int ASN1_UTCTIME_check(const ASN1_UTCTIME *a);
  ASN1_UTCTIME *ASN1_UTCTIME_set(ASN1_UTCTIME *s, time_t t);
  ASN1_UTCTIME *ASN1_UTCTIME_adj(ASN1_UTCTIME *s, time_t t,
                                 int offset_day, long offset_sec);
  int ASN1_UTCTIME_set_string(ASN1_UTCTIME *s, const char *str);
  int ASN1_UTCTIME_cmp_time_t(const ASN1_UTCTIME *s, time_t t);
  int ASN1_GENERALIZEDTIME_check(const ASN1_GENERALIZEDTIME *a);
  ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_set(ASN1_GENERALIZEDTIME *s,
                                                 time_t t);
  ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_adj(ASN1_GENERALIZEDTIME *s,
                                                 time_t t, int offset_day,
                                                 long offset_sec);
  int ASN1_GENERALIZEDTIME_set_string(ASN1_GENERALIZEDTIME *s, const char *str);
  int ASN1_TIME_diff(int *pday, int *psec,
                     const ASN1_TIME *from, const ASN1_TIME *to);
  ASN1_OCTET_STRING *ASN1_OCTET_STRING_new(void);
  void ASN1_OCTET_STRING_free(ASN1_OCTET_STRING *a);
  ASN1_OCTET_STRING *d2i_ASN1_OCTET_STRING(ASN1_OCTET_STRING **a, const unsigned char **in, long len);
  int i2d_ASN1_OCTET_STRING(ASN1_OCTET_STRING *a, unsigned char **out);
  extern const ASN1_ITEM ASN1_OCTET_STRING_it;
  ASN1_OCTET_STRING *ASN1_OCTET_STRING_dup(const ASN1_OCTET_STRING *a);
  int ASN1_OCTET_STRING_cmp(const ASN1_OCTET_STRING *a,
                            const ASN1_OCTET_STRING *b);
  int ASN1_OCTET_STRING_set(ASN1_OCTET_STRING *str, const unsigned char *data,
                            int len);
  ASN1_VISIBLESTRING *ASN1_VISIBLESTRING_new(void);
  void ASN1_VISIBLESTRING_free(ASN1_VISIBLESTRING *a);
  ASN1_VISIBLESTRING *d2i_ASN1_VISIBLESTRING(ASN1_VISIBLESTRING **a, const unsigned char **in, long len);
  int i2d_ASN1_VISIBLESTRING(ASN1_VISIBLESTRING *a, unsigned char **out);
  extern const ASN1_ITEM ASN1_VISIBLESTRING_it;
  ASN1_UNIVERSALSTRING *ASN1_UNIVERSALSTRING_new(void);
  void ASN1_UNIVERSALSTRING_free(ASN1_UNIVERSALSTRING *a);
  ASN1_UNIVERSALSTRING *d2i_ASN1_UNIVERSALSTRING(ASN1_UNIVERSALSTRING **a, const unsigned char **in, long len);
  int i2d_ASN1_UNIVERSALSTRING(ASN1_UNIVERSALSTRING *a, unsigned char **out);
  extern const ASN1_ITEM ASN1_UNIVERSALSTRING_it;
  ASN1_UTF8STRING *ASN1_UTF8STRING_new(void);
  void ASN1_UTF8STRING_free(ASN1_UTF8STRING *a);
  ASN1_UTF8STRING *d2i_ASN1_UTF8STRING(ASN1_UTF8STRING **a, const unsigned char **in, long len);
  int i2d_ASN1_UTF8STRING(ASN1_UTF8STRING *a, unsigned char **out);
  extern const ASN1_ITEM ASN1_UTF8STRING_it;
  ASN1_NULL *ASN1_NULL_new(void);
  void ASN1_NULL_free(ASN1_NULL *a);
  ASN1_NULL *d2i_ASN1_NULL(ASN1_NULL **a, const unsigned char **in, long len);
  int i2d_ASN1_NULL(ASN1_NULL *a, unsigned char **out);
  extern const ASN1_ITEM ASN1_NULL_it;
  ASN1_BMPSTRING *ASN1_BMPSTRING_new(void);
  void ASN1_BMPSTRING_free(ASN1_BMPSTRING *a);
  ASN1_BMPSTRING *d2i_ASN1_BMPSTRING(ASN1_BMPSTRING **a, const unsigned char **in, long len);
  int i2d_ASN1_BMPSTRING(ASN1_BMPSTRING *a, unsigned char **out);
  extern const ASN1_ITEM ASN1_BMPSTRING_it;
  int UTF8_getc(const unsigned char *str, int len, unsigned long *val);
  int UTF8_putc(unsigned char *str, int len, unsigned long value);
  ASN1_STRING *ASN1_PRINTABLE_new(void);
  void ASN1_PRINTABLE_free(ASN1_STRING *a);
  ASN1_STRING *d2i_ASN1_PRINTABLE(ASN1_STRING **a, const unsigned char **in, long len);
  int i2d_ASN1_PRINTABLE(ASN1_STRING *a, unsigned char **out);
  extern const ASN1_ITEM ASN1_PRINTABLE_it;
  ASN1_STRING *DIRECTORYSTRING_new(void);
  void DIRECTORYSTRING_free(ASN1_STRING *a);
  ASN1_STRING *d2i_DIRECTORYSTRING(ASN1_STRING **a, const unsigned char **in, long len);
  int i2d_DIRECTORYSTRING(ASN1_STRING *a, unsigned char **out);
  extern const ASN1_ITEM DIRECTORYSTRING_it;
  ASN1_STRING *DISPLAYTEXT_new(void);
  void DISPLAYTEXT_free(ASN1_STRING *a);
  ASN1_STRING *d2i_DISPLAYTEXT(ASN1_STRING **a, const unsigned char **in, long len);
  int i2d_DISPLAYTEXT(ASN1_STRING *a, unsigned char **out);
  extern const ASN1_ITEM DISPLAYTEXT_it;
  ASN1_PRINTABLESTRING *ASN1_PRINTABLESTRING_new(void);
  void ASN1_PRINTABLESTRING_free(ASN1_PRINTABLESTRING *a);
  ASN1_PRINTABLESTRING *d2i_ASN1_PRINTABLESTRING(ASN1_PRINTABLESTRING **a, const unsigned char **in, long len);
  int i2d_ASN1_PRINTABLESTRING(ASN1_PRINTABLESTRING *a, unsigned char **out);
  extern const ASN1_ITEM ASN1_PRINTABLESTRING_it;
  ASN1_T61STRING *ASN1_T61STRING_new(void);
  void ASN1_T61STRING_free(ASN1_T61STRING *a);
  ASN1_T61STRING *d2i_ASN1_T61STRING(ASN1_T61STRING **a, const unsigned char **in, long len);
  int i2d_ASN1_T61STRING(ASN1_T61STRING *a, unsigned char **out);
  extern const ASN1_ITEM ASN1_T61STRING_it;
  ASN1_IA5STRING *ASN1_IA5STRING_new(void);
  void ASN1_IA5STRING_free(ASN1_IA5STRING *a);
  ASN1_IA5STRING *d2i_ASN1_IA5STRING(ASN1_IA5STRING **a, const unsigned char **in, long len);
  int i2d_ASN1_IA5STRING(ASN1_IA5STRING *a, unsigned char **out);
  extern const ASN1_ITEM ASN1_IA5STRING_it;
  ASN1_GENERALSTRING *ASN1_GENERALSTRING_new(void);
  void ASN1_GENERALSTRING_free(ASN1_GENERALSTRING *a);
  ASN1_GENERALSTRING *d2i_ASN1_GENERALSTRING(ASN1_GENERALSTRING **a, const unsigned char **in, long len);
  int i2d_ASN1_GENERALSTRING(ASN1_GENERALSTRING *a, unsigned char **out);
  extern const ASN1_ITEM ASN1_GENERALSTRING_it;
  ASN1_UTCTIME *ASN1_UTCTIME_new(void);
  void ASN1_UTCTIME_free(ASN1_UTCTIME *a);
  ASN1_UTCTIME *d2i_ASN1_UTCTIME(ASN1_UTCTIME **a, const unsigned char **in, long len);
  int i2d_ASN1_UTCTIME(ASN1_UTCTIME *a, unsigned char **out);
  extern const ASN1_ITEM ASN1_UTCTIME_it;
  ASN1_GENERALIZEDTIME *ASN1_GENERALIZEDTIME_new(void);
  void ASN1_GENERALIZEDTIME_free(ASN1_GENERALIZEDTIME *a);
  ASN1_GENERALIZEDTIME *d2i_ASN1_GENERALIZEDTIME(ASN1_GENERALIZEDTIME **a, const unsigned char **in, long len);
  int i2d_ASN1_GENERALIZEDTIME(ASN1_GENERALIZEDTIME *a, unsigned char **out);
  extern const ASN1_ITEM ASN1_GENERALIZEDTIME_it;
  ASN1_TIME *ASN1_TIME_new(void);
  void ASN1_TIME_free(ASN1_TIME *a);
  ASN1_TIME *d2i_ASN1_TIME(ASN1_TIME **a, const unsigned char **in, long len);
  int i2d_ASN1_TIME(ASN1_TIME *a, unsigned char **out);
  extern const ASN1_ITEM ASN1_TIME_it;
  extern const ASN1_ITEM ASN1_OCTET_STRING_NDEF_it;
  ASN1_TIME *ASN1_TIME_set(ASN1_TIME *s, time_t t);
  ASN1_TIME *ASN1_TIME_adj(ASN1_TIME *s, time_t t,
                           int offset_day, long offset_sec);
  int ASN1_TIME_check(const ASN1_TIME *t);
  ASN1_GENERALIZEDTIME *ASN1_TIME_to_generalizedtime(const ASN1_TIME *t,
                                                     ASN1_GENERALIZEDTIME **out);
  int ASN1_TIME_set_string(ASN1_TIME *s, const char *str);
  int ASN1_TIME_set_string_X509(ASN1_TIME *s, const char *str);
  int ASN1_TIME_to_tm(const ASN1_TIME *s, struct tm *tm);
  int ASN1_TIME_normalize(ASN1_TIME *s);
  int ASN1_TIME_cmp_time_t(const ASN1_TIME *s, time_t t);
  int ASN1_TIME_compare(const ASN1_TIME *a, const ASN1_TIME *b);
  int i2a_ASN1_INTEGER(BIO *bp, const ASN1_INTEGER *a);
  int a2i_ASN1_INTEGER(BIO *bp, ASN1_INTEGER *bs, char *buf, int size);
  int i2a_ASN1_ENUMERATED(BIO *bp, const ASN1_ENUMERATED *a);
  int a2i_ASN1_ENUMERATED(BIO *bp, ASN1_ENUMERATED *bs, char *buf, int size);
  int i2a_ASN1_OBJECT(BIO *bp, const ASN1_OBJECT *a);
  int a2i_ASN1_STRING(BIO *bp, ASN1_STRING *bs, char *buf, int size);
  int i2a_ASN1_STRING(BIO *bp, const ASN1_STRING *a, int type);
  int i2t_ASN1_OBJECT(char *buf, int buf_len, const ASN1_OBJECT *a);
  int a2d_ASN1_OBJECT(unsigned char *out, int olen, const char *buf, int num);
  ASN1_OBJECT *ASN1_OBJECT_create(int nid, unsigned char *data, int len,
                                  const char *sn, const char *ln);
  int ASN1_INTEGER_get_int64(int64_t *pr, const ASN1_INTEGER *a);
  int ASN1_INTEGER_set_int64(ASN1_INTEGER *a, int64_t r);
  int ASN1_INTEGER_get_uint64(uint64_t *pr, const ASN1_INTEGER *a);
  int ASN1_INTEGER_set_uint64(ASN1_INTEGER *a, uint64_t r);
  int ASN1_INTEGER_set(ASN1_INTEGER *a, long v);
  long ASN1_INTEGER_get(const ASN1_INTEGER *a);
  ASN1_INTEGER *BN_to_ASN1_INTEGER(const BIGNUM *bn, ASN1_INTEGER *ai);
  BIGNUM *ASN1_INTEGER_to_BN(const ASN1_INTEGER *ai, BIGNUM *bn);
  int ASN1_ENUMERATED_get_int64(int64_t *pr, const ASN1_ENUMERATED *a);
  int ASN1_ENUMERATED_set_int64(ASN1_ENUMERATED *a, int64_t r);
  int ASN1_ENUMERATED_set(ASN1_ENUMERATED *a, long v);
  long ASN1_ENUMERATED_get(const ASN1_ENUMERATED *a);
  ASN1_ENUMERATED *BN_to_ASN1_ENUMERATED(const BIGNUM *bn, ASN1_ENUMERATED *ai);
  BIGNUM *ASN1_ENUMERATED_to_BN(const ASN1_ENUMERATED *ai, BIGNUM *bn);
  int ASN1_PRINTABLE_type(const unsigned char *s, int max);
  unsigned long ASN1_tag2bit(int tag);
  int ASN1_get_object(const unsigned char **pp, long *plength, int *ptag,
                      int *pclass, long omax);
  int ASN1_check_infinite_end(unsigned char **p, long len);
  int ASN1_const_check_infinite_end(const unsigned char **p, long len);
  void ASN1_put_object(unsigned char **pp, int constructed, int length,
                       int tag, int xclass);
  int ASN1_put_eoc(unsigned char **pp);
  int ASN1_object_size(int constructed, int length, int tag);
  void *ASN1_dup(i2d_of_void *i2d, d2i_of_void *d2i, void *x);
  void *ASN1_item_dup(const ASN1_ITEM *it, void *x);
  void *ASN1_d2i_fp(void *(*xnew)(void), d2i_of_void *d2i, FILE *in, void **x);
  void *ASN1_item_d2i_fp(const ASN1_ITEM *it, FILE *in, void *x);
  int ASN1_i2d_fp(i2d_of_void *i2d, FILE *out, void *x);
  int ASN1_item_i2d_fp(const ASN1_ITEM *it, FILE *out, void *x);
  int ASN1_STRING_print_ex_fp(FILE *fp, const ASN1_STRING *str, unsigned long flags);
  int ASN1_STRING_to_UTF8(unsigned char **out, const ASN1_STRING *in);
  void *ASN1_d2i_bio(void *(*xnew)(void), d2i_of_void *d2i, BIO *in, void **x);
  void *ASN1_item_d2i_bio(const ASN1_ITEM *it, BIO *in, void *x);
  int ASN1_i2d_bio(i2d_of_void *i2d, BIO *out, unsigned char *x);
  int ASN1_item_i2d_bio(const ASN1_ITEM *it, BIO *out, void *x);
  int ASN1_UTCTIME_print(BIO *fp, const ASN1_UTCTIME *a);
  int ASN1_GENERALIZEDTIME_print(BIO *fp, const ASN1_GENERALIZEDTIME *a);
  int ASN1_TIME_print(BIO *fp, const ASN1_TIME *a);
  int ASN1_STRING_print(BIO *bp, const ASN1_STRING *v);
  int ASN1_STRING_print_ex(BIO *out, const ASN1_STRING *str, unsigned long flags);
  int ASN1_buf_print(BIO *bp, const unsigned char *buf, size_t buflen, int off);
  int ASN1_bn_print(BIO *bp, const char *number, const BIGNUM *num,
                    unsigned char *buf, int off);
  int ASN1_parse(BIO *bp, const unsigned char *pp, long len, int indent);
  int ASN1_parse_dump(BIO *bp, const unsigned char *pp, long len, int indent,
                      int dump);
  const char *ASN1_tag2str(int tag);
  int ASN1_UNIVERSALSTRING_to_string(ASN1_UNIVERSALSTRING *s);
  int ASN1_TYPE_set_octetstring(ASN1_TYPE *a, unsigned char *data, int len);
  int ASN1_TYPE_get_octetstring(const ASN1_TYPE *a, unsigned char *data, int max_len);
  int ASN1_TYPE_set_int_octetstring(ASN1_TYPE *a, long num,
                                    unsigned char *data, int len);
  int ASN1_TYPE_get_int_octetstring(const ASN1_TYPE *a, long *num,
                                    unsigned char *data, int max_len);
  void *ASN1_item_unpack(const ASN1_STRING *oct, const ASN1_ITEM *it);
  ASN1_STRING *ASN1_item_pack(void *obj, const ASN1_ITEM *it,
                              ASN1_OCTET_STRING **oct);
  void ASN1_STRING_set_default_mask(unsigned long mask);
  int ASN1_STRING_set_default_mask_asc(const char *p);
  unsigned long ASN1_STRING_get_default_mask(void);
  int ASN1_mbstring_copy(ASN1_STRING **out, const unsigned char *in, int len,
                         int inform, unsigned long mask);
  int ASN1_mbstring_ncopy(ASN1_STRING **out, const unsigned char *in, int len,
                          int inform, unsigned long mask,
                          long minsize, long maxsize);
  ASN1_STRING *ASN1_STRING_set_by_NID(ASN1_STRING **out,
                                      const unsigned char *in, int inlen,
                                      int inform, int nid);
  ASN1_STRING_TABLE *ASN1_STRING_TABLE_get(int nid);
  int ASN1_STRING_TABLE_add(int, long, long, unsigned long, unsigned long);
  void ASN1_STRING_TABLE_cleanup(void);
  ASN1_VALUE *ASN1_item_new(const ASN1_ITEM *it);
  void ASN1_item_free(ASN1_VALUE *val, const ASN1_ITEM *it);
  ASN1_VALUE *ASN1_item_d2i(ASN1_VALUE **val, const unsigned char **in,
                            long len, const ASN1_ITEM *it);
  int ASN1_item_i2d(ASN1_VALUE *val, unsigned char **out, const ASN1_ITEM *it);
  int ASN1_item_ndef_i2d(ASN1_VALUE *val, unsigned char **out,
                         const ASN1_ITEM *it);
  void ASN1_add_oid_module(void);
  void ASN1_add_stable_module(void);
  ASN1_TYPE *ASN1_generate_nconf(const char *str, CONF *nconf);
  ASN1_TYPE *ASN1_generate_v3(const char *str, X509V3_CTX *cnf);
  int ASN1_str2mask(const char *str, unsigned long *pmask);
  int ASN1_item_print(BIO *out, ASN1_VALUE *ifld, int indent,
                      const ASN1_ITEM *it, const ASN1_PCTX *pctx);
  ASN1_PCTX *ASN1_PCTX_new(void);
  void ASN1_PCTX_free(ASN1_PCTX *p);
  unsigned long ASN1_PCTX_get_flags(const ASN1_PCTX *p);
  void ASN1_PCTX_set_flags(ASN1_PCTX *p, unsigned long flags);
  unsigned long ASN1_PCTX_get_nm_flags(const ASN1_PCTX *p);
  void ASN1_PCTX_set_nm_flags(ASN1_PCTX *p, unsigned long flags);
  unsigned long ASN1_PCTX_get_cert_flags(const ASN1_PCTX *p);
  void ASN1_PCTX_set_cert_flags(ASN1_PCTX *p, unsigned long flags);
  unsigned long ASN1_PCTX_get_oid_flags(const ASN1_PCTX *p);
  void ASN1_PCTX_set_oid_flags(ASN1_PCTX *p, unsigned long flags);
  unsigned long ASN1_PCTX_get_str_flags(const ASN1_PCTX *p);
  void ASN1_PCTX_set_str_flags(ASN1_PCTX *p, unsigned long flags);
  ASN1_SCTX *ASN1_SCTX_new(int (*scan_cb)(ASN1_SCTX *ctx));
  void ASN1_SCTX_free(ASN1_SCTX *p);
  const ASN1_ITEM *ASN1_SCTX_get_item(ASN1_SCTX *p);
  const ASN1_TEMPLATE *ASN1_SCTX_get_template(ASN1_SCTX *p);
  unsigned long ASN1_SCTX_get_flags(ASN1_SCTX *p);
  void ASN1_SCTX_set_app_data(ASN1_SCTX *p, void *data);
  void *ASN1_SCTX_get_app_data(ASN1_SCTX *p);
  const BIO_METHOD *BIO_f_asn1(void);
  BIO *BIO_new_NDEF(BIO *out, ASN1_VALUE *val, const ASN1_ITEM *it);
  int i2d_ASN1_bio_stream(BIO *out, ASN1_VALUE *val, BIO *in, int flags,
                          const ASN1_ITEM *it);
  int PEM_write_bio_ASN1_stream(BIO *out, ASN1_VALUE *val, BIO *in, int flags,
                                const char *hdr, const ASN1_ITEM *it);
  int SMIME_write_ASN1(BIO *bio, ASN1_VALUE *val, BIO *data, int flags,
                       int ctype_nid, int econt_nid,
                       struct stack_st_X509_ALGOR *mdalgs, const ASN1_ITEM *it);
  ASN1_VALUE *SMIME_read_ASN1(BIO *bio, BIO **bcont, const ASN1_ITEM *it);
  int SMIME_crlf_copy(BIO *in, BIO *out, int flags);
  int SMIME_text(BIO *in, BIO *out);
  const ASN1_ITEM *ASN1_ITEM_lookup(const char *name);
  const ASN1_ITEM *ASN1_ITEM_get(size_t i);
}
extern "C" int ERR_load_OBJ_strings(void);
extern "C"
{
  typedef struct obj_name_st
  {
    int type;
    int alias;
    const char *name;
    const char *data;
  } OBJ_NAME;
  int OBJ_NAME_init(void);
  int OBJ_NAME_new_index(unsigned long (*hash_func)(const char *),
                         int (*cmp_func)(const char *, const char *),
                         void (*free_func)(const char *, int, const char *));
  const char *OBJ_NAME_get(const char *name, int type);
  int OBJ_NAME_add(const char *name, int type, const char *data);
  int OBJ_NAME_remove(const char *name, int type);
  void OBJ_NAME_cleanup(int type);
  void OBJ_NAME_do_all(int type, void (*fn)(const OBJ_NAME *, void *arg),
                       void *arg);
  void OBJ_NAME_do_all_sorted(int type,
                              void (*fn)(const OBJ_NAME *, void *arg),
                              void *arg);
  ASN1_OBJECT *OBJ_dup(const ASN1_OBJECT *o);
  ASN1_OBJECT *OBJ_nid2obj(int n);
  const char *OBJ_nid2ln(int n);
  const char *OBJ_nid2sn(int n);
  int OBJ_obj2nid(const ASN1_OBJECT *o);
  ASN1_OBJECT *OBJ_txt2obj(const char *s, int no_name);
  int OBJ_obj2txt(char *buf, int buf_len, const ASN1_OBJECT *a, int no_name);
  int OBJ_txt2nid(const char *s);
  int OBJ_ln2nid(const char *s);
  int OBJ_sn2nid(const char *s);
  int OBJ_cmp(const ASN1_OBJECT *a, const ASN1_OBJECT *b);
  const void *OBJ_bsearch_(const void *key, const void *base, int num, int size,
                           int (*cmp)(const void *, const void *));
  const void *OBJ_bsearch_ex_(const void *key, const void *base, int num,
                              int size,
                              int (*cmp)(const void *, const void *),
                              int flags);
  int OBJ_new_nid(int num);
  int OBJ_add_object(const ASN1_OBJECT *obj);
  int OBJ_create(const char *oid, const char *sn, const char *ln);
  int OBJ_create_objects(BIO *in);
  size_t OBJ_length(const ASN1_OBJECT *obj);
  const unsigned char *OBJ_get0_data(const ASN1_OBJECT *obj);
  int OBJ_find_sigid_algs(int signid, int *pdig_nid, int *ppkey_nid);
  int OBJ_find_sigid_by_algs(int *psignid, int dig_nid, int pkey_nid);
  int OBJ_add_sigid(int signid, int dig_id, int pkey_id);
  void OBJ_sigid_free(void);
}
extern "C"
{
  EVP_MD *EVP_MD_meth_new(int md_type, int pkey_type);
  EVP_MD *EVP_MD_meth_dup(const EVP_MD *md);
  void EVP_MD_meth_free(EVP_MD *md);
  int EVP_MD_meth_set_input_blocksize(EVP_MD *md, int blocksize);
  int EVP_MD_meth_set_result_size(EVP_MD *md, int resultsize);
  int EVP_MD_meth_set_app_datasize(EVP_MD *md, int datasize);
  int EVP_MD_meth_set_flags(EVP_MD *md, unsigned long flags);
  int EVP_MD_meth_set_init(EVP_MD *md, int (*init)(EVP_MD_CTX *ctx));
  int EVP_MD_meth_set_update(EVP_MD *md, int (*update)(EVP_MD_CTX *ctx,
                                                       const void *data,
                                                       size_t count));
  int EVP_MD_meth_set_final(EVP_MD *md, int (*final)(EVP_MD_CTX *ctx,
                                                     unsigned char *md));
  int EVP_MD_meth_set_copy(EVP_MD *md, int (*copy)(EVP_MD_CTX *to,
                                                   const EVP_MD_CTX *from));
  int EVP_MD_meth_set_cleanup(EVP_MD *md, int (*cleanup)(EVP_MD_CTX *ctx));
  int EVP_MD_meth_set_ctrl(EVP_MD *md, int (*ctrl)(EVP_MD_CTX *ctx, int cmd,
                                                   int p1, void *p2));
  int EVP_MD_meth_get_input_blocksize(const EVP_MD *md);
  int EVP_MD_meth_get_result_size(const EVP_MD *md);
  int EVP_MD_meth_get_app_datasize(const EVP_MD *md);
  unsigned long EVP_MD_meth_get_flags(const EVP_MD *md);
  int (*EVP_MD_meth_get_init(const EVP_MD *md))(EVP_MD_CTX *ctx);
  int (*EVP_MD_meth_get_update(const EVP_MD *md))(EVP_MD_CTX *ctx,
                                                  const void *data,
                                                  size_t count);
  int (*EVP_MD_meth_get_final(const EVP_MD *md))(EVP_MD_CTX *ctx,
                                                 unsigned char *md);
  int (*EVP_MD_meth_get_copy(const EVP_MD *md))(EVP_MD_CTX *to,
                                                const EVP_MD_CTX *from);
  int (*EVP_MD_meth_get_cleanup(const EVP_MD *md))(EVP_MD_CTX *ctx);
  int (*EVP_MD_meth_get_ctrl(const EVP_MD *md))(EVP_MD_CTX *ctx, int cmd,
                                                int p1, void *p2);
  EVP_CIPHER *EVP_CIPHER_meth_new(int cipher_type, int block_size, int key_len);
  EVP_CIPHER *EVP_CIPHER_meth_dup(const EVP_CIPHER *cipher);
  void EVP_CIPHER_meth_free(EVP_CIPHER *cipher);
  int EVP_CIPHER_meth_set_iv_length(EVP_CIPHER *cipher, int iv_len);
  int EVP_CIPHER_meth_set_flags(EVP_CIPHER *cipher, unsigned long flags);
  int EVP_CIPHER_meth_set_impl_ctx_size(EVP_CIPHER *cipher, int ctx_size);
  int EVP_CIPHER_meth_set_init(EVP_CIPHER *cipher,
                               int (*init)(EVP_CIPHER_CTX *ctx,
                                           const unsigned char *key,
                                           const unsigned char *iv,
                                           int enc));
  int EVP_CIPHER_meth_set_do_cipher(EVP_CIPHER *cipher,
                                    int (*do_cipher)(EVP_CIPHER_CTX *ctx,
                                                     unsigned char *out,
                                                     const unsigned char *in,
                                                     size_t inl));
  int EVP_CIPHER_meth_set_cleanup(EVP_CIPHER *cipher,
                                  int (*cleanup)(EVP_CIPHER_CTX *));
  int EVP_CIPHER_meth_set_set_asn1_params(EVP_CIPHER *cipher,
                                          int (*set_asn1_parameters)(EVP_CIPHER_CTX *,
                                                                     ASN1_TYPE *));
  int EVP_CIPHER_meth_set_get_asn1_params(EVP_CIPHER *cipher,
                                          int (*get_asn1_parameters)(EVP_CIPHER_CTX *,
                                                                     ASN1_TYPE *));
  int EVP_CIPHER_meth_set_ctrl(EVP_CIPHER *cipher,
                               int (*ctrl)(EVP_CIPHER_CTX *, int type,
                                           int arg, void *ptr));
  int (*EVP_CIPHER_meth_get_init(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *ctx,
                                                            const unsigned char *key,
                                                            const unsigned char *iv,
                                                            int enc);
  int (*EVP_CIPHER_meth_get_do_cipher(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *ctx,
                                                                 unsigned char *out,
                                                                 const unsigned char *in,
                                                                 size_t inl);
  int (*EVP_CIPHER_meth_get_cleanup(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *);
  int (*EVP_CIPHER_meth_get_set_asn1_params(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *,
                                                                       ASN1_TYPE *);
  int (*EVP_CIPHER_meth_get_get_asn1_params(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *,
                                                                       ASN1_TYPE *);
  int (*EVP_CIPHER_meth_get_ctrl(const EVP_CIPHER *cipher))(EVP_CIPHER_CTX *,
                                                            int type, int arg,
                                                            void *ptr);
  typedef struct
  {
    unsigned char *out;
    const unsigned char *inp;
    size_t len;
    unsigned int interleave;
  } EVP_CTRL_TLS1_1_MULTIBLOCK_PARAM;
  typedef struct evp_cipher_info_st
  {
    const EVP_CIPHER *cipher;
    unsigned char iv[16];
  } EVP_CIPHER_INFO;
  typedef int(EVP_PBE_KEYGEN)(EVP_CIPHER_CTX *ctx, const char *pass,
                              int passlen, ASN1_TYPE *param,
                              const EVP_CIPHER *cipher, const EVP_MD *md,
                              int en_de);
  int EVP_MD_type(const EVP_MD *md);
  int EVP_MD_pkey_type(const EVP_MD *md);
  int EVP_MD_size(const EVP_MD *md);
  int EVP_MD_block_size(const EVP_MD *md);
  unsigned long EVP_MD_flags(const EVP_MD *md);
  const EVP_MD *EVP_MD_CTX_md(const EVP_MD_CTX *ctx);
  int (*EVP_MD_CTX_update_fn(EVP_MD_CTX *ctx))(EVP_MD_CTX *ctx,
                                               const void *data, size_t count);
  void EVP_MD_CTX_set_update_fn(EVP_MD_CTX *ctx,
                                int (*update)(EVP_MD_CTX *ctx,
                                              const void *data, size_t count));
  EVP_PKEY_CTX *EVP_MD_CTX_pkey_ctx(const EVP_MD_CTX *ctx);
  void EVP_MD_CTX_set_pkey_ctx(EVP_MD_CTX *ctx, EVP_PKEY_CTX *pctx);
  void *EVP_MD_CTX_md_data(const EVP_MD_CTX *ctx);
  int EVP_CIPHER_nid(const EVP_CIPHER *cipher);
  int EVP_CIPHER_block_size(const EVP_CIPHER *cipher);
  int EVP_CIPHER_impl_ctx_size(const EVP_CIPHER *cipher);
  int EVP_CIPHER_key_length(const EVP_CIPHER *cipher);
  int EVP_CIPHER_iv_length(const EVP_CIPHER *cipher);
  unsigned long EVP_CIPHER_flags(const EVP_CIPHER *cipher);
  const EVP_CIPHER *EVP_CIPHER_CTX_cipher(const EVP_CIPHER_CTX *ctx);
  int EVP_CIPHER_CTX_encrypting(const EVP_CIPHER_CTX *ctx);
  int EVP_CIPHER_CTX_nid(const EVP_CIPHER_CTX *ctx);
  int EVP_CIPHER_CTX_block_size(const EVP_CIPHER_CTX *ctx);
  int EVP_CIPHER_CTX_key_length(const EVP_CIPHER_CTX *ctx);
  int EVP_CIPHER_CTX_iv_length(const EVP_CIPHER_CTX *ctx);
  const unsigned char *EVP_CIPHER_CTX_iv(const EVP_CIPHER_CTX *ctx);
  const unsigned char *EVP_CIPHER_CTX_original_iv(const EVP_CIPHER_CTX *ctx);
  unsigned char *EVP_CIPHER_CTX_iv_noconst(EVP_CIPHER_CTX *ctx);
  unsigned char *EVP_CIPHER_CTX_buf_noconst(EVP_CIPHER_CTX *ctx);
  int EVP_CIPHER_CTX_num(const EVP_CIPHER_CTX *ctx);
  void EVP_CIPHER_CTX_set_num(EVP_CIPHER_CTX *ctx, int num);
  int EVP_CIPHER_CTX_copy(EVP_CIPHER_CTX *out, const EVP_CIPHER_CTX *in);
  void *EVP_CIPHER_CTX_get_app_data(const EVP_CIPHER_CTX *ctx);
  void EVP_CIPHER_CTX_set_app_data(EVP_CIPHER_CTX *ctx, void *data);
  void *EVP_CIPHER_CTX_get_cipher_data(const EVP_CIPHER_CTX *ctx);
  void *EVP_CIPHER_CTX_set_cipher_data(EVP_CIPHER_CTX *ctx, void *cipher_data);
  int EVP_Cipher(EVP_CIPHER_CTX *c,
                 unsigned char *out,
                 const unsigned char *in, unsigned int inl);
  int EVP_MD_CTX_ctrl(EVP_MD_CTX *ctx, int cmd, int p1, void *p2);
  EVP_MD_CTX *EVP_MD_CTX_new(void);
  int EVP_MD_CTX_reset(EVP_MD_CTX *ctx);
  void EVP_MD_CTX_free(EVP_MD_CTX *ctx);
  int EVP_MD_CTX_copy_ex(EVP_MD_CTX *out, const EVP_MD_CTX *in);
  void EVP_MD_CTX_set_flags(EVP_MD_CTX *ctx, int flags);
  void EVP_MD_CTX_clear_flags(EVP_MD_CTX *ctx, int flags);
  int EVP_MD_CTX_test_flags(const EVP_MD_CTX *ctx, int flags);
  int EVP_DigestInit_ex(EVP_MD_CTX *ctx, const EVP_MD *type,
                        ENGINE *impl);
  int EVP_DigestUpdate(EVP_MD_CTX *ctx, const void *d,
                       size_t cnt);
  int EVP_DigestFinal_ex(EVP_MD_CTX *ctx, unsigned char *md,
                         unsigned int *s);
  int EVP_Digest(const void *data, size_t count,
                 unsigned char *md, unsigned int *size,
                 const EVP_MD *type, ENGINE *impl);
  int EVP_MD_CTX_copy(EVP_MD_CTX *out, const EVP_MD_CTX *in);
  int EVP_DigestInit(EVP_MD_CTX *ctx, const EVP_MD *type);
  int EVP_DigestFinal(EVP_MD_CTX *ctx, unsigned char *md,
                      unsigned int *s);
  int EVP_DigestFinalXOF(EVP_MD_CTX *ctx, unsigned char *md,
                         size_t len);
  int EVP_read_pw_string(char *buf, int length, const char *prompt, int verify);
  int EVP_read_pw_string_min(char *buf, int minlen, int maxlen,
                             const char *prompt, int verify);
  void EVP_set_pw_prompt(const char *prompt);
  char *EVP_get_pw_prompt(void);
  int EVP_BytesToKey(const EVP_CIPHER *type, const EVP_MD *md,
                     const unsigned char *salt,
                     const unsigned char *data, int datal, int count,
                     unsigned char *key, unsigned char *iv);
  void EVP_CIPHER_CTX_set_flags(EVP_CIPHER_CTX *ctx, int flags);
  void EVP_CIPHER_CTX_clear_flags(EVP_CIPHER_CTX *ctx, int flags);
  int EVP_CIPHER_CTX_test_flags(const EVP_CIPHER_CTX *ctx, int flags);
  int EVP_EncryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
                      const unsigned char *key, const unsigned char *iv);
  int EVP_EncryptInit_ex(EVP_CIPHER_CTX *ctx,
                         const EVP_CIPHER *cipher, ENGINE *impl,
                         const unsigned char *key,
                         const unsigned char *iv);
  int EVP_EncryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
                        int *outl, const unsigned char *in, int inl);
  int EVP_EncryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *out,
                          int *outl);
  int EVP_EncryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *out,
                       int *outl);
  int EVP_DecryptInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
                      const unsigned char *key, const unsigned char *iv);
  int EVP_DecryptInit_ex(EVP_CIPHER_CTX *ctx,
                         const EVP_CIPHER *cipher, ENGINE *impl,
                         const unsigned char *key,
                         const unsigned char *iv);
  int EVP_DecryptUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
                        int *outl, const unsigned char *in, int inl);
  int EVP_DecryptFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,
                       int *outl);
  int EVP_DecryptFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,
                          int *outl);
  int EVP_CipherInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *cipher,
                     const unsigned char *key, const unsigned char *iv,
                     int enc);
  int EVP_CipherInit_ex(EVP_CIPHER_CTX *ctx,
                        const EVP_CIPHER *cipher, ENGINE *impl,
                        const unsigned char *key,
                        const unsigned char *iv, int enc);
  int EVP_CipherUpdate(EVP_CIPHER_CTX *ctx, unsigned char *out,
                       int *outl, const unsigned char *in, int inl);
  int EVP_CipherFinal(EVP_CIPHER_CTX *ctx, unsigned char *outm,
                      int *outl);
  int EVP_CipherFinal_ex(EVP_CIPHER_CTX *ctx, unsigned char *outm,
                         int *outl);
  int EVP_SignFinal(EVP_MD_CTX *ctx, unsigned char *md, unsigned int *s,
                    EVP_PKEY *pkey);
  int EVP_DigestSign(EVP_MD_CTX *ctx, unsigned char *sigret,
                     size_t *siglen, const unsigned char *tbs,
                     size_t tbslen);
  int EVP_VerifyFinal(EVP_MD_CTX *ctx, const unsigned char *sigbuf,
                      unsigned int siglen, EVP_PKEY *pkey);
  int EVP_DigestVerify(EVP_MD_CTX *ctx, const unsigned char *sigret,
                       size_t siglen, const unsigned char *tbs,
                       size_t tbslen);
  int EVP_DigestSignInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
                         const EVP_MD *type, ENGINE *e,
                         EVP_PKEY *pkey);
  int EVP_DigestSignFinal(EVP_MD_CTX *ctx, unsigned char *sigret,
                          size_t *siglen);
  int EVP_DigestVerifyInit(EVP_MD_CTX *ctx, EVP_PKEY_CTX **pctx,
                           const EVP_MD *type, ENGINE *e,
                           EVP_PKEY *pkey);
  int EVP_DigestVerifyFinal(EVP_MD_CTX *ctx, const unsigned char *sig,
                            size_t siglen);
  int EVP_OpenInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
                   const unsigned char *ek, int ekl,
                   const unsigned char *iv, EVP_PKEY *priv);
  int EVP_OpenFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);
  int EVP_SealInit(EVP_CIPHER_CTX *ctx, const EVP_CIPHER *type,
                   unsigned char **ek, int *ekl, unsigned char *iv,
                   EVP_PKEY **pubk, int npubk);
  int EVP_SealFinal(EVP_CIPHER_CTX *ctx, unsigned char *out, int *outl);
  EVP_ENCODE_CTX *EVP_ENCODE_CTX_new(void);
  void EVP_ENCODE_CTX_free(EVP_ENCODE_CTX *ctx);
  int EVP_ENCODE_CTX_copy(EVP_ENCODE_CTX *dctx, EVP_ENCODE_CTX *sctx);
  int EVP_ENCODE_CTX_num(EVP_ENCODE_CTX *ctx);
  void EVP_EncodeInit(EVP_ENCODE_CTX *ctx);
  int EVP_EncodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,
                       const unsigned char *in, int inl);
  void EVP_EncodeFinal(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl);
  int EVP_EncodeBlock(unsigned char *t, const unsigned char *f, int n);
  void EVP_DecodeInit(EVP_ENCODE_CTX *ctx);
  int EVP_DecodeUpdate(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl,
                       const unsigned char *in, int inl);
  int EVP_DecodeFinal(EVP_ENCODE_CTX *ctx, unsigned char *out, int *outl);
  int EVP_DecodeBlock(unsigned char *t, const unsigned char *f, int n);
  EVP_CIPHER_CTX *EVP_CIPHER_CTX_new(void);
  int EVP_CIPHER_CTX_reset(EVP_CIPHER_CTX *c);
  void EVP_CIPHER_CTX_free(EVP_CIPHER_CTX *c);
  int EVP_CIPHER_CTX_set_key_length(EVP_CIPHER_CTX *x, int keylen);
  int EVP_CIPHER_CTX_set_padding(EVP_CIPHER_CTX *c, int pad);
  int EVP_CIPHER_CTX_ctrl(EVP_CIPHER_CTX *ctx, int type, int arg, void *ptr);
  int EVP_CIPHER_CTX_rand_key(EVP_CIPHER_CTX *ctx, unsigned char *key);
  const BIO_METHOD *BIO_f_md(void);
  const BIO_METHOD *BIO_f_base64(void);
  const BIO_METHOD *BIO_f_cipher(void);
  const BIO_METHOD *BIO_f_reliable(void);
  int BIO_set_cipher(BIO *b, const EVP_CIPHER *c, const unsigned char *k,
                     const unsigned char *i, int enc);
  const EVP_MD *EVP_md_null(void);
  const EVP_MD *EVP_md4(void);
  const EVP_MD *EVP_md5(void);
  const EVP_MD *EVP_md5_sha1(void);
  const EVP_MD *EVP_blake2b512(void);
  const EVP_MD *EVP_blake2s256(void);
  const EVP_MD *EVP_sha1(void);
  const EVP_MD *EVP_sha224(void);
  const EVP_MD *EVP_sha256(void);
  const EVP_MD *EVP_sha384(void);
  const EVP_MD *EVP_sha512(void);
  const EVP_MD *EVP_sha512_224(void);
  const EVP_MD *EVP_sha512_256(void);
  const EVP_MD *EVP_sha3_224(void);
  const EVP_MD *EVP_sha3_256(void);
  const EVP_MD *EVP_sha3_384(void);
  const EVP_MD *EVP_sha3_512(void);
  const EVP_MD *EVP_shake128(void);
  const EVP_MD *EVP_shake256(void);
  const EVP_MD *EVP_mdc2(void);
  const EVP_MD *EVP_ripemd160(void);
  const EVP_MD *EVP_whirlpool(void);
  const EVP_MD *EVP_sm3(void);
  const EVP_CIPHER *EVP_enc_null(void);
  const EVP_CIPHER *EVP_des_ecb(void);
  const EVP_CIPHER *EVP_des_ede(void);
  const EVP_CIPHER *EVP_des_ede3(void);
  const EVP_CIPHER *EVP_des_ede_ecb(void);
  const EVP_CIPHER *EVP_des_ede3_ecb(void);
  const EVP_CIPHER *EVP_des_cfb64(void);
  const EVP_CIPHER *EVP_des_cfb1(void);
  const EVP_CIPHER *EVP_des_cfb8(void);
  const EVP_CIPHER *EVP_des_ede_cfb64(void);
  const EVP_CIPHER *EVP_des_ede3_cfb64(void);
  const EVP_CIPHER *EVP_des_ede3_cfb1(void);
  const EVP_CIPHER *EVP_des_ede3_cfb8(void);
  const EVP_CIPHER *EVP_des_ofb(void);
  const EVP_CIPHER *EVP_des_ede_ofb(void);
  const EVP_CIPHER *EVP_des_ede3_ofb(void);
  const EVP_CIPHER *EVP_des_cbc(void);
  const EVP_CIPHER *EVP_des_ede_cbc(void);
  const EVP_CIPHER *EVP_des_ede3_cbc(void);
  const EVP_CIPHER *EVP_desx_cbc(void);
  const EVP_CIPHER *EVP_des_ede3_wrap(void);
  const EVP_CIPHER *EVP_rc4(void);
  const EVP_CIPHER *EVP_rc4_40(void);
  const EVP_CIPHER *EVP_rc4_hmac_md5(void);
  const EVP_CIPHER *EVP_idea_ecb(void);
  const EVP_CIPHER *EVP_idea_cfb64(void);
  const EVP_CIPHER *EVP_idea_ofb(void);
  const EVP_CIPHER *EVP_idea_cbc(void);
  const EVP_CIPHER *EVP_rc2_ecb(void);
  const EVP_CIPHER *EVP_rc2_cbc(void);
  const EVP_CIPHER *EVP_rc2_40_cbc(void);
  const EVP_CIPHER *EVP_rc2_64_cbc(void);
  const EVP_CIPHER *EVP_rc2_cfb64(void);
  const EVP_CIPHER *EVP_rc2_ofb(void);
  const EVP_CIPHER *EVP_bf_ecb(void);
  const EVP_CIPHER *EVP_bf_cbc(void);
  const EVP_CIPHER *EVP_bf_cfb64(void);
  const EVP_CIPHER *EVP_bf_ofb(void);
  const EVP_CIPHER *EVP_cast5_ecb(void);
  const EVP_CIPHER *EVP_cast5_cbc(void);
  const EVP_CIPHER *EVP_cast5_cfb64(void);
  const EVP_CIPHER *EVP_cast5_ofb(void);
  const EVP_CIPHER *EVP_aes_128_ecb(void);
  const EVP_CIPHER *EVP_aes_128_cbc(void);
  const EVP_CIPHER *EVP_aes_128_cfb1(void);
  const EVP_CIPHER *EVP_aes_128_cfb8(void);
  const EVP_CIPHER *EVP_aes_128_cfb128(void);
  const EVP_CIPHER *EVP_aes_128_ofb(void);
  const EVP_CIPHER *EVP_aes_128_ctr(void);
  const EVP_CIPHER *EVP_aes_128_ccm(void);
  const EVP_CIPHER *EVP_aes_128_gcm(void);
  const EVP_CIPHER *EVP_aes_128_xts(void);
  const EVP_CIPHER *EVP_aes_128_wrap(void);
  const EVP_CIPHER *EVP_aes_128_wrap_pad(void);
  const EVP_CIPHER *EVP_aes_128_ocb(void);
  const EVP_CIPHER *EVP_aes_192_ecb(void);
  const EVP_CIPHER *EVP_aes_192_cbc(void);
  const EVP_CIPHER *EVP_aes_192_cfb1(void);
  const EVP_CIPHER *EVP_aes_192_cfb8(void);
  const EVP_CIPHER *EVP_aes_192_cfb128(void);
  const EVP_CIPHER *EVP_aes_192_ofb(void);
  const EVP_CIPHER *EVP_aes_192_ctr(void);
  const EVP_CIPHER *EVP_aes_192_ccm(void);
  const EVP_CIPHER *EVP_aes_192_gcm(void);
  const EVP_CIPHER *EVP_aes_192_wrap(void);
  const EVP_CIPHER *EVP_aes_192_wrap_pad(void);
  const EVP_CIPHER *EVP_aes_192_ocb(void);
  const EVP_CIPHER *EVP_aes_256_ecb(void);
  const EVP_CIPHER *EVP_aes_256_cbc(void);
  const EVP_CIPHER *EVP_aes_256_cfb1(void);
  const EVP_CIPHER *EVP_aes_256_cfb8(void);
  const EVP_CIPHER *EVP_aes_256_cfb128(void);
  const EVP_CIPHER *EVP_aes_256_ofb(void);
  const EVP_CIPHER *EVP_aes_256_ctr(void);
  const EVP_CIPHER *EVP_aes_256_ccm(void);
  const EVP_CIPHER *EVP_aes_256_gcm(void);
  const EVP_CIPHER *EVP_aes_256_xts(void);
  const EVP_CIPHER *EVP_aes_256_wrap(void);
  const EVP_CIPHER *EVP_aes_256_wrap_pad(void);
  const EVP_CIPHER *EVP_aes_256_ocb(void);
  const EVP_CIPHER *EVP_aes_128_cbc_hmac_sha1(void);
  const EVP_CIPHER *EVP_aes_256_cbc_hmac_sha1(void);
  const EVP_CIPHER *EVP_aes_128_cbc_hmac_sha256(void);
  const EVP_CIPHER *EVP_aes_256_cbc_hmac_sha256(void);
  const EVP_CIPHER *EVP_aria_128_ecb(void);
  const EVP_CIPHER *EVP_aria_128_cbc(void);
  const EVP_CIPHER *EVP_aria_128_cfb1(void);
  const EVP_CIPHER *EVP_aria_128_cfb8(void);
  const EVP_CIPHER *EVP_aria_128_cfb128(void);
  const EVP_CIPHER *EVP_aria_128_ctr(void);
  const EVP_CIPHER *EVP_aria_128_ofb(void);
  const EVP_CIPHER *EVP_aria_128_gcm(void);
  const EVP_CIPHER *EVP_aria_128_ccm(void);
  const EVP_CIPHER *EVP_aria_192_ecb(void);
  const EVP_CIPHER *EVP_aria_192_cbc(void);
  const EVP_CIPHER *EVP_aria_192_cfb1(void);
  const EVP_CIPHER *EVP_aria_192_cfb8(void);
  const EVP_CIPHER *EVP_aria_192_cfb128(void);
  const EVP_CIPHER *EVP_aria_192_ctr(void);
  const EVP_CIPHER *EVP_aria_192_ofb(void);
  const EVP_CIPHER *EVP_aria_192_gcm(void);
  const EVP_CIPHER *EVP_aria_192_ccm(void);
  const EVP_CIPHER *EVP_aria_256_ecb(void);
  const EVP_CIPHER *EVP_aria_256_cbc(void);
  const EVP_CIPHER *EVP_aria_256_cfb1(void);
  const EVP_CIPHER *EVP_aria_256_cfb8(void);
  const EVP_CIPHER *EVP_aria_256_cfb128(void);
  const EVP_CIPHER *EVP_aria_256_ctr(void);
  const EVP_CIPHER *EVP_aria_256_ofb(void);
  const EVP_CIPHER *EVP_aria_256_gcm(void);
  const EVP_CIPHER *EVP_aria_256_ccm(void);
  const EVP_CIPHER *EVP_camellia_128_ecb(void);
  const EVP_CIPHER *EVP_camellia_128_cbc(void);
  const EVP_CIPHER *EVP_camellia_128_cfb1(void);
  const EVP_CIPHER *EVP_camellia_128_cfb8(void);
  const EVP_CIPHER *EVP_camellia_128_cfb128(void);
  const EVP_CIPHER *EVP_camellia_128_ofb(void);
  const EVP_CIPHER *EVP_camellia_128_ctr(void);
  const EVP_CIPHER *EVP_camellia_192_ecb(void);
  const EVP_CIPHER *EVP_camellia_192_cbc(void);
  const EVP_CIPHER *EVP_camellia_192_cfb1(void);
  const EVP_CIPHER *EVP_camellia_192_cfb8(void);
  const EVP_CIPHER *EVP_camellia_192_cfb128(void);
  const EVP_CIPHER *EVP_camellia_192_ofb(void);
  const EVP_CIPHER *EVP_camellia_192_ctr(void);
  const EVP_CIPHER *EVP_camellia_256_ecb(void);
  const EVP_CIPHER *EVP_camellia_256_cbc(void);
  const EVP_CIPHER *EVP_camellia_256_cfb1(void);
  const EVP_CIPHER *EVP_camellia_256_cfb8(void);
  const EVP_CIPHER *EVP_camellia_256_cfb128(void);
  const EVP_CIPHER *EVP_camellia_256_ofb(void);
  const EVP_CIPHER *EVP_camellia_256_ctr(void);
  const EVP_CIPHER *EVP_chacha20(void);
  const EVP_CIPHER *EVP_chacha20_poly1305(void);
  const EVP_CIPHER *EVP_seed_ecb(void);
  const EVP_CIPHER *EVP_seed_cbc(void);
  const EVP_CIPHER *EVP_seed_cfb128(void);
  const EVP_CIPHER *EVP_seed_ofb(void);
  const EVP_CIPHER *EVP_sm4_ecb(void);
  const EVP_CIPHER *EVP_sm4_cbc(void);
  const EVP_CIPHER *EVP_sm4_cfb128(void);
  const EVP_CIPHER *EVP_sm4_ofb(void);
  const EVP_CIPHER *EVP_sm4_ctr(void);
  int EVP_add_cipher(const EVP_CIPHER *cipher);
  int EVP_add_digest(const EVP_MD *digest);
  const EVP_CIPHER *EVP_get_cipherbyname(const char *name);
  const EVP_MD *EVP_get_digestbyname(const char *name);
  void EVP_CIPHER_do_all(void (*fn)(const EVP_CIPHER *ciph,
                                    const char *from, const char *to, void *x),
                         void *arg);
  void EVP_CIPHER_do_all_sorted(void (*fn)(const EVP_CIPHER *ciph, const char *from,
                                           const char *to, void *x),
                                void *arg);
  void EVP_MD_do_all(void (*fn)(const EVP_MD *ciph,
                                const char *from, const char *to, void *x),
                     void *arg);
  void EVP_MD_do_all_sorted(void (*fn)(const EVP_MD *ciph, const char *from,
                                       const char *to, void *x),
                            void *arg);
  int EVP_PKEY_decrypt_old(unsigned char *dec_key,
                           const unsigned char *enc_key, int enc_key_len,
                           EVP_PKEY *private_key);
  int EVP_PKEY_encrypt_old(unsigned char *enc_key,
                           const unsigned char *key, int key_len,
                           EVP_PKEY *pub_key);
  int EVP_PKEY_type(int type);
  int EVP_PKEY_id(const EVP_PKEY *pkey);
  int EVP_PKEY_base_id(const EVP_PKEY *pkey);
  int EVP_PKEY_bits(const EVP_PKEY *pkey);
  int EVP_PKEY_security_bits(const EVP_PKEY *pkey);
  int EVP_PKEY_size(const EVP_PKEY *pkey);
  int EVP_PKEY_set_type(EVP_PKEY *pkey, int type);
  int EVP_PKEY_set_type_str(EVP_PKEY *pkey, const char *str, int len);
  int EVP_PKEY_set_alias_type(EVP_PKEY *pkey, int type);
  int EVP_PKEY_set1_engine(EVP_PKEY *pkey, ENGINE *e);
  ENGINE *EVP_PKEY_get0_engine(const EVP_PKEY *pkey);
  int EVP_PKEY_assign(EVP_PKEY *pkey, int type, void *key);
  void *EVP_PKEY_get0(const EVP_PKEY *pkey);
  const unsigned char *EVP_PKEY_get0_hmac(const EVP_PKEY *pkey, size_t *len);
  const unsigned char *EVP_PKEY_get0_poly1305(const EVP_PKEY *pkey, size_t *len);
  const unsigned char *EVP_PKEY_get0_siphash(const EVP_PKEY *pkey, size_t *len);
  struct rsa_st;
  int EVP_PKEY_set1_RSA(EVP_PKEY *pkey, struct rsa_st *key);
  struct rsa_st *EVP_PKEY_get0_RSA(EVP_PKEY *pkey);
  struct rsa_st *EVP_PKEY_get1_RSA(EVP_PKEY *pkey);
  struct dsa_st;
  int EVP_PKEY_set1_DSA(EVP_PKEY *pkey, struct dsa_st *key);
  struct dsa_st *EVP_PKEY_get0_DSA(EVP_PKEY *pkey);
  struct dsa_st *EVP_PKEY_get1_DSA(EVP_PKEY *pkey);
  struct dh_st;
  int EVP_PKEY_set1_DH(EVP_PKEY *pkey, struct dh_st *key);
  struct dh_st *EVP_PKEY_get0_DH(EVP_PKEY *pkey);
  struct dh_st *EVP_PKEY_get1_DH(EVP_PKEY *pkey);
  struct ec_key_st;
  int EVP_PKEY_set1_EC_KEY(EVP_PKEY *pkey, struct ec_key_st *key);
  struct ec_key_st *EVP_PKEY_get0_EC_KEY(EVP_PKEY *pkey);
  struct ec_key_st *EVP_PKEY_get1_EC_KEY(EVP_PKEY *pkey);
  EVP_PKEY *EVP_PKEY_new(void);
  int EVP_PKEY_up_ref(EVP_PKEY *pkey);
  void EVP_PKEY_free(EVP_PKEY *pkey);
  EVP_PKEY *d2i_PublicKey(int type, EVP_PKEY **a, const unsigned char **pp,
                          long length);
  int i2d_PublicKey(EVP_PKEY *a, unsigned char **pp);
  EVP_PKEY *d2i_PrivateKey(int type, EVP_PKEY **a, const unsigned char **pp,
                           long length);
  EVP_PKEY *d2i_AutoPrivateKey(EVP_PKEY **a, const unsigned char **pp,
                               long length);
  int i2d_PrivateKey(EVP_PKEY *a, unsigned char **pp);
  int EVP_PKEY_copy_parameters(EVP_PKEY *to, const EVP_PKEY *from);
  int EVP_PKEY_missing_parameters(const EVP_PKEY *pkey);
  int EVP_PKEY_save_parameters(EVP_PKEY *pkey, int mode);
  int EVP_PKEY_cmp_parameters(const EVP_PKEY *a, const EVP_PKEY *b);
  int EVP_PKEY_cmp(const EVP_PKEY *a, const EVP_PKEY *b);
  int EVP_PKEY_print_public(BIO *out, const EVP_PKEY *pkey,
                            int indent, ASN1_PCTX *pctx);
  int EVP_PKEY_print_private(BIO *out, const EVP_PKEY *pkey,
                             int indent, ASN1_PCTX *pctx);
  int EVP_PKEY_print_params(BIO *out, const EVP_PKEY *pkey,
                            int indent, ASN1_PCTX *pctx);
  int EVP_PKEY_get_default_digest_nid(EVP_PKEY *pkey, int *pnid);
  int EVP_PKEY_set1_tls_encodedpoint(EVP_PKEY *pkey,
                                     const unsigned char *pt, size_t ptlen);
  size_t EVP_PKEY_get1_tls_encodedpoint(EVP_PKEY *pkey, unsigned char **ppt);
  int EVP_CIPHER_type(const EVP_CIPHER *ctx);
  int EVP_CIPHER_param_to_asn1(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
  int EVP_CIPHER_asn1_to_param(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
  int EVP_CIPHER_set_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
  int EVP_CIPHER_get_asn1_iv(EVP_CIPHER_CTX *c, ASN1_TYPE *type);
  int PKCS5_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
                         ASN1_TYPE *param, const EVP_CIPHER *cipher,
                         const EVP_MD *md, int en_de);
  int PKCS5_PBKDF2_HMAC_SHA1(const char *pass, int passlen,
                             const unsigned char *salt, int saltlen, int iter,
                             int keylen, unsigned char *out);
  int PKCS5_PBKDF2_HMAC(const char *pass, int passlen,
                        const unsigned char *salt, int saltlen, int iter,
                        const EVP_MD *digest, int keylen, unsigned char *out);
  int PKCS5_v2_PBE_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass, int passlen,
                            ASN1_TYPE *param, const EVP_CIPHER *cipher,
                            const EVP_MD *md, int en_de);
  int EVP_PBE_scrypt(const char *pass, size_t passlen,
                     const unsigned char *salt, size_t saltlen,
                     uint64_t N, uint64_t r, uint64_t p, uint64_t maxmem,
                     unsigned char *key, size_t keylen);
  int PKCS5_v2_scrypt_keyivgen(EVP_CIPHER_CTX *ctx, const char *pass,
                               int passlen, ASN1_TYPE *param,
                               const EVP_CIPHER *c, const EVP_MD *md, int en_de);
  void PKCS5_PBE_add(void);
  int EVP_PBE_CipherInit(ASN1_OBJECT *pbe_obj, const char *pass, int passlen,
                         ASN1_TYPE *param, EVP_CIPHER_CTX *ctx, int en_de);
  int EVP_PBE_alg_add_type(int pbe_type, int pbe_nid, int cipher_nid,
                           int md_nid, EVP_PBE_KEYGEN *keygen);
  int EVP_PBE_alg_add(int nid, const EVP_CIPHER *cipher, const EVP_MD *md,
                      EVP_PBE_KEYGEN *keygen);
  int EVP_PBE_find(int type, int pbe_nid, int *pcnid, int *pmnid,
                   EVP_PBE_KEYGEN **pkeygen);
  void EVP_PBE_cleanup(void);
  int EVP_PBE_get(int *ptype, int *ppbe_nid, size_t num);
  int EVP_PKEY_asn1_get_count(void);
  const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_get0(int idx);
  const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find(ENGINE **pe, int type);
  const EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_find_str(ENGINE **pe,
                                                     const char *str, int len);
  int EVP_PKEY_asn1_add0(const EVP_PKEY_ASN1_METHOD *ameth);
  int EVP_PKEY_asn1_add_alias(int to, int from);
  int EVP_PKEY_asn1_get0_info(int *ppkey_id, int *pkey_base_id,
                              int *ppkey_flags, const char **pinfo,
                              const char **ppem_str,
                              const EVP_PKEY_ASN1_METHOD *ameth);
  const EVP_PKEY_ASN1_METHOD *EVP_PKEY_get0_asn1(const EVP_PKEY *pkey);
  EVP_PKEY_ASN1_METHOD *EVP_PKEY_asn1_new(int id, int flags,
                                          const char *pem_str,
                                          const char *info);
  void EVP_PKEY_asn1_copy(EVP_PKEY_ASN1_METHOD *dst,
                          const EVP_PKEY_ASN1_METHOD *src);
  void EVP_PKEY_asn1_free(EVP_PKEY_ASN1_METHOD *ameth);
  void EVP_PKEY_asn1_set_public(EVP_PKEY_ASN1_METHOD *ameth,
                                int (*pub_decode)(EVP_PKEY *pk,
                                                  X509_PUBKEY *pub),
                                int (*pub_encode)(X509_PUBKEY *pub,
                                                  const EVP_PKEY *pk),
                                int (*pub_cmp)(const EVP_PKEY *a,
                                               const EVP_PKEY *b),
                                int (*pub_print)(BIO *out,
                                                 const EVP_PKEY *pkey,
                                                 int indent, ASN1_PCTX *pctx),
                                int (*pkey_size)(const EVP_PKEY *pk),
                                int (*pkey_bits)(const EVP_PKEY *pk));
  void EVP_PKEY_asn1_set_private(EVP_PKEY_ASN1_METHOD *ameth,
                                 int (*priv_decode)(EVP_PKEY *pk,
                                                    const PKCS8_PRIV_KEY_INFO
                                                        *p8inf),
                                 int (*priv_encode)(PKCS8_PRIV_KEY_INFO *p8,
                                                    const EVP_PKEY *pk),
                                 int (*priv_print)(BIO *out,
                                                   const EVP_PKEY *pkey,
                                                   int indent,
                                                   ASN1_PCTX *pctx));
  void EVP_PKEY_asn1_set_param(EVP_PKEY_ASN1_METHOD *ameth,
                               int (*param_decode)(EVP_PKEY *pkey,
                                                   const unsigned char **pder,
                                                   int derlen),
                               int (*param_encode)(const EVP_PKEY *pkey,
                                                   unsigned char **pder),
                               int (*param_missing)(const EVP_PKEY *pk),
                               int (*param_copy)(EVP_PKEY *to,
                                                 const EVP_PKEY *from),
                               int (*param_cmp)(const EVP_PKEY *a,
                                                const EVP_PKEY *b),
                               int (*param_print)(BIO *out,
                                                  const EVP_PKEY *pkey,
                                                  int indent,
                                                  ASN1_PCTX *pctx));
  void EVP_PKEY_asn1_set_free(EVP_PKEY_ASN1_METHOD *ameth,
                              void (*pkey_free)(EVP_PKEY *pkey));
  void EVP_PKEY_asn1_set_ctrl(EVP_PKEY_ASN1_METHOD *ameth,
                              int (*pkey_ctrl)(EVP_PKEY *pkey, int op,
                                               long arg1, void *arg2));
  void EVP_PKEY_asn1_set_item(EVP_PKEY_ASN1_METHOD *ameth,
                              int (*item_verify)(EVP_MD_CTX *ctx,
                                                 const ASN1_ITEM *it,
                                                 void *asn,
                                                 X509_ALGOR *a,
                                                 ASN1_BIT_STRING *sig,
                                                 EVP_PKEY *pkey),
                              int (*item_sign)(EVP_MD_CTX *ctx,
                                               const ASN1_ITEM *it,
                                               void *asn,
                                               X509_ALGOR *alg1,
                                               X509_ALGOR *alg2,
                                               ASN1_BIT_STRING *sig));
  void EVP_PKEY_asn1_set_siginf(EVP_PKEY_ASN1_METHOD *ameth,
                                int (*siginf_set)(X509_SIG_INFO *siginf,
                                                  const X509_ALGOR *alg,
                                                  const ASN1_STRING *sig));
  void EVP_PKEY_asn1_set_check(EVP_PKEY_ASN1_METHOD *ameth,
                               int (*pkey_check)(const EVP_PKEY *pk));
  void EVP_PKEY_asn1_set_public_check(EVP_PKEY_ASN1_METHOD *ameth,
                                      int (*pkey_pub_check)(const EVP_PKEY *pk));
  void EVP_PKEY_asn1_set_param_check(EVP_PKEY_ASN1_METHOD *ameth,
                                     int (*pkey_param_check)(const EVP_PKEY *pk));
  void EVP_PKEY_asn1_set_set_priv_key(EVP_PKEY_ASN1_METHOD *ameth,
                                      int (*set_priv_key)(EVP_PKEY *pk,
                                                          const unsigned char
                                                              *priv,
                                                          size_t len));
  void EVP_PKEY_asn1_set_set_pub_key(EVP_PKEY_ASN1_METHOD *ameth,
                                     int (*set_pub_key)(EVP_PKEY *pk,
                                                        const unsigned char *pub,
                                                        size_t len));
  void EVP_PKEY_asn1_set_get_priv_key(EVP_PKEY_ASN1_METHOD *ameth,
                                      int (*get_priv_key)(const EVP_PKEY *pk,
                                                          unsigned char *priv,
                                                          size_t *len));
  void EVP_PKEY_asn1_set_get_pub_key(EVP_PKEY_ASN1_METHOD *ameth,
                                     int (*get_pub_key)(const EVP_PKEY *pk,
                                                        unsigned char *pub,
                                                        size_t *len));
  void EVP_PKEY_asn1_set_security_bits(EVP_PKEY_ASN1_METHOD *ameth,
                                       int (*pkey_security_bits)(const EVP_PKEY
                                                                     *pk));
  const EVP_PKEY_METHOD *EVP_PKEY_meth_find(int type);
  EVP_PKEY_METHOD *EVP_PKEY_meth_new(int id, int flags);
  void EVP_PKEY_meth_get0_info(int *ppkey_id, int *pflags,
                               const EVP_PKEY_METHOD *meth);
  void EVP_PKEY_meth_copy(EVP_PKEY_METHOD *dst, const EVP_PKEY_METHOD *src);
  void EVP_PKEY_meth_free(EVP_PKEY_METHOD *pmeth);
  int EVP_PKEY_meth_add0(const EVP_PKEY_METHOD *pmeth);
  int EVP_PKEY_meth_remove(const EVP_PKEY_METHOD *pmeth);
  size_t EVP_PKEY_meth_get_count(void);
  const EVP_PKEY_METHOD *EVP_PKEY_meth_get0(size_t idx);
  EVP_PKEY_CTX *EVP_PKEY_CTX_new(EVP_PKEY *pkey, ENGINE *e);
  EVP_PKEY_CTX *EVP_PKEY_CTX_new_id(int id, ENGINE *e);
  EVP_PKEY_CTX *EVP_PKEY_CTX_dup(EVP_PKEY_CTX *ctx);
  void EVP_PKEY_CTX_free(EVP_PKEY_CTX *ctx);
  int EVP_PKEY_CTX_ctrl(EVP_PKEY_CTX *ctx, int keytype, int optype,
                        int cmd, int p1, void *p2);
  int EVP_PKEY_CTX_ctrl_str(EVP_PKEY_CTX *ctx, const char *type,
                            const char *value);
  int EVP_PKEY_CTX_ctrl_uint64(EVP_PKEY_CTX *ctx, int keytype, int optype,
                               int cmd, uint64_t value);
  int EVP_PKEY_CTX_str2ctrl(EVP_PKEY_CTX *ctx, int cmd, const char *str);
  int EVP_PKEY_CTX_hex2ctrl(EVP_PKEY_CTX *ctx, int cmd, const char *hex);
  int EVP_PKEY_CTX_md(EVP_PKEY_CTX *ctx, int optype, int cmd, const char *md);
  int EVP_PKEY_CTX_get_operation(EVP_PKEY_CTX *ctx);
  void EVP_PKEY_CTX_set0_keygen_info(EVP_PKEY_CTX *ctx, int *dat, int datlen);
  EVP_PKEY *EVP_PKEY_new_mac_key(int type, ENGINE *e,
                                 const unsigned char *key, int keylen);
  EVP_PKEY *EVP_PKEY_new_raw_private_key(int type, ENGINE *e,
                                         const unsigned char *priv,
                                         size_t len);
  EVP_PKEY *EVP_PKEY_new_raw_public_key(int type, ENGINE *e,
                                        const unsigned char *pub,
                                        size_t len);
  int EVP_PKEY_get_raw_private_key(const EVP_PKEY *pkey, unsigned char *priv,
                                   size_t *len);
  int EVP_PKEY_get_raw_public_key(const EVP_PKEY *pkey, unsigned char *pub,
                                  size_t *len);
  EVP_PKEY *EVP_PKEY_new_CMAC_key(ENGINE *e, const unsigned char *priv,
                                  size_t len, const EVP_CIPHER *cipher);
  void EVP_PKEY_CTX_set_data(EVP_PKEY_CTX *ctx, void *data);
  void *EVP_PKEY_CTX_get_data(EVP_PKEY_CTX *ctx);
  EVP_PKEY *EVP_PKEY_CTX_get0_pkey(EVP_PKEY_CTX *ctx);
  EVP_PKEY *EVP_PKEY_CTX_get0_peerkey(EVP_PKEY_CTX *ctx);
  void EVP_PKEY_CTX_set_app_data(EVP_PKEY_CTX *ctx, void *data);
  void *EVP_PKEY_CTX_get_app_data(EVP_PKEY_CTX *ctx);
  int EVP_PKEY_sign_init(EVP_PKEY_CTX *ctx);
  int EVP_PKEY_sign(EVP_PKEY_CTX *ctx,
                    unsigned char *sig, size_t *siglen,
                    const unsigned char *tbs, size_t tbslen);
  int EVP_PKEY_verify_init(EVP_PKEY_CTX *ctx);
  int EVP_PKEY_verify(EVP_PKEY_CTX *ctx,
                      const unsigned char *sig, size_t siglen,
                      const unsigned char *tbs, size_t tbslen);
  int EVP_PKEY_verify_recover_init(EVP_PKEY_CTX *ctx);
  int EVP_PKEY_verify_recover(EVP_PKEY_CTX *ctx,
                              unsigned char *rout, size_t *routlen,
                              const unsigned char *sig, size_t siglen);
  int EVP_PKEY_encrypt_init(EVP_PKEY_CTX *ctx);
  int EVP_PKEY_encrypt(EVP_PKEY_CTX *ctx,
                       unsigned char *out, size_t *outlen,
                       const unsigned char *in, size_t inlen);
  int EVP_PKEY_decrypt_init(EVP_PKEY_CTX *ctx);
  int EVP_PKEY_decrypt(EVP_PKEY_CTX *ctx,
                       unsigned char *out, size_t *outlen,
                       const unsigned char *in, size_t inlen);
  int EVP_PKEY_derive_init(EVP_PKEY_CTX *ctx);
  int EVP_PKEY_derive_set_peer(EVP_PKEY_CTX *ctx, EVP_PKEY *peer);
  int EVP_PKEY_derive(EVP_PKEY_CTX *ctx, unsigned char *key, size_t *keylen);
  typedef int EVP_PKEY_gen_cb(EVP_PKEY_CTX *ctx);
  int EVP_PKEY_paramgen_init(EVP_PKEY_CTX *ctx);
  int EVP_PKEY_paramgen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);
  int EVP_PKEY_keygen_init(EVP_PKEY_CTX *ctx);
  int EVP_PKEY_keygen(EVP_PKEY_CTX *ctx, EVP_PKEY **ppkey);
  int EVP_PKEY_check(EVP_PKEY_CTX *ctx);
  int EVP_PKEY_public_check(EVP_PKEY_CTX *ctx);
  int EVP_PKEY_param_check(EVP_PKEY_CTX *ctx);
  void EVP_PKEY_CTX_set_cb(EVP_PKEY_CTX *ctx, EVP_PKEY_gen_cb *cb);
  EVP_PKEY_gen_cb *EVP_PKEY_CTX_get_cb(EVP_PKEY_CTX *ctx);
  int EVP_PKEY_CTX_get_keygen_info(EVP_PKEY_CTX *ctx, int idx);
  void EVP_PKEY_meth_set_init(EVP_PKEY_METHOD *pmeth,
                              int (*init)(EVP_PKEY_CTX *ctx));
  void EVP_PKEY_meth_set_copy(EVP_PKEY_METHOD *pmeth,
                              int (*copy)(EVP_PKEY_CTX *dst,
                                          EVP_PKEY_CTX *src));
  void EVP_PKEY_meth_set_cleanup(EVP_PKEY_METHOD *pmeth,
                                 void (*cleanup)(EVP_PKEY_CTX *ctx));
  void EVP_PKEY_meth_set_paramgen(EVP_PKEY_METHOD *pmeth,
                                  int (*paramgen_init)(EVP_PKEY_CTX *ctx),
                                  int (*paramgen)(EVP_PKEY_CTX *ctx,
                                                  EVP_PKEY *pkey));
  void EVP_PKEY_meth_set_keygen(EVP_PKEY_METHOD *pmeth,
                                int (*keygen_init)(EVP_PKEY_CTX *ctx),
                                int (*keygen)(EVP_PKEY_CTX *ctx,
                                              EVP_PKEY *pkey));
  void EVP_PKEY_meth_set_sign(EVP_PKEY_METHOD *pmeth,
                              int (*sign_init)(EVP_PKEY_CTX *ctx),
                              int (*sign)(EVP_PKEY_CTX *ctx,
                                          unsigned char *sig, size_t *siglen,
                                          const unsigned char *tbs,
                                          size_t tbslen));
  void EVP_PKEY_meth_set_verify(EVP_PKEY_METHOD *pmeth,
                                int (*verify_init)(EVP_PKEY_CTX *ctx),
                                int (*verify)(EVP_PKEY_CTX *ctx,
                                              const unsigned char *sig,
                                              size_t siglen,
                                              const unsigned char *tbs,
                                              size_t tbslen));
  void EVP_PKEY_meth_set_verify_recover(EVP_PKEY_METHOD *pmeth,
                                        int (*verify_recover_init)(EVP_PKEY_CTX
                                                                       *ctx),
                                        int (*verify_recover)(EVP_PKEY_CTX
                                                                  *ctx,
                                                              unsigned char
                                                                  *sig,
                                                              size_t *siglen,
                                                              const unsigned char *tbs,
                                                              size_t tbslen));
  void EVP_PKEY_meth_set_signctx(EVP_PKEY_METHOD *pmeth,
                                 int (*signctx_init)(EVP_PKEY_CTX *ctx,
                                                     EVP_MD_CTX *mctx),
                                 int (*signctx)(EVP_PKEY_CTX *ctx,
                                                unsigned char *sig,
                                                size_t *siglen,
                                                EVP_MD_CTX *mctx));
  void EVP_PKEY_meth_set_verifyctx(EVP_PKEY_METHOD *pmeth,
                                   int (*verifyctx_init)(EVP_PKEY_CTX *ctx,
                                                         EVP_MD_CTX *mctx),
                                   int (*verifyctx)(EVP_PKEY_CTX *ctx,
                                                    const unsigned char *sig,
                                                    int siglen,
                                                    EVP_MD_CTX *mctx));
  void EVP_PKEY_meth_set_encrypt(EVP_PKEY_METHOD *pmeth,
                                 int (*encrypt_init)(EVP_PKEY_CTX *ctx),
                                 int (*encryptfn)(EVP_PKEY_CTX *ctx,
                                                  unsigned char *out,
                                                  size_t *outlen,
                                                  const unsigned char *in,
                                                  size_t inlen));
  void EVP_PKEY_meth_set_decrypt(EVP_PKEY_METHOD *pmeth,
                                 int (*decrypt_init)(EVP_PKEY_CTX *ctx),
                                 int (*decrypt)(EVP_PKEY_CTX *ctx,
                                                unsigned char *out,
                                                size_t *outlen,
                                                const unsigned char *in,
                                                size_t inlen));
  void EVP_PKEY_meth_set_derive(EVP_PKEY_METHOD *pmeth,
                                int (*derive_init)(EVP_PKEY_CTX *ctx),
                                int (*derive)(EVP_PKEY_CTX *ctx,
                                              unsigned char *key,
                                              size_t *keylen));
  void EVP_PKEY_meth_set_ctrl(EVP_PKEY_METHOD *pmeth,
                              int (*ctrl)(EVP_PKEY_CTX *ctx, int type, int p1,
                                          void *p2),
                              int (*ctrl_str)(EVP_PKEY_CTX *ctx,
                                              const char *type,
                                              const char *value));
  void EVP_PKEY_meth_set_digestsign(EVP_PKEY_METHOD *pmeth,
                                    int (*digestsign)(EVP_MD_CTX *ctx,
                                                      unsigned char *sig,
                                                      size_t *siglen,
                                                      const unsigned char *tbs,
                                                      size_t tbslen));
  void EVP_PKEY_meth_set_digestverify(EVP_PKEY_METHOD *pmeth,
                                      int (*digestverify)(EVP_MD_CTX *ctx,
                                                          const unsigned char *sig,
                                                          size_t siglen,
                                                          const unsigned char *tbs,
                                                          size_t tbslen));
  void EVP_PKEY_meth_set_check(EVP_PKEY_METHOD *pmeth,
                               int (*check)(EVP_PKEY *pkey));
  void EVP_PKEY_meth_set_public_check(EVP_PKEY_METHOD *pmeth,
                                      int (*check)(EVP_PKEY *pkey));
  void EVP_PKEY_meth_set_param_check(EVP_PKEY_METHOD *pmeth,
                                     int (*check)(EVP_PKEY *pkey));
  void EVP_PKEY_meth_set_digest_custom(EVP_PKEY_METHOD *pmeth,
                                       int (*digest_custom)(EVP_PKEY_CTX *ctx,
                                                            EVP_MD_CTX *mctx));
  void EVP_PKEY_meth_get_init(const EVP_PKEY_METHOD *pmeth,
                              int (**pinit)(EVP_PKEY_CTX *ctx));
  void EVP_PKEY_meth_get_copy(const EVP_PKEY_METHOD *pmeth,
                              int (**pcopy)(EVP_PKEY_CTX *dst,
                                            EVP_PKEY_CTX *src));
  void EVP_PKEY_meth_get_cleanup(const EVP_PKEY_METHOD *pmeth,
                                 void (**pcleanup)(EVP_PKEY_CTX *ctx));
  void EVP_PKEY_meth_get_paramgen(const EVP_PKEY_METHOD *pmeth,
                                  int (**pparamgen_init)(EVP_PKEY_CTX *ctx),
                                  int (**pparamgen)(EVP_PKEY_CTX *ctx,
                                                    EVP_PKEY *pkey));
  void EVP_PKEY_meth_get_keygen(const EVP_PKEY_METHOD *pmeth,
                                int (**pkeygen_init)(EVP_PKEY_CTX *ctx),
                                int (**pkeygen)(EVP_PKEY_CTX *ctx,
                                                EVP_PKEY *pkey));
  void EVP_PKEY_meth_get_sign(const EVP_PKEY_METHOD *pmeth,
                              int (**psign_init)(EVP_PKEY_CTX *ctx),
                              int (**psign)(EVP_PKEY_CTX *ctx,
                                            unsigned char *sig, size_t *siglen,
                                            const unsigned char *tbs,
                                            size_t tbslen));
  void EVP_PKEY_meth_get_verify(const EVP_PKEY_METHOD *pmeth,
                                int (**pverify_init)(EVP_PKEY_CTX *ctx),
                                int (**pverify)(EVP_PKEY_CTX *ctx,
                                                const unsigned char *sig,
                                                size_t siglen,
                                                const unsigned char *tbs,
                                                size_t tbslen));
  void EVP_PKEY_meth_get_verify_recover(const EVP_PKEY_METHOD *pmeth,
                                        int (**pverify_recover_init)(EVP_PKEY_CTX
                                                                         *ctx),
                                        int (**pverify_recover)(EVP_PKEY_CTX
                                                                    *ctx,
                                                                unsigned char
                                                                    *sig,
                                                                size_t *siglen,
                                                                const unsigned char *tbs,
                                                                size_t tbslen));
  void EVP_PKEY_meth_get_signctx(const EVP_PKEY_METHOD *pmeth,
                                 int (**psignctx_init)(EVP_PKEY_CTX *ctx,
                                                       EVP_MD_CTX *mctx),
                                 int (**psignctx)(EVP_PKEY_CTX *ctx,
                                                  unsigned char *sig,
                                                  size_t *siglen,
                                                  EVP_MD_CTX *mctx));
  void EVP_PKEY_meth_get_verifyctx(const EVP_PKEY_METHOD *pmeth,
                                   int (**pverifyctx_init)(EVP_PKEY_CTX *ctx,
                                                           EVP_MD_CTX *mctx),
                                   int (**pverifyctx)(EVP_PKEY_CTX *ctx,
                                                      const unsigned char *sig,
                                                      int siglen,
                                                      EVP_MD_CTX *mctx));
  void EVP_PKEY_meth_get_encrypt(const EVP_PKEY_METHOD *pmeth,
                                 int (**pencrypt_init)(EVP_PKEY_CTX *ctx),
                                 int (**pencryptfn)(EVP_PKEY_CTX *ctx,
                                                    unsigned char *out,
                                                    size_t *outlen,
                                                    const unsigned char *in,
                                                    size_t inlen));
  void EVP_PKEY_meth_get_decrypt(const EVP_PKEY_METHOD *pmeth,
                                 int (**pdecrypt_init)(EVP_PKEY_CTX *ctx),
                                 int (**pdecrypt)(EVP_PKEY_CTX *ctx,
                                                  unsigned char *out,
                                                  size_t *outlen,
                                                  const unsigned char *in,
                                                  size_t inlen));
  void EVP_PKEY_meth_get_derive(const EVP_PKEY_METHOD *pmeth,
                                int (**pderive_init)(EVP_PKEY_CTX *ctx),
                                int (**pderive)(EVP_PKEY_CTX *ctx,
                                                unsigned char *key,
                                                size_t *keylen));
  void EVP_PKEY_meth_get_ctrl(const EVP_PKEY_METHOD *pmeth,
                              int (**pctrl)(EVP_PKEY_CTX *ctx, int type, int p1,
                                            void *p2),
                              int (**pctrl_str)(EVP_PKEY_CTX *ctx,
                                                const char *type,
                                                const char *value));
  void EVP_PKEY_meth_get_digestsign(EVP_PKEY_METHOD *pmeth,
                                    int (**digestsign)(EVP_MD_CTX *ctx,
                                                       unsigned char *sig,
                                                       size_t *siglen,
                                                       const unsigned char *tbs,
                                                       size_t tbslen));
  void EVP_PKEY_meth_get_digestverify(EVP_PKEY_METHOD *pmeth,
                                      int (**digestverify)(EVP_MD_CTX *ctx,
                                                           const unsigned char *sig,
                                                           size_t siglen,
                                                           const unsigned char *tbs,
                                                           size_t tbslen));
  void EVP_PKEY_meth_get_check(const EVP_PKEY_METHOD *pmeth,
                               int (**pcheck)(EVP_PKEY *pkey));
  void EVP_PKEY_meth_get_public_check(const EVP_PKEY_METHOD *pmeth,
                                      int (**pcheck)(EVP_PKEY *pkey));
  void EVP_PKEY_meth_get_param_check(const EVP_PKEY_METHOD *pmeth,
                                     int (**pcheck)(EVP_PKEY *pkey));
  void EVP_PKEY_meth_get_digest_custom(EVP_PKEY_METHOD *pmeth,
                                       int (**pdigest_custom)(EVP_PKEY_CTX *ctx,
                                                              EVP_MD_CTX *mctx));
  void EVP_add_alg_module(void);
}
extern "C"
{
}
extern "C"
{
}
extern "C" int ERR_load_EC_strings(void);
extern "C"
{
  typedef enum
  {
    POINT_CONVERSION_COMPRESSED = 2,
    POINT_CONVERSION_UNCOMPRESSED = 4,
    POINT_CONVERSION_HYBRID = 6
  } point_conversion_form_t;
  typedef struct ec_method_st EC_METHOD;
  typedef struct ec_group_st EC_GROUP;
  typedef struct ec_point_st EC_POINT;
  typedef struct ecpk_parameters_st ECPKPARAMETERS;
  typedef struct ec_parameters_st ECPARAMETERS;
  const EC_METHOD *EC_GFp_simple_method(void);
  const EC_METHOD *EC_GFp_mont_method(void);
  const EC_METHOD *EC_GFp_nist_method(void);
  const EC_METHOD *EC_GF2m_simple_method(void);
  EC_GROUP *EC_GROUP_new(const EC_METHOD *meth);
  void EC_GROUP_free(EC_GROUP *group);
  void EC_GROUP_clear_free(EC_GROUP *group);
  int EC_GROUP_copy(EC_GROUP *dst, const EC_GROUP *src);
  EC_GROUP *EC_GROUP_dup(const EC_GROUP *src);
  const EC_METHOD *EC_GROUP_method_of(const EC_GROUP *group);
  int EC_METHOD_get_field_type(const EC_METHOD *meth);
  int EC_GROUP_set_generator(EC_GROUP *group, const EC_POINT *generator,
                             const BIGNUM *order, const BIGNUM *cofactor);
  const EC_POINT *EC_GROUP_get0_generator(const EC_GROUP *group);
  BN_MONT_CTX *EC_GROUP_get_mont_data(const EC_GROUP *group);
  int EC_GROUP_get_order(const EC_GROUP *group, BIGNUM *order, BN_CTX *ctx);
  const BIGNUM *EC_GROUP_get0_order(const EC_GROUP *group);
  int EC_GROUP_order_bits(const EC_GROUP *group);
  int EC_GROUP_get_cofactor(const EC_GROUP *group, BIGNUM *cofactor,
                            BN_CTX *ctx);
  const BIGNUM *EC_GROUP_get0_cofactor(const EC_GROUP *group);
  void EC_GROUP_set_curve_name(EC_GROUP *group, int nid);
  int EC_GROUP_get_curve_name(const EC_GROUP *group);
  void EC_GROUP_set_asn1_flag(EC_GROUP *group, int flag);
  int EC_GROUP_get_asn1_flag(const EC_GROUP *group);
  void EC_GROUP_set_point_conversion_form(EC_GROUP *group,
                                          point_conversion_form_t form);
  point_conversion_form_t EC_GROUP_get_point_conversion_form(const EC_GROUP *);
  unsigned char *EC_GROUP_get0_seed(const EC_GROUP *x);
  size_t EC_GROUP_get_seed_len(const EC_GROUP *);
  size_t EC_GROUP_set_seed(EC_GROUP *, const unsigned char *, size_t len);
  int EC_GROUP_set_curve(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a,
                         const BIGNUM *b, BN_CTX *ctx);
  int EC_GROUP_get_curve(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b,
                         BN_CTX *ctx);
  int EC_GROUP_set_curve_GFp(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);
  int EC_GROUP_get_curve_GFp(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);
  int EC_GROUP_set_curve_GF2m(EC_GROUP *group, const BIGNUM *p, const BIGNUM *a, const BIGNUM *b, BN_CTX *ctx);
  int EC_GROUP_get_curve_GF2m(const EC_GROUP *group, BIGNUM *p, BIGNUM *a, BIGNUM *b, BN_CTX *ctx);
  int EC_GROUP_get_degree(const EC_GROUP *group);
  int EC_GROUP_check(const EC_GROUP *group, BN_CTX *ctx);
  int EC_GROUP_check_discriminant(const EC_GROUP *group, BN_CTX *ctx);
  int EC_GROUP_cmp(const EC_GROUP *a, const EC_GROUP *b, BN_CTX *ctx);
  EC_GROUP *EC_GROUP_new_curve_GFp(const BIGNUM *p, const BIGNUM *a,
                                   const BIGNUM *b, BN_CTX *ctx);
  EC_GROUP *EC_GROUP_new_curve_GF2m(const BIGNUM *p, const BIGNUM *a,
                                    const BIGNUM *b, BN_CTX *ctx);
  EC_GROUP *EC_GROUP_new_by_curve_name(int nid);
  EC_GROUP *EC_GROUP_new_from_ecparameters(const ECPARAMETERS *params);
  ECPARAMETERS *EC_GROUP_get_ecparameters(const EC_GROUP *group,
                                          ECPARAMETERS *params);
  EC_GROUP *EC_GROUP_new_from_ecpkparameters(const ECPKPARAMETERS *params);
  ECPKPARAMETERS *EC_GROUP_get_ecpkparameters(const EC_GROUP *group,
                                              ECPKPARAMETERS *params);
  typedef struct
  {
    int nid;
    const char *comment;
  } EC_builtin_curve;
  size_t EC_get_builtin_curves(EC_builtin_curve *r, size_t nitems);
  const char *EC_curve_nid2nist(int nid);
  int EC_curve_nist2nid(const char *name);
  EC_POINT *EC_POINT_new(const EC_GROUP *group);
  void EC_POINT_free(EC_POINT *point);
  void EC_POINT_clear_free(EC_POINT *point);
  int EC_POINT_copy(EC_POINT *dst, const EC_POINT *src);
  EC_POINT *EC_POINT_dup(const EC_POINT *src, const EC_GROUP *group);
  const EC_METHOD *EC_POINT_method_of(const EC_POINT *point);
  int EC_POINT_set_to_infinity(const EC_GROUP *group, EC_POINT *point);
  int EC_POINT_set_Jprojective_coordinates_GFp(const EC_GROUP *group,
                                               EC_POINT *p, const BIGNUM *x,
                                               const BIGNUM *y, const BIGNUM *z,
                                               BN_CTX *ctx);
  int EC_POINT_get_Jprojective_coordinates_GFp(const EC_GROUP *group,
                                               const EC_POINT *p, BIGNUM *x,
                                               BIGNUM *y, BIGNUM *z,
                                               BN_CTX *ctx);
  int EC_POINT_set_affine_coordinates(const EC_GROUP *group, EC_POINT *p,
                                      const BIGNUM *x, const BIGNUM *y,
                                      BN_CTX *ctx);
  int EC_POINT_get_affine_coordinates(const EC_GROUP *group, const EC_POINT *p,
                                      BIGNUM *x, BIGNUM *y, BN_CTX *ctx);
  int EC_POINT_set_affine_coordinates_GFp(const EC_GROUP *group, EC_POINT *p, const BIGNUM *x, const BIGNUM *y, BN_CTX *ctx);
  int EC_POINT_get_affine_coordinates_GFp(const EC_GROUP *group, const EC_POINT *p, BIGNUM *x, BIGNUM *y, BN_CTX *ctx);
  int EC_POINT_set_compressed_coordinates(const EC_GROUP *group, EC_POINT *p,
                                          const BIGNUM *x, int y_bit,
                                          BN_CTX *ctx);
  int EC_POINT_set_compressed_coordinates_GFp(const EC_GROUP *group, EC_POINT *p, const BIGNUM *x, int y_bit, BN_CTX *ctx);
  int EC_POINT_set_affine_coordinates_GF2m(const EC_GROUP *group, EC_POINT *p, const BIGNUM *x, const BIGNUM *y, BN_CTX *ctx);
  int EC_POINT_get_affine_coordinates_GF2m(const EC_GROUP *group, const EC_POINT *p, BIGNUM *x, BIGNUM *y, BN_CTX *ctx);
  int EC_POINT_set_compressed_coordinates_GF2m(const EC_GROUP *group, EC_POINT *p, const BIGNUM *x, int y_bit, BN_CTX *ctx);
  size_t EC_POINT_point2oct(const EC_GROUP *group, const EC_POINT *p,
                            point_conversion_form_t form,
                            unsigned char *buf, size_t len, BN_CTX *ctx);
  int EC_POINT_oct2point(const EC_GROUP *group, EC_POINT *p,
                         const unsigned char *buf, size_t len, BN_CTX *ctx);
  size_t EC_POINT_point2buf(const EC_GROUP *group, const EC_POINT *point,
                            point_conversion_form_t form,
                            unsigned char **pbuf, BN_CTX *ctx);
  BIGNUM *EC_POINT_point2bn(const EC_GROUP *, const EC_POINT *,
                            point_conversion_form_t form, BIGNUM *, BN_CTX *);
  EC_POINT *EC_POINT_bn2point(const EC_GROUP *, const BIGNUM *,
                              EC_POINT *, BN_CTX *);
  char *EC_POINT_point2hex(const EC_GROUP *, const EC_POINT *,
                           point_conversion_form_t form, BN_CTX *);
  EC_POINT *EC_POINT_hex2point(const EC_GROUP *, const char *,
                               EC_POINT *, BN_CTX *);
  int EC_POINT_add(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
                   const EC_POINT *b, BN_CTX *ctx);
  int EC_POINT_dbl(const EC_GROUP *group, EC_POINT *r, const EC_POINT *a,
                   BN_CTX *ctx);
  int EC_POINT_invert(const EC_GROUP *group, EC_POINT *a, BN_CTX *ctx);
  int EC_POINT_is_at_infinity(const EC_GROUP *group, const EC_POINT *p);
  int EC_POINT_is_on_curve(const EC_GROUP *group, const EC_POINT *point,
                           BN_CTX *ctx);
  int EC_POINT_cmp(const EC_GROUP *group, const EC_POINT *a, const EC_POINT *b,
                   BN_CTX *ctx);
  int EC_POINT_make_affine(const EC_GROUP *group, EC_POINT *point, BN_CTX *ctx);
  int EC_POINTs_make_affine(const EC_GROUP *group, size_t num,
                            EC_POINT *points[], BN_CTX *ctx);
  int EC_POINTs_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n,
                    size_t num, const EC_POINT *p[], const BIGNUM *m[],
                    BN_CTX *ctx);
  int EC_POINT_mul(const EC_GROUP *group, EC_POINT *r, const BIGNUM *n,
                   const EC_POINT *q, const BIGNUM *m, BN_CTX *ctx);
  int EC_GROUP_precompute_mult(EC_GROUP *group, BN_CTX *ctx);
  int EC_GROUP_have_precompute_mult(const EC_GROUP *group);
  extern const ASN1_ITEM ECPKPARAMETERS_it;
  ECPKPARAMETERS *ECPKPARAMETERS_new(void);
  void ECPKPARAMETERS_free(ECPKPARAMETERS *a);
  extern const ASN1_ITEM ECPARAMETERS_it;
  ECPARAMETERS *ECPARAMETERS_new(void);
  void ECPARAMETERS_free(ECPARAMETERS *a);
  int EC_GROUP_get_basis_type(const EC_GROUP *);
  int EC_GROUP_get_trinomial_basis(const EC_GROUP *, unsigned int *k);
  int EC_GROUP_get_pentanomial_basis(const EC_GROUP *, unsigned int *k1,
                                     unsigned int *k2, unsigned int *k3);
  EC_GROUP *d2i_ECPKParameters(EC_GROUP **, const unsigned char **in, long len);
  int i2d_ECPKParameters(const EC_GROUP *, unsigned char **out);
  int ECPKParameters_print(BIO *bp, const EC_GROUP *x, int off);
  int ECPKParameters_print_fp(FILE *fp, const EC_GROUP *x, int off);
  EC_KEY *EC_KEY_new(void);
  int EC_KEY_get_flags(const EC_KEY *key);
  void EC_KEY_set_flags(EC_KEY *key, int flags);
  void EC_KEY_clear_flags(EC_KEY *key, int flags);
  EC_KEY *EC_KEY_new_by_curve_name(int nid);
  void EC_KEY_free(EC_KEY *key);
  EC_KEY *EC_KEY_copy(EC_KEY *dst, const EC_KEY *src);
  EC_KEY *EC_KEY_dup(const EC_KEY *src);
  int EC_KEY_up_ref(EC_KEY *key);
  ENGINE *EC_KEY_get0_engine(const EC_KEY *eckey);
  const EC_GROUP *EC_KEY_get0_group(const EC_KEY *key);
  int EC_KEY_set_group(EC_KEY *key, const EC_GROUP *group);
  const BIGNUM *EC_KEY_get0_private_key(const EC_KEY *key);
  int EC_KEY_set_private_key(EC_KEY *key, const BIGNUM *prv);
  const EC_POINT *EC_KEY_get0_public_key(const EC_KEY *key);
  int EC_KEY_set_public_key(EC_KEY *key, const EC_POINT *pub);
  unsigned EC_KEY_get_enc_flags(const EC_KEY *key);
  void EC_KEY_set_enc_flags(EC_KEY *eckey, unsigned int flags);
  point_conversion_form_t EC_KEY_get_conv_form(const EC_KEY *key);
  void EC_KEY_set_conv_form(EC_KEY *eckey, point_conversion_form_t cform);
  int EC_KEY_set_ex_data(EC_KEY *key, int idx, void *arg);
  void *EC_KEY_get_ex_data(const EC_KEY *key, int idx);
  void EC_KEY_set_asn1_flag(EC_KEY *eckey, int asn1_flag);
  int EC_KEY_precompute_mult(EC_KEY *key, BN_CTX *ctx);
  int EC_KEY_generate_key(EC_KEY *key);
  int EC_KEY_check_key(const EC_KEY *key);
  int EC_KEY_can_sign(const EC_KEY *eckey);
  int EC_KEY_set_public_key_affine_coordinates(EC_KEY *key, BIGNUM *x,
                                               BIGNUM *y);
  size_t EC_KEY_key2buf(const EC_KEY *key, point_conversion_form_t form,
                        unsigned char **pbuf, BN_CTX *ctx);
  int EC_KEY_oct2key(EC_KEY *key, const unsigned char *buf, size_t len,
                     BN_CTX *ctx);
  int EC_KEY_oct2priv(EC_KEY *key, const unsigned char *buf, size_t len);
  size_t EC_KEY_priv2oct(const EC_KEY *key, unsigned char *buf, size_t len);
  size_t EC_KEY_priv2buf(const EC_KEY *eckey, unsigned char **pbuf);
  EC_KEY *d2i_ECPrivateKey(EC_KEY **key, const unsigned char **in, long len);
  int i2d_ECPrivateKey(EC_KEY *key, unsigned char **out);
  EC_KEY *d2i_ECParameters(EC_KEY **key, const unsigned char **in, long len);
  int i2d_ECParameters(EC_KEY *key, unsigned char **out);
  EC_KEY *o2i_ECPublicKey(EC_KEY **key, const unsigned char **in, long len);
  int i2o_ECPublicKey(const EC_KEY *key, unsigned char **out);
  int ECParameters_print(BIO *bp, const EC_KEY *key);
  int EC_KEY_print(BIO *bp, const EC_KEY *key, int off);
  int ECParameters_print_fp(FILE *fp, const EC_KEY *key);
  int EC_KEY_print_fp(FILE *fp, const EC_KEY *key, int off);
  const EC_KEY_METHOD *EC_KEY_OpenSSL(void);
  const EC_KEY_METHOD *EC_KEY_get_default_method(void);
  void EC_KEY_set_default_method(const EC_KEY_METHOD *meth);
  const EC_KEY_METHOD *EC_KEY_get_method(const EC_KEY *key);
  int EC_KEY_set_method(EC_KEY *key, const EC_KEY_METHOD *meth);
  EC_KEY *EC_KEY_new_method(ENGINE *engine);
  int ECDH_KDF_X9_62(unsigned char *out, size_t outlen,
                     const unsigned char *Z, size_t Zlen,
                     const unsigned char *sinfo, size_t sinfolen,
                     const EVP_MD *md);
  int ECDH_compute_key(void *out, size_t outlen, const EC_POINT *pub_key,
                       const EC_KEY *ecdh,
                       void *(*KDF)(const void *in, size_t inlen,
                                    void *out, size_t *outlen));
  typedef struct ECDSA_SIG_st ECDSA_SIG;
  ECDSA_SIG *ECDSA_SIG_new(void);
  void ECDSA_SIG_free(ECDSA_SIG *sig);
  int i2d_ECDSA_SIG(const ECDSA_SIG *sig, unsigned char **pp);
  ECDSA_SIG *d2i_ECDSA_SIG(ECDSA_SIG **sig, const unsigned char **pp, long len);
  void ECDSA_SIG_get0(const ECDSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps);
  const BIGNUM *ECDSA_SIG_get0_r(const ECDSA_SIG *sig);
  const BIGNUM *ECDSA_SIG_get0_s(const ECDSA_SIG *sig);
  int ECDSA_SIG_set0(ECDSA_SIG *sig, BIGNUM *r, BIGNUM *s);
  ECDSA_SIG *ECDSA_do_sign(const unsigned char *dgst, int dgst_len,
                           EC_KEY *eckey);
  ECDSA_SIG *ECDSA_do_sign_ex(const unsigned char *dgst, int dgstlen,
                              const BIGNUM *kinv, const BIGNUM *rp,
                              EC_KEY *eckey);
  int ECDSA_do_verify(const unsigned char *dgst, int dgst_len,
                      const ECDSA_SIG *sig, EC_KEY *eckey);
  int ECDSA_sign_setup(EC_KEY *eckey, BN_CTX *ctx, BIGNUM **kinv, BIGNUM **rp);
  int ECDSA_sign(int type, const unsigned char *dgst, int dgstlen,
                 unsigned char *sig, unsigned int *siglen, EC_KEY *eckey);
  int ECDSA_sign_ex(int type, const unsigned char *dgst, int dgstlen,
                    unsigned char *sig, unsigned int *siglen,
                    const BIGNUM *kinv, const BIGNUM *rp, EC_KEY *eckey);
  int ECDSA_verify(int type, const unsigned char *dgst, int dgstlen,
                   const unsigned char *sig, int siglen, EC_KEY *eckey);
  int ECDSA_size(const EC_KEY *eckey);
  EC_KEY_METHOD *EC_KEY_METHOD_new(const EC_KEY_METHOD *meth);
  void EC_KEY_METHOD_free(EC_KEY_METHOD *meth);
  void EC_KEY_METHOD_set_init(EC_KEY_METHOD *meth,
                              int (*init)(EC_KEY *key),
                              void (*finish)(EC_KEY *key),
                              int (*copy)(EC_KEY *dest, const EC_KEY *src),
                              int (*set_group)(EC_KEY *key, const EC_GROUP *grp),
                              int (*set_private)(EC_KEY *key,
                                                 const BIGNUM *priv_key),
                              int (*set_public)(EC_KEY *key,
                                                const EC_POINT *pub_key));
  void EC_KEY_METHOD_set_keygen(EC_KEY_METHOD *meth,
                                int (*keygen)(EC_KEY *key));
  void EC_KEY_METHOD_set_compute_key(EC_KEY_METHOD *meth,
                                     int (*ckey)(unsigned char **psec,
                                                 size_t *pseclen,
                                                 const EC_POINT *pub_key,
                                                 const EC_KEY *ecdh));
  void EC_KEY_METHOD_set_sign(EC_KEY_METHOD *meth,
                              int (*sign)(int type, const unsigned char *dgst,
                                          int dlen, unsigned char *sig,
                                          unsigned int *siglen,
                                          const BIGNUM *kinv, const BIGNUM *r,
                                          EC_KEY *eckey),
                              int (*sign_setup)(EC_KEY *eckey, BN_CTX *ctx_in,
                                                BIGNUM **kinvp, BIGNUM **rp),
                              ECDSA_SIG *(*sign_sig)(const unsigned char *dgst,
                                                     int dgst_len,
                                                     const BIGNUM *in_kinv,
                                                     const BIGNUM *in_r,
                                                     EC_KEY *eckey));
  void EC_KEY_METHOD_set_verify(EC_KEY_METHOD *meth,
                                int (*verify)(int type, const unsigned char *dgst, int dgst_len,
                                              const unsigned char *sigbuf,
                                              int sig_len, EC_KEY *eckey),
                                int (*verify_sig)(const unsigned char *dgst,
                                                  int dgst_len,
                                                  const ECDSA_SIG *sig,
                                                  EC_KEY *eckey));
  void EC_KEY_METHOD_get_init(const EC_KEY_METHOD *meth,
                              int (**pinit)(EC_KEY *key),
                              void (**pfinish)(EC_KEY *key),
                              int (**pcopy)(EC_KEY *dest, const EC_KEY *src),
                              int (**pset_group)(EC_KEY *key,
                                                 const EC_GROUP *grp),
                              int (**pset_private)(EC_KEY *key,
                                                   const BIGNUM *priv_key),
                              int (**pset_public)(EC_KEY *key,
                                                  const EC_POINT *pub_key));
  void EC_KEY_METHOD_get_keygen(const EC_KEY_METHOD *meth,
                                int (**pkeygen)(EC_KEY *key));
  void EC_KEY_METHOD_get_compute_key(const EC_KEY_METHOD *meth,
                                     int (**pck)(unsigned char **psec,
                                                 size_t *pseclen,
                                                 const EC_POINT *pub_key,
                                                 const EC_KEY *ecdh));
  void EC_KEY_METHOD_get_sign(const EC_KEY_METHOD *meth,
                              int (**psign)(int type, const unsigned char *dgst,
                                            int dlen, unsigned char *sig,
                                            unsigned int *siglen,
                                            const BIGNUM *kinv, const BIGNUM *r,
                                            EC_KEY *eckey),
                              int (**psign_setup)(EC_KEY *eckey, BN_CTX *ctx_in,
                                                  BIGNUM **kinvp, BIGNUM **rp),
                              ECDSA_SIG *(**psign_sig)(const unsigned char *dgst,
                                                       int dgst_len,
                                                       const BIGNUM *in_kinv,
                                                       const BIGNUM *in_r,
                                                       EC_KEY *eckey));
  void EC_KEY_METHOD_get_verify(const EC_KEY_METHOD *meth,
                                int (**pverify)(int type, const unsigned char *dgst, int dgst_len,
                                                const unsigned char *sigbuf,
                                                int sig_len, EC_KEY *eckey),
                                int (**pverify_sig)(const unsigned char *dgst,
                                                    int dgst_len,
                                                    const ECDSA_SIG *sig,
                                                    EC_KEY *eckey));
}
extern "C"
{
}
extern "C" int ERR_load_RSA_strings(void);
extern "C"
{
  RSA *RSA_new(void);
  RSA *RSA_new_method(ENGINE *engine);
  int RSA_bits(const RSA *rsa);
  int RSA_size(const RSA *rsa);
  int RSA_security_bits(const RSA *rsa);
  int RSA_set0_key(RSA *r, BIGNUM *n, BIGNUM *e, BIGNUM *d);
  int RSA_set0_factors(RSA *r, BIGNUM *p, BIGNUM *q);
  int RSA_set0_crt_params(RSA *r, BIGNUM *dmp1, BIGNUM *dmq1, BIGNUM *iqmp);
  int RSA_set0_multi_prime_params(RSA *r, BIGNUM *primes[], BIGNUM *exps[],
                                  BIGNUM *coeffs[], int pnum);
  void RSA_get0_key(const RSA *r,
                    const BIGNUM **n, const BIGNUM **e, const BIGNUM **d);
  void RSA_get0_factors(const RSA *r, const BIGNUM **p, const BIGNUM **q);
  int RSA_get_multi_prime_extra_count(const RSA *r);
  int RSA_get0_multi_prime_factors(const RSA *r, const BIGNUM *primes[]);
  void RSA_get0_crt_params(const RSA *r,
                           const BIGNUM **dmp1, const BIGNUM **dmq1,
                           const BIGNUM **iqmp);
  int RSA_get0_multi_prime_crt_params(const RSA *r, const BIGNUM *exps[],
                                      const BIGNUM *coeffs[]);
  const BIGNUM *RSA_get0_n(const RSA *d);
  const BIGNUM *RSA_get0_e(const RSA *d);
  const BIGNUM *RSA_get0_d(const RSA *d);
  const BIGNUM *RSA_get0_p(const RSA *d);
  const BIGNUM *RSA_get0_q(const RSA *d);
  const BIGNUM *RSA_get0_dmp1(const RSA *r);
  const BIGNUM *RSA_get0_dmq1(const RSA *r);
  const BIGNUM *RSA_get0_iqmp(const RSA *r);
  const RSA_PSS_PARAMS *RSA_get0_pss_params(const RSA *r);
  void RSA_clear_flags(RSA *r, int flags);
  int RSA_test_flags(const RSA *r, int flags);
  void RSA_set_flags(RSA *r, int flags);
  int RSA_get_version(RSA *r);
  ENGINE *RSA_get0_engine(const RSA *r);
  RSA *RSA_generate_key(int bits, unsigned long e, void (*callback)(int, int, void *), void *cb_arg) __attribute__((deprecated));
  int RSA_generate_key_ex(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);
  int RSA_generate_multi_prime_key(RSA *rsa, int bits, int primes,
                                   BIGNUM *e, BN_GENCB *cb);
  int RSA_X931_derive_ex(RSA *rsa, BIGNUM *p1, BIGNUM *p2, BIGNUM *q1,
                         BIGNUM *q2, const BIGNUM *Xp1, const BIGNUM *Xp2,
                         const BIGNUM *Xp, const BIGNUM *Xq1, const BIGNUM *Xq2,
                         const BIGNUM *Xq, const BIGNUM *e, BN_GENCB *cb);
  int RSA_X931_generate_key_ex(RSA *rsa, int bits, const BIGNUM *e,
                               BN_GENCB *cb);
  int RSA_check_key(const RSA *);
  int RSA_check_key_ex(const RSA *, BN_GENCB *cb);
  int RSA_public_encrypt(int flen, const unsigned char *from,
                         unsigned char *to, RSA *rsa, int padding);
  int RSA_private_encrypt(int flen, const unsigned char *from,
                          unsigned char *to, RSA *rsa, int padding);
  int RSA_public_decrypt(int flen, const unsigned char *from,
                         unsigned char *to, RSA *rsa, int padding);
  int RSA_private_decrypt(int flen, const unsigned char *from,
                          unsigned char *to, RSA *rsa, int padding);
  void RSA_free(RSA *r);
  int RSA_up_ref(RSA *r);
  int RSA_flags(const RSA *r);
  void RSA_set_default_method(const RSA_METHOD *meth);
  const RSA_METHOD *RSA_get_default_method(void);
  const RSA_METHOD *RSA_null_method(void);
  const RSA_METHOD *RSA_get_method(const RSA *rsa);
  int RSA_set_method(RSA *rsa, const RSA_METHOD *meth);
  const RSA_METHOD *RSA_PKCS1_OpenSSL(void);
  int RSA_pkey_ctx_ctrl(EVP_PKEY_CTX *ctx, int optype, int cmd, int p1, void *p2);
  RSA *d2i_RSAPublicKey(RSA **a, const unsigned char **in, long len);
  int i2d_RSAPublicKey(const RSA *a, unsigned char **out);
  extern const ASN1_ITEM RSAPublicKey_it;
  RSA *d2i_RSAPrivateKey(RSA **a, const unsigned char **in, long len);
  int i2d_RSAPrivateKey(const RSA *a, unsigned char **out);
  extern const ASN1_ITEM RSAPrivateKey_it;
  struct rsa_pss_params_st
  {
    X509_ALGOR *hashAlgorithm;
    X509_ALGOR *maskGenAlgorithm;
    ASN1_INTEGER *saltLength;
    ASN1_INTEGER *trailerField;
    X509_ALGOR *maskHash;
  };
  RSA_PSS_PARAMS *RSA_PSS_PARAMS_new(void);
  void RSA_PSS_PARAMS_free(RSA_PSS_PARAMS *a);
  RSA_PSS_PARAMS *d2i_RSA_PSS_PARAMS(RSA_PSS_PARAMS **a, const unsigned char **in, long len);
  int i2d_RSA_PSS_PARAMS(RSA_PSS_PARAMS *a, unsigned char **out);
  extern const ASN1_ITEM RSA_PSS_PARAMS_it;
  typedef struct rsa_oaep_params_st
  {
    X509_ALGOR *hashFunc;
    X509_ALGOR *maskGenFunc;
    X509_ALGOR *pSourceFunc;
    X509_ALGOR *maskHash;
  } RSA_OAEP_PARAMS;
  RSA_OAEP_PARAMS *RSA_OAEP_PARAMS_new(void);
  void RSA_OAEP_PARAMS_free(RSA_OAEP_PARAMS *a);
  RSA_OAEP_PARAMS *d2i_RSA_OAEP_PARAMS(RSA_OAEP_PARAMS **a, const unsigned char **in, long len);
  int i2d_RSA_OAEP_PARAMS(RSA_OAEP_PARAMS *a, unsigned char **out);
  extern const ASN1_ITEM RSA_OAEP_PARAMS_it;
  int RSA_print_fp(FILE *fp, const RSA *r, int offset);
  int RSA_print(BIO *bp, const RSA *r, int offset);
  int RSA_sign(int type, const unsigned char *m, unsigned int m_length,
               unsigned char *sigret, unsigned int *siglen, RSA *rsa);
  int RSA_verify(int type, const unsigned char *m, unsigned int m_length,
                 const unsigned char *sigbuf, unsigned int siglen, RSA *rsa);
  int RSA_sign_ASN1_OCTET_STRING(int type,
                                 const unsigned char *m, unsigned int m_length,
                                 unsigned char *sigret, unsigned int *siglen,
                                 RSA *rsa);
  int RSA_verify_ASN1_OCTET_STRING(int type, const unsigned char *m,
                                   unsigned int m_length, unsigned char *sigbuf,
                                   unsigned int siglen, RSA *rsa);
  int RSA_blinding_on(RSA *rsa, BN_CTX *ctx);
  void RSA_blinding_off(RSA *rsa);
  BN_BLINDING *RSA_setup_blinding(RSA *rsa, BN_CTX *ctx);
  int RSA_padding_add_PKCS1_type_1(unsigned char *to, int tlen,
                                   const unsigned char *f, int fl);
  int RSA_padding_check_PKCS1_type_1(unsigned char *to, int tlen,
                                     const unsigned char *f, int fl,
                                     int rsa_len);
  int RSA_padding_add_PKCS1_type_2(unsigned char *to, int tlen,
                                   const unsigned char *f, int fl);
  int RSA_padding_check_PKCS1_type_2(unsigned char *to, int tlen,
                                     const unsigned char *f, int fl,
                                     int rsa_len);
  int PKCS1_MGF1(unsigned char *mask, long len, const unsigned char *seed,
                 long seedlen, const EVP_MD *dgst);
  int RSA_padding_add_PKCS1_OAEP(unsigned char *to, int tlen,
                                 const unsigned char *f, int fl,
                                 const unsigned char *p, int pl);
  int RSA_padding_check_PKCS1_OAEP(unsigned char *to, int tlen,
                                   const unsigned char *f, int fl, int rsa_len,
                                   const unsigned char *p, int pl);
  int RSA_padding_add_PKCS1_OAEP_mgf1(unsigned char *to, int tlen,
                                      const unsigned char *from, int flen,
                                      const unsigned char *param, int plen,
                                      const EVP_MD *md, const EVP_MD *mgf1md);
  int RSA_padding_check_PKCS1_OAEP_mgf1(unsigned char *to, int tlen,
                                        const unsigned char *from, int flen,
                                        int num, const unsigned char *param,
                                        int plen, const EVP_MD *md,
                                        const EVP_MD *mgf1md);
  int RSA_padding_add_SSLv23(unsigned char *to, int tlen,
                             const unsigned char *f, int fl);
  int RSA_padding_check_SSLv23(unsigned char *to, int tlen,
                               const unsigned char *f, int fl, int rsa_len);
  int RSA_padding_add_none(unsigned char *to, int tlen, const unsigned char *f,
                           int fl);
  int RSA_padding_check_none(unsigned char *to, int tlen,
                             const unsigned char *f, int fl, int rsa_len);
  int RSA_padding_add_X931(unsigned char *to, int tlen, const unsigned char *f,
                           int fl);
  int RSA_padding_check_X931(unsigned char *to, int tlen,
                             const unsigned char *f, int fl, int rsa_len);
  int RSA_X931_hash_id(int nid);
  int RSA_verify_PKCS1_PSS(RSA *rsa, const unsigned char *mHash,
                           const EVP_MD *Hash, const unsigned char *EM,
                           int sLen);
  int RSA_padding_add_PKCS1_PSS(RSA *rsa, unsigned char *EM,
                                const unsigned char *mHash, const EVP_MD *Hash,
                                int sLen);
  int RSA_verify_PKCS1_PSS_mgf1(RSA *rsa, const unsigned char *mHash,
                                const EVP_MD *Hash, const EVP_MD *mgf1Hash,
                                const unsigned char *EM, int sLen);
  int RSA_padding_add_PKCS1_PSS_mgf1(RSA *rsa, unsigned char *EM,
                                     const unsigned char *mHash,
                                     const EVP_MD *Hash, const EVP_MD *mgf1Hash,
                                     int sLen);
  int RSA_set_ex_data(RSA *r, int idx, void *arg);
  void *RSA_get_ex_data(const RSA *r, int idx);
  RSA *RSAPublicKey_dup(RSA *rsa);
  RSA *RSAPrivateKey_dup(RSA *rsa);
  RSA_METHOD *RSA_meth_new(const char *name, int flags);
  void RSA_meth_free(RSA_METHOD *meth);
  RSA_METHOD *RSA_meth_dup(const RSA_METHOD *meth);
  const char *RSA_meth_get0_name(const RSA_METHOD *meth);
  int RSA_meth_set1_name(RSA_METHOD *meth, const char *name);
  int RSA_meth_get_flags(const RSA_METHOD *meth);
  int RSA_meth_set_flags(RSA_METHOD *meth, int flags);
  void *RSA_meth_get0_app_data(const RSA_METHOD *meth);
  int RSA_meth_set0_app_data(RSA_METHOD *meth, void *app_data);
  int (*RSA_meth_get_pub_enc(const RSA_METHOD *meth))(int flen, const unsigned char *from,
                                                      unsigned char *to, RSA *rsa, int padding);
  int RSA_meth_set_pub_enc(RSA_METHOD *rsa,
                           int (*pub_enc)(int flen, const unsigned char *from,
                                          unsigned char *to, RSA *rsa,
                                          int padding));
  int (*RSA_meth_get_pub_dec(const RSA_METHOD *meth))(int flen, const unsigned char *from,
                                                      unsigned char *to, RSA *rsa, int padding);
  int RSA_meth_set_pub_dec(RSA_METHOD *rsa,
                           int (*pub_dec)(int flen, const unsigned char *from,
                                          unsigned char *to, RSA *rsa,
                                          int padding));
  int (*RSA_meth_get_priv_enc(const RSA_METHOD *meth))(int flen, const unsigned char *from,
                                                       unsigned char *to, RSA *rsa, int padding);
  int RSA_meth_set_priv_enc(RSA_METHOD *rsa,
                            int (*priv_enc)(int flen, const unsigned char *from,
                                            unsigned char *to, RSA *rsa,
                                            int padding));
  int (*RSA_meth_get_priv_dec(const RSA_METHOD *meth))(int flen, const unsigned char *from,
                                                       unsigned char *to, RSA *rsa, int padding);
  int RSA_meth_set_priv_dec(RSA_METHOD *rsa,
                            int (*priv_dec)(int flen, const unsigned char *from,
                                            unsigned char *to, RSA *rsa,
                                            int padding));
  int (*RSA_meth_get_mod_exp(const RSA_METHOD *meth))(BIGNUM *r0, const BIGNUM *i, RSA *rsa, BN_CTX *ctx);
  int RSA_meth_set_mod_exp(RSA_METHOD *rsa,
                           int (*mod_exp)(BIGNUM *r0, const BIGNUM *i, RSA *rsa,
                                          BN_CTX *ctx));
  int (*RSA_meth_get_bn_mod_exp(const RSA_METHOD *meth))(BIGNUM *r, const BIGNUM *a, const BIGNUM *p,
                                                         const BIGNUM *m, BN_CTX *ctx, BN_MONT_CTX *m_ctx);
  int RSA_meth_set_bn_mod_exp(RSA_METHOD *rsa,
                              int (*bn_mod_exp)(BIGNUM *r,
                                                const BIGNUM *a,
                                                const BIGNUM *p,
                                                const BIGNUM *m,
                                                BN_CTX *ctx,
                                                BN_MONT_CTX *m_ctx));
  int (*RSA_meth_get_init(const RSA_METHOD *meth))(RSA *rsa);
  int RSA_meth_set_init(RSA_METHOD *rsa, int (*init)(RSA *rsa));
  int (*RSA_meth_get_finish(const RSA_METHOD *meth))(RSA *rsa);
  int RSA_meth_set_finish(RSA_METHOD *rsa, int (*finish)(RSA *rsa));
  int (*RSA_meth_get_sign(const RSA_METHOD *meth))(int type,
                                                   const unsigned char *m, unsigned int m_length,
                                                   unsigned char *sigret, unsigned int *siglen,
                                                   const RSA *rsa);
  int RSA_meth_set_sign(RSA_METHOD *rsa,
                        int (*sign)(int type, const unsigned char *m,
                                    unsigned int m_length,
                                    unsigned char *sigret, unsigned int *siglen,
                                    const RSA *rsa));
  int (*RSA_meth_get_verify(const RSA_METHOD *meth))(int dtype, const unsigned char *m,
                                                     unsigned int m_length, const unsigned char *sigbuf,
                                                     unsigned int siglen, const RSA *rsa);
  int RSA_meth_set_verify(RSA_METHOD *rsa,
                          int (*verify)(int dtype, const unsigned char *m,
                                        unsigned int m_length,
                                        const unsigned char *sigbuf,
                                        unsigned int siglen, const RSA *rsa));
  int (*RSA_meth_get_keygen(const RSA_METHOD *meth))(RSA *rsa, int bits, BIGNUM *e, BN_GENCB *cb);
  int RSA_meth_set_keygen(RSA_METHOD *rsa,
                          int (*keygen)(RSA *rsa, int bits, BIGNUM *e,
                                        BN_GENCB *cb));
  int (*RSA_meth_get_multi_prime_keygen(const RSA_METHOD *meth))(RSA *rsa, int bits, int primes, BIGNUM *e, BN_GENCB *cb);
  int RSA_meth_set_multi_prime_keygen(RSA_METHOD *meth,
                                      int (*keygen)(RSA *rsa, int bits,
                                                    int primes, BIGNUM *e,
                                                    BN_GENCB *cb));
}
extern "C"
{
}
extern "C"
{
  extern "C"
  {
  }
  extern "C"
  {
  }
  extern "C" int ERR_load_DH_strings(void);
  extern "C"
  {
    extern const ASN1_ITEM DHparams_it;
    DH *DHparams_dup(DH *);
    const DH_METHOD *DH_OpenSSL(void);
    void DH_set_default_method(const DH_METHOD *meth);
    const DH_METHOD *DH_get_default_method(void);
    int DH_set_method(DH *dh, const DH_METHOD *meth);
    DH *DH_new_method(ENGINE *engine);
    DH *DH_new(void);
    void DH_free(DH *dh);
    int DH_up_ref(DH *dh);
    int DH_bits(const DH *dh);
    int DH_size(const DH *dh);
    int DH_security_bits(const DH *dh);
    int DH_set_ex_data(DH *d, int idx, void *arg);
    void *DH_get_ex_data(DH *d, int idx);
    DH *DH_generate_parameters(int prime_len, int generator, void (*callback)(int, int, void *), void *cb_arg) __attribute__((deprecated));
    int DH_generate_parameters_ex(DH *dh, int prime_len, int generator,
                                  BN_GENCB *cb);
    int DH_check_params_ex(const DH *dh);
    int DH_check_ex(const DH *dh);
    int DH_check_pub_key_ex(const DH *dh, const BIGNUM *pub_key);
    int DH_check_params(const DH *dh, int *ret);
    int DH_check(const DH *dh, int *codes);
    int DH_check_pub_key(const DH *dh, const BIGNUM *pub_key, int *codes);
    int DH_generate_key(DH *dh);
    int DH_compute_key(unsigned char *key, const BIGNUM *pub_key, DH *dh);
    int DH_compute_key_padded(unsigned char *key, const BIGNUM *pub_key, DH *dh);
    DH *d2i_DHparams(DH **a, const unsigned char **pp, long length);
    int i2d_DHparams(const DH *a, unsigned char **pp);
    DH *d2i_DHxparams(DH **a, const unsigned char **pp, long length);
    int i2d_DHxparams(const DH *a, unsigned char **pp);
    int DHparams_print_fp(FILE *fp, const DH *x);
    int DHparams_print(BIO *bp, const DH *x);
    DH *DH_get_1024_160(void);
    DH *DH_get_2048_224(void);
    DH *DH_get_2048_256(void);
    DH *DH_new_by_nid(int nid);
    int DH_get_nid(const DH *dh);
    int DH_KDF_X9_42(unsigned char *out, size_t outlen,
                     const unsigned char *Z, size_t Zlen,
                     ASN1_OBJECT *key_oid,
                     const unsigned char *ukm, size_t ukmlen, const EVP_MD *md);
    void DH_get0_pqg(const DH *dh,
                     const BIGNUM **p, const BIGNUM **q, const BIGNUM **g);
    int DH_set0_pqg(DH *dh, BIGNUM *p, BIGNUM *q, BIGNUM *g);
    void DH_get0_key(const DH *dh,
                     const BIGNUM **pub_key, const BIGNUM **priv_key);
    int DH_set0_key(DH *dh, BIGNUM *pub_key, BIGNUM *priv_key);
    const BIGNUM *DH_get0_p(const DH *dh);
    const BIGNUM *DH_get0_q(const DH *dh);
    const BIGNUM *DH_get0_g(const DH *dh);
    const BIGNUM *DH_get0_priv_key(const DH *dh);
    const BIGNUM *DH_get0_pub_key(const DH *dh);
    void DH_clear_flags(DH *dh, int flags);
    int DH_test_flags(const DH *dh, int flags);
    void DH_set_flags(DH *dh, int flags);
    ENGINE *DH_get0_engine(DH *d);
    long DH_get_length(const DH *dh);
    int DH_set_length(DH *dh, long length);
    DH_METHOD *DH_meth_new(const char *name, int flags);
    void DH_meth_free(DH_METHOD *dhm);
    DH_METHOD *DH_meth_dup(const DH_METHOD *dhm);
    const char *DH_meth_get0_name(const DH_METHOD *dhm);
    int DH_meth_set1_name(DH_METHOD *dhm, const char *name);
    int DH_meth_get_flags(const DH_METHOD *dhm);
    int DH_meth_set_flags(DH_METHOD *dhm, int flags);
    void *DH_meth_get0_app_data(const DH_METHOD *dhm);
    int DH_meth_set0_app_data(DH_METHOD *dhm, void *app_data);
    int (*DH_meth_get_generate_key(const DH_METHOD *dhm))(DH *);
    int DH_meth_set_generate_key(DH_METHOD *dhm, int (*generate_key)(DH *));
    int (*DH_meth_get_compute_key(const DH_METHOD *dhm))(unsigned char *key, const BIGNUM *pub_key, DH *dh);
    int DH_meth_set_compute_key(DH_METHOD *dhm,
                                int (*compute_key)(unsigned char *key, const BIGNUM *pub_key, DH *dh));
    int (*DH_meth_get_bn_mod_exp(const DH_METHOD *dhm))(const DH *, BIGNUM *, const BIGNUM *, const BIGNUM *, const BIGNUM *,
                                                        BN_CTX *, BN_MONT_CTX *);
    int DH_meth_set_bn_mod_exp(DH_METHOD *dhm,
                               int (*bn_mod_exp)(const DH *, BIGNUM *, const BIGNUM *, const BIGNUM *,
                                                 const BIGNUM *, BN_CTX *, BN_MONT_CTX *));
    int (*DH_meth_get_init(const DH_METHOD *dhm))(DH *);
    int DH_meth_set_init(DH_METHOD *dhm, int (*init)(DH *));
    int (*DH_meth_get_finish(const DH_METHOD *dhm))(DH *);
    int DH_meth_set_finish(DH_METHOD *dhm, int (*finish)(DH *));
    int (*DH_meth_get_generate_params(const DH_METHOD *dhm))(DH *, int, int, BN_GENCB *);
    int DH_meth_set_generate_params(DH_METHOD *dhm,
                                    int (*generate_params)(DH *, int, int, BN_GENCB *));
  }
  extern "C"
  {
  }
  extern "C" int ERR_load_DSA_strings(void);
  typedef struct DSA_SIG_st DSA_SIG;
  DSA *DSAparams_dup(DSA *x);
  DSA_SIG *DSA_SIG_new(void);
  void DSA_SIG_free(DSA_SIG *a);
  int i2d_DSA_SIG(const DSA_SIG *a, unsigned char **pp);
  DSA_SIG *d2i_DSA_SIG(DSA_SIG **v, const unsigned char **pp, long length);
  void DSA_SIG_get0(const DSA_SIG *sig, const BIGNUM **pr, const BIGNUM **ps);
  int DSA_SIG_set0(DSA_SIG *sig, BIGNUM *r, BIGNUM *s);
  DSA_SIG *DSA_do_sign(const unsigned char *dgst, int dlen, DSA *dsa);
  int DSA_do_verify(const unsigned char *dgst, int dgst_len,
                    DSA_SIG *sig, DSA *dsa);
  const DSA_METHOD *DSA_OpenSSL(void);
  void DSA_set_default_method(const DSA_METHOD *);
  const DSA_METHOD *DSA_get_default_method(void);
  int DSA_set_method(DSA *dsa, const DSA_METHOD *);
  const DSA_METHOD *DSA_get_method(DSA *d);
  DSA *DSA_new(void);
  DSA *DSA_new_method(ENGINE *engine);
  void DSA_free(DSA *r);
  int DSA_up_ref(DSA *r);
  int DSA_size(const DSA *);
  int DSA_bits(const DSA *d);
  int DSA_security_bits(const DSA *d);
  int DSA_sign_setup(DSA *dsa, BN_CTX *ctx_in, BIGNUM **kinvp, BIGNUM **rp);
  int DSA_sign(int type, const unsigned char *dgst, int dlen,
               unsigned char *sig, unsigned int *siglen, DSA *dsa);
  int DSA_verify(int type, const unsigned char *dgst, int dgst_len,
                 const unsigned char *sigbuf, int siglen, DSA *dsa);
  int DSA_set_ex_data(DSA *d, int idx, void *arg);
  void *DSA_get_ex_data(DSA *d, int idx);
  DSA *d2i_DSAPublicKey(DSA **a, const unsigned char **pp, long length);
  DSA *d2i_DSAPrivateKey(DSA **a, const unsigned char **pp, long length);
  DSA *d2i_DSAparams(DSA **a, const unsigned char **pp, long length);
  DSA *DSA_generate_parameters(int bits, unsigned char *seed, int seed_len, int *counter_ret, unsigned long *h_ret, void (*callback)(int, int, void *), void *cb_arg) __attribute__((deprecated));
  int DSA_generate_parameters_ex(DSA *dsa, int bits,
                                 const unsigned char *seed, int seed_len,
                                 int *counter_ret, unsigned long *h_ret,
                                 BN_GENCB *cb);
  int DSA_generate_key(DSA *a);
  int i2d_DSAPublicKey(const DSA *a, unsigned char **pp);
  int i2d_DSAPrivateKey(const DSA *a, unsigned char **pp);
  int i2d_DSAparams(const DSA *a, unsigned char **pp);
  int DSAparams_print(BIO *bp, const DSA *x);
  int DSA_print(BIO *bp, const DSA *x, int off);
  int DSAparams_print_fp(FILE *fp, const DSA *x);
  int DSA_print_fp(FILE *bp, const DSA *x, int off);
  DH *DSA_dup_DH(const DSA *r);
  void DSA_get0_pqg(const DSA *d,
                    const BIGNUM **p, const BIGNUM **q, const BIGNUM **g);
  int DSA_set0_pqg(DSA *d, BIGNUM *p, BIGNUM *q, BIGNUM *g);
  void DSA_get0_key(const DSA *d,
                    const BIGNUM **pub_key, const BIGNUM **priv_key);
  int DSA_set0_key(DSA *d, BIGNUM *pub_key, BIGNUM *priv_key);
  const BIGNUM *DSA_get0_p(const DSA *d);
  const BIGNUM *DSA_get0_q(const DSA *d);
  const BIGNUM *DSA_get0_g(const DSA *d);
  const BIGNUM *DSA_get0_pub_key(const DSA *d);
  const BIGNUM *DSA_get0_priv_key(const DSA *d);
  void DSA_clear_flags(DSA *d, int flags);
  int DSA_test_flags(const DSA *d, int flags);
  void DSA_set_flags(DSA *d, int flags);
  ENGINE *DSA_get0_engine(DSA *d);
  DSA_METHOD *DSA_meth_new(const char *name, int flags);
  void DSA_meth_free(DSA_METHOD *dsam);
  DSA_METHOD *DSA_meth_dup(const DSA_METHOD *dsam);
  const char *DSA_meth_get0_name(const DSA_METHOD *dsam);
  int DSA_meth_set1_name(DSA_METHOD *dsam, const char *name);
  int DSA_meth_get_flags(const DSA_METHOD *dsam);
  int DSA_meth_set_flags(DSA_METHOD *dsam, int flags);
  void *DSA_meth_get0_app_data(const DSA_METHOD *dsam);
  int DSA_meth_set0_app_data(DSA_METHOD *dsam, void *app_data);
  DSA_SIG *(*DSA_meth_get_sign(const DSA_METHOD *dsam))(const unsigned char *, int, DSA *);
  int DSA_meth_set_sign(DSA_METHOD *dsam,
                        DSA_SIG *(*sign)(const unsigned char *, int, DSA *));
  int (*DSA_meth_get_sign_setup(const DSA_METHOD *dsam))(DSA *, BN_CTX *, BIGNUM **, BIGNUM **);
  int DSA_meth_set_sign_setup(DSA_METHOD *dsam,
                              int (*sign_setup)(DSA *, BN_CTX *, BIGNUM **, BIGNUM **));
  int (*DSA_meth_get_verify(const DSA_METHOD *dsam))(const unsigned char *, int, DSA_SIG *, DSA *);
  int DSA_meth_set_verify(DSA_METHOD *dsam,
                          int (*verify)(const unsigned char *, int, DSA_SIG *, DSA *));
  int (*DSA_meth_get_mod_exp(const DSA_METHOD *dsam))(DSA *, BIGNUM *, const BIGNUM *, const BIGNUM *, const BIGNUM *,
                                                      const BIGNUM *, const BIGNUM *, BN_CTX *, BN_MONT_CTX *);
  int DSA_meth_set_mod_exp(DSA_METHOD *dsam,
                           int (*mod_exp)(DSA *, BIGNUM *, const BIGNUM *, const BIGNUM *,
                                          const BIGNUM *, const BIGNUM *, const BIGNUM *, BN_CTX *,
                                          BN_MONT_CTX *));
  int (*DSA_meth_get_bn_mod_exp(const DSA_METHOD *dsam))(DSA *, BIGNUM *, const BIGNUM *, const BIGNUM *, const BIGNUM *,
                                                         BN_CTX *, BN_MONT_CTX *);
  int DSA_meth_set_bn_mod_exp(DSA_METHOD *dsam,
                              int (*bn_mod_exp)(DSA *, BIGNUM *, const BIGNUM *, const BIGNUM *,
                                                const BIGNUM *, BN_CTX *, BN_MONT_CTX *));
  int (*DSA_meth_get_init(const DSA_METHOD *dsam))(DSA *);
  int DSA_meth_set_init(DSA_METHOD *dsam, int (*init)(DSA *));
  int (*DSA_meth_get_finish(const DSA_METHOD *dsam))(DSA *);
  int DSA_meth_set_finish(DSA_METHOD *dsam, int (*finish)(DSA *));
  int (*DSA_meth_get_paramgen(const DSA_METHOD *dsam))(DSA *, int, const unsigned char *, int, int *, unsigned long *,
                                                       BN_GENCB *);
  int DSA_meth_set_paramgen(DSA_METHOD *dsam,
                            int (*paramgen)(DSA *, int, const unsigned char *, int, int *,
                                            unsigned long *, BN_GENCB *));
  int (*DSA_meth_get_keygen(const DSA_METHOD *dsam))(DSA *);
  int DSA_meth_set_keygen(DSA_METHOD *dsam, int (*keygen)(DSA *));
}
extern "C"
{
  typedef struct SHAstate_st
  {
    unsigned int h0, h1, h2, h3, h4;
    unsigned int Nl, Nh;
    unsigned int data[16];
    unsigned int num;
  } SHA_CTX;
  int SHA1_Init(SHA_CTX *c);
  int SHA1_Update(SHA_CTX *c, const void *data, size_t len);
  int SHA1_Final(unsigned char *md, SHA_CTX *c);
  unsigned char *SHA1(const unsigned char *d, size_t n, unsigned char *md);
  void SHA1_Transform(SHA_CTX *c, const unsigned char *data);
  typedef struct SHA256state_st
  {
    unsigned int h[8];
    unsigned int Nl, Nh;
    unsigned int data[16];
    unsigned int num, md_len;
  } SHA256_CTX;
  int SHA224_Init(SHA256_CTX *c);
  int SHA224_Update(SHA256_CTX *c, const void *data, size_t len);
  int SHA224_Final(unsigned char *md, SHA256_CTX *c);
  unsigned char *SHA224(const unsigned char *d, size_t n, unsigned char *md);
  int SHA256_Init(SHA256_CTX *c);
  int SHA256_Update(SHA256_CTX *c, const void *data, size_t len);
  int SHA256_Final(unsigned char *md, SHA256_CTX *c);
  unsigned char *SHA256(const unsigned char *d, size_t n, unsigned char *md);
  void SHA256_Transform(SHA256_CTX *c, const unsigned char *data);
  typedef struct SHA512state_st
  {
    unsigned long long h[8];
    unsigned long long Nl, Nh;
    union
    {
      unsigned long long d[16];
      unsigned char p[(16 * 8)];
    } u;
    unsigned int num, md_len;
  } SHA512_CTX;
  int SHA384_Init(SHA512_CTX *c);
  int SHA384_Update(SHA512_CTX *c, const void *data, size_t len);
  int SHA384_Final(unsigned char *md, SHA512_CTX *c);
  unsigned char *SHA384(const unsigned char *d, size_t n, unsigned char *md);
  int SHA512_Init(SHA512_CTX *c);
  int SHA512_Update(SHA512_CTX *c, const void *data, size_t len);
  int SHA512_Final(unsigned char *md, SHA512_CTX *c);
  unsigned char *SHA512(const unsigned char *d, size_t n, unsigned char *md);
  void SHA512_Transform(SHA512_CTX *c, const unsigned char *data);
}
extern "C" int ERR_load_X509_strings(void);
extern "C"
{
  struct X509_algor_st
  {
    ASN1_OBJECT *algorithm;
    ASN1_TYPE *parameter;
  };
  typedef struct stack_st_X509_ALGOR X509_ALGORS;
  typedef struct X509_val_st
  {
    ASN1_TIME *notBefore;
    ASN1_TIME *notAfter;
  } X509_VAL;
  typedef struct X509_sig_st X509_SIG;
  typedef struct X509_name_entry_st X509_NAME_ENTRY;
  struct stack_st_X509_NAME_ENTRY;
  typedef int (*sk_X509_NAME_ENTRY_compfunc)(const X509_NAME_ENTRY *const *a, const X509_NAME_ENTRY *const *b);
  typedef void (*sk_X509_NAME_ENTRY_freefunc)(X509_NAME_ENTRY *a);
  typedef X509_NAME_ENTRY *(*sk_X509_NAME_ENTRY_copyfunc)(const X509_NAME_ENTRY *a);
  static __attribute__((unused)) inline int sk_X509_NAME_ENTRY_num(const struct stack_st_X509_NAME_ENTRY *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_NAME_ENTRY *sk_X509_NAME_ENTRY_value(const struct stack_st_X509_NAME_ENTRY *sk, int idx) { return (X509_NAME_ENTRY *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_X509_NAME_ENTRY *sk_X509_NAME_ENTRY_new(sk_X509_NAME_ENTRY_compfunc compare) { return (struct stack_st_X509_NAME_ENTRY *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_X509_NAME_ENTRY *sk_X509_NAME_ENTRY_new_null(void) { return (struct stack_st_X509_NAME_ENTRY *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_X509_NAME_ENTRY *sk_X509_NAME_ENTRY_new_reserve(sk_X509_NAME_ENTRY_compfunc compare, int n) { return (struct stack_st_X509_NAME_ENTRY *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_X509_NAME_ENTRY_reserve(struct stack_st_X509_NAME_ENTRY *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_X509_NAME_ENTRY_free(struct stack_st_X509_NAME_ENTRY *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_NAME_ENTRY_zero(struct stack_st_X509_NAME_ENTRY *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_NAME_ENTRY *sk_X509_NAME_ENTRY_delete(struct stack_st_X509_NAME_ENTRY *sk, int i) { return (X509_NAME_ENTRY *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline X509_NAME_ENTRY *sk_X509_NAME_ENTRY_delete_ptr(struct stack_st_X509_NAME_ENTRY *sk, X509_NAME_ENTRY *ptr) { return (X509_NAME_ENTRY *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_NAME_ENTRY_push(struct stack_st_X509_NAME_ENTRY *sk, X509_NAME_ENTRY *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_NAME_ENTRY_unshift(struct stack_st_X509_NAME_ENTRY *sk, X509_NAME_ENTRY *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline X509_NAME_ENTRY *sk_X509_NAME_ENTRY_pop(struct stack_st_X509_NAME_ENTRY *sk) { return (X509_NAME_ENTRY *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_NAME_ENTRY *sk_X509_NAME_ENTRY_shift(struct stack_st_X509_NAME_ENTRY *sk) { return (X509_NAME_ENTRY *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_NAME_ENTRY_pop_free(struct stack_st_X509_NAME_ENTRY *sk, sk_X509_NAME_ENTRY_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_X509_NAME_ENTRY_insert(struct stack_st_X509_NAME_ENTRY *sk, X509_NAME_ENTRY *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline X509_NAME_ENTRY *sk_X509_NAME_ENTRY_set(struct stack_st_X509_NAME_ENTRY *sk, int idx, X509_NAME_ENTRY *ptr) { return (X509_NAME_ENTRY *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_NAME_ENTRY_find(struct stack_st_X509_NAME_ENTRY *sk, X509_NAME_ENTRY *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_NAME_ENTRY_find_ex(struct stack_st_X509_NAME_ENTRY *sk, X509_NAME_ENTRY *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_X509_NAME_ENTRY_sort(struct stack_st_X509_NAME_ENTRY *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_X509_NAME_ENTRY_is_sorted(const struct stack_st_X509_NAME_ENTRY *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_NAME_ENTRY *sk_X509_NAME_ENTRY_dup(const struct stack_st_X509_NAME_ENTRY *sk) { return (struct stack_st_X509_NAME_ENTRY *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_NAME_ENTRY *sk_X509_NAME_ENTRY_deep_copy(const struct stack_st_X509_NAME_ENTRY *sk, sk_X509_NAME_ENTRY_copyfunc copyfunc, sk_X509_NAME_ENTRY_freefunc freefunc) { return (struct stack_st_X509_NAME_ENTRY *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_X509_NAME_ENTRY_compfunc sk_X509_NAME_ENTRY_set_cmp_func(struct stack_st_X509_NAME_ENTRY *sk, sk_X509_NAME_ENTRY_compfunc compare) { return (sk_X509_NAME_ENTRY_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  struct stack_st_X509_NAME;
  typedef int (*sk_X509_NAME_compfunc)(const X509_NAME *const *a, const X509_NAME *const *b);
  typedef void (*sk_X509_NAME_freefunc)(X509_NAME *a);
  typedef X509_NAME *(*sk_X509_NAME_copyfunc)(const X509_NAME *a);
  static __attribute__((unused)) inline int sk_X509_NAME_num(const struct stack_st_X509_NAME *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_NAME *sk_X509_NAME_value(const struct stack_st_X509_NAME *sk, int idx) { return (X509_NAME *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_X509_NAME *sk_X509_NAME_new(sk_X509_NAME_compfunc compare) { return (struct stack_st_X509_NAME *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_X509_NAME *sk_X509_NAME_new_null(void) { return (struct stack_st_X509_NAME *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_X509_NAME *sk_X509_NAME_new_reserve(sk_X509_NAME_compfunc compare, int n) { return (struct stack_st_X509_NAME *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_X509_NAME_reserve(struct stack_st_X509_NAME *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_X509_NAME_free(struct stack_st_X509_NAME *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_NAME_zero(struct stack_st_X509_NAME *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_NAME *sk_X509_NAME_delete(struct stack_st_X509_NAME *sk, int i) { return (X509_NAME *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline X509_NAME *sk_X509_NAME_delete_ptr(struct stack_st_X509_NAME *sk, X509_NAME *ptr) { return (X509_NAME *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_NAME_push(struct stack_st_X509_NAME *sk, X509_NAME *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_NAME_unshift(struct stack_st_X509_NAME *sk, X509_NAME *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline X509_NAME *sk_X509_NAME_pop(struct stack_st_X509_NAME *sk) { return (X509_NAME *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_NAME *sk_X509_NAME_shift(struct stack_st_X509_NAME *sk) { return (X509_NAME *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_NAME_pop_free(struct stack_st_X509_NAME *sk, sk_X509_NAME_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_X509_NAME_insert(struct stack_st_X509_NAME *sk, X509_NAME *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline X509_NAME *sk_X509_NAME_set(struct stack_st_X509_NAME *sk, int idx, X509_NAME *ptr) { return (X509_NAME *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_NAME_find(struct stack_st_X509_NAME *sk, X509_NAME *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_NAME_find_ex(struct stack_st_X509_NAME *sk, X509_NAME *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_X509_NAME_sort(struct stack_st_X509_NAME *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_X509_NAME_is_sorted(const struct stack_st_X509_NAME *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_NAME *sk_X509_NAME_dup(const struct stack_st_X509_NAME *sk) { return (struct stack_st_X509_NAME *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_NAME *sk_X509_NAME_deep_copy(const struct stack_st_X509_NAME *sk, sk_X509_NAME_copyfunc copyfunc, sk_X509_NAME_freefunc freefunc) { return (struct stack_st_X509_NAME *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_X509_NAME_compfunc sk_X509_NAME_set_cmp_func(struct stack_st_X509_NAME *sk, sk_X509_NAME_compfunc compare) { return (sk_X509_NAME_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  typedef struct X509_extension_st X509_EXTENSION;
  typedef struct stack_st_X509_EXTENSION X509_EXTENSIONS;
  struct stack_st_X509_EXTENSION;
  typedef int (*sk_X509_EXTENSION_compfunc)(const X509_EXTENSION *const *a, const X509_EXTENSION *const *b);
  typedef void (*sk_X509_EXTENSION_freefunc)(X509_EXTENSION *a);
  typedef X509_EXTENSION *(*sk_X509_EXTENSION_copyfunc)(const X509_EXTENSION *a);
  static __attribute__((unused)) inline int sk_X509_EXTENSION_num(const struct stack_st_X509_EXTENSION *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_EXTENSION *sk_X509_EXTENSION_value(const struct stack_st_X509_EXTENSION *sk, int idx) { return (X509_EXTENSION *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_X509_EXTENSION *sk_X509_EXTENSION_new(sk_X509_EXTENSION_compfunc compare) { return (struct stack_st_X509_EXTENSION *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_X509_EXTENSION *sk_X509_EXTENSION_new_null(void) { return (struct stack_st_X509_EXTENSION *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_X509_EXTENSION *sk_X509_EXTENSION_new_reserve(sk_X509_EXTENSION_compfunc compare, int n) { return (struct stack_st_X509_EXTENSION *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_X509_EXTENSION_reserve(struct stack_st_X509_EXTENSION *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_X509_EXTENSION_free(struct stack_st_X509_EXTENSION *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_EXTENSION_zero(struct stack_st_X509_EXTENSION *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_EXTENSION *sk_X509_EXTENSION_delete(struct stack_st_X509_EXTENSION *sk, int i) { return (X509_EXTENSION *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline X509_EXTENSION *sk_X509_EXTENSION_delete_ptr(struct stack_st_X509_EXTENSION *sk, X509_EXTENSION *ptr) { return (X509_EXTENSION *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_EXTENSION_push(struct stack_st_X509_EXTENSION *sk, X509_EXTENSION *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_EXTENSION_unshift(struct stack_st_X509_EXTENSION *sk, X509_EXTENSION *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline X509_EXTENSION *sk_X509_EXTENSION_pop(struct stack_st_X509_EXTENSION *sk) { return (X509_EXTENSION *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_EXTENSION *sk_X509_EXTENSION_shift(struct stack_st_X509_EXTENSION *sk) { return (X509_EXTENSION *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_EXTENSION_pop_free(struct stack_st_X509_EXTENSION *sk, sk_X509_EXTENSION_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_X509_EXTENSION_insert(struct stack_st_X509_EXTENSION *sk, X509_EXTENSION *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline X509_EXTENSION *sk_X509_EXTENSION_set(struct stack_st_X509_EXTENSION *sk, int idx, X509_EXTENSION *ptr) { return (X509_EXTENSION *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_EXTENSION_find(struct stack_st_X509_EXTENSION *sk, X509_EXTENSION *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_EXTENSION_find_ex(struct stack_st_X509_EXTENSION *sk, X509_EXTENSION *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_X509_EXTENSION_sort(struct stack_st_X509_EXTENSION *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_X509_EXTENSION_is_sorted(const struct stack_st_X509_EXTENSION *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_EXTENSION *sk_X509_EXTENSION_dup(const struct stack_st_X509_EXTENSION *sk) { return (struct stack_st_X509_EXTENSION *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_EXTENSION *sk_X509_EXTENSION_deep_copy(const struct stack_st_X509_EXTENSION *sk, sk_X509_EXTENSION_copyfunc copyfunc, sk_X509_EXTENSION_freefunc freefunc) { return (struct stack_st_X509_EXTENSION *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_X509_EXTENSION_compfunc sk_X509_EXTENSION_set_cmp_func(struct stack_st_X509_EXTENSION *sk, sk_X509_EXTENSION_compfunc compare) { return (sk_X509_EXTENSION_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  typedef struct x509_attributes_st X509_ATTRIBUTE;
  struct stack_st_X509_ATTRIBUTE;
  typedef int (*sk_X509_ATTRIBUTE_compfunc)(const X509_ATTRIBUTE *const *a, const X509_ATTRIBUTE *const *b);
  typedef void (*sk_X509_ATTRIBUTE_freefunc)(X509_ATTRIBUTE *a);
  typedef X509_ATTRIBUTE *(*sk_X509_ATTRIBUTE_copyfunc)(const X509_ATTRIBUTE *a);
  static __attribute__((unused)) inline int sk_X509_ATTRIBUTE_num(const struct stack_st_X509_ATTRIBUTE *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_ATTRIBUTE *sk_X509_ATTRIBUTE_value(const struct stack_st_X509_ATTRIBUTE *sk, int idx) { return (X509_ATTRIBUTE *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_X509_ATTRIBUTE *sk_X509_ATTRIBUTE_new(sk_X509_ATTRIBUTE_compfunc compare) { return (struct stack_st_X509_ATTRIBUTE *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_X509_ATTRIBUTE *sk_X509_ATTRIBUTE_new_null(void) { return (struct stack_st_X509_ATTRIBUTE *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_X509_ATTRIBUTE *sk_X509_ATTRIBUTE_new_reserve(sk_X509_ATTRIBUTE_compfunc compare, int n) { return (struct stack_st_X509_ATTRIBUTE *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_X509_ATTRIBUTE_reserve(struct stack_st_X509_ATTRIBUTE *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_X509_ATTRIBUTE_free(struct stack_st_X509_ATTRIBUTE *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_ATTRIBUTE_zero(struct stack_st_X509_ATTRIBUTE *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_ATTRIBUTE *sk_X509_ATTRIBUTE_delete(struct stack_st_X509_ATTRIBUTE *sk, int i) { return (X509_ATTRIBUTE *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline X509_ATTRIBUTE *sk_X509_ATTRIBUTE_delete_ptr(struct stack_st_X509_ATTRIBUTE *sk, X509_ATTRIBUTE *ptr) { return (X509_ATTRIBUTE *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_ATTRIBUTE_push(struct stack_st_X509_ATTRIBUTE *sk, X509_ATTRIBUTE *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_ATTRIBUTE_unshift(struct stack_st_X509_ATTRIBUTE *sk, X509_ATTRIBUTE *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline X509_ATTRIBUTE *sk_X509_ATTRIBUTE_pop(struct stack_st_X509_ATTRIBUTE *sk) { return (X509_ATTRIBUTE *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_ATTRIBUTE *sk_X509_ATTRIBUTE_shift(struct stack_st_X509_ATTRIBUTE *sk) { return (X509_ATTRIBUTE *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_ATTRIBUTE_pop_free(struct stack_st_X509_ATTRIBUTE *sk, sk_X509_ATTRIBUTE_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_X509_ATTRIBUTE_insert(struct stack_st_X509_ATTRIBUTE *sk, X509_ATTRIBUTE *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline X509_ATTRIBUTE *sk_X509_ATTRIBUTE_set(struct stack_st_X509_ATTRIBUTE *sk, int idx, X509_ATTRIBUTE *ptr) { return (X509_ATTRIBUTE *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_ATTRIBUTE_find(struct stack_st_X509_ATTRIBUTE *sk, X509_ATTRIBUTE *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_ATTRIBUTE_find_ex(struct stack_st_X509_ATTRIBUTE *sk, X509_ATTRIBUTE *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_X509_ATTRIBUTE_sort(struct stack_st_X509_ATTRIBUTE *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_X509_ATTRIBUTE_is_sorted(const struct stack_st_X509_ATTRIBUTE *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_ATTRIBUTE *sk_X509_ATTRIBUTE_dup(const struct stack_st_X509_ATTRIBUTE *sk) { return (struct stack_st_X509_ATTRIBUTE *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_ATTRIBUTE *sk_X509_ATTRIBUTE_deep_copy(const struct stack_st_X509_ATTRIBUTE *sk, sk_X509_ATTRIBUTE_copyfunc copyfunc, sk_X509_ATTRIBUTE_freefunc freefunc) { return (struct stack_st_X509_ATTRIBUTE *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_X509_ATTRIBUTE_compfunc sk_X509_ATTRIBUTE_set_cmp_func(struct stack_st_X509_ATTRIBUTE *sk, sk_X509_ATTRIBUTE_compfunc compare) { return (sk_X509_ATTRIBUTE_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  typedef struct X509_req_info_st X509_REQ_INFO;
  typedef struct X509_req_st X509_REQ;
  typedef struct x509_cert_aux_st X509_CERT_AUX;
  typedef struct x509_cinf_st X509_CINF;
  struct stack_st_X509;
  typedef int (*sk_X509_compfunc)(const X509 *const *a, const X509 *const *b);
  typedef void (*sk_X509_freefunc)(X509 *a);
  typedef X509 *(*sk_X509_copyfunc)(const X509 *a);
  static __attribute__((unused)) inline int sk_X509_num(const struct stack_st_X509 *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509 *sk_X509_value(const struct stack_st_X509 *sk, int idx) { return (X509 *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_X509 *sk_X509_new(sk_X509_compfunc compare) { return (struct stack_st_X509 *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_X509 *sk_X509_new_null(void) { return (struct stack_st_X509 *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_X509 *sk_X509_new_reserve(sk_X509_compfunc compare, int n) { return (struct stack_st_X509 *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_X509_reserve(struct stack_st_X509 *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_X509_free(struct stack_st_X509 *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_zero(struct stack_st_X509 *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509 *sk_X509_delete(struct stack_st_X509 *sk, int i) { return (X509 *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline X509 *sk_X509_delete_ptr(struct stack_st_X509 *sk, X509 *ptr) { return (X509 *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_push(struct stack_st_X509 *sk, X509 *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_unshift(struct stack_st_X509 *sk, X509 *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline X509 *sk_X509_pop(struct stack_st_X509 *sk) { return (X509 *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509 *sk_X509_shift(struct stack_st_X509 *sk) { return (X509 *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_pop_free(struct stack_st_X509 *sk, sk_X509_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_X509_insert(struct stack_st_X509 *sk, X509 *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline X509 *sk_X509_set(struct stack_st_X509 *sk, int idx, X509 *ptr) { return (X509 *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_find(struct stack_st_X509 *sk, X509 *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_find_ex(struct stack_st_X509 *sk, X509 *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_X509_sort(struct stack_st_X509 *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_X509_is_sorted(const struct stack_st_X509 *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509 *sk_X509_dup(const struct stack_st_X509 *sk) { return (struct stack_st_X509 *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509 *sk_X509_deep_copy(const struct stack_st_X509 *sk, sk_X509_copyfunc copyfunc, sk_X509_freefunc freefunc) { return (struct stack_st_X509 *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_X509_compfunc sk_X509_set_cmp_func(struct stack_st_X509 *sk, sk_X509_compfunc compare) { return (sk_X509_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  typedef struct x509_trust_st
  {
    int trust;
    int flags;
    int (*check_trust)(struct x509_trust_st *, X509 *, int);
    char *name;
    int arg1;
    void *arg2;
  } X509_TRUST;
  struct stack_st_X509_TRUST;
  typedef int (*sk_X509_TRUST_compfunc)(const X509_TRUST *const *a, const X509_TRUST *const *b);
  typedef void (*sk_X509_TRUST_freefunc)(X509_TRUST *a);
  typedef X509_TRUST *(*sk_X509_TRUST_copyfunc)(const X509_TRUST *a);
  static __attribute__((unused)) inline int sk_X509_TRUST_num(const struct stack_st_X509_TRUST *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_TRUST *sk_X509_TRUST_value(const struct stack_st_X509_TRUST *sk, int idx) { return (X509_TRUST *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_X509_TRUST *sk_X509_TRUST_new(sk_X509_TRUST_compfunc compare) { return (struct stack_st_X509_TRUST *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_X509_TRUST *sk_X509_TRUST_new_null(void) { return (struct stack_st_X509_TRUST *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_X509_TRUST *sk_X509_TRUST_new_reserve(sk_X509_TRUST_compfunc compare, int n) { return (struct stack_st_X509_TRUST *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_X509_TRUST_reserve(struct stack_st_X509_TRUST *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_X509_TRUST_free(struct stack_st_X509_TRUST *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_TRUST_zero(struct stack_st_X509_TRUST *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_TRUST *sk_X509_TRUST_delete(struct stack_st_X509_TRUST *sk, int i) { return (X509_TRUST *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline X509_TRUST *sk_X509_TRUST_delete_ptr(struct stack_st_X509_TRUST *sk, X509_TRUST *ptr) { return (X509_TRUST *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_TRUST_push(struct stack_st_X509_TRUST *sk, X509_TRUST *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_TRUST_unshift(struct stack_st_X509_TRUST *sk, X509_TRUST *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline X509_TRUST *sk_X509_TRUST_pop(struct stack_st_X509_TRUST *sk) { return (X509_TRUST *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_TRUST *sk_X509_TRUST_shift(struct stack_st_X509_TRUST *sk) { return (X509_TRUST *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_TRUST_pop_free(struct stack_st_X509_TRUST *sk, sk_X509_TRUST_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_X509_TRUST_insert(struct stack_st_X509_TRUST *sk, X509_TRUST *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline X509_TRUST *sk_X509_TRUST_set(struct stack_st_X509_TRUST *sk, int idx, X509_TRUST *ptr) { return (X509_TRUST *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_TRUST_find(struct stack_st_X509_TRUST *sk, X509_TRUST *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_TRUST_find_ex(struct stack_st_X509_TRUST *sk, X509_TRUST *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_X509_TRUST_sort(struct stack_st_X509_TRUST *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_X509_TRUST_is_sorted(const struct stack_st_X509_TRUST *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_TRUST *sk_X509_TRUST_dup(const struct stack_st_X509_TRUST *sk) { return (struct stack_st_X509_TRUST *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_TRUST *sk_X509_TRUST_deep_copy(const struct stack_st_X509_TRUST *sk, sk_X509_TRUST_copyfunc copyfunc, sk_X509_TRUST_freefunc freefunc) { return (struct stack_st_X509_TRUST *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_X509_TRUST_compfunc sk_X509_TRUST_set_cmp_func(struct stack_st_X509_TRUST *sk, sk_X509_TRUST_compfunc compare) { return (sk_X509_TRUST_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  struct stack_st_X509_REVOKED;
  typedef int (*sk_X509_REVOKED_compfunc)(const X509_REVOKED *const *a, const X509_REVOKED *const *b);
  typedef void (*sk_X509_REVOKED_freefunc)(X509_REVOKED *a);
  typedef X509_REVOKED *(*sk_X509_REVOKED_copyfunc)(const X509_REVOKED *a);
  static __attribute__((unused)) inline int sk_X509_REVOKED_num(const struct stack_st_X509_REVOKED *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_REVOKED *sk_X509_REVOKED_value(const struct stack_st_X509_REVOKED *sk, int idx) { return (X509_REVOKED *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_X509_REVOKED *sk_X509_REVOKED_new(sk_X509_REVOKED_compfunc compare) { return (struct stack_st_X509_REVOKED *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_X509_REVOKED *sk_X509_REVOKED_new_null(void) { return (struct stack_st_X509_REVOKED *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_X509_REVOKED *sk_X509_REVOKED_new_reserve(sk_X509_REVOKED_compfunc compare, int n) { return (struct stack_st_X509_REVOKED *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_X509_REVOKED_reserve(struct stack_st_X509_REVOKED *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_X509_REVOKED_free(struct stack_st_X509_REVOKED *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_REVOKED_zero(struct stack_st_X509_REVOKED *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_REVOKED *sk_X509_REVOKED_delete(struct stack_st_X509_REVOKED *sk, int i) { return (X509_REVOKED *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline X509_REVOKED *sk_X509_REVOKED_delete_ptr(struct stack_st_X509_REVOKED *sk, X509_REVOKED *ptr) { return (X509_REVOKED *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_REVOKED_push(struct stack_st_X509_REVOKED *sk, X509_REVOKED *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_REVOKED_unshift(struct stack_st_X509_REVOKED *sk, X509_REVOKED *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline X509_REVOKED *sk_X509_REVOKED_pop(struct stack_st_X509_REVOKED *sk) { return (X509_REVOKED *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_REVOKED *sk_X509_REVOKED_shift(struct stack_st_X509_REVOKED *sk) { return (X509_REVOKED *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_REVOKED_pop_free(struct stack_st_X509_REVOKED *sk, sk_X509_REVOKED_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_X509_REVOKED_insert(struct stack_st_X509_REVOKED *sk, X509_REVOKED *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline X509_REVOKED *sk_X509_REVOKED_set(struct stack_st_X509_REVOKED *sk, int idx, X509_REVOKED *ptr) { return (X509_REVOKED *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_REVOKED_find(struct stack_st_X509_REVOKED *sk, X509_REVOKED *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_REVOKED_find_ex(struct stack_st_X509_REVOKED *sk, X509_REVOKED *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_X509_REVOKED_sort(struct stack_st_X509_REVOKED *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_X509_REVOKED_is_sorted(const struct stack_st_X509_REVOKED *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_REVOKED *sk_X509_REVOKED_dup(const struct stack_st_X509_REVOKED *sk) { return (struct stack_st_X509_REVOKED *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_REVOKED *sk_X509_REVOKED_deep_copy(const struct stack_st_X509_REVOKED *sk, sk_X509_REVOKED_copyfunc copyfunc, sk_X509_REVOKED_freefunc freefunc) { return (struct stack_st_X509_REVOKED *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_X509_REVOKED_compfunc sk_X509_REVOKED_set_cmp_func(struct stack_st_X509_REVOKED *sk, sk_X509_REVOKED_compfunc compare) { return (sk_X509_REVOKED_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  typedef struct X509_crl_info_st X509_CRL_INFO;
  struct stack_st_X509_CRL;
  typedef int (*sk_X509_CRL_compfunc)(const X509_CRL *const *a, const X509_CRL *const *b);
  typedef void (*sk_X509_CRL_freefunc)(X509_CRL *a);
  typedef X509_CRL *(*sk_X509_CRL_copyfunc)(const X509_CRL *a);
  static __attribute__((unused)) inline int sk_X509_CRL_num(const struct stack_st_X509_CRL *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_CRL *sk_X509_CRL_value(const struct stack_st_X509_CRL *sk, int idx) { return (X509_CRL *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_X509_CRL *sk_X509_CRL_new(sk_X509_CRL_compfunc compare) { return (struct stack_st_X509_CRL *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_X509_CRL *sk_X509_CRL_new_null(void) { return (struct stack_st_X509_CRL *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_X509_CRL *sk_X509_CRL_new_reserve(sk_X509_CRL_compfunc compare, int n) { return (struct stack_st_X509_CRL *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_X509_CRL_reserve(struct stack_st_X509_CRL *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_X509_CRL_free(struct stack_st_X509_CRL *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_CRL_zero(struct stack_st_X509_CRL *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_CRL *sk_X509_CRL_delete(struct stack_st_X509_CRL *sk, int i) { return (X509_CRL *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline X509_CRL *sk_X509_CRL_delete_ptr(struct stack_st_X509_CRL *sk, X509_CRL *ptr) { return (X509_CRL *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_CRL_push(struct stack_st_X509_CRL *sk, X509_CRL *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_CRL_unshift(struct stack_st_X509_CRL *sk, X509_CRL *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline X509_CRL *sk_X509_CRL_pop(struct stack_st_X509_CRL *sk) { return (X509_CRL *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_CRL *sk_X509_CRL_shift(struct stack_st_X509_CRL *sk) { return (X509_CRL *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_CRL_pop_free(struct stack_st_X509_CRL *sk, sk_X509_CRL_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_X509_CRL_insert(struct stack_st_X509_CRL *sk, X509_CRL *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline X509_CRL *sk_X509_CRL_set(struct stack_st_X509_CRL *sk, int idx, X509_CRL *ptr) { return (X509_CRL *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_CRL_find(struct stack_st_X509_CRL *sk, X509_CRL *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_CRL_find_ex(struct stack_st_X509_CRL *sk, X509_CRL *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_X509_CRL_sort(struct stack_st_X509_CRL *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_X509_CRL_is_sorted(const struct stack_st_X509_CRL *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_CRL *sk_X509_CRL_dup(const struct stack_st_X509_CRL *sk) { return (struct stack_st_X509_CRL *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_CRL *sk_X509_CRL_deep_copy(const struct stack_st_X509_CRL *sk, sk_X509_CRL_copyfunc copyfunc, sk_X509_CRL_freefunc freefunc) { return (struct stack_st_X509_CRL *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_X509_CRL_compfunc sk_X509_CRL_set_cmp_func(struct stack_st_X509_CRL *sk, sk_X509_CRL_compfunc compare) { return (sk_X509_CRL_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  typedef struct private_key_st
  {
    int version;
    X509_ALGOR *enc_algor;
    ASN1_OCTET_STRING *enc_pkey;
    EVP_PKEY *dec_pkey;
    int key_length;
    char *key_data;
    int key_free;
    EVP_CIPHER_INFO cipher;
  } X509_PKEY;
  typedef struct X509_info_st
  {
    X509 *x509;
    X509_CRL *crl;
    X509_PKEY *x_pkey;
    EVP_CIPHER_INFO enc_cipher;
    int enc_len;
    char *enc_data;
  } X509_INFO;
  struct stack_st_X509_INFO;
  typedef int (*sk_X509_INFO_compfunc)(const X509_INFO *const *a, const X509_INFO *const *b);
  typedef void (*sk_X509_INFO_freefunc)(X509_INFO *a);
  typedef X509_INFO *(*sk_X509_INFO_copyfunc)(const X509_INFO *a);
  static __attribute__((unused)) inline int sk_X509_INFO_num(const struct stack_st_X509_INFO *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_INFO *sk_X509_INFO_value(const struct stack_st_X509_INFO *sk, int idx) { return (X509_INFO *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_X509_INFO *sk_X509_INFO_new(sk_X509_INFO_compfunc compare) { return (struct stack_st_X509_INFO *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_X509_INFO *sk_X509_INFO_new_null(void) { return (struct stack_st_X509_INFO *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_X509_INFO *sk_X509_INFO_new_reserve(sk_X509_INFO_compfunc compare, int n) { return (struct stack_st_X509_INFO *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_X509_INFO_reserve(struct stack_st_X509_INFO *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_X509_INFO_free(struct stack_st_X509_INFO *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_INFO_zero(struct stack_st_X509_INFO *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_INFO *sk_X509_INFO_delete(struct stack_st_X509_INFO *sk, int i) { return (X509_INFO *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline X509_INFO *sk_X509_INFO_delete_ptr(struct stack_st_X509_INFO *sk, X509_INFO *ptr) { return (X509_INFO *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_INFO_push(struct stack_st_X509_INFO *sk, X509_INFO *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_INFO_unshift(struct stack_st_X509_INFO *sk, X509_INFO *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline X509_INFO *sk_X509_INFO_pop(struct stack_st_X509_INFO *sk) { return (X509_INFO *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_INFO *sk_X509_INFO_shift(struct stack_st_X509_INFO *sk) { return (X509_INFO *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_INFO_pop_free(struct stack_st_X509_INFO *sk, sk_X509_INFO_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_X509_INFO_insert(struct stack_st_X509_INFO *sk, X509_INFO *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline X509_INFO *sk_X509_INFO_set(struct stack_st_X509_INFO *sk, int idx, X509_INFO *ptr) { return (X509_INFO *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_INFO_find(struct stack_st_X509_INFO *sk, X509_INFO *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_INFO_find_ex(struct stack_st_X509_INFO *sk, X509_INFO *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_X509_INFO_sort(struct stack_st_X509_INFO *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_X509_INFO_is_sorted(const struct stack_st_X509_INFO *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_INFO *sk_X509_INFO_dup(const struct stack_st_X509_INFO *sk) { return (struct stack_st_X509_INFO *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_INFO *sk_X509_INFO_deep_copy(const struct stack_st_X509_INFO *sk, sk_X509_INFO_copyfunc copyfunc, sk_X509_INFO_freefunc freefunc) { return (struct stack_st_X509_INFO *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_X509_INFO_compfunc sk_X509_INFO_set_cmp_func(struct stack_st_X509_INFO *sk, sk_X509_INFO_compfunc compare) { return (sk_X509_INFO_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  typedef struct Netscape_spkac_st
  {
    X509_PUBKEY *pubkey;
    ASN1_IA5STRING *challenge;
  } NETSCAPE_SPKAC;
  typedef struct Netscape_spki_st
  {
    NETSCAPE_SPKAC *spkac;
    X509_ALGOR sig_algor;
    ASN1_BIT_STRING *signature;
  } NETSCAPE_SPKI;
  typedef struct Netscape_certificate_sequence
  {
    ASN1_OBJECT *type;
    struct stack_st_X509 *certs;
  } NETSCAPE_CERT_SEQUENCE;
  typedef struct PBEPARAM_st
  {
    ASN1_OCTET_STRING *salt;
    ASN1_INTEGER *iter;
  } PBEPARAM;
  typedef struct PBE2PARAM_st
  {
    X509_ALGOR *keyfunc;
    X509_ALGOR *encryption;
  } PBE2PARAM;
  typedef struct PBKDF2PARAM_st
  {
    ASN1_TYPE *salt;
    ASN1_INTEGER *iter;
    ASN1_INTEGER *keylength;
    X509_ALGOR *prf;
  } PBKDF2PARAM;
  typedef struct SCRYPT_PARAMS_st
  {
    ASN1_OCTET_STRING *salt;
    ASN1_INTEGER *costParameter;
    ASN1_INTEGER *blockSize;
    ASN1_INTEGER *parallelizationParameter;
    ASN1_INTEGER *keyLength;
  } SCRYPT_PARAMS;
}
extern "C"
{
}
extern "C"
{
  typedef struct lhash_node_st OPENSSL_LH_NODE;
  typedef int (*OPENSSL_LH_COMPFUNC)(const void *, const void *);
  typedef unsigned long (*OPENSSL_LH_HASHFUNC)(const void *);
  typedef void (*OPENSSL_LH_DOALL_FUNC)(void *);
  typedef void (*OPENSSL_LH_DOALL_FUNCARG)(void *, void *);
  typedef struct lhash_st OPENSSL_LHASH;
  int OPENSSL_LH_error(OPENSSL_LHASH *lh);
  OPENSSL_LHASH *OPENSSL_LH_new(OPENSSL_LH_HASHFUNC h, OPENSSL_LH_COMPFUNC c);
  void OPENSSL_LH_free(OPENSSL_LHASH *lh);
  void *OPENSSL_LH_insert(OPENSSL_LHASH *lh, void *data);
  void *OPENSSL_LH_delete(OPENSSL_LHASH *lh, const void *data);
  void *OPENSSL_LH_retrieve(OPENSSL_LHASH *lh, const void *data);
  void OPENSSL_LH_doall(OPENSSL_LHASH *lh, OPENSSL_LH_DOALL_FUNC func);
  void OPENSSL_LH_doall_arg(OPENSSL_LHASH *lh, OPENSSL_LH_DOALL_FUNCARG func, void *arg);
  unsigned long OPENSSL_LH_strhash(const char *c);
  unsigned long OPENSSL_LH_num_items(const OPENSSL_LHASH *lh);
  unsigned long OPENSSL_LH_get_down_load(const OPENSSL_LHASH *lh);
  void OPENSSL_LH_set_down_load(OPENSSL_LHASH *lh, unsigned long down_load);
  void OPENSSL_LH_stats(const OPENSSL_LHASH *lh, FILE *fp);
  void OPENSSL_LH_node_stats(const OPENSSL_LHASH *lh, FILE *fp);
  void OPENSSL_LH_node_usage_stats(const OPENSSL_LHASH *lh, FILE *fp);
  void OPENSSL_LH_stats_bio(const OPENSSL_LHASH *lh, BIO *out);
  void OPENSSL_LH_node_stats_bio(const OPENSSL_LHASH *lh, BIO *out);
  void OPENSSL_LH_node_usage_stats_bio(const OPENSSL_LHASH *lh, BIO *out);
  struct lhash_st_OPENSSL_STRING
  {
    union lh_OPENSSL_STRING_dummy
    {
      void *d1;
      unsigned long d2;
      int d3;
    } dummy;
  };
  static __attribute__((unused)) inline struct lhash_st_OPENSSL_STRING *lh_OPENSSL_STRING_new(unsigned long (*hfn)(const OPENSSL_STRING *), int (*cfn)(const OPENSSL_STRING *, const OPENSSL_STRING *)) { return (struct lhash_st_OPENSSL_STRING *)OPENSSL_LH_new((OPENSSL_LH_HASHFUNC)hfn, (OPENSSL_LH_COMPFUNC)cfn); }
  static __attribute__((unused)) inline void lh_OPENSSL_STRING_free(struct lhash_st_OPENSSL_STRING *lh) { OPENSSL_LH_free((OPENSSL_LHASH *)lh); }
  static __attribute__((unused)) inline OPENSSL_STRING *lh_OPENSSL_STRING_insert(struct lhash_st_OPENSSL_STRING *lh, OPENSSL_STRING *d) { return (OPENSSL_STRING *)OPENSSL_LH_insert((OPENSSL_LHASH *)lh, d); }
  static __attribute__((unused)) inline OPENSSL_STRING *lh_OPENSSL_STRING_delete(struct lhash_st_OPENSSL_STRING *lh, const OPENSSL_STRING *d) { return (OPENSSL_STRING *)OPENSSL_LH_delete((OPENSSL_LHASH *)lh, d); }
  static __attribute__((unused)) inline OPENSSL_STRING *lh_OPENSSL_STRING_retrieve(struct lhash_st_OPENSSL_STRING *lh, const OPENSSL_STRING *d) { return (OPENSSL_STRING *)OPENSSL_LH_retrieve((OPENSSL_LHASH *)lh, d); }
  static __attribute__((unused)) inline int lh_OPENSSL_STRING_error(struct lhash_st_OPENSSL_STRING *lh) { return OPENSSL_LH_error((OPENSSL_LHASH *)lh); }
  static __attribute__((unused)) inline unsigned long lh_OPENSSL_STRING_num_items(struct lhash_st_OPENSSL_STRING *lh) { return OPENSSL_LH_num_items((OPENSSL_LHASH *)lh); }
  static __attribute__((unused)) inline void lh_OPENSSL_STRING_node_stats_bio(const struct lhash_st_OPENSSL_STRING *lh, BIO *out) { OPENSSL_LH_node_stats_bio((const OPENSSL_LHASH *)lh, out); }
  static __attribute__((unused)) inline void lh_OPENSSL_STRING_node_usage_stats_bio(const struct lhash_st_OPENSSL_STRING *lh, BIO *out) { OPENSSL_LH_node_usage_stats_bio((const OPENSSL_LHASH *)lh, out); }
  static __attribute__((unused)) inline void lh_OPENSSL_STRING_stats_bio(const struct lhash_st_OPENSSL_STRING *lh, BIO *out) { OPENSSL_LH_stats_bio((const OPENSSL_LHASH *)lh, out); }
  static __attribute__((unused)) inline unsigned long lh_OPENSSL_STRING_get_down_load(struct lhash_st_OPENSSL_STRING *lh) { return OPENSSL_LH_get_down_load((OPENSSL_LHASH *)lh); }
  static __attribute__((unused)) inline void lh_OPENSSL_STRING_set_down_load(struct lhash_st_OPENSSL_STRING *lh, unsigned long dl) { OPENSSL_LH_set_down_load((OPENSSL_LHASH *)lh, dl); }
  static __attribute__((unused)) inline void lh_OPENSSL_STRING_doall(struct lhash_st_OPENSSL_STRING *lh, void (*doall)(OPENSSL_STRING *)) { OPENSSL_LH_doall((OPENSSL_LHASH *)lh, (OPENSSL_LH_DOALL_FUNC)doall); }
  struct lhash_st_OPENSSL_STRING;
  struct lhash_st_OPENSSL_CSTRING
  {
    union lh_OPENSSL_CSTRING_dummy
    {
      void *d1;
      unsigned long d2;
      int d3;
    } dummy;
  };
  static __attribute__((unused)) inline struct lhash_st_OPENSSL_CSTRING *lh_OPENSSL_CSTRING_new(unsigned long (*hfn)(const OPENSSL_CSTRING *), int (*cfn)(const OPENSSL_CSTRING *, const OPENSSL_CSTRING *)) { return (struct lhash_st_OPENSSL_CSTRING *)OPENSSL_LH_new((OPENSSL_LH_HASHFUNC)hfn, (OPENSSL_LH_COMPFUNC)cfn); }
  static __attribute__((unused)) inline void lh_OPENSSL_CSTRING_free(struct lhash_st_OPENSSL_CSTRING *lh) { OPENSSL_LH_free((OPENSSL_LHASH *)lh); }
  static __attribute__((unused)) inline OPENSSL_CSTRING *lh_OPENSSL_CSTRING_insert(struct lhash_st_OPENSSL_CSTRING *lh, OPENSSL_CSTRING *d) { return (OPENSSL_CSTRING *)OPENSSL_LH_insert((OPENSSL_LHASH *)lh, d); }
  static __attribute__((unused)) inline OPENSSL_CSTRING *lh_OPENSSL_CSTRING_delete(struct lhash_st_OPENSSL_CSTRING *lh, const OPENSSL_CSTRING *d) { return (OPENSSL_CSTRING *)OPENSSL_LH_delete((OPENSSL_LHASH *)lh, d); }
  static __attribute__((unused)) inline OPENSSL_CSTRING *lh_OPENSSL_CSTRING_retrieve(struct lhash_st_OPENSSL_CSTRING *lh, const OPENSSL_CSTRING *d) { return (OPENSSL_CSTRING *)OPENSSL_LH_retrieve((OPENSSL_LHASH *)lh, d); }
  static __attribute__((unused)) inline int lh_OPENSSL_CSTRING_error(struct lhash_st_OPENSSL_CSTRING *lh) { return OPENSSL_LH_error((OPENSSL_LHASH *)lh); }
  static __attribute__((unused)) inline unsigned long lh_OPENSSL_CSTRING_num_items(struct lhash_st_OPENSSL_CSTRING *lh) { return OPENSSL_LH_num_items((OPENSSL_LHASH *)lh); }
  static __attribute__((unused)) inline void lh_OPENSSL_CSTRING_node_stats_bio(const struct lhash_st_OPENSSL_CSTRING *lh, BIO *out) { OPENSSL_LH_node_stats_bio((const OPENSSL_LHASH *)lh, out); }
  static __attribute__((unused)) inline void lh_OPENSSL_CSTRING_node_usage_stats_bio(const struct lhash_st_OPENSSL_CSTRING *lh, BIO *out) { OPENSSL_LH_node_usage_stats_bio((const OPENSSL_LHASH *)lh, out); }
  static __attribute__((unused)) inline void lh_OPENSSL_CSTRING_stats_bio(const struct lhash_st_OPENSSL_CSTRING *lh, BIO *out) { OPENSSL_LH_stats_bio((const OPENSSL_LHASH *)lh, out); }
  static __attribute__((unused)) inline unsigned long lh_OPENSSL_CSTRING_get_down_load(struct lhash_st_OPENSSL_CSTRING *lh) { return OPENSSL_LH_get_down_load((OPENSSL_LHASH *)lh); }
  static __attribute__((unused)) inline void lh_OPENSSL_CSTRING_set_down_load(struct lhash_st_OPENSSL_CSTRING *lh, unsigned long dl) { OPENSSL_LH_set_down_load((OPENSSL_LHASH *)lh, dl); }
  static __attribute__((unused)) inline void lh_OPENSSL_CSTRING_doall(struct lhash_st_OPENSSL_CSTRING *lh, void (*doall)(OPENSSL_CSTRING *)) { OPENSSL_LH_doall((OPENSSL_LHASH *)lh, (OPENSSL_LH_DOALL_FUNC)doall); }
  struct lhash_st_OPENSSL_CSTRING;
}
extern "C"
{
  typedef enum
  {
    X509_LU_NONE = 0,
    X509_LU_X509,
    X509_LU_CRL
  } X509_LOOKUP_TYPE;
  struct stack_st_X509_LOOKUP;
  typedef int (*sk_X509_LOOKUP_compfunc)(const X509_LOOKUP *const *a, const X509_LOOKUP *const *b);
  typedef void (*sk_X509_LOOKUP_freefunc)(X509_LOOKUP *a);
  typedef X509_LOOKUP *(*sk_X509_LOOKUP_copyfunc)(const X509_LOOKUP *a);
  static __attribute__((unused)) inline int sk_X509_LOOKUP_num(const struct stack_st_X509_LOOKUP *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_LOOKUP *sk_X509_LOOKUP_value(const struct stack_st_X509_LOOKUP *sk, int idx) { return (X509_LOOKUP *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_X509_LOOKUP *sk_X509_LOOKUP_new(sk_X509_LOOKUP_compfunc compare) { return (struct stack_st_X509_LOOKUP *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_X509_LOOKUP *sk_X509_LOOKUP_new_null(void) { return (struct stack_st_X509_LOOKUP *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_X509_LOOKUP *sk_X509_LOOKUP_new_reserve(sk_X509_LOOKUP_compfunc compare, int n) { return (struct stack_st_X509_LOOKUP *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_X509_LOOKUP_reserve(struct stack_st_X509_LOOKUP *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_X509_LOOKUP_free(struct stack_st_X509_LOOKUP *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_LOOKUP_zero(struct stack_st_X509_LOOKUP *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_LOOKUP *sk_X509_LOOKUP_delete(struct stack_st_X509_LOOKUP *sk, int i) { return (X509_LOOKUP *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline X509_LOOKUP *sk_X509_LOOKUP_delete_ptr(struct stack_st_X509_LOOKUP *sk, X509_LOOKUP *ptr) { return (X509_LOOKUP *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_LOOKUP_push(struct stack_st_X509_LOOKUP *sk, X509_LOOKUP *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_LOOKUP_unshift(struct stack_st_X509_LOOKUP *sk, X509_LOOKUP *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline X509_LOOKUP *sk_X509_LOOKUP_pop(struct stack_st_X509_LOOKUP *sk) { return (X509_LOOKUP *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_LOOKUP *sk_X509_LOOKUP_shift(struct stack_st_X509_LOOKUP *sk) { return (X509_LOOKUP *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_LOOKUP_pop_free(struct stack_st_X509_LOOKUP *sk, sk_X509_LOOKUP_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_X509_LOOKUP_insert(struct stack_st_X509_LOOKUP *sk, X509_LOOKUP *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline X509_LOOKUP *sk_X509_LOOKUP_set(struct stack_st_X509_LOOKUP *sk, int idx, X509_LOOKUP *ptr) { return (X509_LOOKUP *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_LOOKUP_find(struct stack_st_X509_LOOKUP *sk, X509_LOOKUP *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_LOOKUP_find_ex(struct stack_st_X509_LOOKUP *sk, X509_LOOKUP *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_X509_LOOKUP_sort(struct stack_st_X509_LOOKUP *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_X509_LOOKUP_is_sorted(const struct stack_st_X509_LOOKUP *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_LOOKUP *sk_X509_LOOKUP_dup(const struct stack_st_X509_LOOKUP *sk) { return (struct stack_st_X509_LOOKUP *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_LOOKUP *sk_X509_LOOKUP_deep_copy(const struct stack_st_X509_LOOKUP *sk, sk_X509_LOOKUP_copyfunc copyfunc, sk_X509_LOOKUP_freefunc freefunc) { return (struct stack_st_X509_LOOKUP *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_X509_LOOKUP_compfunc sk_X509_LOOKUP_set_cmp_func(struct stack_st_X509_LOOKUP *sk, sk_X509_LOOKUP_compfunc compare) { return (sk_X509_LOOKUP_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  struct stack_st_X509_OBJECT;
  typedef int (*sk_X509_OBJECT_compfunc)(const X509_OBJECT *const *a, const X509_OBJECT *const *b);
  typedef void (*sk_X509_OBJECT_freefunc)(X509_OBJECT *a);
  typedef X509_OBJECT *(*sk_X509_OBJECT_copyfunc)(const X509_OBJECT *a);
  static __attribute__((unused)) inline int sk_X509_OBJECT_num(const struct stack_st_X509_OBJECT *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_OBJECT *sk_X509_OBJECT_value(const struct stack_st_X509_OBJECT *sk, int idx) { return (X509_OBJECT *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_X509_OBJECT *sk_X509_OBJECT_new(sk_X509_OBJECT_compfunc compare) { return (struct stack_st_X509_OBJECT *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_X509_OBJECT *sk_X509_OBJECT_new_null(void) { return (struct stack_st_X509_OBJECT *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_X509_OBJECT *sk_X509_OBJECT_new_reserve(sk_X509_OBJECT_compfunc compare, int n) { return (struct stack_st_X509_OBJECT *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_X509_OBJECT_reserve(struct stack_st_X509_OBJECT *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_X509_OBJECT_free(struct stack_st_X509_OBJECT *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_OBJECT_zero(struct stack_st_X509_OBJECT *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_OBJECT *sk_X509_OBJECT_delete(struct stack_st_X509_OBJECT *sk, int i) { return (X509_OBJECT *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline X509_OBJECT *sk_X509_OBJECT_delete_ptr(struct stack_st_X509_OBJECT *sk, X509_OBJECT *ptr) { return (X509_OBJECT *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_OBJECT_push(struct stack_st_X509_OBJECT *sk, X509_OBJECT *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_OBJECT_unshift(struct stack_st_X509_OBJECT *sk, X509_OBJECT *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline X509_OBJECT *sk_X509_OBJECT_pop(struct stack_st_X509_OBJECT *sk) { return (X509_OBJECT *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_OBJECT *sk_X509_OBJECT_shift(struct stack_st_X509_OBJECT *sk) { return (X509_OBJECT *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_OBJECT_pop_free(struct stack_st_X509_OBJECT *sk, sk_X509_OBJECT_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_X509_OBJECT_insert(struct stack_st_X509_OBJECT *sk, X509_OBJECT *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline X509_OBJECT *sk_X509_OBJECT_set(struct stack_st_X509_OBJECT *sk, int idx, X509_OBJECT *ptr) { return (X509_OBJECT *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_OBJECT_find(struct stack_st_X509_OBJECT *sk, X509_OBJECT *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_OBJECT_find_ex(struct stack_st_X509_OBJECT *sk, X509_OBJECT *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_X509_OBJECT_sort(struct stack_st_X509_OBJECT *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_X509_OBJECT_is_sorted(const struct stack_st_X509_OBJECT *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_OBJECT *sk_X509_OBJECT_dup(const struct stack_st_X509_OBJECT *sk) { return (struct stack_st_X509_OBJECT *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_OBJECT *sk_X509_OBJECT_deep_copy(const struct stack_st_X509_OBJECT *sk, sk_X509_OBJECT_copyfunc copyfunc, sk_X509_OBJECT_freefunc freefunc) { return (struct stack_st_X509_OBJECT *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_X509_OBJECT_compfunc sk_X509_OBJECT_set_cmp_func(struct stack_st_X509_OBJECT *sk, sk_X509_OBJECT_compfunc compare) { return (sk_X509_OBJECT_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  struct stack_st_X509_VERIFY_PARAM;
  typedef int (*sk_X509_VERIFY_PARAM_compfunc)(const X509_VERIFY_PARAM *const *a, const X509_VERIFY_PARAM *const *b);
  typedef void (*sk_X509_VERIFY_PARAM_freefunc)(X509_VERIFY_PARAM *a);
  typedef X509_VERIFY_PARAM *(*sk_X509_VERIFY_PARAM_copyfunc)(const X509_VERIFY_PARAM *a);
  static __attribute__((unused)) inline int sk_X509_VERIFY_PARAM_num(const struct stack_st_X509_VERIFY_PARAM *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_VERIFY_PARAM *sk_X509_VERIFY_PARAM_value(const struct stack_st_X509_VERIFY_PARAM *sk, int idx) { return (X509_VERIFY_PARAM *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_X509_VERIFY_PARAM *sk_X509_VERIFY_PARAM_new(sk_X509_VERIFY_PARAM_compfunc compare) { return (struct stack_st_X509_VERIFY_PARAM *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_X509_VERIFY_PARAM *sk_X509_VERIFY_PARAM_new_null(void) { return (struct stack_st_X509_VERIFY_PARAM *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_X509_VERIFY_PARAM *sk_X509_VERIFY_PARAM_new_reserve(sk_X509_VERIFY_PARAM_compfunc compare, int n) { return (struct stack_st_X509_VERIFY_PARAM *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_X509_VERIFY_PARAM_reserve(struct stack_st_X509_VERIFY_PARAM *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_X509_VERIFY_PARAM_free(struct stack_st_X509_VERIFY_PARAM *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_VERIFY_PARAM_zero(struct stack_st_X509_VERIFY_PARAM *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_VERIFY_PARAM *sk_X509_VERIFY_PARAM_delete(struct stack_st_X509_VERIFY_PARAM *sk, int i) { return (X509_VERIFY_PARAM *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline X509_VERIFY_PARAM *sk_X509_VERIFY_PARAM_delete_ptr(struct stack_st_X509_VERIFY_PARAM *sk, X509_VERIFY_PARAM *ptr) { return (X509_VERIFY_PARAM *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_VERIFY_PARAM_push(struct stack_st_X509_VERIFY_PARAM *sk, X509_VERIFY_PARAM *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_VERIFY_PARAM_unshift(struct stack_st_X509_VERIFY_PARAM *sk, X509_VERIFY_PARAM *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline X509_VERIFY_PARAM *sk_X509_VERIFY_PARAM_pop(struct stack_st_X509_VERIFY_PARAM *sk) { return (X509_VERIFY_PARAM *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline X509_VERIFY_PARAM *sk_X509_VERIFY_PARAM_shift(struct stack_st_X509_VERIFY_PARAM *sk) { return (X509_VERIFY_PARAM *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_X509_VERIFY_PARAM_pop_free(struct stack_st_X509_VERIFY_PARAM *sk, sk_X509_VERIFY_PARAM_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_X509_VERIFY_PARAM_insert(struct stack_st_X509_VERIFY_PARAM *sk, X509_VERIFY_PARAM *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline X509_VERIFY_PARAM *sk_X509_VERIFY_PARAM_set(struct stack_st_X509_VERIFY_PARAM *sk, int idx, X509_VERIFY_PARAM *ptr) { return (X509_VERIFY_PARAM *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_VERIFY_PARAM_find(struct stack_st_X509_VERIFY_PARAM *sk, X509_VERIFY_PARAM *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_X509_VERIFY_PARAM_find_ex(struct stack_st_X509_VERIFY_PARAM *sk, X509_VERIFY_PARAM *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_X509_VERIFY_PARAM_sort(struct stack_st_X509_VERIFY_PARAM *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_X509_VERIFY_PARAM_is_sorted(const struct stack_st_X509_VERIFY_PARAM *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_VERIFY_PARAM *sk_X509_VERIFY_PARAM_dup(const struct stack_st_X509_VERIFY_PARAM *sk) { return (struct stack_st_X509_VERIFY_PARAM *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_X509_VERIFY_PARAM *sk_X509_VERIFY_PARAM_deep_copy(const struct stack_st_X509_VERIFY_PARAM *sk, sk_X509_VERIFY_PARAM_copyfunc copyfunc, sk_X509_VERIFY_PARAM_freefunc freefunc) { return (struct stack_st_X509_VERIFY_PARAM *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_X509_VERIFY_PARAM_compfunc sk_X509_VERIFY_PARAM_set_cmp_func(struct stack_st_X509_VERIFY_PARAM *sk, sk_X509_VERIFY_PARAM_compfunc compare) { return (sk_X509_VERIFY_PARAM_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  int X509_STORE_set_depth(X509_STORE *store, int depth);
  typedef int (*X509_STORE_CTX_verify_cb)(int, X509_STORE_CTX *);
  typedef int (*X509_STORE_CTX_verify_fn)(X509_STORE_CTX *);
  typedef int (*X509_STORE_CTX_get_issuer_fn)(X509 **issuer,
                                              X509_STORE_CTX *ctx, X509 *x);
  typedef int (*X509_STORE_CTX_check_issued_fn)(X509_STORE_CTX *ctx,
                                                X509 *x, X509 *issuer);
  typedef int (*X509_STORE_CTX_check_revocation_fn)(X509_STORE_CTX *ctx);
  typedef int (*X509_STORE_CTX_get_crl_fn)(X509_STORE_CTX *ctx,
                                           X509_CRL **crl, X509 *x);
  typedef int (*X509_STORE_CTX_check_crl_fn)(X509_STORE_CTX *ctx, X509_CRL *crl);
  typedef int (*X509_STORE_CTX_cert_crl_fn)(X509_STORE_CTX *ctx,
                                            X509_CRL *crl, X509 *x);
  typedef int (*X509_STORE_CTX_check_policy_fn)(X509_STORE_CTX *ctx);
  typedef struct stack_st_X509 *(*X509_STORE_CTX_lookup_certs_fn)(X509_STORE_CTX *ctx,
                                                                  X509_NAME *nm);
  typedef struct stack_st_X509_CRL *(*X509_STORE_CTX_lookup_crls_fn)(X509_STORE_CTX *ctx,
                                                                     X509_NAME *nm);
  typedef int (*X509_STORE_CTX_cleanup_fn)(X509_STORE_CTX *ctx);
  void X509_STORE_CTX_set_depth(X509_STORE_CTX *ctx, int depth);
  int X509_OBJECT_idx_by_subject(struct stack_st_X509_OBJECT *h, X509_LOOKUP_TYPE type,
                                 X509_NAME *name);
  X509_OBJECT *X509_OBJECT_retrieve_by_subject(struct stack_st_X509_OBJECT *h,
                                               X509_LOOKUP_TYPE type,
                                               X509_NAME *name);
  X509_OBJECT *X509_OBJECT_retrieve_match(struct stack_st_X509_OBJECT *h,
                                          X509_OBJECT *x);
  int X509_OBJECT_up_ref_count(X509_OBJECT *a);
  X509_OBJECT *X509_OBJECT_new(void);
  void X509_OBJECT_free(X509_OBJECT *a);
  X509_LOOKUP_TYPE X509_OBJECT_get_type(const X509_OBJECT *a);
  X509 *X509_OBJECT_get0_X509(const X509_OBJECT *a);
  int X509_OBJECT_set1_X509(X509_OBJECT *a, X509 *obj);
  X509_CRL *X509_OBJECT_get0_X509_CRL(X509_OBJECT *a);
  int X509_OBJECT_set1_X509_CRL(X509_OBJECT *a, X509_CRL *obj);
  X509_STORE *X509_STORE_new(void);
  void X509_STORE_free(X509_STORE *v);
  int X509_STORE_lock(X509_STORE *ctx);
  int X509_STORE_unlock(X509_STORE *ctx);
  int X509_STORE_up_ref(X509_STORE *v);
  struct stack_st_X509_OBJECT *X509_STORE_get0_objects(X509_STORE *v);
  struct stack_st_X509 *X509_STORE_CTX_get1_certs(X509_STORE_CTX *st, X509_NAME *nm);
  struct stack_st_X509_CRL *X509_STORE_CTX_get1_crls(X509_STORE_CTX *st, X509_NAME *nm);
  int X509_STORE_set_flags(X509_STORE *ctx, unsigned long flags);
  int X509_STORE_set_purpose(X509_STORE *ctx, int purpose);
  int X509_STORE_set_trust(X509_STORE *ctx, int trust);
  int X509_STORE_set1_param(X509_STORE *ctx, X509_VERIFY_PARAM *pm);
  X509_VERIFY_PARAM *X509_STORE_get0_param(X509_STORE *ctx);
  void X509_STORE_set_verify(X509_STORE *ctx, X509_STORE_CTX_verify_fn verify);
  void X509_STORE_CTX_set_verify(X509_STORE_CTX *ctx,
                                 X509_STORE_CTX_verify_fn verify);
  X509_STORE_CTX_verify_fn X509_STORE_get_verify(X509_STORE *ctx);
  void X509_STORE_set_verify_cb(X509_STORE *ctx,
                                X509_STORE_CTX_verify_cb verify_cb);
  X509_STORE_CTX_verify_cb X509_STORE_get_verify_cb(X509_STORE *ctx);
  void X509_STORE_set_get_issuer(X509_STORE *ctx,
                                 X509_STORE_CTX_get_issuer_fn get_issuer);
  X509_STORE_CTX_get_issuer_fn X509_STORE_get_get_issuer(X509_STORE *ctx);
  void X509_STORE_set_check_issued(X509_STORE *ctx,
                                   X509_STORE_CTX_check_issued_fn check_issued);
  X509_STORE_CTX_check_issued_fn X509_STORE_get_check_issued(X509_STORE *ctx);
  void X509_STORE_set_check_revocation(X509_STORE *ctx,
                                       X509_STORE_CTX_check_revocation_fn check_revocation);
  X509_STORE_CTX_check_revocation_fn X509_STORE_get_check_revocation(X509_STORE *ctx);
  void X509_STORE_set_get_crl(X509_STORE *ctx,
                              X509_STORE_CTX_get_crl_fn get_crl);
  X509_STORE_CTX_get_crl_fn X509_STORE_get_get_crl(X509_STORE *ctx);
  void X509_STORE_set_check_crl(X509_STORE *ctx,
                                X509_STORE_CTX_check_crl_fn check_crl);
  X509_STORE_CTX_check_crl_fn X509_STORE_get_check_crl(X509_STORE *ctx);
  void X509_STORE_set_cert_crl(X509_STORE *ctx,
                               X509_STORE_CTX_cert_crl_fn cert_crl);
  X509_STORE_CTX_cert_crl_fn X509_STORE_get_cert_crl(X509_STORE *ctx);
  void X509_STORE_set_check_policy(X509_STORE *ctx,
                                   X509_STORE_CTX_check_policy_fn check_policy);
  X509_STORE_CTX_check_policy_fn X509_STORE_get_check_policy(X509_STORE *ctx);
  void X509_STORE_set_lookup_certs(X509_STORE *ctx,
                                   X509_STORE_CTX_lookup_certs_fn lookup_certs);
  X509_STORE_CTX_lookup_certs_fn X509_STORE_get_lookup_certs(X509_STORE *ctx);
  void X509_STORE_set_lookup_crls(X509_STORE *ctx,
                                  X509_STORE_CTX_lookup_crls_fn lookup_crls);
  X509_STORE_CTX_lookup_crls_fn X509_STORE_get_lookup_crls(X509_STORE *ctx);
  void X509_STORE_set_cleanup(X509_STORE *ctx,
                              X509_STORE_CTX_cleanup_fn cleanup);
  X509_STORE_CTX_cleanup_fn X509_STORE_get_cleanup(X509_STORE *ctx);
  int X509_STORE_set_ex_data(X509_STORE *ctx, int idx, void *data);
  void *X509_STORE_get_ex_data(X509_STORE *ctx, int idx);
  X509_STORE_CTX *X509_STORE_CTX_new(void);
  int X509_STORE_CTX_get1_issuer(X509 **issuer, X509_STORE_CTX *ctx, X509 *x);
  void X509_STORE_CTX_free(X509_STORE_CTX *ctx);
  int X509_STORE_CTX_init(X509_STORE_CTX *ctx, X509_STORE *store,
                          X509 *x509, struct stack_st_X509 *chain);
  void X509_STORE_CTX_set0_trusted_stack(X509_STORE_CTX *ctx, struct stack_st_X509 *sk);
  void X509_STORE_CTX_cleanup(X509_STORE_CTX *ctx);
  X509_STORE *X509_STORE_CTX_get0_store(X509_STORE_CTX *ctx);
  X509 *X509_STORE_CTX_get0_cert(X509_STORE_CTX *ctx);
  struct stack_st_X509 *X509_STORE_CTX_get0_untrusted(X509_STORE_CTX *ctx);
  void X509_STORE_CTX_set0_untrusted(X509_STORE_CTX *ctx, struct stack_st_X509 *sk);
  void X509_STORE_CTX_set_verify_cb(X509_STORE_CTX *ctx,
                                    X509_STORE_CTX_verify_cb verify);
  X509_STORE_CTX_verify_cb X509_STORE_CTX_get_verify_cb(X509_STORE_CTX *ctx);
  X509_STORE_CTX_verify_fn X509_STORE_CTX_get_verify(X509_STORE_CTX *ctx);
  X509_STORE_CTX_get_issuer_fn X509_STORE_CTX_get_get_issuer(X509_STORE_CTX *ctx);
  X509_STORE_CTX_check_issued_fn X509_STORE_CTX_get_check_issued(X509_STORE_CTX *ctx);
  X509_STORE_CTX_check_revocation_fn X509_STORE_CTX_get_check_revocation(X509_STORE_CTX *ctx);
  X509_STORE_CTX_get_crl_fn X509_STORE_CTX_get_get_crl(X509_STORE_CTX *ctx);
  X509_STORE_CTX_check_crl_fn X509_STORE_CTX_get_check_crl(X509_STORE_CTX *ctx);
  X509_STORE_CTX_cert_crl_fn X509_STORE_CTX_get_cert_crl(X509_STORE_CTX *ctx);
  X509_STORE_CTX_check_policy_fn X509_STORE_CTX_get_check_policy(X509_STORE_CTX *ctx);
  X509_STORE_CTX_lookup_certs_fn X509_STORE_CTX_get_lookup_certs(X509_STORE_CTX *ctx);
  X509_STORE_CTX_lookup_crls_fn X509_STORE_CTX_get_lookup_crls(X509_STORE_CTX *ctx);
  X509_STORE_CTX_cleanup_fn X509_STORE_CTX_get_cleanup(X509_STORE_CTX *ctx);
  X509_LOOKUP *X509_STORE_add_lookup(X509_STORE *v, X509_LOOKUP_METHOD *m);
  X509_LOOKUP_METHOD *X509_LOOKUP_hash_dir(void);
  X509_LOOKUP_METHOD *X509_LOOKUP_file(void);
  typedef int (*X509_LOOKUP_ctrl_fn)(X509_LOOKUP *ctx, int cmd, const char *argc,
                                     long argl, char **ret);
  typedef int (*X509_LOOKUP_get_by_subject_fn)(X509_LOOKUP *ctx,
                                               X509_LOOKUP_TYPE type,
                                               X509_NAME *name,
                                               X509_OBJECT *ret);
  typedef int (*X509_LOOKUP_get_by_issuer_serial_fn)(X509_LOOKUP *ctx,
                                                     X509_LOOKUP_TYPE type,
                                                     X509_NAME *name,
                                                     ASN1_INTEGER *serial,
                                                     X509_OBJECT *ret);
  typedef int (*X509_LOOKUP_get_by_fingerprint_fn)(X509_LOOKUP *ctx,
                                                   X509_LOOKUP_TYPE type,
                                                   const unsigned char *bytes,
                                                   int len,
                                                   X509_OBJECT *ret);
  typedef int (*X509_LOOKUP_get_by_alias_fn)(X509_LOOKUP *ctx,
                                             X509_LOOKUP_TYPE type,
                                             const char *str,
                                             int len,
                                             X509_OBJECT *ret);
  X509_LOOKUP_METHOD *X509_LOOKUP_meth_new(const char *name);
  void X509_LOOKUP_meth_free(X509_LOOKUP_METHOD *method);
  int X509_LOOKUP_meth_set_new_item(X509_LOOKUP_METHOD *method,
                                    int (*new_item)(X509_LOOKUP *ctx));
  int (*X509_LOOKUP_meth_get_new_item(const X509_LOOKUP_METHOD *method))(X509_LOOKUP *ctx);
  int X509_LOOKUP_meth_set_free(X509_LOOKUP_METHOD *method,
                                void (*free_fn)(X509_LOOKUP *ctx));
  void (*X509_LOOKUP_meth_get_free(const X509_LOOKUP_METHOD *method))(X509_LOOKUP *ctx);
  int X509_LOOKUP_meth_set_init(X509_LOOKUP_METHOD *method,
                                int (*init)(X509_LOOKUP *ctx));
  int (*X509_LOOKUP_meth_get_init(const X509_LOOKUP_METHOD *method))(X509_LOOKUP *ctx);
  int X509_LOOKUP_meth_set_shutdown(X509_LOOKUP_METHOD *method,
                                    int (*shutdown)(X509_LOOKUP *ctx));
  int (*X509_LOOKUP_meth_get_shutdown(const X509_LOOKUP_METHOD *method))(X509_LOOKUP *ctx);
  int X509_LOOKUP_meth_set_ctrl(X509_LOOKUP_METHOD *method,
                                X509_LOOKUP_ctrl_fn ctrl_fn);
  X509_LOOKUP_ctrl_fn X509_LOOKUP_meth_get_ctrl(const X509_LOOKUP_METHOD *method);
  int X509_LOOKUP_meth_set_get_by_subject(X509_LOOKUP_METHOD *method,
                                          X509_LOOKUP_get_by_subject_fn fn);
  X509_LOOKUP_get_by_subject_fn X509_LOOKUP_meth_get_get_by_subject(
      const X509_LOOKUP_METHOD *method);
  int X509_LOOKUP_meth_set_get_by_issuer_serial(X509_LOOKUP_METHOD *method,
                                                X509_LOOKUP_get_by_issuer_serial_fn fn);
  X509_LOOKUP_get_by_issuer_serial_fn X509_LOOKUP_meth_get_get_by_issuer_serial(
      const X509_LOOKUP_METHOD *method);
  int X509_LOOKUP_meth_set_get_by_fingerprint(X509_LOOKUP_METHOD *method,
                                              X509_LOOKUP_get_by_fingerprint_fn fn);
  X509_LOOKUP_get_by_fingerprint_fn X509_LOOKUP_meth_get_get_by_fingerprint(
      const X509_LOOKUP_METHOD *method);
  int X509_LOOKUP_meth_set_get_by_alias(X509_LOOKUP_METHOD *method,
                                        X509_LOOKUP_get_by_alias_fn fn);
  X509_LOOKUP_get_by_alias_fn X509_LOOKUP_meth_get_get_by_alias(
      const X509_LOOKUP_METHOD *method);
  int X509_STORE_add_cert(X509_STORE *ctx, X509 *x);
  int X509_STORE_add_crl(X509_STORE *ctx, X509_CRL *x);
  int X509_STORE_CTX_get_by_subject(X509_STORE_CTX *vs, X509_LOOKUP_TYPE type,
                                    X509_NAME *name, X509_OBJECT *ret);
  X509_OBJECT *X509_STORE_CTX_get_obj_by_subject(X509_STORE_CTX *vs,
                                                 X509_LOOKUP_TYPE type,
                                                 X509_NAME *name);
  int X509_LOOKUP_ctrl(X509_LOOKUP *ctx, int cmd, const char *argc,
                       long argl, char **ret);
  int X509_load_cert_file(X509_LOOKUP *ctx, const char *file, int type);
  int X509_load_crl_file(X509_LOOKUP *ctx, const char *file, int type);
  int X509_load_cert_crl_file(X509_LOOKUP *ctx, const char *file, int type);
  X509_LOOKUP *X509_LOOKUP_new(X509_LOOKUP_METHOD *method);
  void X509_LOOKUP_free(X509_LOOKUP *ctx);
  int X509_LOOKUP_init(X509_LOOKUP *ctx);
  int X509_LOOKUP_by_subject(X509_LOOKUP *ctx, X509_LOOKUP_TYPE type,
                             X509_NAME *name, X509_OBJECT *ret);
  int X509_LOOKUP_by_issuer_serial(X509_LOOKUP *ctx, X509_LOOKUP_TYPE type,
                                   X509_NAME *name, ASN1_INTEGER *serial,
                                   X509_OBJECT *ret);
  int X509_LOOKUP_by_fingerprint(X509_LOOKUP *ctx, X509_LOOKUP_TYPE type,
                                 const unsigned char *bytes, int len,
                                 X509_OBJECT *ret);
  int X509_LOOKUP_by_alias(X509_LOOKUP *ctx, X509_LOOKUP_TYPE type,
                           const char *str, int len, X509_OBJECT *ret);
  int X509_LOOKUP_set_method_data(X509_LOOKUP *ctx, void *data);
  void *X509_LOOKUP_get_method_data(const X509_LOOKUP *ctx);
  X509_STORE *X509_LOOKUP_get_store(const X509_LOOKUP *ctx);
  int X509_LOOKUP_shutdown(X509_LOOKUP *ctx);
  int X509_STORE_load_locations(X509_STORE *ctx,
                                const char *file, const char *dir);
  int X509_STORE_set_default_paths(X509_STORE *ctx);
  int X509_STORE_CTX_set_ex_data(X509_STORE_CTX *ctx, int idx, void *data);
  void *X509_STORE_CTX_get_ex_data(X509_STORE_CTX *ctx, int idx);
  int X509_STORE_CTX_get_error(X509_STORE_CTX *ctx);
  void X509_STORE_CTX_set_error(X509_STORE_CTX *ctx, int s);
  int X509_STORE_CTX_get_error_depth(X509_STORE_CTX *ctx);
  void X509_STORE_CTX_set_error_depth(X509_STORE_CTX *ctx, int depth);
  X509 *X509_STORE_CTX_get_current_cert(X509_STORE_CTX *ctx);
  void X509_STORE_CTX_set_current_cert(X509_STORE_CTX *ctx, X509 *x);
  X509 *X509_STORE_CTX_get0_current_issuer(X509_STORE_CTX *ctx);
  X509_CRL *X509_STORE_CTX_get0_current_crl(X509_STORE_CTX *ctx);
  X509_STORE_CTX *X509_STORE_CTX_get0_parent_ctx(X509_STORE_CTX *ctx);
  struct stack_st_X509 *X509_STORE_CTX_get0_chain(X509_STORE_CTX *ctx);
  struct stack_st_X509 *X509_STORE_CTX_get1_chain(X509_STORE_CTX *ctx);
  void X509_STORE_CTX_set_cert(X509_STORE_CTX *c, X509 *x);
  void X509_STORE_CTX_set0_verified_chain(X509_STORE_CTX *c, struct stack_st_X509 *sk);
  void X509_STORE_CTX_set0_crls(X509_STORE_CTX *c, struct stack_st_X509_CRL *sk);
  int X509_STORE_CTX_set_purpose(X509_STORE_CTX *ctx, int purpose);
  int X509_STORE_CTX_set_trust(X509_STORE_CTX *ctx, int trust);
  int X509_STORE_CTX_purpose_inherit(X509_STORE_CTX *ctx, int def_purpose,
                                     int purpose, int trust);
  void X509_STORE_CTX_set_flags(X509_STORE_CTX *ctx, unsigned long flags);
  void X509_STORE_CTX_set_time(X509_STORE_CTX *ctx, unsigned long flags,
                               time_t t);
  X509_POLICY_TREE *X509_STORE_CTX_get0_policy_tree(X509_STORE_CTX *ctx);
  int X509_STORE_CTX_get_explicit_policy(X509_STORE_CTX *ctx);
  int X509_STORE_CTX_get_num_untrusted(X509_STORE_CTX *ctx);
  X509_VERIFY_PARAM *X509_STORE_CTX_get0_param(X509_STORE_CTX *ctx);
  void X509_STORE_CTX_set0_param(X509_STORE_CTX *ctx, X509_VERIFY_PARAM *param);
  int X509_STORE_CTX_set_default(X509_STORE_CTX *ctx, const char *name);
  void X509_STORE_CTX_set0_dane(X509_STORE_CTX *ctx, SSL_DANE *dane);
  X509_VERIFY_PARAM *X509_VERIFY_PARAM_new(void);
  void X509_VERIFY_PARAM_free(X509_VERIFY_PARAM *param);
  int X509_VERIFY_PARAM_inherit(X509_VERIFY_PARAM *to,
                                const X509_VERIFY_PARAM *from);
  int X509_VERIFY_PARAM_set1(X509_VERIFY_PARAM *to,
                             const X509_VERIFY_PARAM *from);
  int X509_VERIFY_PARAM_set1_name(X509_VERIFY_PARAM *param, const char *name);
  int X509_VERIFY_PARAM_set_flags(X509_VERIFY_PARAM *param,
                                  unsigned long flags);
  int X509_VERIFY_PARAM_clear_flags(X509_VERIFY_PARAM *param,
                                    unsigned long flags);
  unsigned long X509_VERIFY_PARAM_get_flags(X509_VERIFY_PARAM *param);
  int X509_VERIFY_PARAM_set_purpose(X509_VERIFY_PARAM *param, int purpose);
  int X509_VERIFY_PARAM_set_trust(X509_VERIFY_PARAM *param, int trust);
  void X509_VERIFY_PARAM_set_depth(X509_VERIFY_PARAM *param, int depth);
  void X509_VERIFY_PARAM_set_auth_level(X509_VERIFY_PARAM *param, int auth_level);
  time_t X509_VERIFY_PARAM_get_time(const X509_VERIFY_PARAM *param);
  void X509_VERIFY_PARAM_set_time(X509_VERIFY_PARAM *param, time_t t);
  int X509_VERIFY_PARAM_add0_policy(X509_VERIFY_PARAM *param,
                                    ASN1_OBJECT *policy);
  int X509_VERIFY_PARAM_set1_policies(X509_VERIFY_PARAM *param,
                                      struct stack_st_ASN1_OBJECT *policies);
  int X509_VERIFY_PARAM_set_inh_flags(X509_VERIFY_PARAM *param,
                                      uint32_t flags);
  uint32_t X509_VERIFY_PARAM_get_inh_flags(const X509_VERIFY_PARAM *param);
  int X509_VERIFY_PARAM_set1_host(X509_VERIFY_PARAM *param,
                                  const char *name, size_t namelen);
  int X509_VERIFY_PARAM_add1_host(X509_VERIFY_PARAM *param,
                                  const char *name, size_t namelen);
  void X509_VERIFY_PARAM_set_hostflags(X509_VERIFY_PARAM *param,
                                       unsigned int flags);
  unsigned int X509_VERIFY_PARAM_get_hostflags(const X509_VERIFY_PARAM *param);
  char *X509_VERIFY_PARAM_get0_peername(X509_VERIFY_PARAM *);
  void X509_VERIFY_PARAM_move_peername(X509_VERIFY_PARAM *, X509_VERIFY_PARAM *);
  int X509_VERIFY_PARAM_set1_email(X509_VERIFY_PARAM *param,
                                   const char *email, size_t emaillen);
  int X509_VERIFY_PARAM_set1_ip(X509_VERIFY_PARAM *param,
                                const unsigned char *ip, size_t iplen);
  int X509_VERIFY_PARAM_set1_ip_asc(X509_VERIFY_PARAM *param,
                                    const char *ipasc);
  int X509_VERIFY_PARAM_get_depth(const X509_VERIFY_PARAM *param);
  int X509_VERIFY_PARAM_get_auth_level(const X509_VERIFY_PARAM *param);
  const char *X509_VERIFY_PARAM_get0_name(const X509_VERIFY_PARAM *param);
  int X509_VERIFY_PARAM_add0_table(X509_VERIFY_PARAM *param);
  int X509_VERIFY_PARAM_get_count(void);
  const X509_VERIFY_PARAM *X509_VERIFY_PARAM_get0(int id);
  const X509_VERIFY_PARAM *X509_VERIFY_PARAM_lookup(const char *name);
  void X509_VERIFY_PARAM_table_cleanup(void);
  int X509_policy_check(X509_POLICY_TREE **ptree, int *pexplicit_policy,
                        struct stack_st_X509 *certs,
                        struct stack_st_ASN1_OBJECT *policy_oids, unsigned int flags);
  void X509_policy_tree_free(X509_POLICY_TREE *tree);
  int X509_policy_tree_level_count(const X509_POLICY_TREE *tree);
  X509_POLICY_LEVEL *X509_policy_tree_get0_level(const X509_POLICY_TREE *tree,
                                                 int i);
  struct stack_st_X509_POLICY_NODE *X509_policy_tree_get0_policies(const X509_POLICY_TREE
                                                                       *tree);
  struct stack_st_X509_POLICY_NODE *X509_policy_tree_get0_user_policies(const X509_POLICY_TREE
                                                                            *tree);
  int X509_policy_level_node_count(X509_POLICY_LEVEL *level);
  X509_POLICY_NODE *X509_policy_level_get0_node(X509_POLICY_LEVEL *level,
                                                int i);
  const ASN1_OBJECT *X509_policy_node_get0_policy(const X509_POLICY_NODE *node);
  struct stack_st_POLICYQUALINFO *X509_policy_node_get0_qualifiers(const X509_POLICY_NODE
                                                                       *node);
  const X509_POLICY_NODE *X509_policy_node_get0_parent(const X509_POLICY_NODE
                                                           *node);
}
extern "C" int ERR_load_PKCS7_strings(void);
extern "C"
{
  typedef struct pkcs7_issuer_and_serial_st
  {
    X509_NAME *issuer;
    ASN1_INTEGER *serial;
  } PKCS7_ISSUER_AND_SERIAL;
  typedef struct pkcs7_signer_info_st
  {
    ASN1_INTEGER *version;
    PKCS7_ISSUER_AND_SERIAL *issuer_and_serial;
    X509_ALGOR *digest_alg;
    struct stack_st_X509_ATTRIBUTE *auth_attr;
    X509_ALGOR *digest_enc_alg;
    ASN1_OCTET_STRING *enc_digest;
    struct stack_st_X509_ATTRIBUTE *unauth_attr;
    EVP_PKEY *pkey;
  } PKCS7_SIGNER_INFO;
  struct stack_st_PKCS7_SIGNER_INFO;
  typedef int (*sk_PKCS7_SIGNER_INFO_compfunc)(const PKCS7_SIGNER_INFO *const *a, const PKCS7_SIGNER_INFO *const *b);
  typedef void (*sk_PKCS7_SIGNER_INFO_freefunc)(PKCS7_SIGNER_INFO *a);
  typedef PKCS7_SIGNER_INFO *(*sk_PKCS7_SIGNER_INFO_copyfunc)(const PKCS7_SIGNER_INFO *a);
  static __attribute__((unused)) inline int sk_PKCS7_SIGNER_INFO_num(const struct stack_st_PKCS7_SIGNER_INFO *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline PKCS7_SIGNER_INFO *sk_PKCS7_SIGNER_INFO_value(const struct stack_st_PKCS7_SIGNER_INFO *sk, int idx) { return (PKCS7_SIGNER_INFO *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_PKCS7_SIGNER_INFO *sk_PKCS7_SIGNER_INFO_new(sk_PKCS7_SIGNER_INFO_compfunc compare) { return (struct stack_st_PKCS7_SIGNER_INFO *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_PKCS7_SIGNER_INFO *sk_PKCS7_SIGNER_INFO_new_null(void) { return (struct stack_st_PKCS7_SIGNER_INFO *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_PKCS7_SIGNER_INFO *sk_PKCS7_SIGNER_INFO_new_reserve(sk_PKCS7_SIGNER_INFO_compfunc compare, int n) { return (struct stack_st_PKCS7_SIGNER_INFO *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_PKCS7_SIGNER_INFO_reserve(struct stack_st_PKCS7_SIGNER_INFO *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_PKCS7_SIGNER_INFO_free(struct stack_st_PKCS7_SIGNER_INFO *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_PKCS7_SIGNER_INFO_zero(struct stack_st_PKCS7_SIGNER_INFO *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline PKCS7_SIGNER_INFO *sk_PKCS7_SIGNER_INFO_delete(struct stack_st_PKCS7_SIGNER_INFO *sk, int i) { return (PKCS7_SIGNER_INFO *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline PKCS7_SIGNER_INFO *sk_PKCS7_SIGNER_INFO_delete_ptr(struct stack_st_PKCS7_SIGNER_INFO *sk, PKCS7_SIGNER_INFO *ptr) { return (PKCS7_SIGNER_INFO *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_PKCS7_SIGNER_INFO_push(struct stack_st_PKCS7_SIGNER_INFO *sk, PKCS7_SIGNER_INFO *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_PKCS7_SIGNER_INFO_unshift(struct stack_st_PKCS7_SIGNER_INFO *sk, PKCS7_SIGNER_INFO *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline PKCS7_SIGNER_INFO *sk_PKCS7_SIGNER_INFO_pop(struct stack_st_PKCS7_SIGNER_INFO *sk) { return (PKCS7_SIGNER_INFO *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline PKCS7_SIGNER_INFO *sk_PKCS7_SIGNER_INFO_shift(struct stack_st_PKCS7_SIGNER_INFO *sk) { return (PKCS7_SIGNER_INFO *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_PKCS7_SIGNER_INFO_pop_free(struct stack_st_PKCS7_SIGNER_INFO *sk, sk_PKCS7_SIGNER_INFO_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_PKCS7_SIGNER_INFO_insert(struct stack_st_PKCS7_SIGNER_INFO *sk, PKCS7_SIGNER_INFO *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline PKCS7_SIGNER_INFO *sk_PKCS7_SIGNER_INFO_set(struct stack_st_PKCS7_SIGNER_INFO *sk, int idx, PKCS7_SIGNER_INFO *ptr) { return (PKCS7_SIGNER_INFO *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_PKCS7_SIGNER_INFO_find(struct stack_st_PKCS7_SIGNER_INFO *sk, PKCS7_SIGNER_INFO *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_PKCS7_SIGNER_INFO_find_ex(struct stack_st_PKCS7_SIGNER_INFO *sk, PKCS7_SIGNER_INFO *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_PKCS7_SIGNER_INFO_sort(struct stack_st_PKCS7_SIGNER_INFO *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_PKCS7_SIGNER_INFO_is_sorted(const struct stack_st_PKCS7_SIGNER_INFO *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_PKCS7_SIGNER_INFO *sk_PKCS7_SIGNER_INFO_dup(const struct stack_st_PKCS7_SIGNER_INFO *sk) { return (struct stack_st_PKCS7_SIGNER_INFO *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_PKCS7_SIGNER_INFO *sk_PKCS7_SIGNER_INFO_deep_copy(const struct stack_st_PKCS7_SIGNER_INFO *sk, sk_PKCS7_SIGNER_INFO_copyfunc copyfunc, sk_PKCS7_SIGNER_INFO_freefunc freefunc) { return (struct stack_st_PKCS7_SIGNER_INFO *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_PKCS7_SIGNER_INFO_compfunc sk_PKCS7_SIGNER_INFO_set_cmp_func(struct stack_st_PKCS7_SIGNER_INFO *sk, sk_PKCS7_SIGNER_INFO_compfunc compare) { return (sk_PKCS7_SIGNER_INFO_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  typedef struct pkcs7_recip_info_st
  {
    ASN1_INTEGER *version;
    PKCS7_ISSUER_AND_SERIAL *issuer_and_serial;
    X509_ALGOR *key_enc_algor;
    ASN1_OCTET_STRING *enc_key;
    X509 *cert;
  } PKCS7_RECIP_INFO;
  struct stack_st_PKCS7_RECIP_INFO;
  typedef int (*sk_PKCS7_RECIP_INFO_compfunc)(const PKCS7_RECIP_INFO *const *a, const PKCS7_RECIP_INFO *const *b);
  typedef void (*sk_PKCS7_RECIP_INFO_freefunc)(PKCS7_RECIP_INFO *a);
  typedef PKCS7_RECIP_INFO *(*sk_PKCS7_RECIP_INFO_copyfunc)(const PKCS7_RECIP_INFO *a);
  static __attribute__((unused)) inline int sk_PKCS7_RECIP_INFO_num(const struct stack_st_PKCS7_RECIP_INFO *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline PKCS7_RECIP_INFO *sk_PKCS7_RECIP_INFO_value(const struct stack_st_PKCS7_RECIP_INFO *sk, int idx) { return (PKCS7_RECIP_INFO *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_PKCS7_RECIP_INFO *sk_PKCS7_RECIP_INFO_new(sk_PKCS7_RECIP_INFO_compfunc compare) { return (struct stack_st_PKCS7_RECIP_INFO *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_PKCS7_RECIP_INFO *sk_PKCS7_RECIP_INFO_new_null(void) { return (struct stack_st_PKCS7_RECIP_INFO *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_PKCS7_RECIP_INFO *sk_PKCS7_RECIP_INFO_new_reserve(sk_PKCS7_RECIP_INFO_compfunc compare, int n) { return (struct stack_st_PKCS7_RECIP_INFO *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_PKCS7_RECIP_INFO_reserve(struct stack_st_PKCS7_RECIP_INFO *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_PKCS7_RECIP_INFO_free(struct stack_st_PKCS7_RECIP_INFO *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_PKCS7_RECIP_INFO_zero(struct stack_st_PKCS7_RECIP_INFO *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline PKCS7_RECIP_INFO *sk_PKCS7_RECIP_INFO_delete(struct stack_st_PKCS7_RECIP_INFO *sk, int i) { return (PKCS7_RECIP_INFO *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline PKCS7_RECIP_INFO *sk_PKCS7_RECIP_INFO_delete_ptr(struct stack_st_PKCS7_RECIP_INFO *sk, PKCS7_RECIP_INFO *ptr) { return (PKCS7_RECIP_INFO *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_PKCS7_RECIP_INFO_push(struct stack_st_PKCS7_RECIP_INFO *sk, PKCS7_RECIP_INFO *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_PKCS7_RECIP_INFO_unshift(struct stack_st_PKCS7_RECIP_INFO *sk, PKCS7_RECIP_INFO *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline PKCS7_RECIP_INFO *sk_PKCS7_RECIP_INFO_pop(struct stack_st_PKCS7_RECIP_INFO *sk) { return (PKCS7_RECIP_INFO *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline PKCS7_RECIP_INFO *sk_PKCS7_RECIP_INFO_shift(struct stack_st_PKCS7_RECIP_INFO *sk) { return (PKCS7_RECIP_INFO *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_PKCS7_RECIP_INFO_pop_free(struct stack_st_PKCS7_RECIP_INFO *sk, sk_PKCS7_RECIP_INFO_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_PKCS7_RECIP_INFO_insert(struct stack_st_PKCS7_RECIP_INFO *sk, PKCS7_RECIP_INFO *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline PKCS7_RECIP_INFO *sk_PKCS7_RECIP_INFO_set(struct stack_st_PKCS7_RECIP_INFO *sk, int idx, PKCS7_RECIP_INFO *ptr) { return (PKCS7_RECIP_INFO *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_PKCS7_RECIP_INFO_find(struct stack_st_PKCS7_RECIP_INFO *sk, PKCS7_RECIP_INFO *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_PKCS7_RECIP_INFO_find_ex(struct stack_st_PKCS7_RECIP_INFO *sk, PKCS7_RECIP_INFO *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_PKCS7_RECIP_INFO_sort(struct stack_st_PKCS7_RECIP_INFO *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_PKCS7_RECIP_INFO_is_sorted(const struct stack_st_PKCS7_RECIP_INFO *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_PKCS7_RECIP_INFO *sk_PKCS7_RECIP_INFO_dup(const struct stack_st_PKCS7_RECIP_INFO *sk) { return (struct stack_st_PKCS7_RECIP_INFO *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_PKCS7_RECIP_INFO *sk_PKCS7_RECIP_INFO_deep_copy(const struct stack_st_PKCS7_RECIP_INFO *sk, sk_PKCS7_RECIP_INFO_copyfunc copyfunc, sk_PKCS7_RECIP_INFO_freefunc freefunc) { return (struct stack_st_PKCS7_RECIP_INFO *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_PKCS7_RECIP_INFO_compfunc sk_PKCS7_RECIP_INFO_set_cmp_func(struct stack_st_PKCS7_RECIP_INFO *sk, sk_PKCS7_RECIP_INFO_compfunc compare) { return (sk_PKCS7_RECIP_INFO_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  typedef struct pkcs7_signed_st
  {
    ASN1_INTEGER *version;
    struct stack_st_X509_ALGOR *md_algs;
    struct stack_st_X509 *cert;
    struct stack_st_X509_CRL *crl;
    struct stack_st_PKCS7_SIGNER_INFO *signer_info;
    struct pkcs7_st *contents;
  } PKCS7_SIGNED;
  typedef struct pkcs7_enc_content_st
  {
    ASN1_OBJECT *content_type;
    X509_ALGOR *algorithm;
    ASN1_OCTET_STRING *enc_data;
    const EVP_CIPHER *cipher;
  } PKCS7_ENC_CONTENT;
  typedef struct pkcs7_enveloped_st
  {
    ASN1_INTEGER *version;
    struct stack_st_PKCS7_RECIP_INFO *recipientinfo;
    PKCS7_ENC_CONTENT *enc_data;
  } PKCS7_ENVELOPE;
  typedef struct pkcs7_signedandenveloped_st
  {
    ASN1_INTEGER *version;
    struct stack_st_X509_ALGOR *md_algs;
    struct stack_st_X509 *cert;
    struct stack_st_X509_CRL *crl;
    struct stack_st_PKCS7_SIGNER_INFO *signer_info;
    PKCS7_ENC_CONTENT *enc_data;
    struct stack_st_PKCS7_RECIP_INFO *recipientinfo;
  } PKCS7_SIGN_ENVELOPE;
  typedef struct pkcs7_digest_st
  {
    ASN1_INTEGER *version;
    X509_ALGOR *md;
    struct pkcs7_st *contents;
    ASN1_OCTET_STRING *digest;
  } PKCS7_DIGEST;
  typedef struct pkcs7_encrypted_st
  {
    ASN1_INTEGER *version;
    PKCS7_ENC_CONTENT *enc_data;
  } PKCS7_ENCRYPT;
  typedef struct pkcs7_st
  {
    unsigned char *asn1;
    long length;
    int state;
    int detached;
    ASN1_OBJECT *type;
    union
    {
      char *ptr;
      ASN1_OCTET_STRING *data;
      PKCS7_SIGNED *sign;
      PKCS7_ENVELOPE *enveloped;
      PKCS7_SIGN_ENVELOPE *signed_and_enveloped;
      PKCS7_DIGEST *digest;
      PKCS7_ENCRYPT *encrypted;
      ASN1_TYPE *other;
    } d;
  } PKCS7;
  struct stack_st_PKCS7;
  typedef int (*sk_PKCS7_compfunc)(const PKCS7 *const *a, const PKCS7 *const *b);
  typedef void (*sk_PKCS7_freefunc)(PKCS7 *a);
  typedef PKCS7 *(*sk_PKCS7_copyfunc)(const PKCS7 *a);
  static __attribute__((unused)) inline int sk_PKCS7_num(const struct stack_st_PKCS7 *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline PKCS7 *sk_PKCS7_value(const struct stack_st_PKCS7 *sk, int idx) { return (PKCS7 *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_PKCS7 *sk_PKCS7_new(sk_PKCS7_compfunc compare) { return (struct stack_st_PKCS7 *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_PKCS7 *sk_PKCS7_new_null(void) { return (struct stack_st_PKCS7 *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_PKCS7 *sk_PKCS7_new_reserve(sk_PKCS7_compfunc compare, int n) { return (struct stack_st_PKCS7 *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_PKCS7_reserve(struct stack_st_PKCS7 *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_PKCS7_free(struct stack_st_PKCS7 *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_PKCS7_zero(struct stack_st_PKCS7 *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline PKCS7 *sk_PKCS7_delete(struct stack_st_PKCS7 *sk, int i) { return (PKCS7 *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline PKCS7 *sk_PKCS7_delete_ptr(struct stack_st_PKCS7 *sk, PKCS7 *ptr) { return (PKCS7 *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_PKCS7_push(struct stack_st_PKCS7 *sk, PKCS7 *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_PKCS7_unshift(struct stack_st_PKCS7 *sk, PKCS7 *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline PKCS7 *sk_PKCS7_pop(struct stack_st_PKCS7 *sk) { return (PKCS7 *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline PKCS7 *sk_PKCS7_shift(struct stack_st_PKCS7 *sk) { return (PKCS7 *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_PKCS7_pop_free(struct stack_st_PKCS7 *sk, sk_PKCS7_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_PKCS7_insert(struct stack_st_PKCS7 *sk, PKCS7 *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline PKCS7 *sk_PKCS7_set(struct stack_st_PKCS7 *sk, int idx, PKCS7 *ptr) { return (PKCS7 *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_PKCS7_find(struct stack_st_PKCS7 *sk, PKCS7 *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_PKCS7_find_ex(struct stack_st_PKCS7 *sk, PKCS7 *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_PKCS7_sort(struct stack_st_PKCS7 *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_PKCS7_is_sorted(const struct stack_st_PKCS7 *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_PKCS7 *sk_PKCS7_dup(const struct stack_st_PKCS7 *sk) { return (struct stack_st_PKCS7 *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_PKCS7 *sk_PKCS7_deep_copy(const struct stack_st_PKCS7 *sk, sk_PKCS7_copyfunc copyfunc, sk_PKCS7_freefunc freefunc) { return (struct stack_st_PKCS7 *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_PKCS7_compfunc sk_PKCS7_set_cmp_func(struct stack_st_PKCS7 *sk, sk_PKCS7_compfunc compare) { return (sk_PKCS7_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  PKCS7_ISSUER_AND_SERIAL *PKCS7_ISSUER_AND_SERIAL_new(void);
  void PKCS7_ISSUER_AND_SERIAL_free(PKCS7_ISSUER_AND_SERIAL *a);
  PKCS7_ISSUER_AND_SERIAL *d2i_PKCS7_ISSUER_AND_SERIAL(PKCS7_ISSUER_AND_SERIAL **a, const unsigned char **in, long len);
  int i2d_PKCS7_ISSUER_AND_SERIAL(PKCS7_ISSUER_AND_SERIAL *a, unsigned char **out);
  extern const ASN1_ITEM PKCS7_ISSUER_AND_SERIAL_it;
  int PKCS7_ISSUER_AND_SERIAL_digest(PKCS7_ISSUER_AND_SERIAL *data,
                                     const EVP_MD *type, unsigned char *md,
                                     unsigned int *len);
  PKCS7 *d2i_PKCS7_fp(FILE *fp, PKCS7 **p7);
  int i2d_PKCS7_fp(FILE *fp, PKCS7 *p7);
  PKCS7 *PKCS7_dup(PKCS7 *p7);
  PKCS7 *d2i_PKCS7_bio(BIO *bp, PKCS7 **p7);
  int i2d_PKCS7_bio(BIO *bp, PKCS7 *p7);
  int i2d_PKCS7_bio_stream(BIO *out, PKCS7 *p7, BIO *in, int flags);
  int PEM_write_bio_PKCS7_stream(BIO *out, PKCS7 *p7, BIO *in, int flags);
  PKCS7_SIGNER_INFO *PKCS7_SIGNER_INFO_new(void);
  void PKCS7_SIGNER_INFO_free(PKCS7_SIGNER_INFO *a);
  PKCS7_SIGNER_INFO *d2i_PKCS7_SIGNER_INFO(PKCS7_SIGNER_INFO **a, const unsigned char **in, long len);
  int i2d_PKCS7_SIGNER_INFO(PKCS7_SIGNER_INFO *a, unsigned char **out);
  extern const ASN1_ITEM PKCS7_SIGNER_INFO_it;
  PKCS7_RECIP_INFO *PKCS7_RECIP_INFO_new(void);
  void PKCS7_RECIP_INFO_free(PKCS7_RECIP_INFO *a);
  PKCS7_RECIP_INFO *d2i_PKCS7_RECIP_INFO(PKCS7_RECIP_INFO **a, const unsigned char **in, long len);
  int i2d_PKCS7_RECIP_INFO(PKCS7_RECIP_INFO *a, unsigned char **out);
  extern const ASN1_ITEM PKCS7_RECIP_INFO_it;
  PKCS7_SIGNED *PKCS7_SIGNED_new(void);
  void PKCS7_SIGNED_free(PKCS7_SIGNED *a);
  PKCS7_SIGNED *d2i_PKCS7_SIGNED(PKCS7_SIGNED **a, const unsigned char **in, long len);
  int i2d_PKCS7_SIGNED(PKCS7_SIGNED *a, unsigned char **out);
  extern const ASN1_ITEM PKCS7_SIGNED_it;
  PKCS7_ENC_CONTENT *PKCS7_ENC_CONTENT_new(void);
  void PKCS7_ENC_CONTENT_free(PKCS7_ENC_CONTENT *a);
  PKCS7_ENC_CONTENT *d2i_PKCS7_ENC_CONTENT(PKCS7_ENC_CONTENT **a, const unsigned char **in, long len);
  int i2d_PKCS7_ENC_CONTENT(PKCS7_ENC_CONTENT *a, unsigned char **out);
  extern const ASN1_ITEM PKCS7_ENC_CONTENT_it;
  PKCS7_ENVELOPE *PKCS7_ENVELOPE_new(void);
  void PKCS7_ENVELOPE_free(PKCS7_ENVELOPE *a);
  PKCS7_ENVELOPE *d2i_PKCS7_ENVELOPE(PKCS7_ENVELOPE **a, const unsigned char **in, long len);
  int i2d_PKCS7_ENVELOPE(PKCS7_ENVELOPE *a, unsigned char **out);
  extern const ASN1_ITEM PKCS7_ENVELOPE_it;
  PKCS7_SIGN_ENVELOPE *PKCS7_SIGN_ENVELOPE_new(void);
  void PKCS7_SIGN_ENVELOPE_free(PKCS7_SIGN_ENVELOPE *a);
  PKCS7_SIGN_ENVELOPE *d2i_PKCS7_SIGN_ENVELOPE(PKCS7_SIGN_ENVELOPE **a, const unsigned char **in, long len);
  int i2d_PKCS7_SIGN_ENVELOPE(PKCS7_SIGN_ENVELOPE *a, unsigned char **out);
  extern const ASN1_ITEM PKCS7_SIGN_ENVELOPE_it;
  PKCS7_DIGEST *PKCS7_DIGEST_new(void);
  void PKCS7_DIGEST_free(PKCS7_DIGEST *a);
  PKCS7_DIGEST *d2i_PKCS7_DIGEST(PKCS7_DIGEST **a, const unsigned char **in, long len);
  int i2d_PKCS7_DIGEST(PKCS7_DIGEST *a, unsigned char **out);
  extern const ASN1_ITEM PKCS7_DIGEST_it;
  PKCS7_ENCRYPT *PKCS7_ENCRYPT_new(void);
  void PKCS7_ENCRYPT_free(PKCS7_ENCRYPT *a);
  PKCS7_ENCRYPT *d2i_PKCS7_ENCRYPT(PKCS7_ENCRYPT **a, const unsigned char **in, long len);
  int i2d_PKCS7_ENCRYPT(PKCS7_ENCRYPT *a, unsigned char **out);
  extern const ASN1_ITEM PKCS7_ENCRYPT_it;
  PKCS7 *PKCS7_new(void);
  void PKCS7_free(PKCS7 *a);
  PKCS7 *d2i_PKCS7(PKCS7 **a, const unsigned char **in, long len);
  int i2d_PKCS7(PKCS7 *a, unsigned char **out);
  extern const ASN1_ITEM PKCS7_it;
  extern const ASN1_ITEM PKCS7_ATTR_SIGN_it;
  extern const ASN1_ITEM PKCS7_ATTR_VERIFY_it;
  int i2d_PKCS7_NDEF(PKCS7 *a, unsigned char **out);
  int PKCS7_print_ctx(BIO *out, PKCS7 *x, int indent, const ASN1_PCTX *pctx);
  long PKCS7_ctrl(PKCS7 *p7, int cmd, long larg, char *parg);
  int PKCS7_set_type(PKCS7 *p7, int type);
  int PKCS7_set0_type_other(PKCS7 *p7, int type, ASN1_TYPE *other);
  int PKCS7_set_content(PKCS7 *p7, PKCS7 *p7_data);
  int PKCS7_SIGNER_INFO_set(PKCS7_SIGNER_INFO *p7i, X509 *x509, EVP_PKEY *pkey,
                            const EVP_MD *dgst);
  int PKCS7_SIGNER_INFO_sign(PKCS7_SIGNER_INFO *si);
  int PKCS7_add_signer(PKCS7 *p7, PKCS7_SIGNER_INFO *p7i);
  int PKCS7_add_certificate(PKCS7 *p7, X509 *x509);
  int PKCS7_add_crl(PKCS7 *p7, X509_CRL *x509);
  int PKCS7_content_new(PKCS7 *p7, int nid);
  int PKCS7_dataVerify(X509_STORE *cert_store, X509_STORE_CTX *ctx,
                       BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si);
  int PKCS7_signatureVerify(BIO *bio, PKCS7 *p7, PKCS7_SIGNER_INFO *si,
                            X509 *x509);
  BIO *PKCS7_dataInit(PKCS7 *p7, BIO *bio);
  int PKCS7_dataFinal(PKCS7 *p7, BIO *bio);
  BIO *PKCS7_dataDecode(PKCS7 *p7, EVP_PKEY *pkey, BIO *in_bio, X509 *pcert);
  PKCS7_SIGNER_INFO *PKCS7_add_signature(PKCS7 *p7, X509 *x509,
                                         EVP_PKEY *pkey, const EVP_MD *dgst);
  X509 *PKCS7_cert_from_signer_info(PKCS7 *p7, PKCS7_SIGNER_INFO *si);
  int PKCS7_set_digest(PKCS7 *p7, const EVP_MD *md);
  struct stack_st_PKCS7_SIGNER_INFO *PKCS7_get_signer_info(PKCS7 *p7);
  PKCS7_RECIP_INFO *PKCS7_add_recipient(PKCS7 *p7, X509 *x509);
  void PKCS7_SIGNER_INFO_get0_algs(PKCS7_SIGNER_INFO *si, EVP_PKEY **pk,
                                   X509_ALGOR **pdig, X509_ALGOR **psig);
  void PKCS7_RECIP_INFO_get0_alg(PKCS7_RECIP_INFO *ri, X509_ALGOR **penc);
  int PKCS7_add_recipient_info(PKCS7 *p7, PKCS7_RECIP_INFO *ri);
  int PKCS7_RECIP_INFO_set(PKCS7_RECIP_INFO *p7i, X509 *x509);
  int PKCS7_set_cipher(PKCS7 *p7, const EVP_CIPHER *cipher);
  int PKCS7_stream(unsigned char ***boundary, PKCS7 *p7);
  PKCS7_ISSUER_AND_SERIAL *PKCS7_get_issuer_and_serial(PKCS7 *p7, int idx);
  ASN1_OCTET_STRING *PKCS7_digest_from_attributes(struct stack_st_X509_ATTRIBUTE *sk);
  int PKCS7_add_signed_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int type,
                                 void *data);
  int PKCS7_add_attribute(PKCS7_SIGNER_INFO *p7si, int nid, int atrtype,
                          void *value);
  ASN1_TYPE *PKCS7_get_attribute(PKCS7_SIGNER_INFO *si, int nid);
  ASN1_TYPE *PKCS7_get_signed_attribute(PKCS7_SIGNER_INFO *si, int nid);
  int PKCS7_set_signed_attributes(PKCS7_SIGNER_INFO *p7si,
                                  struct stack_st_X509_ATTRIBUTE *sk);
  int PKCS7_set_attributes(PKCS7_SIGNER_INFO *p7si,
                           struct stack_st_X509_ATTRIBUTE *sk);
  PKCS7 *PKCS7_sign(X509 *signcert, EVP_PKEY *pkey, struct stack_st_X509 *certs,
                    BIO *data, int flags);
  PKCS7_SIGNER_INFO *PKCS7_sign_add_signer(PKCS7 *p7,
                                           X509 *signcert, EVP_PKEY *pkey,
                                           const EVP_MD *md, int flags);
  int PKCS7_final(PKCS7 *p7, BIO *data, int flags);
  int PKCS7_verify(PKCS7 *p7, struct stack_st_X509 *certs, X509_STORE *store,
                   BIO *indata, BIO *out, int flags);
  struct stack_st_X509 *PKCS7_get0_signers(PKCS7 *p7, struct stack_st_X509 *certs,
                                           int flags);
  PKCS7 *PKCS7_encrypt(struct stack_st_X509 *certs, BIO *in, const EVP_CIPHER *cipher,
                       int flags);
  int PKCS7_decrypt(PKCS7 *p7, EVP_PKEY *pkey, X509 *cert, BIO *data,
                    int flags);
  int PKCS7_add_attrib_smimecap(PKCS7_SIGNER_INFO *si,
                                struct stack_st_X509_ALGOR *cap);
  struct stack_st_X509_ALGOR *PKCS7_get_smimecap(PKCS7_SIGNER_INFO *si);
  int PKCS7_simple_smimecap(struct stack_st_X509_ALGOR *sk, int nid, int arg);
  int PKCS7_add_attrib_content_type(PKCS7_SIGNER_INFO *si, ASN1_OBJECT *coid);
  int PKCS7_add0_attrib_signing_time(PKCS7_SIGNER_INFO *si, ASN1_TIME *t);
  int PKCS7_add1_attrib_digest(PKCS7_SIGNER_INFO *si,
                               const unsigned char *md, int mdlen);
  int SMIME_write_PKCS7(BIO *bio, PKCS7 *p7, BIO *data, int flags);
  PKCS7 *SMIME_read_PKCS7(BIO *bio, BIO **bcont);
  BIO *BIO_new_PKCS7(BIO *out, PKCS7 *p7);
}
extern "C"
{
  void X509_CRL_set_default_method(const X509_CRL_METHOD *meth);
  X509_CRL_METHOD *X509_CRL_METHOD_new(int (*crl_init)(X509_CRL *crl),
                                       int (*crl_free)(X509_CRL *crl),
                                       int (*crl_lookup)(X509_CRL *crl,
                                                         X509_REVOKED **ret,
                                                         ASN1_INTEGER *ser,
                                                         X509_NAME *issuer),
                                       int (*crl_verify)(X509_CRL *crl,
                                                         EVP_PKEY *pk));
  void X509_CRL_METHOD_free(X509_CRL_METHOD *m);
  void X509_CRL_set_meth_data(X509_CRL *crl, void *dat);
  void *X509_CRL_get_meth_data(X509_CRL *crl);
  const char *X509_verify_cert_error_string(long n);
  int X509_verify(X509 *a, EVP_PKEY *r);
  int X509_REQ_verify(X509_REQ *a, EVP_PKEY *r);
  int X509_CRL_verify(X509_CRL *a, EVP_PKEY *r);
  int NETSCAPE_SPKI_verify(NETSCAPE_SPKI *a, EVP_PKEY *r);
  NETSCAPE_SPKI *NETSCAPE_SPKI_b64_decode(const char *str, int len);
  char *NETSCAPE_SPKI_b64_encode(NETSCAPE_SPKI *x);
  EVP_PKEY *NETSCAPE_SPKI_get_pubkey(NETSCAPE_SPKI *x);
  int NETSCAPE_SPKI_set_pubkey(NETSCAPE_SPKI *x, EVP_PKEY *pkey);
  int NETSCAPE_SPKI_print(BIO *out, NETSCAPE_SPKI *spki);
  int X509_signature_dump(BIO *bp, const ASN1_STRING *sig, int indent);
  int X509_signature_print(BIO *bp, const X509_ALGOR *alg,
                           const ASN1_STRING *sig);
  int X509_sign(X509 *x, EVP_PKEY *pkey, const EVP_MD *md);
  int X509_sign_ctx(X509 *x, EVP_MD_CTX *ctx);
  int X509_http_nbio(OCSP_REQ_CTX *rctx, X509 **pcert);
  int X509_REQ_sign(X509_REQ *x, EVP_PKEY *pkey, const EVP_MD *md);
  int X509_REQ_sign_ctx(X509_REQ *x, EVP_MD_CTX *ctx);
  int X509_CRL_sign(X509_CRL *x, EVP_PKEY *pkey, const EVP_MD *md);
  int X509_CRL_sign_ctx(X509_CRL *x, EVP_MD_CTX *ctx);
  int X509_CRL_http_nbio(OCSP_REQ_CTX *rctx, X509_CRL **pcrl);
  int NETSCAPE_SPKI_sign(NETSCAPE_SPKI *x, EVP_PKEY *pkey, const EVP_MD *md);
  int X509_pubkey_digest(const X509 *data, const EVP_MD *type,
                         unsigned char *md, unsigned int *len);
  int X509_digest(const X509 *data, const EVP_MD *type,
                  unsigned char *md, unsigned int *len);
  int X509_CRL_digest(const X509_CRL *data, const EVP_MD *type,
                      unsigned char *md, unsigned int *len);
  int X509_REQ_digest(const X509_REQ *data, const EVP_MD *type,
                      unsigned char *md, unsigned int *len);
  int X509_NAME_digest(const X509_NAME *data, const EVP_MD *type,
                       unsigned char *md, unsigned int *len);
  X509 *d2i_X509_fp(FILE *fp, X509 **x509);
  int i2d_X509_fp(FILE *fp, X509 *x509);
  X509_CRL *d2i_X509_CRL_fp(FILE *fp, X509_CRL **crl);
  int i2d_X509_CRL_fp(FILE *fp, X509_CRL *crl);
  X509_REQ *d2i_X509_REQ_fp(FILE *fp, X509_REQ **req);
  int i2d_X509_REQ_fp(FILE *fp, X509_REQ *req);
  RSA *d2i_RSAPrivateKey_fp(FILE *fp, RSA **rsa);
  int i2d_RSAPrivateKey_fp(FILE *fp, RSA *rsa);
  RSA *d2i_RSAPublicKey_fp(FILE *fp, RSA **rsa);
  int i2d_RSAPublicKey_fp(FILE *fp, RSA *rsa);
  RSA *d2i_RSA_PUBKEY_fp(FILE *fp, RSA **rsa);
  int i2d_RSA_PUBKEY_fp(FILE *fp, RSA *rsa);
  DSA *d2i_DSA_PUBKEY_fp(FILE *fp, DSA **dsa);
  int i2d_DSA_PUBKEY_fp(FILE *fp, DSA *dsa);
  DSA *d2i_DSAPrivateKey_fp(FILE *fp, DSA **dsa);
  int i2d_DSAPrivateKey_fp(FILE *fp, DSA *dsa);
  EC_KEY *d2i_EC_PUBKEY_fp(FILE *fp, EC_KEY **eckey);
  int i2d_EC_PUBKEY_fp(FILE *fp, EC_KEY *eckey);
  EC_KEY *d2i_ECPrivateKey_fp(FILE *fp, EC_KEY **eckey);
  int i2d_ECPrivateKey_fp(FILE *fp, EC_KEY *eckey);
  X509_SIG *d2i_PKCS8_fp(FILE *fp, X509_SIG **p8);
  int i2d_PKCS8_fp(FILE *fp, X509_SIG *p8);
  PKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_fp(FILE *fp,
                                                  PKCS8_PRIV_KEY_INFO **p8inf);
  int i2d_PKCS8_PRIV_KEY_INFO_fp(FILE *fp, PKCS8_PRIV_KEY_INFO *p8inf);
  int i2d_PKCS8PrivateKeyInfo_fp(FILE *fp, EVP_PKEY *key);
  int i2d_PrivateKey_fp(FILE *fp, EVP_PKEY *pkey);
  EVP_PKEY *d2i_PrivateKey_fp(FILE *fp, EVP_PKEY **a);
  int i2d_PUBKEY_fp(FILE *fp, EVP_PKEY *pkey);
  EVP_PKEY *d2i_PUBKEY_fp(FILE *fp, EVP_PKEY **a);
  X509 *d2i_X509_bio(BIO *bp, X509 **x509);
  int i2d_X509_bio(BIO *bp, X509 *x509);
  X509_CRL *d2i_X509_CRL_bio(BIO *bp, X509_CRL **crl);
  int i2d_X509_CRL_bio(BIO *bp, X509_CRL *crl);
  X509_REQ *d2i_X509_REQ_bio(BIO *bp, X509_REQ **req);
  int i2d_X509_REQ_bio(BIO *bp, X509_REQ *req);
  RSA *d2i_RSAPrivateKey_bio(BIO *bp, RSA **rsa);
  int i2d_RSAPrivateKey_bio(BIO *bp, RSA *rsa);
  RSA *d2i_RSAPublicKey_bio(BIO *bp, RSA **rsa);
  int i2d_RSAPublicKey_bio(BIO *bp, RSA *rsa);
  RSA *d2i_RSA_PUBKEY_bio(BIO *bp, RSA **rsa);
  int i2d_RSA_PUBKEY_bio(BIO *bp, RSA *rsa);
  DSA *d2i_DSA_PUBKEY_bio(BIO *bp, DSA **dsa);
  int i2d_DSA_PUBKEY_bio(BIO *bp, DSA *dsa);
  DSA *d2i_DSAPrivateKey_bio(BIO *bp, DSA **dsa);
  int i2d_DSAPrivateKey_bio(BIO *bp, DSA *dsa);
  EC_KEY *d2i_EC_PUBKEY_bio(BIO *bp, EC_KEY **eckey);
  int i2d_EC_PUBKEY_bio(BIO *bp, EC_KEY *eckey);
  EC_KEY *d2i_ECPrivateKey_bio(BIO *bp, EC_KEY **eckey);
  int i2d_ECPrivateKey_bio(BIO *bp, EC_KEY *eckey);
  X509_SIG *d2i_PKCS8_bio(BIO *bp, X509_SIG **p8);
  int i2d_PKCS8_bio(BIO *bp, X509_SIG *p8);
  PKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO_bio(BIO *bp,
                                                   PKCS8_PRIV_KEY_INFO **p8inf);
  int i2d_PKCS8_PRIV_KEY_INFO_bio(BIO *bp, PKCS8_PRIV_KEY_INFO *p8inf);
  int i2d_PKCS8PrivateKeyInfo_bio(BIO *bp, EVP_PKEY *key);
  int i2d_PrivateKey_bio(BIO *bp, EVP_PKEY *pkey);
  EVP_PKEY *d2i_PrivateKey_bio(BIO *bp, EVP_PKEY **a);
  int i2d_PUBKEY_bio(BIO *bp, EVP_PKEY *pkey);
  EVP_PKEY *d2i_PUBKEY_bio(BIO *bp, EVP_PKEY **a);
  X509 *X509_dup(X509 *x509);
  X509_ATTRIBUTE *X509_ATTRIBUTE_dup(X509_ATTRIBUTE *xa);
  X509_EXTENSION *X509_EXTENSION_dup(X509_EXTENSION *ex);
  X509_CRL *X509_CRL_dup(X509_CRL *crl);
  X509_REVOKED *X509_REVOKED_dup(X509_REVOKED *rev);
  X509_REQ *X509_REQ_dup(X509_REQ *req);
  X509_ALGOR *X509_ALGOR_dup(X509_ALGOR *xn);
  int X509_ALGOR_set0(X509_ALGOR *alg, ASN1_OBJECT *aobj, int ptype,
                      void *pval);
  void X509_ALGOR_get0(const ASN1_OBJECT **paobj, int *pptype,
                       const void **ppval, const X509_ALGOR *algor);
  void X509_ALGOR_set_md(X509_ALGOR *alg, const EVP_MD *md);
  int X509_ALGOR_cmp(const X509_ALGOR *a, const X509_ALGOR *b);
  X509_NAME *X509_NAME_dup(X509_NAME *xn);
  X509_NAME_ENTRY *X509_NAME_ENTRY_dup(X509_NAME_ENTRY *ne);
  int X509_cmp_time(const ASN1_TIME *s, time_t *t);
  int X509_cmp_current_time(const ASN1_TIME *s);
  ASN1_TIME *X509_time_adj(ASN1_TIME *s, long adj, time_t *t);
  ASN1_TIME *X509_time_adj_ex(ASN1_TIME *s,
                              int offset_day, long offset_sec, time_t *t);
  ASN1_TIME *X509_gmtime_adj(ASN1_TIME *s, long adj);
  const char *X509_get_default_cert_area(void);
  const char *X509_get_default_cert_dir(void);
  const char *X509_get_default_cert_file(void);
  const char *X509_get_default_cert_dir_env(void);
  const char *X509_get_default_cert_file_env(void);
  const char *X509_get_default_private_dir(void);
  X509_REQ *X509_to_X509_REQ(X509 *x, EVP_PKEY *pkey, const EVP_MD *md);
  X509 *X509_REQ_to_X509(X509_REQ *r, int days, EVP_PKEY *pkey);
  X509_ALGOR *X509_ALGOR_new(void);
  void X509_ALGOR_free(X509_ALGOR *a);
  X509_ALGOR *d2i_X509_ALGOR(X509_ALGOR **a, const unsigned char **in, long len);
  int i2d_X509_ALGOR(X509_ALGOR *a, unsigned char **out);
  extern const ASN1_ITEM X509_ALGOR_it;
  X509_ALGORS *d2i_X509_ALGORS(X509_ALGORS **a, const unsigned char **in, long len);
  int i2d_X509_ALGORS(X509_ALGORS *a, unsigned char **out);
  extern const ASN1_ITEM X509_ALGORS_it;
  X509_VAL *X509_VAL_new(void);
  void X509_VAL_free(X509_VAL *a);
  X509_VAL *d2i_X509_VAL(X509_VAL **a, const unsigned char **in, long len);
  int i2d_X509_VAL(X509_VAL *a, unsigned char **out);
  extern const ASN1_ITEM X509_VAL_it;
  X509_PUBKEY *X509_PUBKEY_new(void);
  void X509_PUBKEY_free(X509_PUBKEY *a);
  X509_PUBKEY *d2i_X509_PUBKEY(X509_PUBKEY **a, const unsigned char **in, long len);
  int i2d_X509_PUBKEY(X509_PUBKEY *a, unsigned char **out);
  extern const ASN1_ITEM X509_PUBKEY_it;
  int X509_PUBKEY_set(X509_PUBKEY **x, EVP_PKEY *pkey);
  EVP_PKEY *X509_PUBKEY_get0(X509_PUBKEY *key);
  EVP_PKEY *X509_PUBKEY_get(X509_PUBKEY *key);
  int X509_get_pubkey_parameters(EVP_PKEY *pkey, struct stack_st_X509 *chain);
  long X509_get_pathlen(X509 *x);
  int i2d_PUBKEY(EVP_PKEY *a, unsigned char **pp);
  EVP_PKEY *d2i_PUBKEY(EVP_PKEY **a, const unsigned char **pp, long length);
  int i2d_RSA_PUBKEY(RSA *a, unsigned char **pp);
  RSA *d2i_RSA_PUBKEY(RSA **a, const unsigned char **pp, long length);
  int i2d_DSA_PUBKEY(DSA *a, unsigned char **pp);
  DSA *d2i_DSA_PUBKEY(DSA **a, const unsigned char **pp, long length);
  int i2d_EC_PUBKEY(EC_KEY *a, unsigned char **pp);
  EC_KEY *d2i_EC_PUBKEY(EC_KEY **a, const unsigned char **pp, long length);
  X509_SIG *X509_SIG_new(void);
  void X509_SIG_free(X509_SIG *a);
  X509_SIG *d2i_X509_SIG(X509_SIG **a, const unsigned char **in, long len);
  int i2d_X509_SIG(X509_SIG *a, unsigned char **out);
  extern const ASN1_ITEM X509_SIG_it;
  void X509_SIG_get0(const X509_SIG *sig, const X509_ALGOR **palg,
                     const ASN1_OCTET_STRING **pdigest);
  void X509_SIG_getm(X509_SIG *sig, X509_ALGOR **palg,
                     ASN1_OCTET_STRING **pdigest);
  X509_REQ_INFO *X509_REQ_INFO_new(void);
  void X509_REQ_INFO_free(X509_REQ_INFO *a);
  X509_REQ_INFO *d2i_X509_REQ_INFO(X509_REQ_INFO **a, const unsigned char **in, long len);
  int i2d_X509_REQ_INFO(X509_REQ_INFO *a, unsigned char **out);
  extern const ASN1_ITEM X509_REQ_INFO_it;
  X509_REQ *X509_REQ_new(void);
  void X509_REQ_free(X509_REQ *a);
  X509_REQ *d2i_X509_REQ(X509_REQ **a, const unsigned char **in, long len);
  int i2d_X509_REQ(X509_REQ *a, unsigned char **out);
  extern const ASN1_ITEM X509_REQ_it;
  X509_ATTRIBUTE *X509_ATTRIBUTE_new(void);
  void X509_ATTRIBUTE_free(X509_ATTRIBUTE *a);
  X509_ATTRIBUTE *d2i_X509_ATTRIBUTE(X509_ATTRIBUTE **a, const unsigned char **in, long len);
  int i2d_X509_ATTRIBUTE(X509_ATTRIBUTE *a, unsigned char **out);
  extern const ASN1_ITEM X509_ATTRIBUTE_it;
  X509_ATTRIBUTE *X509_ATTRIBUTE_create(int nid, int atrtype, void *value);
  X509_EXTENSION *X509_EXTENSION_new(void);
  void X509_EXTENSION_free(X509_EXTENSION *a);
  X509_EXTENSION *d2i_X509_EXTENSION(X509_EXTENSION **a, const unsigned char **in, long len);
  int i2d_X509_EXTENSION(X509_EXTENSION *a, unsigned char **out);
  extern const ASN1_ITEM X509_EXTENSION_it;
  X509_EXTENSIONS *d2i_X509_EXTENSIONS(X509_EXTENSIONS **a, const unsigned char **in, long len);
  int i2d_X509_EXTENSIONS(X509_EXTENSIONS *a, unsigned char **out);
  extern const ASN1_ITEM X509_EXTENSIONS_it;
  X509_NAME_ENTRY *X509_NAME_ENTRY_new(void);
  void X509_NAME_ENTRY_free(X509_NAME_ENTRY *a);
  X509_NAME_ENTRY *d2i_X509_NAME_ENTRY(X509_NAME_ENTRY **a, const unsigned char **in, long len);
  int i2d_X509_NAME_ENTRY(X509_NAME_ENTRY *a, unsigned char **out);
  extern const ASN1_ITEM X509_NAME_ENTRY_it;
  X509_NAME *X509_NAME_new(void);
  void X509_NAME_free(X509_NAME *a);
  X509_NAME *d2i_X509_NAME(X509_NAME **a, const unsigned char **in, long len);
  int i2d_X509_NAME(X509_NAME *a, unsigned char **out);
  extern const ASN1_ITEM X509_NAME_it;
  int X509_NAME_set(X509_NAME **xn, X509_NAME *name);
  X509_CINF *X509_CINF_new(void);
  void X509_CINF_free(X509_CINF *a);
  X509_CINF *d2i_X509_CINF(X509_CINF **a, const unsigned char **in, long len);
  int i2d_X509_CINF(X509_CINF *a, unsigned char **out);
  extern const ASN1_ITEM X509_CINF_it;
  X509 *X509_new(void);
  void X509_free(X509 *a);
  X509 *d2i_X509(X509 **a, const unsigned char **in, long len);
  int i2d_X509(X509 *a, unsigned char **out);
  extern const ASN1_ITEM X509_it;
  X509_CERT_AUX *X509_CERT_AUX_new(void);
  void X509_CERT_AUX_free(X509_CERT_AUX *a);
  X509_CERT_AUX *d2i_X509_CERT_AUX(X509_CERT_AUX **a, const unsigned char **in, long len);
  int i2d_X509_CERT_AUX(X509_CERT_AUX *a, unsigned char **out);
  extern const ASN1_ITEM X509_CERT_AUX_it;
  int X509_set_ex_data(X509 *r, int idx, void *arg);
  void *X509_get_ex_data(X509 *r, int idx);
  int i2d_X509_AUX(X509 *a, unsigned char **pp);
  X509 *d2i_X509_AUX(X509 **a, const unsigned char **pp, long length);
  int i2d_re_X509_tbs(X509 *x, unsigned char **pp);
  int X509_SIG_INFO_get(const X509_SIG_INFO *siginf, int *mdnid, int *pknid,
                        int *secbits, uint32_t *flags);
  void X509_SIG_INFO_set(X509_SIG_INFO *siginf, int mdnid, int pknid,
                         int secbits, uint32_t flags);
  int X509_get_signature_info(X509 *x, int *mdnid, int *pknid, int *secbits,
                              uint32_t *flags);
  void X509_get0_signature(const ASN1_BIT_STRING **psig,
                           const X509_ALGOR **palg, const X509 *x);
  int X509_get_signature_nid(const X509 *x);
  int X509_trusted(const X509 *x);
  int X509_alias_set1(X509 *x, const unsigned char *name, int len);
  int X509_keyid_set1(X509 *x, const unsigned char *id, int len);
  unsigned char *X509_alias_get0(X509 *x, int *len);
  unsigned char *X509_keyid_get0(X509 *x, int *len);
  int (*X509_TRUST_set_default(int (*trust)(int, X509 *, int)))(int, X509 *,
                                                                int);
  int X509_TRUST_set(int *t, int trust);
  int X509_add1_trust_object(X509 *x, const ASN1_OBJECT *obj);
  int X509_add1_reject_object(X509 *x, const ASN1_OBJECT *obj);
  void X509_trust_clear(X509 *x);
  void X509_reject_clear(X509 *x);
  struct stack_st_ASN1_OBJECT *X509_get0_trust_objects(X509 *x);
  struct stack_st_ASN1_OBJECT *X509_get0_reject_objects(X509 *x);
  X509_REVOKED *X509_REVOKED_new(void);
  void X509_REVOKED_free(X509_REVOKED *a);
  X509_REVOKED *d2i_X509_REVOKED(X509_REVOKED **a, const unsigned char **in, long len);
  int i2d_X509_REVOKED(X509_REVOKED *a, unsigned char **out);
  extern const ASN1_ITEM X509_REVOKED_it;
  X509_CRL_INFO *X509_CRL_INFO_new(void);
  void X509_CRL_INFO_free(X509_CRL_INFO *a);
  X509_CRL_INFO *d2i_X509_CRL_INFO(X509_CRL_INFO **a, const unsigned char **in, long len);
  int i2d_X509_CRL_INFO(X509_CRL_INFO *a, unsigned char **out);
  extern const ASN1_ITEM X509_CRL_INFO_it;
  X509_CRL *X509_CRL_new(void);
  void X509_CRL_free(X509_CRL *a);
  X509_CRL *d2i_X509_CRL(X509_CRL **a, const unsigned char **in, long len);
  int i2d_X509_CRL(X509_CRL *a, unsigned char **out);
  extern const ASN1_ITEM X509_CRL_it;
  int X509_CRL_add0_revoked(X509_CRL *crl, X509_REVOKED *rev);
  int X509_CRL_get0_by_serial(X509_CRL *crl,
                              X509_REVOKED **ret, ASN1_INTEGER *serial);
  int X509_CRL_get0_by_cert(X509_CRL *crl, X509_REVOKED **ret, X509 *x);
  X509_PKEY *X509_PKEY_new(void);
  void X509_PKEY_free(X509_PKEY *a);
  NETSCAPE_SPKI *NETSCAPE_SPKI_new(void);
  void NETSCAPE_SPKI_free(NETSCAPE_SPKI *a);
  NETSCAPE_SPKI *d2i_NETSCAPE_SPKI(NETSCAPE_SPKI **a, const unsigned char **in, long len);
  int i2d_NETSCAPE_SPKI(NETSCAPE_SPKI *a, unsigned char **out);
  extern const ASN1_ITEM NETSCAPE_SPKI_it;
  NETSCAPE_SPKAC *NETSCAPE_SPKAC_new(void);
  void NETSCAPE_SPKAC_free(NETSCAPE_SPKAC *a);
  NETSCAPE_SPKAC *d2i_NETSCAPE_SPKAC(NETSCAPE_SPKAC **a, const unsigned char **in, long len);
  int i2d_NETSCAPE_SPKAC(NETSCAPE_SPKAC *a, unsigned char **out);
  extern const ASN1_ITEM NETSCAPE_SPKAC_it;
  NETSCAPE_CERT_SEQUENCE *NETSCAPE_CERT_SEQUENCE_new(void);
  void NETSCAPE_CERT_SEQUENCE_free(NETSCAPE_CERT_SEQUENCE *a);
  NETSCAPE_CERT_SEQUENCE *d2i_NETSCAPE_CERT_SEQUENCE(NETSCAPE_CERT_SEQUENCE **a, const unsigned char **in, long len);
  int i2d_NETSCAPE_CERT_SEQUENCE(NETSCAPE_CERT_SEQUENCE *a, unsigned char **out);
  extern const ASN1_ITEM NETSCAPE_CERT_SEQUENCE_it;
  X509_INFO *X509_INFO_new(void);
  void X509_INFO_free(X509_INFO *a);
  char *X509_NAME_oneline(const X509_NAME *a, char *buf, int size);
  int ASN1_verify(i2d_of_void *i2d, X509_ALGOR *algor1,
                  ASN1_BIT_STRING *signature, char *data, EVP_PKEY *pkey);
  int ASN1_digest(i2d_of_void *i2d, const EVP_MD *type, char *data,
                  unsigned char *md, unsigned int *len);
  int ASN1_sign(i2d_of_void *i2d, X509_ALGOR *algor1,
                X509_ALGOR *algor2, ASN1_BIT_STRING *signature,
                char *data, EVP_PKEY *pkey, const EVP_MD *type);
  int ASN1_item_digest(const ASN1_ITEM *it, const EVP_MD *type, void *data,
                       unsigned char *md, unsigned int *len);
  int ASN1_item_verify(const ASN1_ITEM *it, X509_ALGOR *algor1,
                       ASN1_BIT_STRING *signature, void *data, EVP_PKEY *pkey);
  int ASN1_item_sign(const ASN1_ITEM *it, X509_ALGOR *algor1,
                     X509_ALGOR *algor2, ASN1_BIT_STRING *signature, void *data,
                     EVP_PKEY *pkey, const EVP_MD *type);
  int ASN1_item_sign_ctx(const ASN1_ITEM *it, X509_ALGOR *algor1,
                         X509_ALGOR *algor2, ASN1_BIT_STRING *signature,
                         void *asn, EVP_MD_CTX *ctx);
  long X509_get_version(const X509 *x);
  int X509_set_version(X509 *x, long version);
  int X509_set_serialNumber(X509 *x, ASN1_INTEGER *serial);
  ASN1_INTEGER *X509_get_serialNumber(X509 *x);
  const ASN1_INTEGER *X509_get0_serialNumber(const X509 *x);
  int X509_set_issuer_name(X509 *x, X509_NAME *name);
  X509_NAME *X509_get_issuer_name(const X509 *a);
  int X509_set_subject_name(X509 *x, X509_NAME *name);
  X509_NAME *X509_get_subject_name(const X509 *a);
  const ASN1_TIME *X509_get0_notBefore(const X509 *x);
  ASN1_TIME *X509_getm_notBefore(const X509 *x);
  int X509_set1_notBefore(X509 *x, const ASN1_TIME *tm);
  const ASN1_TIME *X509_get0_notAfter(const X509 *x);
  ASN1_TIME *X509_getm_notAfter(const X509 *x);
  int X509_set1_notAfter(X509 *x, const ASN1_TIME *tm);
  int X509_set_pubkey(X509 *x, EVP_PKEY *pkey);
  int X509_up_ref(X509 *x);
  int X509_get_signature_type(const X509 *x);
  X509_PUBKEY *X509_get_X509_PUBKEY(const X509 *x);
  const struct stack_st_X509_EXTENSION *X509_get0_extensions(const X509 *x);
  void X509_get0_uids(const X509 *x, const ASN1_BIT_STRING **piuid,
                      const ASN1_BIT_STRING **psuid);
  const X509_ALGOR *X509_get0_tbs_sigalg(const X509 *x);
  EVP_PKEY *X509_get0_pubkey(const X509 *x);
  EVP_PKEY *X509_get_pubkey(X509 *x);
  ASN1_BIT_STRING *X509_get0_pubkey_bitstr(const X509 *x);
  int X509_certificate_type(const X509 *x, const EVP_PKEY *pubkey);
  long X509_REQ_get_version(const X509_REQ *req);
  int X509_REQ_set_version(X509_REQ *x, long version);
  X509_NAME *X509_REQ_get_subject_name(const X509_REQ *req);
  int X509_REQ_set_subject_name(X509_REQ *req, X509_NAME *name);
  void X509_REQ_get0_signature(const X509_REQ *req, const ASN1_BIT_STRING **psig,
                               const X509_ALGOR **palg);
  int X509_REQ_get_signature_nid(const X509_REQ *req);
  int i2d_re_X509_REQ_tbs(X509_REQ *req, unsigned char **pp);
  int X509_REQ_set_pubkey(X509_REQ *x, EVP_PKEY *pkey);
  EVP_PKEY *X509_REQ_get_pubkey(X509_REQ *req);
  EVP_PKEY *X509_REQ_get0_pubkey(X509_REQ *req);
  X509_PUBKEY *X509_REQ_get_X509_PUBKEY(X509_REQ *req);
  int X509_REQ_extension_nid(int nid);
  int *X509_REQ_get_extension_nids(void);
  void X509_REQ_set_extension_nids(int *nids);
  struct stack_st_X509_EXTENSION *X509_REQ_get_extensions(X509_REQ *req);
  int X509_REQ_add_extensions_nid(X509_REQ *req, struct stack_st_X509_EXTENSION *exts,
                                  int nid);
  int X509_REQ_add_extensions(X509_REQ *req, struct stack_st_X509_EXTENSION *exts);
  int X509_REQ_get_attr_count(const X509_REQ *req);
  int X509_REQ_get_attr_by_NID(const X509_REQ *req, int nid, int lastpos);
  int X509_REQ_get_attr_by_OBJ(const X509_REQ *req, const ASN1_OBJECT *obj,
                               int lastpos);
  X509_ATTRIBUTE *X509_REQ_get_attr(const X509_REQ *req, int loc);
  X509_ATTRIBUTE *X509_REQ_delete_attr(X509_REQ *req, int loc);
  int X509_REQ_add1_attr(X509_REQ *req, X509_ATTRIBUTE *attr);
  int X509_REQ_add1_attr_by_OBJ(X509_REQ *req,
                                const ASN1_OBJECT *obj, int type,
                                const unsigned char *bytes, int len);
  int X509_REQ_add1_attr_by_NID(X509_REQ *req,
                                int nid, int type,
                                const unsigned char *bytes, int len);
  int X509_REQ_add1_attr_by_txt(X509_REQ *req,
                                const char *attrname, int type,
                                const unsigned char *bytes, int len);
  int X509_CRL_set_version(X509_CRL *x, long version);
  int X509_CRL_set_issuer_name(X509_CRL *x, X509_NAME *name);
  int X509_CRL_set1_lastUpdate(X509_CRL *x, const ASN1_TIME *tm);
  int X509_CRL_set1_nextUpdate(X509_CRL *x, const ASN1_TIME *tm);
  int X509_CRL_sort(X509_CRL *crl);
  int X509_CRL_up_ref(X509_CRL *crl);
  long X509_CRL_get_version(const X509_CRL *crl);
  const ASN1_TIME *X509_CRL_get0_lastUpdate(const X509_CRL *crl);
  const ASN1_TIME *X509_CRL_get0_nextUpdate(const X509_CRL *crl);
  ASN1_TIME *X509_CRL_get_lastUpdate(X509_CRL *crl) __attribute__((deprecated));
  ASN1_TIME *X509_CRL_get_nextUpdate(X509_CRL *crl) __attribute__((deprecated));
  X509_NAME *X509_CRL_get_issuer(const X509_CRL *crl);
  const struct stack_st_X509_EXTENSION *X509_CRL_get0_extensions(const X509_CRL *crl);
  struct stack_st_X509_REVOKED *X509_CRL_get_REVOKED(X509_CRL *crl);
  void X509_CRL_get0_signature(const X509_CRL *crl, const ASN1_BIT_STRING **psig,
                               const X509_ALGOR **palg);
  int X509_CRL_get_signature_nid(const X509_CRL *crl);
  int i2d_re_X509_CRL_tbs(X509_CRL *req, unsigned char **pp);
  const ASN1_INTEGER *X509_REVOKED_get0_serialNumber(const X509_REVOKED *x);
  int X509_REVOKED_set_serialNumber(X509_REVOKED *x, ASN1_INTEGER *serial);
  const ASN1_TIME *X509_REVOKED_get0_revocationDate(const X509_REVOKED *x);
  int X509_REVOKED_set_revocationDate(X509_REVOKED *r, ASN1_TIME *tm);
  const struct stack_st_X509_EXTENSION *
  X509_REVOKED_get0_extensions(const X509_REVOKED *r);
  X509_CRL *X509_CRL_diff(X509_CRL *base, X509_CRL *newer,
                          EVP_PKEY *skey, const EVP_MD *md, unsigned int flags);
  int X509_REQ_check_private_key(X509_REQ *x509, EVP_PKEY *pkey);
  int X509_check_private_key(const X509 *x509, const EVP_PKEY *pkey);
  int X509_chain_check_suiteb(int *perror_depth,
                              X509 *x, struct stack_st_X509 *chain,
                              unsigned long flags);
  int X509_CRL_check_suiteb(X509_CRL *crl, EVP_PKEY *pk, unsigned long flags);
  struct stack_st_X509 *X509_chain_up_ref(struct stack_st_X509 *chain);
  int X509_issuer_and_serial_cmp(const X509 *a, const X509 *b);
  unsigned long X509_issuer_and_serial_hash(X509 *a);
  int X509_issuer_name_cmp(const X509 *a, const X509 *b);
  unsigned long X509_issuer_name_hash(X509 *a);
  int X509_subject_name_cmp(const X509 *a, const X509 *b);
  unsigned long X509_subject_name_hash(X509 *x);
  unsigned long X509_issuer_name_hash_old(X509 *a);
  unsigned long X509_subject_name_hash_old(X509 *x);
  int X509_cmp(const X509 *a, const X509 *b);
  int X509_NAME_cmp(const X509_NAME *a, const X509_NAME *b);
  unsigned long X509_NAME_hash(X509_NAME *x);
  unsigned long X509_NAME_hash_old(X509_NAME *x);
  int X509_CRL_cmp(const X509_CRL *a, const X509_CRL *b);
  int X509_CRL_match(const X509_CRL *a, const X509_CRL *b);
  int X509_aux_print(BIO *out, X509 *x, int indent);
  int X509_print_ex_fp(FILE *bp, X509 *x, unsigned long nmflag,
                       unsigned long cflag);
  int X509_print_fp(FILE *bp, X509 *x);
  int X509_CRL_print_fp(FILE *bp, X509_CRL *x);
  int X509_REQ_print_fp(FILE *bp, X509_REQ *req);
  int X509_NAME_print_ex_fp(FILE *fp, const X509_NAME *nm, int indent,
                            unsigned long flags);
  int X509_NAME_print(BIO *bp, const X509_NAME *name, int obase);
  int X509_NAME_print_ex(BIO *out, const X509_NAME *nm, int indent,
                         unsigned long flags);
  int X509_print_ex(BIO *bp, X509 *x, unsigned long nmflag,
                    unsigned long cflag);
  int X509_print(BIO *bp, X509 *x);
  int X509_ocspid_print(BIO *bp, X509 *x);
  int X509_CRL_print_ex(BIO *out, X509_CRL *x, unsigned long nmflag);
  int X509_CRL_print(BIO *bp, X509_CRL *x);
  int X509_REQ_print_ex(BIO *bp, X509_REQ *x, unsigned long nmflag,
                        unsigned long cflag);
  int X509_REQ_print(BIO *bp, X509_REQ *req);
  int X509_NAME_entry_count(const X509_NAME *name);
  int X509_NAME_get_text_by_NID(X509_NAME *name, int nid, char *buf, int len);
  int X509_NAME_get_text_by_OBJ(X509_NAME *name, const ASN1_OBJECT *obj,
                                char *buf, int len);
  int X509_NAME_get_index_by_NID(X509_NAME *name, int nid, int lastpos);
  int X509_NAME_get_index_by_OBJ(X509_NAME *name, const ASN1_OBJECT *obj,
                                 int lastpos);
  X509_NAME_ENTRY *X509_NAME_get_entry(const X509_NAME *name, int loc);
  X509_NAME_ENTRY *X509_NAME_delete_entry(X509_NAME *name, int loc);
  int X509_NAME_add_entry(X509_NAME *name, const X509_NAME_ENTRY *ne,
                          int loc, int set);
  int X509_NAME_add_entry_by_OBJ(X509_NAME *name, const ASN1_OBJECT *obj, int type,
                                 const unsigned char *bytes, int len, int loc,
                                 int set);
  int X509_NAME_add_entry_by_NID(X509_NAME *name, int nid, int type,
                                 const unsigned char *bytes, int len, int loc,
                                 int set);
  X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_txt(X509_NAME_ENTRY **ne,
                                                 const char *field, int type,
                                                 const unsigned char *bytes,
                                                 int len);
  X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_NID(X509_NAME_ENTRY **ne, int nid,
                                                 int type,
                                                 const unsigned char *bytes,
                                                 int len);
  int X509_NAME_add_entry_by_txt(X509_NAME *name, const char *field, int type,
                                 const unsigned char *bytes, int len, int loc,
                                 int set);
  X509_NAME_ENTRY *X509_NAME_ENTRY_create_by_OBJ(X509_NAME_ENTRY **ne,
                                                 const ASN1_OBJECT *obj, int type,
                                                 const unsigned char *bytes,
                                                 int len);
  int X509_NAME_ENTRY_set_object(X509_NAME_ENTRY *ne, const ASN1_OBJECT *obj);
  int X509_NAME_ENTRY_set_data(X509_NAME_ENTRY *ne, int type,
                               const unsigned char *bytes, int len);
  ASN1_OBJECT *X509_NAME_ENTRY_get_object(const X509_NAME_ENTRY *ne);
  ASN1_STRING *X509_NAME_ENTRY_get_data(const X509_NAME_ENTRY *ne);
  int X509_NAME_ENTRY_set(const X509_NAME_ENTRY *ne);
  int X509_NAME_get0_der(X509_NAME *nm, const unsigned char **pder,
                         size_t *pderlen);
  int X509v3_get_ext_count(const struct stack_st_X509_EXTENSION *x);
  int X509v3_get_ext_by_NID(const struct stack_st_X509_EXTENSION *x,
                            int nid, int lastpos);
  int X509v3_get_ext_by_OBJ(const struct stack_st_X509_EXTENSION *x,
                            const ASN1_OBJECT *obj, int lastpos);
  int X509v3_get_ext_by_critical(const struct stack_st_X509_EXTENSION *x,
                                 int crit, int lastpos);
  X509_EXTENSION *X509v3_get_ext(const struct stack_st_X509_EXTENSION *x, int loc);
  X509_EXTENSION *X509v3_delete_ext(struct stack_st_X509_EXTENSION *x, int loc);
  struct stack_st_X509_EXTENSION *X509v3_add_ext(struct stack_st_X509_EXTENSION **x,
                                                 X509_EXTENSION *ex, int loc);
  int X509_get_ext_count(const X509 *x);
  int X509_get_ext_by_NID(const X509 *x, int nid, int lastpos);
  int X509_get_ext_by_OBJ(const X509 *x, const ASN1_OBJECT *obj, int lastpos);
  int X509_get_ext_by_critical(const X509 *x, int crit, int lastpos);
  X509_EXTENSION *X509_get_ext(const X509 *x, int loc);
  X509_EXTENSION *X509_delete_ext(X509 *x, int loc);
  int X509_add_ext(X509 *x, X509_EXTENSION *ex, int loc);
  void *X509_get_ext_d2i(const X509 *x, int nid, int *crit, int *idx);
  int X509_add1_ext_i2d(X509 *x, int nid, void *value, int crit,
                        unsigned long flags);
  int X509_CRL_get_ext_count(const X509_CRL *x);
  int X509_CRL_get_ext_by_NID(const X509_CRL *x, int nid, int lastpos);
  int X509_CRL_get_ext_by_OBJ(const X509_CRL *x, const ASN1_OBJECT *obj,
                              int lastpos);
  int X509_CRL_get_ext_by_critical(const X509_CRL *x, int crit, int lastpos);
  X509_EXTENSION *X509_CRL_get_ext(const X509_CRL *x, int loc);
  X509_EXTENSION *X509_CRL_delete_ext(X509_CRL *x, int loc);
  int X509_CRL_add_ext(X509_CRL *x, X509_EXTENSION *ex, int loc);
  void *X509_CRL_get_ext_d2i(const X509_CRL *x, int nid, int *crit, int *idx);
  int X509_CRL_add1_ext_i2d(X509_CRL *x, int nid, void *value, int crit,
                            unsigned long flags);
  int X509_REVOKED_get_ext_count(const X509_REVOKED *x);
  int X509_REVOKED_get_ext_by_NID(const X509_REVOKED *x, int nid, int lastpos);
  int X509_REVOKED_get_ext_by_OBJ(const X509_REVOKED *x, const ASN1_OBJECT *obj,
                                  int lastpos);
  int X509_REVOKED_get_ext_by_critical(const X509_REVOKED *x, int crit,
                                       int lastpos);
  X509_EXTENSION *X509_REVOKED_get_ext(const X509_REVOKED *x, int loc);
  X509_EXTENSION *X509_REVOKED_delete_ext(X509_REVOKED *x, int loc);
  int X509_REVOKED_add_ext(X509_REVOKED *x, X509_EXTENSION *ex, int loc);
  void *X509_REVOKED_get_ext_d2i(const X509_REVOKED *x, int nid, int *crit,
                                 int *idx);
  int X509_REVOKED_add1_ext_i2d(X509_REVOKED *x, int nid, void *value, int crit,
                                unsigned long flags);
  X509_EXTENSION *X509_EXTENSION_create_by_NID(X509_EXTENSION **ex,
                                               int nid, int crit,
                                               ASN1_OCTET_STRING *data);
  X509_EXTENSION *X509_EXTENSION_create_by_OBJ(X509_EXTENSION **ex,
                                               const ASN1_OBJECT *obj, int crit,
                                               ASN1_OCTET_STRING *data);
  int X509_EXTENSION_set_object(X509_EXTENSION *ex, const ASN1_OBJECT *obj);
  int X509_EXTENSION_set_critical(X509_EXTENSION *ex, int crit);
  int X509_EXTENSION_set_data(X509_EXTENSION *ex, ASN1_OCTET_STRING *data);
  ASN1_OBJECT *X509_EXTENSION_get_object(X509_EXTENSION *ex);
  ASN1_OCTET_STRING *X509_EXTENSION_get_data(X509_EXTENSION *ne);
  int X509_EXTENSION_get_critical(const X509_EXTENSION *ex);
  int X509at_get_attr_count(const struct stack_st_X509_ATTRIBUTE *x);
  int X509at_get_attr_by_NID(const struct stack_st_X509_ATTRIBUTE *x, int nid,
                             int lastpos);
  int X509at_get_attr_by_OBJ(const struct stack_st_X509_ATTRIBUTE *sk,
                             const ASN1_OBJECT *obj, int lastpos);
  X509_ATTRIBUTE *X509at_get_attr(const struct stack_st_X509_ATTRIBUTE *x, int loc);
  X509_ATTRIBUTE *X509at_delete_attr(struct stack_st_X509_ATTRIBUTE *x, int loc);
  struct stack_st_X509_ATTRIBUTE *X509at_add1_attr(struct stack_st_X509_ATTRIBUTE **x,
                                                   X509_ATTRIBUTE *attr);
  struct stack_st_X509_ATTRIBUTE *X509at_add1_attr_by_OBJ(struct stack_st_X509_ATTRIBUTE
                                                              **x,
                                                          const ASN1_OBJECT *obj,
                                                          int type,
                                                          const unsigned char *bytes,
                                                          int len);
  struct stack_st_X509_ATTRIBUTE *X509at_add1_attr_by_NID(struct stack_st_X509_ATTRIBUTE
                                                              **x,
                                                          int nid, int type,
                                                          const unsigned char *bytes,
                                                          int len);
  struct stack_st_X509_ATTRIBUTE *X509at_add1_attr_by_txt(struct stack_st_X509_ATTRIBUTE
                                                              **x,
                                                          const char *attrname,
                                                          int type,
                                                          const unsigned char *bytes,
                                                          int len);
  void *X509at_get0_data_by_OBJ(struct stack_st_X509_ATTRIBUTE *x,
                                const ASN1_OBJECT *obj, int lastpos, int type);
  X509_ATTRIBUTE *X509_ATTRIBUTE_create_by_NID(X509_ATTRIBUTE **attr, int nid,
                                               int atrtype, const void *data,
                                               int len);
  X509_ATTRIBUTE *X509_ATTRIBUTE_create_by_OBJ(X509_ATTRIBUTE **attr,
                                               const ASN1_OBJECT *obj,
                                               int atrtype, const void *data,
                                               int len);
  X509_ATTRIBUTE *X509_ATTRIBUTE_create_by_txt(X509_ATTRIBUTE **attr,
                                               const char *atrname, int type,
                                               const unsigned char *bytes,
                                               int len);
  int X509_ATTRIBUTE_set1_object(X509_ATTRIBUTE *attr, const ASN1_OBJECT *obj);
  int X509_ATTRIBUTE_set1_data(X509_ATTRIBUTE *attr, int attrtype,
                               const void *data, int len);
  void *X509_ATTRIBUTE_get0_data(X509_ATTRIBUTE *attr, int idx, int atrtype,
                                 void *data);
  int X509_ATTRIBUTE_count(const X509_ATTRIBUTE *attr);
  ASN1_OBJECT *X509_ATTRIBUTE_get0_object(X509_ATTRIBUTE *attr);
  ASN1_TYPE *X509_ATTRIBUTE_get0_type(X509_ATTRIBUTE *attr, int idx);
  int EVP_PKEY_get_attr_count(const EVP_PKEY *key);
  int EVP_PKEY_get_attr_by_NID(const EVP_PKEY *key, int nid, int lastpos);
  int EVP_PKEY_get_attr_by_OBJ(const EVP_PKEY *key, const ASN1_OBJECT *obj,
                               int lastpos);
  X509_ATTRIBUTE *EVP_PKEY_get_attr(const EVP_PKEY *key, int loc);
  X509_ATTRIBUTE *EVP_PKEY_delete_attr(EVP_PKEY *key, int loc);
  int EVP_PKEY_add1_attr(EVP_PKEY *key, X509_ATTRIBUTE *attr);
  int EVP_PKEY_add1_attr_by_OBJ(EVP_PKEY *key,
                                const ASN1_OBJECT *obj, int type,
                                const unsigned char *bytes, int len);
  int EVP_PKEY_add1_attr_by_NID(EVP_PKEY *key,
                                int nid, int type,
                                const unsigned char *bytes, int len);
  int EVP_PKEY_add1_attr_by_txt(EVP_PKEY *key,
                                const char *attrname, int type,
                                const unsigned char *bytes, int len);
  int X509_verify_cert(X509_STORE_CTX *ctx);
  X509 *X509_find_by_issuer_and_serial(struct stack_st_X509 *sk, X509_NAME *name,
                                       ASN1_INTEGER *serial);
  X509 *X509_find_by_subject(struct stack_st_X509 *sk, X509_NAME *name);
  PBEPARAM *PBEPARAM_new(void);
  void PBEPARAM_free(PBEPARAM *a);
  PBEPARAM *d2i_PBEPARAM(PBEPARAM **a, const unsigned char **in, long len);
  int i2d_PBEPARAM(PBEPARAM *a, unsigned char **out);
  extern const ASN1_ITEM PBEPARAM_it;
  PBE2PARAM *PBE2PARAM_new(void);
  void PBE2PARAM_free(PBE2PARAM *a);
  PBE2PARAM *d2i_PBE2PARAM(PBE2PARAM **a, const unsigned char **in, long len);
  int i2d_PBE2PARAM(PBE2PARAM *a, unsigned char **out);
  extern const ASN1_ITEM PBE2PARAM_it;
  PBKDF2PARAM *PBKDF2PARAM_new(void);
  void PBKDF2PARAM_free(PBKDF2PARAM *a);
  PBKDF2PARAM *d2i_PBKDF2PARAM(PBKDF2PARAM **a, const unsigned char **in, long len);
  int i2d_PBKDF2PARAM(PBKDF2PARAM *a, unsigned char **out);
  extern const ASN1_ITEM PBKDF2PARAM_it;
  SCRYPT_PARAMS *SCRYPT_PARAMS_new(void);
  void SCRYPT_PARAMS_free(SCRYPT_PARAMS *a);
  SCRYPT_PARAMS *d2i_SCRYPT_PARAMS(SCRYPT_PARAMS **a, const unsigned char **in, long len);
  int i2d_SCRYPT_PARAMS(SCRYPT_PARAMS *a, unsigned char **out);
  extern const ASN1_ITEM SCRYPT_PARAMS_it;
  int PKCS5_pbe_set0_algor(X509_ALGOR *algor, int alg, int iter,
                           const unsigned char *salt, int saltlen);
  X509_ALGOR *PKCS5_pbe_set(int alg, int iter,
                            const unsigned char *salt, int saltlen);
  X509_ALGOR *PKCS5_pbe2_set(const EVP_CIPHER *cipher, int iter,
                             unsigned char *salt, int saltlen);
  X509_ALGOR *PKCS5_pbe2_set_iv(const EVP_CIPHER *cipher, int iter,
                                unsigned char *salt, int saltlen,
                                unsigned char *aiv, int prf_nid);
  X509_ALGOR *PKCS5_pbe2_set_scrypt(const EVP_CIPHER *cipher,
                                    const unsigned char *salt, int saltlen,
                                    unsigned char *aiv, uint64_t N, uint64_t r,
                                    uint64_t p);
  X509_ALGOR *PKCS5_pbkdf2_set(int iter, unsigned char *salt, int saltlen,
                               int prf_nid, int keylen);
  PKCS8_PRIV_KEY_INFO *PKCS8_PRIV_KEY_INFO_new(void);
  void PKCS8_PRIV_KEY_INFO_free(PKCS8_PRIV_KEY_INFO *a);
  PKCS8_PRIV_KEY_INFO *d2i_PKCS8_PRIV_KEY_INFO(PKCS8_PRIV_KEY_INFO **a, const unsigned char **in, long len);
  int i2d_PKCS8_PRIV_KEY_INFO(PKCS8_PRIV_KEY_INFO *a, unsigned char **out);
  extern const ASN1_ITEM PKCS8_PRIV_KEY_INFO_it;
  EVP_PKEY *EVP_PKCS82PKEY(const PKCS8_PRIV_KEY_INFO *p8);
  PKCS8_PRIV_KEY_INFO *EVP_PKEY2PKCS8(EVP_PKEY *pkey);
  int PKCS8_pkey_set0(PKCS8_PRIV_KEY_INFO *priv, ASN1_OBJECT *aobj,
                      int version, int ptype, void *pval,
                      unsigned char *penc, int penclen);
  int PKCS8_pkey_get0(const ASN1_OBJECT **ppkalg,
                      const unsigned char **pk, int *ppklen,
                      const X509_ALGOR **pa, const PKCS8_PRIV_KEY_INFO *p8);
  const struct stack_st_X509_ATTRIBUTE *
  PKCS8_pkey_get0_attrs(const PKCS8_PRIV_KEY_INFO *p8);
  int PKCS8_pkey_add1_attr_by_NID(PKCS8_PRIV_KEY_INFO *p8, int nid, int type,
                                  const unsigned char *bytes, int len);
  int X509_PUBKEY_set0_param(X509_PUBKEY *pub, ASN1_OBJECT *aobj,
                             int ptype, void *pval,
                             unsigned char *penc, int penclen);
  int X509_PUBKEY_get0_param(ASN1_OBJECT **ppkalg,
                             const unsigned char **pk, int *ppklen,
                             X509_ALGOR **pa, X509_PUBKEY *pub);
  int X509_check_trust(X509 *x, int id, int flags);
  int X509_TRUST_get_count(void);
  X509_TRUST *X509_TRUST_get0(int idx);
  int X509_TRUST_get_by_id(int id);
  int X509_TRUST_add(int id, int flags, int (*ck)(X509_TRUST *, X509 *, int),
                     const char *name, int arg1, void *arg2);
  void X509_TRUST_cleanup(void);
  int X509_TRUST_get_flags(const X509_TRUST *xp);
  char *X509_TRUST_get0_name(const X509_TRUST *xp);
  int X509_TRUST_get_trust(const X509_TRUST *xp);
}
extern "C" int ERR_load_PEM_strings(void);
extern "C"
{
  typedef int pem_password_cb(char *buf, int size, int rwflag, void *userdata);
  int PEM_get_EVP_CIPHER_INFO(char *header, EVP_CIPHER_INFO *cipher);
  int PEM_do_header(EVP_CIPHER_INFO *cipher, unsigned char *data, long *len,
                    pem_password_cb *callback, void *u);
  int PEM_read_bio(BIO *bp, char **name, char **header,
                   unsigned char **data, long *len);
  int PEM_read_bio_ex(BIO *bp, char **name, char **header,
                      unsigned char **data, long *len, unsigned int flags);
  int PEM_bytes_read_bio_secmem(unsigned char **pdata, long *plen, char **pnm,
                                const char *name, BIO *bp, pem_password_cb *cb,
                                void *u);
  int PEM_write_bio(BIO *bp, const char *name, const char *hdr,
                    const unsigned char *data, long len);
  int PEM_bytes_read_bio(unsigned char **pdata, long *plen, char **pnm,
                         const char *name, BIO *bp, pem_password_cb *cb,
                         void *u);
  void *PEM_ASN1_read_bio(d2i_of_void *d2i, const char *name, BIO *bp, void **x,
                          pem_password_cb *cb, void *u);
  int PEM_ASN1_write_bio(i2d_of_void *i2d, const char *name, BIO *bp, void *x,
                         const EVP_CIPHER *enc, unsigned char *kstr, int klen,
                         pem_password_cb *cb, void *u);
  struct stack_st_X509_INFO *PEM_X509_INFO_read_bio(BIO *bp, struct stack_st_X509_INFO *sk,
                                                    pem_password_cb *cb, void *u);
  int PEM_X509_INFO_write_bio(BIO *bp, X509_INFO *xi, EVP_CIPHER *enc,
                              unsigned char *kstr, int klen,
                              pem_password_cb *cd, void *u);
  int PEM_read(FILE *fp, char **name, char **header,
               unsigned char **data, long *len);
  int PEM_write(FILE *fp, const char *name, const char *hdr,
                const unsigned char *data, long len);
  void *PEM_ASN1_read(d2i_of_void *d2i, const char *name, FILE *fp, void **x,
                      pem_password_cb *cb, void *u);
  int PEM_ASN1_write(i2d_of_void *i2d, const char *name, FILE *fp,
                     void *x, const EVP_CIPHER *enc, unsigned char *kstr,
                     int klen, pem_password_cb *callback, void *u);
  struct stack_st_X509_INFO *PEM_X509_INFO_read(FILE *fp, struct stack_st_X509_INFO *sk,
                                                pem_password_cb *cb, void *u);
  int PEM_SignInit(EVP_MD_CTX *ctx, EVP_MD *type);
  int PEM_SignUpdate(EVP_MD_CTX *ctx, unsigned char *d, unsigned int cnt);
  int PEM_SignFinal(EVP_MD_CTX *ctx, unsigned char *sigret,
                    unsigned int *siglen, EVP_PKEY *pkey);
  int PEM_def_callback(char *buf, int num, int rwflag, void *userdata);
  void PEM_proc_type(char *buf, int type);
  void PEM_dek_info(char *buf, const char *type, int len, char *str);
  X509 *PEM_read_bio_X509(BIO *bp, X509 **x, pem_password_cb *cb, void *u);
  X509 *PEM_read_X509(FILE *fp, X509 **x, pem_password_cb *cb, void *u);
  int PEM_write_bio_X509(BIO *bp, X509 *x);
  int PEM_write_X509(FILE *fp, X509 *x);
  X509 *PEM_read_bio_X509_AUX(BIO *bp, X509 **x, pem_password_cb *cb, void *u);
  X509 *PEM_read_X509_AUX(FILE *fp, X509 **x, pem_password_cb *cb, void *u);
  int PEM_write_bio_X509_AUX(BIO *bp, X509 *x);
  int PEM_write_X509_AUX(FILE *fp, X509 *x);
  X509_REQ *PEM_read_bio_X509_REQ(BIO *bp, X509_REQ **x, pem_password_cb *cb, void *u);
  X509_REQ *PEM_read_X509_REQ(FILE *fp, X509_REQ **x, pem_password_cb *cb, void *u);
  int PEM_write_bio_X509_REQ(BIO *bp, X509_REQ *x);
  int PEM_write_X509_REQ(FILE *fp, X509_REQ *x);
  int PEM_write_bio_X509_REQ_NEW(BIO *bp, X509_REQ *x);
  int PEM_write_X509_REQ_NEW(FILE *fp, X509_REQ *x);
  X509_CRL *PEM_read_bio_X509_CRL(BIO *bp, X509_CRL **x, pem_password_cb *cb, void *u);
  X509_CRL *PEM_read_X509_CRL(FILE *fp, X509_CRL **x, pem_password_cb *cb, void *u);
  int PEM_write_bio_X509_CRL(BIO *bp, X509_CRL *x);
  int PEM_write_X509_CRL(FILE *fp, X509_CRL *x);
  PKCS7 *PEM_read_bio_PKCS7(BIO *bp, PKCS7 **x, pem_password_cb *cb, void *u);
  PKCS7 *PEM_read_PKCS7(FILE *fp, PKCS7 **x, pem_password_cb *cb, void *u);
  int PEM_write_bio_PKCS7(BIO *bp, PKCS7 *x);
  int PEM_write_PKCS7(FILE *fp, PKCS7 *x);
  NETSCAPE_CERT_SEQUENCE *PEM_read_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp, NETSCAPE_CERT_SEQUENCE **x, pem_password_cb *cb, void *u);
  NETSCAPE_CERT_SEQUENCE *PEM_read_NETSCAPE_CERT_SEQUENCE(FILE *fp, NETSCAPE_CERT_SEQUENCE **x, pem_password_cb *cb, void *u);
  int PEM_write_bio_NETSCAPE_CERT_SEQUENCE(BIO *bp, NETSCAPE_CERT_SEQUENCE *x);
  int PEM_write_NETSCAPE_CERT_SEQUENCE(FILE *fp, NETSCAPE_CERT_SEQUENCE *x);
  X509_SIG *PEM_read_bio_PKCS8(BIO *bp, X509_SIG **x, pem_password_cb *cb, void *u);
  X509_SIG *PEM_read_PKCS8(FILE *fp, X509_SIG **x, pem_password_cb *cb, void *u);
  int PEM_write_bio_PKCS8(BIO *bp, X509_SIG *x);
  int PEM_write_PKCS8(FILE *fp, X509_SIG *x);
  PKCS8_PRIV_KEY_INFO *PEM_read_bio_PKCS8_PRIV_KEY_INFO(BIO *bp, PKCS8_PRIV_KEY_INFO **x, pem_password_cb *cb, void *u);
  PKCS8_PRIV_KEY_INFO *PEM_read_PKCS8_PRIV_KEY_INFO(FILE *fp, PKCS8_PRIV_KEY_INFO **x, pem_password_cb *cb, void *u);
  int PEM_write_bio_PKCS8_PRIV_KEY_INFO(BIO *bp, PKCS8_PRIV_KEY_INFO *x);
  int PEM_write_PKCS8_PRIV_KEY_INFO(FILE *fp, PKCS8_PRIV_KEY_INFO *x);
  RSA *PEM_read_bio_RSAPrivateKey(BIO *bp, RSA **x, pem_password_cb *cb, void *u);
  RSA *PEM_read_RSAPrivateKey(FILE *fp, RSA **x, pem_password_cb *cb, void *u);
  int PEM_write_bio_RSAPrivateKey(BIO *bp, RSA *x, const EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb, void *u);
  int PEM_write_RSAPrivateKey(FILE *fp, RSA *x, const EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb, void *u);
  RSA *PEM_read_bio_RSAPublicKey(BIO *bp, RSA **x, pem_password_cb *cb, void *u);
  RSA *PEM_read_RSAPublicKey(FILE *fp, RSA **x, pem_password_cb *cb, void *u);
  int PEM_write_bio_RSAPublicKey(BIO *bp, const RSA *x);
  int PEM_write_RSAPublicKey(FILE *fp, const RSA *x);
  RSA *PEM_read_bio_RSA_PUBKEY(BIO *bp, RSA **x, pem_password_cb *cb, void *u);
  RSA *PEM_read_RSA_PUBKEY(FILE *fp, RSA **x, pem_password_cb *cb, void *u);
  int PEM_write_bio_RSA_PUBKEY(BIO *bp, RSA *x);
  int PEM_write_RSA_PUBKEY(FILE *fp, RSA *x);
  DSA *PEM_read_bio_DSAPrivateKey(BIO *bp, DSA **x, pem_password_cb *cb, void *u);
  DSA *PEM_read_DSAPrivateKey(FILE *fp, DSA **x, pem_password_cb *cb, void *u);
  int PEM_write_bio_DSAPrivateKey(BIO *bp, DSA *x, const EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb, void *u);
  int PEM_write_DSAPrivateKey(FILE *fp, DSA *x, const EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb, void *u);
  DSA *PEM_read_bio_DSA_PUBKEY(BIO *bp, DSA **x, pem_password_cb *cb, void *u);
  DSA *PEM_read_DSA_PUBKEY(FILE *fp, DSA **x, pem_password_cb *cb, void *u);
  int PEM_write_bio_DSA_PUBKEY(BIO *bp, DSA *x);
  int PEM_write_DSA_PUBKEY(FILE *fp, DSA *x);
  DSA *PEM_read_bio_DSAparams(BIO *bp, DSA **x, pem_password_cb *cb, void *u);
  DSA *PEM_read_DSAparams(FILE *fp, DSA **x, pem_password_cb *cb, void *u);
  int PEM_write_bio_DSAparams(BIO *bp, const DSA *x);
  int PEM_write_DSAparams(FILE *fp, const DSA *x);
  EC_GROUP *PEM_read_bio_ECPKParameters(BIO *bp, EC_GROUP **x, pem_password_cb *cb, void *u);
  EC_GROUP *PEM_read_ECPKParameters(FILE *fp, EC_GROUP **x, pem_password_cb *cb, void *u);
  int PEM_write_bio_ECPKParameters(BIO *bp, const EC_GROUP *x);
  int PEM_write_ECPKParameters(FILE *fp, const EC_GROUP *x);
  EC_KEY *PEM_read_bio_ECPrivateKey(BIO *bp, EC_KEY **x, pem_password_cb *cb, void *u);
  EC_KEY *PEM_read_ECPrivateKey(FILE *fp, EC_KEY **x, pem_password_cb *cb, void *u);
  int PEM_write_bio_ECPrivateKey(BIO *bp, EC_KEY *x, const EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb, void *u);
  int PEM_write_ECPrivateKey(FILE *fp, EC_KEY *x, const EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb, void *u);
  EC_KEY *PEM_read_bio_EC_PUBKEY(BIO *bp, EC_KEY **x, pem_password_cb *cb, void *u);
  EC_KEY *PEM_read_EC_PUBKEY(FILE *fp, EC_KEY **x, pem_password_cb *cb, void *u);
  int PEM_write_bio_EC_PUBKEY(BIO *bp, EC_KEY *x);
  int PEM_write_EC_PUBKEY(FILE *fp, EC_KEY *x);
  DH *PEM_read_bio_DHparams(BIO *bp, DH **x, pem_password_cb *cb, void *u);
  DH *PEM_read_DHparams(FILE *fp, DH **x, pem_password_cb *cb, void *u);
  int PEM_write_bio_DHparams(BIO *bp, const DH *x);
  int PEM_write_DHparams(FILE *fp, const DH *x);
  int PEM_write_bio_DHxparams(BIO *bp, const DH *x);
  int PEM_write_DHxparams(FILE *fp, const DH *x);
  EVP_PKEY *PEM_read_bio_PrivateKey(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u);
  EVP_PKEY *PEM_read_PrivateKey(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u);
  int PEM_write_bio_PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb, void *u);
  int PEM_write_PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc, unsigned char *kstr, int klen, pem_password_cb *cb, void *u);
  EVP_PKEY *PEM_read_bio_PUBKEY(BIO *bp, EVP_PKEY **x, pem_password_cb *cb, void *u);
  EVP_PKEY *PEM_read_PUBKEY(FILE *fp, EVP_PKEY **x, pem_password_cb *cb, void *u);
  int PEM_write_bio_PUBKEY(BIO *bp, EVP_PKEY *x);
  int PEM_write_PUBKEY(FILE *fp, EVP_PKEY *x);
  int PEM_write_bio_PrivateKey_traditional(BIO *bp, EVP_PKEY *x,
                                           const EVP_CIPHER *enc,
                                           unsigned char *kstr, int klen,
                                           pem_password_cb *cb, void *u);
  int PEM_write_bio_PKCS8PrivateKey_nid(BIO *bp, EVP_PKEY *x, int nid,
                                        char *kstr, int klen,
                                        pem_password_cb *cb, void *u);
  int PEM_write_bio_PKCS8PrivateKey(BIO *, EVP_PKEY *, const EVP_CIPHER *,
                                    char *, int, pem_password_cb *, void *);
  int i2d_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc,
                              char *kstr, int klen,
                              pem_password_cb *cb, void *u);
  int i2d_PKCS8PrivateKey_nid_bio(BIO *bp, EVP_PKEY *x, int nid,
                                  char *kstr, int klen,
                                  pem_password_cb *cb, void *u);
  EVP_PKEY *d2i_PKCS8PrivateKey_bio(BIO *bp, EVP_PKEY **x, pem_password_cb *cb,
                                    void *u);
  int i2d_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
                             char *kstr, int klen,
                             pem_password_cb *cb, void *u);
  int i2d_PKCS8PrivateKey_nid_fp(FILE *fp, EVP_PKEY *x, int nid,
                                 char *kstr, int klen,
                                 pem_password_cb *cb, void *u);
  int PEM_write_PKCS8PrivateKey_nid(FILE *fp, EVP_PKEY *x, int nid,
                                    char *kstr, int klen,
                                    pem_password_cb *cb, void *u);
  EVP_PKEY *d2i_PKCS8PrivateKey_fp(FILE *fp, EVP_PKEY **x, pem_password_cb *cb,
                                   void *u);
  int PEM_write_PKCS8PrivateKey(FILE *fp, EVP_PKEY *x, const EVP_CIPHER *enc,
                                char *kstr, int klen, pem_password_cb *cd,
                                void *u);
  EVP_PKEY *PEM_read_bio_Parameters(BIO *bp, EVP_PKEY **x);
  int PEM_write_bio_Parameters(BIO *bp, EVP_PKEY *x);
  EVP_PKEY *b2i_PrivateKey(const unsigned char **in, long length);
  EVP_PKEY *b2i_PublicKey(const unsigned char **in, long length);
  EVP_PKEY *b2i_PrivateKey_bio(BIO *in);
  EVP_PKEY *b2i_PublicKey_bio(BIO *in);
  int i2b_PrivateKey_bio(BIO *out, EVP_PKEY *pk);
  int i2b_PublicKey_bio(BIO *out, EVP_PKEY *pk);
  EVP_PKEY *b2i_PVK_bio(BIO *in, pem_password_cb *cb, void *u);
  int i2b_PVK_bio(BIO *out, EVP_PKEY *pk, int enclevel,
                  pem_password_cb *cb, void *u);
}
extern "C"
{
}
extern "C"
{
  size_t HMAC_size(const HMAC_CTX *e);
  HMAC_CTX *HMAC_CTX_new(void);
  int HMAC_CTX_reset(HMAC_CTX *ctx);
  void HMAC_CTX_free(HMAC_CTX *ctx);
  int HMAC_Init(HMAC_CTX *ctx, const void *key, int len, const EVP_MD *md) __attribute__((deprecated));
  int HMAC_Init_ex(HMAC_CTX *ctx, const void *key, int len,
                   const EVP_MD *md, ENGINE *impl);
  int HMAC_Update(HMAC_CTX *ctx, const unsigned char *data,
                  size_t len);
  int HMAC_Final(HMAC_CTX *ctx, unsigned char *md,
                 unsigned int *len);
  unsigned char *HMAC(const EVP_MD *evp_md, const void *key, int key_len,
                      const unsigned char *d, size_t n, unsigned char *md,
                      unsigned int *md_len);
  int HMAC_CTX_copy(HMAC_CTX *dctx, HMAC_CTX *sctx);
  void HMAC_CTX_set_flags(HMAC_CTX *ctx, unsigned long flags);
  const EVP_MD *HMAC_CTX_get_md(const HMAC_CTX *ctx);
}
extern "C" int ERR_load_ASYNC_strings(void);
extern "C"
{
  typedef struct async_job_st ASYNC_JOB;
  typedef struct async_wait_ctx_st ASYNC_WAIT_CTX;
  int ASYNC_init_thread(size_t max_size, size_t init_size);
  void ASYNC_cleanup_thread(void);
  ASYNC_WAIT_CTX *ASYNC_WAIT_CTX_new(void);
  void ASYNC_WAIT_CTX_free(ASYNC_WAIT_CTX *ctx);
  int ASYNC_WAIT_CTX_set_wait_fd(ASYNC_WAIT_CTX *ctx, const void *key,
                                 int fd,
                                 void *custom_data,
                                 void (*cleanup)(ASYNC_WAIT_CTX *, const void *,
                                                 int, void *));
  int ASYNC_WAIT_CTX_get_fd(ASYNC_WAIT_CTX *ctx, const void *key,
                            int *fd, void **custom_data);
  int ASYNC_WAIT_CTX_get_all_fds(ASYNC_WAIT_CTX *ctx, int *fd,
                                 size_t *numfds);
  int ASYNC_WAIT_CTX_get_changed_fds(ASYNC_WAIT_CTX *ctx, int *addfd,
                                     size_t *numaddfds, int *delfd,
                                     size_t *numdelfds);
  int ASYNC_WAIT_CTX_clear_fd(ASYNC_WAIT_CTX *ctx, const void *key);
  int ASYNC_is_capable(void);
  int ASYNC_start_job(ASYNC_JOB **job, ASYNC_WAIT_CTX *ctx, int *ret,
                      int (*func)(void *), void *args, size_t size);
  int ASYNC_pause_job(void);
  ASYNC_JOB *ASYNC_get_current_job(void);
  ASYNC_WAIT_CTX *ASYNC_get_wait_ctx(ASYNC_JOB *job);
  void ASYNC_block_pause(void);
  void ASYNC_unblock_pause(void);
}
extern "C"
{
}
extern "C"
{
}
extern "C" int ERR_load_CT_strings(void);
extern "C"
{
  typedef enum
  {
    CT_LOG_ENTRY_TYPE_NOT_SET = -1,
    CT_LOG_ENTRY_TYPE_X509 = 0,
    CT_LOG_ENTRY_TYPE_PRECERT = 1
  } ct_log_entry_type_t;
  typedef enum
  {
    SCT_VERSION_NOT_SET = -1,
    SCT_VERSION_V1 = 0
  } sct_version_t;
  typedef enum
  {
    SCT_SOURCE_UNKNOWN,
    SCT_SOURCE_TLS_EXTENSION,
    SCT_SOURCE_X509V3_EXTENSION,
    SCT_SOURCE_OCSP_STAPLED_RESPONSE
  } sct_source_t;
  typedef enum
  {
    SCT_VALIDATION_STATUS_NOT_SET,
    SCT_VALIDATION_STATUS_UNKNOWN_LOG,
    SCT_VALIDATION_STATUS_VALID,
    SCT_VALIDATION_STATUS_INVALID,
    SCT_VALIDATION_STATUS_UNVERIFIED,
    SCT_VALIDATION_STATUS_UNKNOWN_VERSION
  } sct_validation_status_t;
  struct stack_st_SCT;
  typedef int (*sk_SCT_compfunc)(const SCT *const *a, const SCT *const *b);
  typedef void (*sk_SCT_freefunc)(SCT *a);
  typedef SCT *(*sk_SCT_copyfunc)(const SCT *a);
  static __attribute__((unused)) inline int sk_SCT_num(const struct stack_st_SCT *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline SCT *sk_SCT_value(const struct stack_st_SCT *sk, int idx) { return (SCT *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_SCT *sk_SCT_new(sk_SCT_compfunc compare) { return (struct stack_st_SCT *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_SCT *sk_SCT_new_null(void) { return (struct stack_st_SCT *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_SCT *sk_SCT_new_reserve(sk_SCT_compfunc compare, int n) { return (struct stack_st_SCT *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_SCT_reserve(struct stack_st_SCT *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_SCT_free(struct stack_st_SCT *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_SCT_zero(struct stack_st_SCT *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline SCT *sk_SCT_delete(struct stack_st_SCT *sk, int i) { return (SCT *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline SCT *sk_SCT_delete_ptr(struct stack_st_SCT *sk, SCT *ptr) { return (SCT *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_SCT_push(struct stack_st_SCT *sk, SCT *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_SCT_unshift(struct stack_st_SCT *sk, SCT *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline SCT *sk_SCT_pop(struct stack_st_SCT *sk) { return (SCT *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline SCT *sk_SCT_shift(struct stack_st_SCT *sk) { return (SCT *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_SCT_pop_free(struct stack_st_SCT *sk, sk_SCT_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_SCT_insert(struct stack_st_SCT *sk, SCT *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline SCT *sk_SCT_set(struct stack_st_SCT *sk, int idx, SCT *ptr) { return (SCT *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_SCT_find(struct stack_st_SCT *sk, SCT *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_SCT_find_ex(struct stack_st_SCT *sk, SCT *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_SCT_sort(struct stack_st_SCT *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_SCT_is_sorted(const struct stack_st_SCT *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_SCT *sk_SCT_dup(const struct stack_st_SCT *sk) { return (struct stack_st_SCT *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_SCT *sk_SCT_deep_copy(const struct stack_st_SCT *sk, sk_SCT_copyfunc copyfunc, sk_SCT_freefunc freefunc) { return (struct stack_st_SCT *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_SCT_compfunc sk_SCT_set_cmp_func(struct stack_st_SCT *sk, sk_SCT_compfunc compare) { return (sk_SCT_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  struct stack_st_CTLOG;
  typedef int (*sk_CTLOG_compfunc)(const CTLOG *const *a, const CTLOG *const *b);
  typedef void (*sk_CTLOG_freefunc)(CTLOG *a);
  typedef CTLOG *(*sk_CTLOG_copyfunc)(const CTLOG *a);
  static __attribute__((unused)) inline int sk_CTLOG_num(const struct stack_st_CTLOG *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline CTLOG *sk_CTLOG_value(const struct stack_st_CTLOG *sk, int idx) { return (CTLOG *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_CTLOG *sk_CTLOG_new(sk_CTLOG_compfunc compare) { return (struct stack_st_CTLOG *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_CTLOG *sk_CTLOG_new_null(void) { return (struct stack_st_CTLOG *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_CTLOG *sk_CTLOG_new_reserve(sk_CTLOG_compfunc compare, int n) { return (struct stack_st_CTLOG *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_CTLOG_reserve(struct stack_st_CTLOG *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_CTLOG_free(struct stack_st_CTLOG *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_CTLOG_zero(struct stack_st_CTLOG *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline CTLOG *sk_CTLOG_delete(struct stack_st_CTLOG *sk, int i) { return (CTLOG *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline CTLOG *sk_CTLOG_delete_ptr(struct stack_st_CTLOG *sk, CTLOG *ptr) { return (CTLOG *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_CTLOG_push(struct stack_st_CTLOG *sk, CTLOG *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_CTLOG_unshift(struct stack_st_CTLOG *sk, CTLOG *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline CTLOG *sk_CTLOG_pop(struct stack_st_CTLOG *sk) { return (CTLOG *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline CTLOG *sk_CTLOG_shift(struct stack_st_CTLOG *sk) { return (CTLOG *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_CTLOG_pop_free(struct stack_st_CTLOG *sk, sk_CTLOG_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_CTLOG_insert(struct stack_st_CTLOG *sk, CTLOG *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline CTLOG *sk_CTLOG_set(struct stack_st_CTLOG *sk, int idx, CTLOG *ptr) { return (CTLOG *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_CTLOG_find(struct stack_st_CTLOG *sk, CTLOG *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_CTLOG_find_ex(struct stack_st_CTLOG *sk, CTLOG *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_CTLOG_sort(struct stack_st_CTLOG *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_CTLOG_is_sorted(const struct stack_st_CTLOG *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_CTLOG *sk_CTLOG_dup(const struct stack_st_CTLOG *sk) { return (struct stack_st_CTLOG *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_CTLOG *sk_CTLOG_deep_copy(const struct stack_st_CTLOG *sk, sk_CTLOG_copyfunc copyfunc, sk_CTLOG_freefunc freefunc) { return (struct stack_st_CTLOG *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_CTLOG_compfunc sk_CTLOG_set_cmp_func(struct stack_st_CTLOG *sk, sk_CTLOG_compfunc compare) { return (sk_CTLOG_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  CT_POLICY_EVAL_CTX *CT_POLICY_EVAL_CTX_new(void);
  void CT_POLICY_EVAL_CTX_free(CT_POLICY_EVAL_CTX *ctx);
  X509 *CT_POLICY_EVAL_CTX_get0_cert(const CT_POLICY_EVAL_CTX *ctx);
  int CT_POLICY_EVAL_CTX_set1_cert(CT_POLICY_EVAL_CTX *ctx, X509 *cert);
  X509 *CT_POLICY_EVAL_CTX_get0_issuer(const CT_POLICY_EVAL_CTX *ctx);
  int CT_POLICY_EVAL_CTX_set1_issuer(CT_POLICY_EVAL_CTX *ctx, X509 *issuer);
  const CTLOG_STORE *CT_POLICY_EVAL_CTX_get0_log_store(const CT_POLICY_EVAL_CTX *ctx);
  void CT_POLICY_EVAL_CTX_set_shared_CTLOG_STORE(CT_POLICY_EVAL_CTX *ctx,
                                                 CTLOG_STORE *log_store);
  uint64_t CT_POLICY_EVAL_CTX_get_time(const CT_POLICY_EVAL_CTX *ctx);
  void CT_POLICY_EVAL_CTX_set_time(CT_POLICY_EVAL_CTX *ctx, uint64_t time_in_ms);
  SCT *SCT_new(void);
  SCT *SCT_new_from_base64(unsigned char version,
                           const char *logid_base64,
                           ct_log_entry_type_t entry_type,
                           uint64_t timestamp,
                           const char *extensions_base64,
                           const char *signature_base64);
  void SCT_free(SCT *sct);
  void SCT_LIST_free(struct stack_st_SCT *a);
  sct_version_t SCT_get_version(const SCT *sct);
  int SCT_set_version(SCT *sct, sct_version_t version);
  ct_log_entry_type_t SCT_get_log_entry_type(const SCT *sct);
  int SCT_set_log_entry_type(SCT *sct, ct_log_entry_type_t entry_type);
  size_t SCT_get0_log_id(const SCT *sct, unsigned char **log_id);
  int SCT_set0_log_id(SCT *sct, unsigned char *log_id, size_t log_id_len);
  int SCT_set1_log_id(SCT *sct, const unsigned char *log_id,
                      size_t log_id_len);
  uint64_t SCT_get_timestamp(const SCT *sct);
  void SCT_set_timestamp(SCT *sct, uint64_t timestamp);
  int SCT_get_signature_nid(const SCT *sct);
  int SCT_set_signature_nid(SCT *sct, int nid);
  size_t SCT_get0_extensions(const SCT *sct, unsigned char **ext);
  void SCT_set0_extensions(SCT *sct, unsigned char *ext, size_t ext_len);
  int SCT_set1_extensions(SCT *sct, const unsigned char *ext,
                          size_t ext_len);
  size_t SCT_get0_signature(const SCT *sct, unsigned char **sig);
  void SCT_set0_signature(SCT *sct, unsigned char *sig, size_t sig_len);
  int SCT_set1_signature(SCT *sct, const unsigned char *sig,
                         size_t sig_len);
  sct_source_t SCT_get_source(const SCT *sct);
  int SCT_set_source(SCT *sct, sct_source_t source);
  const char *SCT_validation_status_string(const SCT *sct);
  void SCT_print(const SCT *sct, BIO *out, int indent, const CTLOG_STORE *logs);
  void SCT_LIST_print(const struct stack_st_SCT *sct_list, BIO *out, int indent,
                      const char *separator, const CTLOG_STORE *logs);
  sct_validation_status_t SCT_get_validation_status(const SCT *sct);
  int SCT_validate(SCT *sct, const CT_POLICY_EVAL_CTX *ctx);
  int SCT_LIST_validate(const struct stack_st_SCT *scts,
                        CT_POLICY_EVAL_CTX *ctx);
  int i2o_SCT_LIST(const struct stack_st_SCT *a, unsigned char **pp);
  struct stack_st_SCT *o2i_SCT_LIST(struct stack_st_SCT **a, const unsigned char **pp,
                                    size_t len);
  int i2d_SCT_LIST(const struct stack_st_SCT *a, unsigned char **pp);
  struct stack_st_SCT *d2i_SCT_LIST(struct stack_st_SCT **a, const unsigned char **pp,
                                    long len);
  int i2o_SCT(const SCT *sct, unsigned char **out);
  SCT *o2i_SCT(SCT **psct, const unsigned char **in, size_t len);
  CTLOG *CTLOG_new(EVP_PKEY *public_key, const char *name);
  int CTLOG_new_from_base64(CTLOG **ct_log,
                            const char *pkey_base64, const char *name);
  void CTLOG_free(CTLOG *log);
  const char *CTLOG_get0_name(const CTLOG *log);
  void CTLOG_get0_log_id(const CTLOG *log, const uint8_t **log_id,
                         size_t *log_id_len);
  EVP_PKEY *CTLOG_get0_public_key(const CTLOG *log);
  CTLOG_STORE *CTLOG_STORE_new(void);
  void CTLOG_STORE_free(CTLOG_STORE *store);
  const CTLOG *CTLOG_STORE_get0_log_by_id(const CTLOG_STORE *store,
                                          const uint8_t *log_id,
                                          size_t log_id_len);
  int CTLOG_STORE_load_file(CTLOG_STORE *store, const char *file);
  int CTLOG_STORE_load_default_file(CTLOG_STORE *store);
}
extern "C" int ERR_load_SSL_strings(void);
extern "C"
{
}
extern "C"
{
  typedef struct ssl_st *ssl_crock_st;
  typedef struct tls_session_ticket_ext_st TLS_SESSION_TICKET_EXT;
  typedef struct ssl_method_st SSL_METHOD;
  typedef struct ssl_cipher_st SSL_CIPHER;
  typedef struct ssl_session_st SSL_SESSION;
  typedef struct tls_sigalgs_st TLS_SIGALGS;
  typedef struct ssl_conf_ctx_st SSL_CONF_CTX;
  typedef struct ssl_comp_st SSL_COMP;
  struct stack_st_SSL_CIPHER;
  struct stack_st_SSL_COMP;
  typedef struct srtp_protection_profile_st
  {
    const char *name;
    unsigned long id;
  } SRTP_PROTECTION_PROFILE;
  struct stack_st_SRTP_PROTECTION_PROFILE;
  typedef int (*sk_SRTP_PROTECTION_PROFILE_compfunc)(const SRTP_PROTECTION_PROFILE *const *a, const SRTP_PROTECTION_PROFILE *const *b);
  typedef void (*sk_SRTP_PROTECTION_PROFILE_freefunc)(SRTP_PROTECTION_PROFILE *a);
  typedef SRTP_PROTECTION_PROFILE *(*sk_SRTP_PROTECTION_PROFILE_copyfunc)(const SRTP_PROTECTION_PROFILE *a);
  static __attribute__((unused)) inline int sk_SRTP_PROTECTION_PROFILE_num(const struct stack_st_SRTP_PROTECTION_PROFILE *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline SRTP_PROTECTION_PROFILE *sk_SRTP_PROTECTION_PROFILE_value(const struct stack_st_SRTP_PROTECTION_PROFILE *sk, int idx) { return (SRTP_PROTECTION_PROFILE *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_SRTP_PROTECTION_PROFILE *sk_SRTP_PROTECTION_PROFILE_new(sk_SRTP_PROTECTION_PROFILE_compfunc compare) { return (struct stack_st_SRTP_PROTECTION_PROFILE *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_SRTP_PROTECTION_PROFILE *sk_SRTP_PROTECTION_PROFILE_new_null(void) { return (struct stack_st_SRTP_PROTECTION_PROFILE *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_SRTP_PROTECTION_PROFILE *sk_SRTP_PROTECTION_PROFILE_new_reserve(sk_SRTP_PROTECTION_PROFILE_compfunc compare, int n) { return (struct stack_st_SRTP_PROTECTION_PROFILE *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_SRTP_PROTECTION_PROFILE_reserve(struct stack_st_SRTP_PROTECTION_PROFILE *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_SRTP_PROTECTION_PROFILE_free(struct stack_st_SRTP_PROTECTION_PROFILE *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_SRTP_PROTECTION_PROFILE_zero(struct stack_st_SRTP_PROTECTION_PROFILE *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline SRTP_PROTECTION_PROFILE *sk_SRTP_PROTECTION_PROFILE_delete(struct stack_st_SRTP_PROTECTION_PROFILE *sk, int i) { return (SRTP_PROTECTION_PROFILE *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline SRTP_PROTECTION_PROFILE *sk_SRTP_PROTECTION_PROFILE_delete_ptr(struct stack_st_SRTP_PROTECTION_PROFILE *sk, SRTP_PROTECTION_PROFILE *ptr) { return (SRTP_PROTECTION_PROFILE *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_SRTP_PROTECTION_PROFILE_push(struct stack_st_SRTP_PROTECTION_PROFILE *sk, SRTP_PROTECTION_PROFILE *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_SRTP_PROTECTION_PROFILE_unshift(struct stack_st_SRTP_PROTECTION_PROFILE *sk, SRTP_PROTECTION_PROFILE *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline SRTP_PROTECTION_PROFILE *sk_SRTP_PROTECTION_PROFILE_pop(struct stack_st_SRTP_PROTECTION_PROFILE *sk) { return (SRTP_PROTECTION_PROFILE *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline SRTP_PROTECTION_PROFILE *sk_SRTP_PROTECTION_PROFILE_shift(struct stack_st_SRTP_PROTECTION_PROFILE *sk) { return (SRTP_PROTECTION_PROFILE *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_SRTP_PROTECTION_PROFILE_pop_free(struct stack_st_SRTP_PROTECTION_PROFILE *sk, sk_SRTP_PROTECTION_PROFILE_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_SRTP_PROTECTION_PROFILE_insert(struct stack_st_SRTP_PROTECTION_PROFILE *sk, SRTP_PROTECTION_PROFILE *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline SRTP_PROTECTION_PROFILE *sk_SRTP_PROTECTION_PROFILE_set(struct stack_st_SRTP_PROTECTION_PROFILE *sk, int idx, SRTP_PROTECTION_PROFILE *ptr) { return (SRTP_PROTECTION_PROFILE *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_SRTP_PROTECTION_PROFILE_find(struct stack_st_SRTP_PROTECTION_PROFILE *sk, SRTP_PROTECTION_PROFILE *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_SRTP_PROTECTION_PROFILE_find_ex(struct stack_st_SRTP_PROTECTION_PROFILE *sk, SRTP_PROTECTION_PROFILE *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_SRTP_PROTECTION_PROFILE_sort(struct stack_st_SRTP_PROTECTION_PROFILE *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_SRTP_PROTECTION_PROFILE_is_sorted(const struct stack_st_SRTP_PROTECTION_PROFILE *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_SRTP_PROTECTION_PROFILE *sk_SRTP_PROTECTION_PROFILE_dup(const struct stack_st_SRTP_PROTECTION_PROFILE *sk) { return (struct stack_st_SRTP_PROTECTION_PROFILE *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_SRTP_PROTECTION_PROFILE *sk_SRTP_PROTECTION_PROFILE_deep_copy(const struct stack_st_SRTP_PROTECTION_PROFILE *sk, sk_SRTP_PROTECTION_PROFILE_copyfunc copyfunc, sk_SRTP_PROTECTION_PROFILE_freefunc freefunc) { return (struct stack_st_SRTP_PROTECTION_PROFILE *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_SRTP_PROTECTION_PROFILE_compfunc sk_SRTP_PROTECTION_PROFILE_set_cmp_func(struct stack_st_SRTP_PROTECTION_PROFILE *sk, sk_SRTP_PROTECTION_PROFILE_compfunc compare) { return (sk_SRTP_PROTECTION_PROFILE_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  typedef int (*tls_session_ticket_ext_cb_fn)(SSL *s, const unsigned char *data,
                                              int len, void *arg);
  typedef int (*tls_session_secret_cb_fn)(SSL *s, void *secret, int *secret_len,
                                          struct stack_st_SSL_CIPHER *peer_ciphers,
                                          const SSL_CIPHER **cipher, void *arg);
  typedef int (*custom_ext_add_cb)(SSL *s, unsigned int ext_type,
                                   const unsigned char **out, size_t *outlen,
                                   int *al, void *add_arg);
  typedef void (*custom_ext_free_cb)(SSL *s, unsigned int ext_type,
                                     const unsigned char *out, void *add_arg);
  typedef int (*custom_ext_parse_cb)(SSL *s, unsigned int ext_type,
                                     const unsigned char *in, size_t inlen,
                                     int *al, void *parse_arg);
  typedef int (*SSL_custom_ext_add_cb_ex)(SSL *s, unsigned int ext_type,
                                          unsigned int context,
                                          const unsigned char **out,
                                          size_t *outlen, X509 *x,
                                          size_t chainidx,
                                          int *al, void *add_arg);
  typedef void (*SSL_custom_ext_free_cb_ex)(SSL *s, unsigned int ext_type,
                                            unsigned int context,
                                            const unsigned char *out,
                                            void *add_arg);
  typedef int (*SSL_custom_ext_parse_cb_ex)(SSL *s, unsigned int ext_type,
                                            unsigned int context,
                                            const unsigned char *in,
                                            size_t inlen, X509 *x,
                                            size_t chainidx,
                                            int *al, void *parse_arg);
  typedef int (*SSL_verify_cb)(int preverify_ok, X509_STORE_CTX *x509_ctx);
  unsigned long SSL_CTX_get_options(const SSL_CTX *ctx);
  unsigned long SSL_get_options(const SSL *s);
  unsigned long SSL_CTX_clear_options(SSL_CTX *ctx, unsigned long op);
  unsigned long SSL_clear_options(SSL *s, unsigned long op);
  unsigned long SSL_CTX_set_options(SSL_CTX *ctx, unsigned long op);
  unsigned long SSL_set_options(SSL *s, unsigned long op);
  void SSL_CTX_set_msg_callback(SSL_CTX *ctx,
                                void (*cb)(int write_p, int version,
                                           int content_type, const void *buf,
                                           size_t len, SSL *ssl, void *arg));
  void SSL_set_msg_callback(SSL *ssl,
                            void (*cb)(int write_p, int version,
                                       int content_type, const void *buf,
                                       size_t len, SSL *ssl, void *arg));
  int SSL_SRP_CTX_init(SSL *s);
  int SSL_CTX_SRP_CTX_init(SSL_CTX *ctx);
  int SSL_SRP_CTX_free(SSL *ctx);
  int SSL_CTX_SRP_CTX_free(SSL_CTX *ctx);
  int SSL_srp_server_param_with_username(SSL *s, int *ad);
  int SRP_Calc_A_param(SSL *s);
  typedef int (*GEN_SESSION_CB)(SSL *ssl, unsigned char *id,
                                unsigned int *id_len);
  struct lhash_st_SSL_SESSION *SSL_CTX_sessions(SSL_CTX *ctx);
  void SSL_CTX_sess_set_new_cb(SSL_CTX *ctx,
                               int (*new_session_cb)(struct ssl_st *ssl,
                                                     SSL_SESSION *sess));
  int (*SSL_CTX_sess_get_new_cb(SSL_CTX *ctx))(struct ssl_st *ssl,
                                               SSL_SESSION *sess);
  void SSL_CTX_sess_set_remove_cb(SSL_CTX *ctx,
                                  void (*remove_session_cb)(struct ssl_ctx_st
                                                                *ctx,
                                                            SSL_SESSION *sess));
  void (*SSL_CTX_sess_get_remove_cb(SSL_CTX *ctx))(struct ssl_ctx_st *ctx,
                                                   SSL_SESSION *sess);
  void SSL_CTX_sess_set_get_cb(SSL_CTX *ctx,
                               SSL_SESSION *(*get_session_cb)(struct ssl_st
                                                                  *ssl,
                                                              const unsigned char
                                                                  *data,
                                                              int len,
                                                              int *copy));
  SSL_SESSION *(*SSL_CTX_sess_get_get_cb(SSL_CTX *ctx))(struct ssl_st *ssl,
                                                        const unsigned char *data,
                                                        int len, int *copy);
  void SSL_CTX_set_info_callback(SSL_CTX *ctx,
                                 void (*cb)(const SSL *ssl, int type, int val));
  void (*SSL_CTX_get_info_callback(SSL_CTX *ctx))(const SSL *ssl, int type,
                                                  int val);
  void SSL_CTX_set_client_cert_cb(SSL_CTX *ctx,
                                  int (*client_cert_cb)(SSL *ssl, X509 **x509,
                                                        EVP_PKEY **pkey));
  int (*SSL_CTX_get_client_cert_cb(SSL_CTX *ctx))(SSL *ssl, X509 **x509,
                                                  EVP_PKEY **pkey);
  int SSL_CTX_set_client_cert_engine(SSL_CTX *ctx, ENGINE *e);
  void SSL_CTX_set_cookie_generate_cb(SSL_CTX *ctx,
                                      int (*app_gen_cookie_cb)(SSL *ssl,
                                                               unsigned char
                                                                   *cookie,
                                                               unsigned int
                                                                   *cookie_len));
  void SSL_CTX_set_cookie_verify_cb(SSL_CTX *ctx,
                                    int (*app_verify_cookie_cb)(SSL *ssl,
                                                                const unsigned char *cookie,
                                                                unsigned int
                                                                    cookie_len));
  void SSL_CTX_set_stateless_cookie_generate_cb(
      SSL_CTX *ctx,
      int (*gen_stateless_cookie_cb)(SSL *ssl,
                                     unsigned char *cookie,
                                     size_t *cookie_len));
  void SSL_CTX_set_stateless_cookie_verify_cb(
      SSL_CTX *ctx,
      int (*verify_stateless_cookie_cb)(SSL *ssl,
                                        const unsigned char *cookie,
                                        size_t cookie_len));
  typedef int (*SSL_CTX_npn_advertised_cb_func)(SSL *ssl,
                                                const unsigned char **out,
                                                unsigned int *outlen,
                                                void *arg);
  void SSL_CTX_set_next_protos_advertised_cb(SSL_CTX *s,
                                             SSL_CTX_npn_advertised_cb_func cb,
                                             void *arg);
  typedef int (*SSL_CTX_npn_select_cb_func)(SSL *s,
                                            unsigned char **out,
                                            unsigned char *outlen,
                                            const unsigned char *in,
                                            unsigned int inlen,
                                            void *arg);
  void SSL_CTX_set_next_proto_select_cb(SSL_CTX *s,
                                        SSL_CTX_npn_select_cb_func cb,
                                        void *arg);
  void SSL_get0_next_proto_negotiated(const SSL *s, const unsigned char **data,
                                      unsigned *len);
  int SSL_select_next_proto(unsigned char **out, unsigned char *outlen,
                            const unsigned char *in, unsigned int inlen,
                            const unsigned char *client,
                            unsigned int client_len);
  int SSL_CTX_set_alpn_protos(SSL_CTX *ctx, const unsigned char *protos,
                              unsigned int protos_len);
  int SSL_set_alpn_protos(SSL *ssl, const unsigned char *protos,
                          unsigned int protos_len);
  typedef int (*SSL_CTX_alpn_select_cb_func)(SSL *ssl,
                                             const unsigned char **out,
                                             unsigned char *outlen,
                                             const unsigned char *in,
                                             unsigned int inlen,
                                             void *arg);
  void SSL_CTX_set_alpn_select_cb(SSL_CTX *ctx,
                                  SSL_CTX_alpn_select_cb_func cb,
                                  void *arg);
  void SSL_get0_alpn_selected(const SSL *ssl, const unsigned char **data,
                              unsigned int *len);
  typedef unsigned int (*SSL_psk_client_cb_func)(SSL *ssl,
                                                 const char *hint,
                                                 char *identity,
                                                 unsigned int max_identity_len,
                                                 unsigned char *psk,
                                                 unsigned int max_psk_len);
  void SSL_CTX_set_psk_client_callback(SSL_CTX *ctx, SSL_psk_client_cb_func cb);
  void SSL_set_psk_client_callback(SSL *ssl, SSL_psk_client_cb_func cb);
  typedef unsigned int (*SSL_psk_server_cb_func)(SSL *ssl,
                                                 const char *identity,
                                                 unsigned char *psk,
                                                 unsigned int max_psk_len);
  void SSL_CTX_set_psk_server_callback(SSL_CTX *ctx, SSL_psk_server_cb_func cb);
  void SSL_set_psk_server_callback(SSL *ssl, SSL_psk_server_cb_func cb);
  int SSL_CTX_use_psk_identity_hint(SSL_CTX *ctx, const char *identity_hint);
  int SSL_use_psk_identity_hint(SSL *s, const char *identity_hint);
  const char *SSL_get_psk_identity_hint(const SSL *s);
  const char *SSL_get_psk_identity(const SSL *s);
  typedef int (*SSL_psk_find_session_cb_func)(SSL *ssl,
                                              const unsigned char *identity,
                                              size_t identity_len,
                                              SSL_SESSION **sess);
  typedef int (*SSL_psk_use_session_cb_func)(SSL *ssl, const EVP_MD *md,
                                             const unsigned char **id,
                                             size_t *idlen,
                                             SSL_SESSION **sess);
  void SSL_set_psk_find_session_callback(SSL *s, SSL_psk_find_session_cb_func cb);
  void SSL_CTX_set_psk_find_session_callback(SSL_CTX *ctx,
                                             SSL_psk_find_session_cb_func cb);
  void SSL_set_psk_use_session_callback(SSL *s, SSL_psk_use_session_cb_func cb);
  void SSL_CTX_set_psk_use_session_callback(SSL_CTX *ctx,
                                            SSL_psk_use_session_cb_func cb);
  int SSL_CTX_has_client_custom_ext(const SSL_CTX *ctx,
                                    unsigned int ext_type);
  int SSL_CTX_add_client_custom_ext(SSL_CTX *ctx,
                                    unsigned int ext_type,
                                    custom_ext_add_cb add_cb,
                                    custom_ext_free_cb free_cb,
                                    void *add_arg,
                                    custom_ext_parse_cb parse_cb,
                                    void *parse_arg);
  int SSL_CTX_add_server_custom_ext(SSL_CTX *ctx,
                                    unsigned int ext_type,
                                    custom_ext_add_cb add_cb,
                                    custom_ext_free_cb free_cb,
                                    void *add_arg,
                                    custom_ext_parse_cb parse_cb,
                                    void *parse_arg);
  int SSL_CTX_add_custom_ext(SSL_CTX *ctx, unsigned int ext_type,
                             unsigned int context,
                             SSL_custom_ext_add_cb_ex add_cb,
                             SSL_custom_ext_free_cb_ex free_cb,
                             void *add_arg,
                             SSL_custom_ext_parse_cb_ex parse_cb,
                             void *parse_arg);
  int SSL_extension_supported(unsigned int ext_type);
  typedef void (*SSL_CTX_keylog_cb_func)(const SSL *ssl, const char *line);
  void SSL_CTX_set_keylog_callback(SSL_CTX *ctx, SSL_CTX_keylog_cb_func cb);
  SSL_CTX_keylog_cb_func SSL_CTX_get_keylog_callback(const SSL_CTX *ctx);
  int SSL_CTX_set_max_early_data(SSL_CTX *ctx, uint32_t max_early_data);
  uint32_t SSL_CTX_get_max_early_data(const SSL_CTX *ctx);
  int SSL_set_max_early_data(SSL *s, uint32_t max_early_data);
  uint32_t SSL_get_max_early_data(const SSL *s);
  int SSL_CTX_set_recv_max_early_data(SSL_CTX *ctx, uint32_t recv_max_early_data);
  uint32_t SSL_CTX_get_recv_max_early_data(const SSL_CTX *ctx);
  int SSL_set_recv_max_early_data(SSL *s, uint32_t recv_max_early_data);
  uint32_t SSL_get_recv_max_early_data(const SSL *s);
}
extern "C"
{
}
extern "C"
{
}
extern "C"
{
  int SSL_CTX_set_tlsext_max_fragment_length(SSL_CTX *ctx, uint8_t mode);
  int SSL_set_tlsext_max_fragment_length(SSL *ssl, uint8_t mode);
  const char *SSL_get_servername(const SSL *s, const int type);
  int SSL_get_servername_type(const SSL *s);
  int SSL_export_keying_material(SSL *s, unsigned char *out, size_t olen,
                                 const char *label, size_t llen,
                                 const unsigned char *context,
                                 size_t contextlen, int use_context);
  int SSL_export_keying_material_early(SSL *s, unsigned char *out,
                                       size_t olen, const char *label,
                                       size_t llen,
                                       const unsigned char *context,
                                       size_t contextlen);
  int SSL_get_peer_signature_type_nid(const SSL *s, int *pnid);
  int SSL_get_signature_type_nid(const SSL *s, int *pnid);
  int SSL_get_sigalgs(SSL *s, int idx,
                      int *psign, int *phash, int *psignandhash,
                      unsigned char *rsig, unsigned char *rhash);
  int SSL_get_shared_sigalgs(SSL *s, int idx,
                             int *psign, int *phash, int *psignandhash,
                             unsigned char *rsig, unsigned char *rhash);
  int SSL_check_chain(SSL *s, X509 *x, EVP_PKEY *pk, struct stack_st_X509 *chain);
  struct tls_session_ticket_ext_st
  {
    unsigned short length;
    void *data;
  };
}
extern "C"
{
}
extern "C"
{
  int SSL_CTX_set_tlsext_use_srtp(SSL_CTX *ctx, const char *profiles);
  int SSL_set_tlsext_use_srtp(SSL *ssl, const char *profiles);
  struct stack_st_SRTP_PROTECTION_PROFILE *SSL_get_srtp_profiles(SSL *ssl);
  SRTP_PROTECTION_PROFILE *SSL_get_selected_srtp_profile(SSL *s);
}
extern "C"
{
  struct stack_st_SSL_CIPHER;
  typedef int (*sk_SSL_CIPHER_compfunc)(const SSL_CIPHER *const *a, const SSL_CIPHER *const *b);
  typedef void (*sk_SSL_CIPHER_freefunc)(SSL_CIPHER *a);
  typedef SSL_CIPHER *(*sk_SSL_CIPHER_copyfunc)(const SSL_CIPHER *a);
  static __attribute__((unused)) inline int sk_SSL_CIPHER_num(const struct stack_st_SSL_CIPHER *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline const SSL_CIPHER *sk_SSL_CIPHER_value(const struct stack_st_SSL_CIPHER *sk, int idx) { return (const SSL_CIPHER *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_SSL_CIPHER *sk_SSL_CIPHER_new(sk_SSL_CIPHER_compfunc compare) { return (struct stack_st_SSL_CIPHER *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_SSL_CIPHER *sk_SSL_CIPHER_new_null(void) { return (struct stack_st_SSL_CIPHER *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_SSL_CIPHER *sk_SSL_CIPHER_new_reserve(sk_SSL_CIPHER_compfunc compare, int n) { return (struct stack_st_SSL_CIPHER *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_SSL_CIPHER_reserve(struct stack_st_SSL_CIPHER *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_SSL_CIPHER_free(struct stack_st_SSL_CIPHER *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_SSL_CIPHER_zero(struct stack_st_SSL_CIPHER *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline const SSL_CIPHER *sk_SSL_CIPHER_delete(struct stack_st_SSL_CIPHER *sk, int i) { return (const SSL_CIPHER *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline const SSL_CIPHER *sk_SSL_CIPHER_delete_ptr(struct stack_st_SSL_CIPHER *sk, const SSL_CIPHER *ptr) { return (const SSL_CIPHER *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_SSL_CIPHER_push(struct stack_st_SSL_CIPHER *sk, const SSL_CIPHER *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_SSL_CIPHER_unshift(struct stack_st_SSL_CIPHER *sk, const SSL_CIPHER *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline const SSL_CIPHER *sk_SSL_CIPHER_pop(struct stack_st_SSL_CIPHER *sk) { return (const SSL_CIPHER *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline const SSL_CIPHER *sk_SSL_CIPHER_shift(struct stack_st_SSL_CIPHER *sk) { return (const SSL_CIPHER *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_SSL_CIPHER_pop_free(struct stack_st_SSL_CIPHER *sk, sk_SSL_CIPHER_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_SSL_CIPHER_insert(struct stack_st_SSL_CIPHER *sk, const SSL_CIPHER *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline const SSL_CIPHER *sk_SSL_CIPHER_set(struct stack_st_SSL_CIPHER *sk, int idx, const SSL_CIPHER *ptr) { return (const SSL_CIPHER *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_SSL_CIPHER_find(struct stack_st_SSL_CIPHER *sk, const SSL_CIPHER *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_SSL_CIPHER_find_ex(struct stack_st_SSL_CIPHER *sk, const SSL_CIPHER *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_SSL_CIPHER_sort(struct stack_st_SSL_CIPHER *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_SSL_CIPHER_is_sorted(const struct stack_st_SSL_CIPHER *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_SSL_CIPHER *sk_SSL_CIPHER_dup(const struct stack_st_SSL_CIPHER *sk) { return (struct stack_st_SSL_CIPHER *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_SSL_CIPHER *sk_SSL_CIPHER_deep_copy(const struct stack_st_SSL_CIPHER *sk, sk_SSL_CIPHER_copyfunc copyfunc, sk_SSL_CIPHER_freefunc freefunc) { return (struct stack_st_SSL_CIPHER *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_SSL_CIPHER_compfunc sk_SSL_CIPHER_set_cmp_func(struct stack_st_SSL_CIPHER *sk, sk_SSL_CIPHER_compfunc compare) { return (sk_SSL_CIPHER_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  struct stack_st_SSL_COMP;
  typedef int (*sk_SSL_COMP_compfunc)(const SSL_COMP *const *a, const SSL_COMP *const *b);
  typedef void (*sk_SSL_COMP_freefunc)(SSL_COMP *a);
  typedef SSL_COMP *(*sk_SSL_COMP_copyfunc)(const SSL_COMP *a);
  static __attribute__((unused)) inline int sk_SSL_COMP_num(const struct stack_st_SSL_COMP *sk) { return OPENSSL_sk_num((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline SSL_COMP *sk_SSL_COMP_value(const struct stack_st_SSL_COMP *sk, int idx) { return (SSL_COMP *)OPENSSL_sk_value((const OPENSSL_STACK *)sk, idx); }
  static __attribute__((unused)) inline struct stack_st_SSL_COMP *sk_SSL_COMP_new(sk_SSL_COMP_compfunc compare) { return (struct stack_st_SSL_COMP *)OPENSSL_sk_new((OPENSSL_sk_compfunc)compare); }
  static __attribute__((unused)) inline struct stack_st_SSL_COMP *sk_SSL_COMP_new_null(void) { return (struct stack_st_SSL_COMP *)OPENSSL_sk_new_null(); }
  static __attribute__((unused)) inline struct stack_st_SSL_COMP *sk_SSL_COMP_new_reserve(sk_SSL_COMP_compfunc compare, int n) { return (struct stack_st_SSL_COMP *)OPENSSL_sk_new_reserve((OPENSSL_sk_compfunc)compare, n); }
  static __attribute__((unused)) inline int sk_SSL_COMP_reserve(struct stack_st_SSL_COMP *sk, int n) { return OPENSSL_sk_reserve((OPENSSL_STACK *)sk, n); }
  static __attribute__((unused)) inline void sk_SSL_COMP_free(struct stack_st_SSL_COMP *sk) { OPENSSL_sk_free((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_SSL_COMP_zero(struct stack_st_SSL_COMP *sk) { OPENSSL_sk_zero((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline SSL_COMP *sk_SSL_COMP_delete(struct stack_st_SSL_COMP *sk, int i) { return (SSL_COMP *)OPENSSL_sk_delete((OPENSSL_STACK *)sk, i); }
  static __attribute__((unused)) inline SSL_COMP *sk_SSL_COMP_delete_ptr(struct stack_st_SSL_COMP *sk, SSL_COMP *ptr) { return (SSL_COMP *)OPENSSL_sk_delete_ptr((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_SSL_COMP_push(struct stack_st_SSL_COMP *sk, SSL_COMP *ptr) { return OPENSSL_sk_push((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_SSL_COMP_unshift(struct stack_st_SSL_COMP *sk, SSL_COMP *ptr) { return OPENSSL_sk_unshift((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline SSL_COMP *sk_SSL_COMP_pop(struct stack_st_SSL_COMP *sk) { return (SSL_COMP *)OPENSSL_sk_pop((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline SSL_COMP *sk_SSL_COMP_shift(struct stack_st_SSL_COMP *sk) { return (SSL_COMP *)OPENSSL_sk_shift((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline void sk_SSL_COMP_pop_free(struct stack_st_SSL_COMP *sk, sk_SSL_COMP_freefunc freefunc) { OPENSSL_sk_pop_free((OPENSSL_STACK *)sk, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline int sk_SSL_COMP_insert(struct stack_st_SSL_COMP *sk, SSL_COMP *ptr, int idx) { return OPENSSL_sk_insert((OPENSSL_STACK *)sk, (const void *)ptr, idx); }
  static __attribute__((unused)) inline SSL_COMP *sk_SSL_COMP_set(struct stack_st_SSL_COMP *sk, int idx, SSL_COMP *ptr) { return (SSL_COMP *)OPENSSL_sk_set((OPENSSL_STACK *)sk, idx, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_SSL_COMP_find(struct stack_st_SSL_COMP *sk, SSL_COMP *ptr) { return OPENSSL_sk_find((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline int sk_SSL_COMP_find_ex(struct stack_st_SSL_COMP *sk, SSL_COMP *ptr) { return OPENSSL_sk_find_ex((OPENSSL_STACK *)sk, (const void *)ptr); }
  static __attribute__((unused)) inline void sk_SSL_COMP_sort(struct stack_st_SSL_COMP *sk) { OPENSSL_sk_sort((OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline int sk_SSL_COMP_is_sorted(const struct stack_st_SSL_COMP *sk) { return OPENSSL_sk_is_sorted((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_SSL_COMP *sk_SSL_COMP_dup(const struct stack_st_SSL_COMP *sk) { return (struct stack_st_SSL_COMP *)OPENSSL_sk_dup((const OPENSSL_STACK *)sk); }
  static __attribute__((unused)) inline struct stack_st_SSL_COMP *sk_SSL_COMP_deep_copy(const struct stack_st_SSL_COMP *sk, sk_SSL_COMP_copyfunc copyfunc, sk_SSL_COMP_freefunc freefunc) { return (struct stack_st_SSL_COMP *)OPENSSL_sk_deep_copy((const OPENSSL_STACK *)sk, (OPENSSL_sk_copyfunc)copyfunc, (OPENSSL_sk_freefunc)freefunc); }
  static __attribute__((unused)) inline sk_SSL_COMP_compfunc sk_SSL_COMP_set_cmp_func(struct stack_st_SSL_COMP *sk, sk_SSL_COMP_compfunc compare) { return (sk_SSL_COMP_compfunc)OPENSSL_sk_set_cmp_func((OPENSSL_STACK *)sk, (OPENSSL_sk_compfunc)compare); }
  void SSL_set_debug(SSL *s, int debug) __attribute__((deprecated));
  typedef enum
  {
    TLS_ST_BEFORE,
    TLS_ST_OK,
    DTLS_ST_CR_HELLO_VERIFY_REQUEST,
    TLS_ST_CR_SRVR_HELLO,
    TLS_ST_CR_CERT,
    TLS_ST_CR_CERT_STATUS,
    TLS_ST_CR_KEY_EXCH,
    TLS_ST_CR_CERT_REQ,
    TLS_ST_CR_SRVR_DONE,
    TLS_ST_CR_SESSION_TICKET,
    TLS_ST_CR_CHANGE,
    TLS_ST_CR_FINISHED,
    TLS_ST_CW_CLNT_HELLO,
    TLS_ST_CW_CERT,
    TLS_ST_CW_KEY_EXCH,
    TLS_ST_CW_CERT_VRFY,
    TLS_ST_CW_CHANGE,
    TLS_ST_CW_NEXT_PROTO,
    TLS_ST_CW_FINISHED,
    TLS_ST_SW_HELLO_REQ,
    TLS_ST_SR_CLNT_HELLO,
    DTLS_ST_SW_HELLO_VERIFY_REQUEST,
    TLS_ST_SW_SRVR_HELLO,
    TLS_ST_SW_CERT,
    TLS_ST_SW_KEY_EXCH,
    TLS_ST_SW_CERT_REQ,
    TLS_ST_SW_SRVR_DONE,
    TLS_ST_SR_CERT,
    TLS_ST_SR_KEY_EXCH,
    TLS_ST_SR_CERT_VRFY,
    TLS_ST_SR_NEXT_PROTO,
    TLS_ST_SR_CHANGE,
    TLS_ST_SR_FINISHED,
    TLS_ST_SW_SESSION_TICKET,
    TLS_ST_SW_CERT_STATUS,
    TLS_ST_SW_CHANGE,
    TLS_ST_SW_FINISHED,
    TLS_ST_SW_ENCRYPTED_EXTENSIONS,
    TLS_ST_CR_ENCRYPTED_EXTENSIONS,
    TLS_ST_CR_CERT_VRFY,
    TLS_ST_SW_CERT_VRFY,
    TLS_ST_CR_HELLO_REQ,
    TLS_ST_SW_KEY_UPDATE,
    TLS_ST_CW_KEY_UPDATE,
    TLS_ST_SR_KEY_UPDATE,
    TLS_ST_CR_KEY_UPDATE,
    TLS_ST_EARLY_DATA,
    TLS_ST_PENDING_EARLY_DATA_END,
    TLS_ST_CW_END_OF_EARLY_DATA,
    TLS_ST_SR_END_OF_EARLY_DATA
  } OSSL_HANDSHAKE_STATE;
  int SSL_in_init(const SSL *s);
  int SSL_in_before(const SSL *s);
  int SSL_is_init_finished(const SSL *s);
  size_t SSL_get_finished(const SSL *s, void *buf, size_t count);
  size_t SSL_get_peer_finished(const SSL *s, void *buf, size_t count);
  SSL_SESSION *PEM_read_bio_SSL_SESSION(BIO *bp, SSL_SESSION **x, pem_password_cb *cb, void *u);
  SSL_SESSION *PEM_read_SSL_SESSION(FILE *fp, SSL_SESSION **x, pem_password_cb *cb, void *u);
  int PEM_write_bio_SSL_SESSION(BIO *bp, SSL_SESSION *x);
  int PEM_write_SSL_SESSION(FILE *fp, SSL_SESSION *x);
  const BIO_METHOD *BIO_f_ssl(void);
  BIO *BIO_new_ssl(SSL_CTX *ctx, int client);
  BIO *BIO_new_ssl_connect(SSL_CTX *ctx);
  BIO *BIO_new_buffer_ssl_connect(SSL_CTX *ctx);
  int BIO_ssl_copy_session_id(BIO *to, BIO *from);
  void BIO_ssl_shutdown(BIO *ssl_bio);
  int SSL_CTX_set_cipher_list(SSL_CTX *, const char *str);
  SSL_CTX *SSL_CTX_new(const SSL_METHOD *meth);
  int SSL_CTX_up_ref(SSL_CTX *ctx);
  void SSL_CTX_free(SSL_CTX *);
  long SSL_CTX_set_timeout(SSL_CTX *ctx, long t);
  long SSL_CTX_get_timeout(const SSL_CTX *ctx);
  X509_STORE *SSL_CTX_get_cert_store(const SSL_CTX *);
  void SSL_CTX_set_cert_store(SSL_CTX *, X509_STORE *);
  void SSL_CTX_set1_cert_store(SSL_CTX *, X509_STORE *);
  int SSL_want(const SSL *s);
  int SSL_clear(SSL *s);
  void SSL_CTX_flush_sessions(SSL_CTX *ctx, long tm);
  const SSL_CIPHER *SSL_get_current_cipher(const SSL *s);
  const SSL_CIPHER *SSL_get_pending_cipher(const SSL *s);
  int SSL_CIPHER_get_bits(const SSL_CIPHER *c, int *alg_bits);
  const char *SSL_CIPHER_get_version(const SSL_CIPHER *c);
  const char *SSL_CIPHER_get_name(const SSL_CIPHER *c);
  const char *SSL_CIPHER_standard_name(const SSL_CIPHER *c);
  const char *OPENSSL_cipher_name(const char *rfc_name);
  uint32_t SSL_CIPHER_get_id(const SSL_CIPHER *c);
  uint16_t SSL_CIPHER_get_protocol_id(const SSL_CIPHER *c);
  int SSL_CIPHER_get_kx_nid(const SSL_CIPHER *c);
  int SSL_CIPHER_get_auth_nid(const SSL_CIPHER *c);
  const EVP_MD *SSL_CIPHER_get_handshake_digest(const SSL_CIPHER *c);
  int SSL_CIPHER_is_aead(const SSL_CIPHER *c);
  int SSL_get_fd(const SSL *s);
  int SSL_get_rfd(const SSL *s);
  int SSL_get_wfd(const SSL *s);
  const char *SSL_get_cipher_list(const SSL *s, int n);
  char *SSL_get_shared_ciphers(const SSL *s, char *buf, int size);
  int SSL_get_read_ahead(const SSL *s);
  int SSL_pending(const SSL *s);
  int SSL_has_pending(const SSL *s);
  int SSL_set_fd(SSL *s, int fd);
  int SSL_set_rfd(SSL *s, int fd);
  int SSL_set_wfd(SSL *s, int fd);
  void SSL_set0_rbio(SSL *s, BIO *rbio);
  void SSL_set0_wbio(SSL *s, BIO *wbio);
  void SSL_set_bio(SSL *s, BIO *rbio, BIO *wbio);
  BIO *SSL_get_rbio(const SSL *s);
  BIO *SSL_get_wbio(const SSL *s);
  int SSL_set_cipher_list(SSL *s, const char *str);
  int SSL_CTX_set_ciphersuites(SSL_CTX *ctx, const char *str);
  int SSL_set_ciphersuites(SSL *s, const char *str);
  void SSL_set_read_ahead(SSL *s, int yes);
  int SSL_get_verify_mode(const SSL *s);
  int SSL_get_verify_depth(const SSL *s);
  SSL_verify_cb SSL_get_verify_callback(const SSL *s);
  void SSL_set_verify(SSL *s, int mode, SSL_verify_cb callback);
  void SSL_set_verify_depth(SSL *s, int depth);
  void SSL_set_cert_cb(SSL *s, int (*cb)(SSL *ssl, void *arg), void *arg);
  int SSL_use_RSAPrivateKey(SSL *ssl, RSA *rsa);
  int SSL_use_RSAPrivateKey_ASN1(SSL *ssl, const unsigned char *d,
                                 long len);
  int SSL_use_PrivateKey(SSL *ssl, EVP_PKEY *pkey);
  int SSL_use_PrivateKey_ASN1(int pk, SSL *ssl, const unsigned char *d,
                              long len);
  int SSL_use_certificate(SSL *ssl, X509 *x);
  int SSL_use_certificate_ASN1(SSL *ssl, const unsigned char *d, int len);
  int SSL_use_cert_and_key(SSL *ssl, X509 *x509, EVP_PKEY *privatekey,
                           struct stack_st_X509 *chain, int override);
  int SSL_CTX_use_serverinfo(SSL_CTX *ctx, const unsigned char *serverinfo,
                             size_t serverinfo_length);
  int SSL_CTX_use_serverinfo_ex(SSL_CTX *ctx, unsigned int version,
                                const unsigned char *serverinfo,
                                size_t serverinfo_length);
  int SSL_CTX_use_serverinfo_file(SSL_CTX *ctx, const char *file);
  int SSL_use_RSAPrivateKey_file(SSL *ssl, const char *file, int type);
  int SSL_use_PrivateKey_file(SSL *ssl, const char *file, int type);
  int SSL_use_certificate_file(SSL *ssl, const char *file, int type);
  int SSL_CTX_use_RSAPrivateKey_file(SSL_CTX *ctx, const char *file,
                                     int type);
  int SSL_CTX_use_PrivateKey_file(SSL_CTX *ctx, const char *file,
                                  int type);
  int SSL_CTX_use_certificate_file(SSL_CTX *ctx, const char *file,
                                   int type);
  int SSL_CTX_use_certificate_chain_file(SSL_CTX *ctx, const char *file);
  int SSL_use_certificate_chain_file(SSL *ssl, const char *file);
  struct stack_st_X509_NAME *SSL_load_client_CA_file(const char *file);
  int SSL_add_file_cert_subjects_to_stack(struct stack_st_X509_NAME *stackCAs,
                                          const char *file);
  int SSL_add_dir_cert_subjects_to_stack(struct stack_st_X509_NAME *stackCAs,
                                         const char *dir);
  const char *SSL_state_string(const SSL *s);
  const char *SSL_rstate_string(const SSL *s);
  const char *SSL_state_string_long(const SSL *s);
  const char *SSL_rstate_string_long(const SSL *s);
  long SSL_SESSION_get_time(const SSL_SESSION *s);
  long SSL_SESSION_set_time(SSL_SESSION *s, long t);
  long SSL_SESSION_get_timeout(const SSL_SESSION *s);
  long SSL_SESSION_set_timeout(SSL_SESSION *s, long t);
  int SSL_SESSION_get_protocol_version(const SSL_SESSION *s);
  int SSL_SESSION_set_protocol_version(SSL_SESSION *s, int version);
  const char *SSL_SESSION_get0_hostname(const SSL_SESSION *s);
  int SSL_SESSION_set1_hostname(SSL_SESSION *s, const char *hostname);
  void SSL_SESSION_get0_alpn_selected(const SSL_SESSION *s,
                                      const unsigned char **alpn,
                                      size_t *len);
  int SSL_SESSION_set1_alpn_selected(SSL_SESSION *s,
                                     const unsigned char *alpn,
                                     size_t len);
  const SSL_CIPHER *SSL_SESSION_get0_cipher(const SSL_SESSION *s);
  int SSL_SESSION_set_cipher(SSL_SESSION *s, const SSL_CIPHER *cipher);
  int SSL_SESSION_has_ticket(const SSL_SESSION *s);
  unsigned long SSL_SESSION_get_ticket_lifetime_hint(const SSL_SESSION *s);
  void SSL_SESSION_get0_ticket(const SSL_SESSION *s, const unsigned char **tick,
                               size_t *len);
  uint32_t SSL_SESSION_get_max_early_data(const SSL_SESSION *s);
  int SSL_SESSION_set_max_early_data(SSL_SESSION *s,
                                     uint32_t max_early_data);
  int SSL_copy_session_id(SSL *to, const SSL *from);
  X509 *SSL_SESSION_get0_peer(SSL_SESSION *s);
  int SSL_SESSION_set1_id_context(SSL_SESSION *s,
                                  const unsigned char *sid_ctx,
                                  unsigned int sid_ctx_len);
  int SSL_SESSION_set1_id(SSL_SESSION *s, const unsigned char *sid,
                          unsigned int sid_len);
  int SSL_SESSION_is_resumable(const SSL_SESSION *s);
  SSL_SESSION *SSL_SESSION_new(void);
  SSL_SESSION *SSL_SESSION_dup(SSL_SESSION *src);
  const unsigned char *SSL_SESSION_get_id(const SSL_SESSION *s,
                                          unsigned int *len);
  const unsigned char *SSL_SESSION_get0_id_context(const SSL_SESSION *s,
                                                   unsigned int *len);
  unsigned int SSL_SESSION_get_compress_id(const SSL_SESSION *s);
  int SSL_SESSION_print_fp(FILE *fp, const SSL_SESSION *ses);
  int SSL_SESSION_print(BIO *fp, const SSL_SESSION *ses);
  int SSL_SESSION_print_keylog(BIO *bp, const SSL_SESSION *x);
  int SSL_SESSION_up_ref(SSL_SESSION *ses);
  void SSL_SESSION_free(SSL_SESSION *ses);
  int i2d_SSL_SESSION(SSL_SESSION *in, unsigned char **pp);
  int SSL_set_session(SSL *to, SSL_SESSION *session);
  int SSL_CTX_add_session(SSL_CTX *ctx, SSL_SESSION *session);
  int SSL_CTX_remove_session(SSL_CTX *ctx, SSL_SESSION *session);
  int SSL_CTX_set_generate_session_id(SSL_CTX *ctx, GEN_SESSION_CB cb);
  int SSL_set_generate_session_id(SSL *s, GEN_SESSION_CB cb);
  int SSL_has_matching_session_id(const SSL *s,
                                  const unsigned char *id,
                                  unsigned int id_len);
  SSL_SESSION *d2i_SSL_SESSION(SSL_SESSION **a, const unsigned char **pp,
                               long length);
  X509 *SSL_get_peer_certificate(const SSL *s);
  struct stack_st_X509 *SSL_get_peer_cert_chain(const SSL *s);
  int SSL_CTX_get_verify_mode(const SSL_CTX *ctx);
  int SSL_CTX_get_verify_depth(const SSL_CTX *ctx);
  SSL_verify_cb SSL_CTX_get_verify_callback(const SSL_CTX *ctx);
  void SSL_CTX_set_verify(SSL_CTX *ctx, int mode, SSL_verify_cb callback);
  void SSL_CTX_set_verify_depth(SSL_CTX *ctx, int depth);
  void SSL_CTX_set_cert_verify_callback(SSL_CTX *ctx,
                                        int (*cb)(X509_STORE_CTX *, void *),
                                        void *arg);
  void SSL_CTX_set_cert_cb(SSL_CTX *c, int (*cb)(SSL *ssl, void *arg),
                           void *arg);
  int SSL_CTX_use_RSAPrivateKey(SSL_CTX *ctx, RSA *rsa);
  int SSL_CTX_use_RSAPrivateKey_ASN1(SSL_CTX *ctx, const unsigned char *d,
                                     long len);
  int SSL_CTX_use_PrivateKey(SSL_CTX *ctx, EVP_PKEY *pkey);
  int SSL_CTX_use_PrivateKey_ASN1(int pk, SSL_CTX *ctx,
                                  const unsigned char *d, long len);
  int SSL_CTX_use_certificate(SSL_CTX *ctx, X509 *x);
  int SSL_CTX_use_certificate_ASN1(SSL_CTX *ctx, int len,
                                   const unsigned char *d);
  int SSL_CTX_use_cert_and_key(SSL_CTX *ctx, X509 *x509, EVP_PKEY *privatekey,
                               struct stack_st_X509 *chain, int override);
  void SSL_CTX_set_default_passwd_cb(SSL_CTX *ctx, pem_password_cb *cb);
  void SSL_CTX_set_default_passwd_cb_userdata(SSL_CTX *ctx, void *u);
  pem_password_cb *SSL_CTX_get_default_passwd_cb(SSL_CTX *ctx);
  void *SSL_CTX_get_default_passwd_cb_userdata(SSL_CTX *ctx);
  void SSL_set_default_passwd_cb(SSL *s, pem_password_cb *cb);
  void SSL_set_default_passwd_cb_userdata(SSL *s, void *u);
  pem_password_cb *SSL_get_default_passwd_cb(SSL *s);
  void *SSL_get_default_passwd_cb_userdata(SSL *s);
  int SSL_CTX_check_private_key(const SSL_CTX *ctx);
  int SSL_check_private_key(const SSL *ctx);
  int SSL_CTX_set_session_id_context(SSL_CTX *ctx,
                                     const unsigned char *sid_ctx,
                                     unsigned int sid_ctx_len);
  SSL *SSL_new(SSL_CTX *ctx);
  int SSL_up_ref(SSL *s);
  int SSL_is_dtls(const SSL *s);
  int SSL_set_session_id_context(SSL *ssl, const unsigned char *sid_ctx,
                                 unsigned int sid_ctx_len);
  int SSL_CTX_set_purpose(SSL_CTX *ctx, int purpose);
  int SSL_set_purpose(SSL *ssl, int purpose);
  int SSL_CTX_set_trust(SSL_CTX *ctx, int trust);
  int SSL_set_trust(SSL *ssl, int trust);
  int SSL_set1_host(SSL *s, const char *hostname);
  int SSL_add1_host(SSL *s, const char *hostname);
  const char *SSL_get0_peername(SSL *s);
  void SSL_set_hostflags(SSL *s, unsigned int flags);
  int SSL_CTX_dane_enable(SSL_CTX *ctx);
  int SSL_CTX_dane_mtype_set(SSL_CTX *ctx, const EVP_MD *md,
                             uint8_t mtype, uint8_t ord);
  int SSL_dane_enable(SSL *s, const char *basedomain);
  int SSL_dane_tlsa_add(SSL *s, uint8_t usage, uint8_t selector,
                        uint8_t mtype, unsigned const char *data, size_t dlen);
  int SSL_get0_dane_authority(SSL *s, X509 **mcert, EVP_PKEY **mspki);
  int SSL_get0_dane_tlsa(SSL *s, uint8_t *usage, uint8_t *selector,
                         uint8_t *mtype, unsigned const char **data,
                         size_t *dlen);
  SSL_DANE *SSL_get0_dane(SSL *ssl);
  unsigned long SSL_CTX_dane_set_flags(SSL_CTX *ctx, unsigned long flags);
  unsigned long SSL_CTX_dane_clear_flags(SSL_CTX *ctx, unsigned long flags);
  unsigned long SSL_dane_set_flags(SSL *ssl, unsigned long flags);
  unsigned long SSL_dane_clear_flags(SSL *ssl, unsigned long flags);
  int SSL_CTX_set1_param(SSL_CTX *ctx, X509_VERIFY_PARAM *vpm);
  int SSL_set1_param(SSL *ssl, X509_VERIFY_PARAM *vpm);
  X509_VERIFY_PARAM *SSL_CTX_get0_param(SSL_CTX *ctx);
  X509_VERIFY_PARAM *SSL_get0_param(SSL *ssl);
  int SSL_CTX_set_srp_username(SSL_CTX *ctx, char *name);
  int SSL_CTX_set_srp_password(SSL_CTX *ctx, char *password);
  int SSL_CTX_set_srp_strength(SSL_CTX *ctx, int strength);
  int SSL_CTX_set_srp_client_pwd_callback(SSL_CTX *ctx,
                                          char *(*cb)(SSL *, void *));
  int SSL_CTX_set_srp_verify_param_callback(SSL_CTX *ctx,
                                            int (*cb)(SSL *, void *));
  int SSL_CTX_set_srp_username_callback(SSL_CTX *ctx,
                                        int (*cb)(SSL *, int *, void *));
  int SSL_CTX_set_srp_cb_arg(SSL_CTX *ctx, void *arg);
  int SSL_set_srp_server_param(SSL *s, const BIGNUM *N, const BIGNUM *g,
                               BIGNUM *sa, BIGNUM *v, char *info);
  int SSL_set_srp_server_param_pw(SSL *s, const char *user, const char *pass,
                                  const char *grp);
  BIGNUM *SSL_get_srp_g(SSL *s);
  BIGNUM *SSL_get_srp_N(SSL *s);
  char *SSL_get_srp_username(SSL *s);
  char *SSL_get_srp_userinfo(SSL *s);
  typedef int (*SSL_client_hello_cb_fn)(SSL *s, int *al, void *arg);
  void SSL_CTX_set_client_hello_cb(SSL_CTX *c, SSL_client_hello_cb_fn cb,
                                   void *arg);
  int SSL_client_hello_isv2(SSL *s);
  unsigned int SSL_client_hello_get0_legacy_version(SSL *s);
  size_t SSL_client_hello_get0_random(SSL *s, const unsigned char **out);
  size_t SSL_client_hello_get0_session_id(SSL *s, const unsigned char **out);
  size_t SSL_client_hello_get0_ciphers(SSL *s, const unsigned char **out);
  size_t SSL_client_hello_get0_compression_methods(SSL *s,
                                                   const unsigned char **out);
  int SSL_client_hello_get1_extensions_present(SSL *s, int **out, size_t *outlen);
  int SSL_client_hello_get0_ext(SSL *s, unsigned int type,
                                const unsigned char **out, size_t *outlen);
  void SSL_certs_clear(SSL *s);
  void SSL_free(SSL *ssl);
  int SSL_waiting_for_async(SSL *s);
  int SSL_get_all_async_fds(SSL *s, int *fds, size_t *numfds);
  int SSL_get_changed_async_fds(SSL *s, int *addfd,
                                size_t *numaddfds, int *delfd,
                                size_t *numdelfds);
  int SSL_accept(SSL *ssl);
  int SSL_stateless(SSL *s);
  int SSL_connect(SSL *ssl);
  int SSL_read(SSL *ssl, void *buf, int num);
  int SSL_read_ex(SSL *ssl, void *buf, size_t num, size_t *readbytes);
  int SSL_read_early_data(SSL *s, void *buf, size_t num,
                          size_t *readbytes);
  int SSL_peek(SSL *ssl, void *buf, int num);
  int SSL_peek_ex(SSL *ssl, void *buf, size_t num, size_t *readbytes);
  int SSL_write(SSL *ssl, const void *buf, int num);
  int SSL_write_ex(SSL *s, const void *buf, size_t num, size_t *written);
  int SSL_write_early_data(SSL *s, const void *buf, size_t num,
                           size_t *written);
  long SSL_ctrl(SSL *ssl, int cmd, long larg, void *parg);
  long SSL_callback_ctrl(SSL *, int, void (*)(void));
  long SSL_CTX_ctrl(SSL_CTX *ctx, int cmd, long larg, void *parg);
  long SSL_CTX_callback_ctrl(SSL_CTX *, int, void (*)(void));
  int SSL_get_early_data_status(const SSL *s);
  int SSL_get_error(const SSL *s, int ret_code);
  const char *SSL_get_version(const SSL *s);
  int SSL_CTX_set_ssl_version(SSL_CTX *ctx, const SSL_METHOD *meth);
  const SSL_METHOD *TLS_method(void);
  const SSL_METHOD *TLS_server_method(void);
  const SSL_METHOD *TLS_client_method(void);
  const SSL_METHOD *TLSv1_method(void) __attribute__((deprecated));
  const SSL_METHOD *TLSv1_server_method(void) __attribute__((deprecated));
  const SSL_METHOD *TLSv1_client_method(void) __attribute__((deprecated));
  const SSL_METHOD *TLSv1_1_method(void) __attribute__((deprecated));
  const SSL_METHOD *TLSv1_1_server_method(void) __attribute__((deprecated));
  const SSL_METHOD *TLSv1_1_client_method(void) __attribute__((deprecated));
  const SSL_METHOD *TLSv1_2_method(void) __attribute__((deprecated));
  const SSL_METHOD *TLSv1_2_server_method(void) __attribute__((deprecated));
  const SSL_METHOD *TLSv1_2_client_method(void) __attribute__((deprecated));
  const SSL_METHOD *DTLSv1_method(void) __attribute__((deprecated));
  const SSL_METHOD *DTLSv1_server_method(void) __attribute__((deprecated));
  const SSL_METHOD *DTLSv1_client_method(void) __attribute__((deprecated));
  const SSL_METHOD *DTLSv1_2_method(void) __attribute__((deprecated));
  const SSL_METHOD *DTLSv1_2_server_method(void) __attribute__((deprecated));
  const SSL_METHOD *DTLSv1_2_client_method(void) __attribute__((deprecated));
  const SSL_METHOD *DTLS_method(void);
  const SSL_METHOD *DTLS_server_method(void);
  const SSL_METHOD *DTLS_client_method(void);
  size_t DTLS_get_data_mtu(const SSL *s);
  struct stack_st_SSL_CIPHER *SSL_get_ciphers(const SSL *s);
  struct stack_st_SSL_CIPHER *SSL_CTX_get_ciphers(const SSL_CTX *ctx);
  struct stack_st_SSL_CIPHER *SSL_get_client_ciphers(const SSL *s);
  struct stack_st_SSL_CIPHER *SSL_get1_supported_ciphers(SSL *s);
  int SSL_do_handshake(SSL *s);
  int SSL_key_update(SSL *s, int updatetype);
  int SSL_get_key_update_type(const SSL *s);
  int SSL_renegotiate(SSL *s);
  int SSL_renegotiate_abbreviated(SSL *s);
  int SSL_renegotiate_pending(const SSL *s);
  int SSL_shutdown(SSL *s);
  int SSL_verify_client_post_handshake(SSL *s);
  void SSL_CTX_set_post_handshake_auth(SSL_CTX *ctx, int val);
  void SSL_set_post_handshake_auth(SSL *s, int val);
  const SSL_METHOD *SSL_CTX_get_ssl_method(const SSL_CTX *ctx);
  const SSL_METHOD *SSL_get_ssl_method(const SSL *s);
  int SSL_set_ssl_method(SSL *s, const SSL_METHOD *method);
  const char *SSL_alert_type_string_long(int value);
  const char *SSL_alert_type_string(int value);
  const char *SSL_alert_desc_string_long(int value);
  const char *SSL_alert_desc_string(int value);
  void SSL_set0_CA_list(SSL *s, struct stack_st_X509_NAME *name_list);
  void SSL_CTX_set0_CA_list(SSL_CTX *ctx, struct stack_st_X509_NAME *name_list);
  const struct stack_st_X509_NAME *SSL_get0_CA_list(const SSL *s);
  const struct stack_st_X509_NAME *SSL_CTX_get0_CA_list(const SSL_CTX *ctx);
  int SSL_add1_to_CA_list(SSL *ssl, const X509 *x);
  int SSL_CTX_add1_to_CA_list(SSL_CTX *ctx, const X509 *x);
  const struct stack_st_X509_NAME *SSL_get0_peer_CA_list(const SSL *s);
  void SSL_set_client_CA_list(SSL *s, struct stack_st_X509_NAME *name_list);
  void SSL_CTX_set_client_CA_list(SSL_CTX *ctx, struct stack_st_X509_NAME *name_list);
  struct stack_st_X509_NAME *SSL_get_client_CA_list(const SSL *s);
  struct stack_st_X509_NAME *SSL_CTX_get_client_CA_list(const SSL_CTX *s);
  int SSL_add_client_CA(SSL *ssl, X509 *x);
  int SSL_CTX_add_client_CA(SSL_CTX *ctx, X509 *x);
  void SSL_set_connect_state(SSL *s);
  void SSL_set_accept_state(SSL *s);
  long SSL_get_default_timeout(const SSL *s);
  char *SSL_CIPHER_description(const SSL_CIPHER *, char *buf, int size);
  struct stack_st_X509_NAME *SSL_dup_CA_list(const struct stack_st_X509_NAME *sk);
  SSL *SSL_dup(SSL *ssl);
  X509 *SSL_get_certificate(const SSL *ssl);
  struct evp_pkey_st *SSL_get_privatekey(const SSL *ssl);
  X509 *SSL_CTX_get0_certificate(const SSL_CTX *ctx);
  EVP_PKEY *SSL_CTX_get0_privatekey(const SSL_CTX *ctx);
  void SSL_CTX_set_quiet_shutdown(SSL_CTX *ctx, int mode);
  int SSL_CTX_get_quiet_shutdown(const SSL_CTX *ctx);
  void SSL_set_quiet_shutdown(SSL *ssl, int mode);
  int SSL_get_quiet_shutdown(const SSL *ssl);
  void SSL_set_shutdown(SSL *ssl, int mode);
  int SSL_get_shutdown(const SSL *ssl);
  int SSL_version(const SSL *ssl);
  int SSL_client_version(const SSL *s);
  int SSL_CTX_set_default_verify_paths(SSL_CTX *ctx);
  int SSL_CTX_set_default_verify_dir(SSL_CTX *ctx);
  int SSL_CTX_set_default_verify_file(SSL_CTX *ctx);
  int SSL_CTX_load_verify_locations(SSL_CTX *ctx, const char *CAfile,
                                    const char *CApath);
  SSL_SESSION *SSL_get_session(const SSL *ssl);
  SSL_SESSION *SSL_get1_session(SSL *ssl);
  SSL_CTX *SSL_get_SSL_CTX(const SSL *ssl);
  SSL_CTX *SSL_set_SSL_CTX(SSL *ssl, SSL_CTX *ctx);
  void SSL_set_info_callback(SSL *ssl,
                             void (*cb)(const SSL *ssl, int type, int val));
  void (*SSL_get_info_callback(const SSL *ssl))(const SSL *ssl, int type,
                                                int val);
  OSSL_HANDSHAKE_STATE SSL_get_state(const SSL *ssl);
  void SSL_set_verify_result(SSL *ssl, long v);
  long SSL_get_verify_result(const SSL *ssl);
  struct stack_st_X509 *SSL_get0_verified_chain(const SSL *s);
  size_t SSL_get_client_random(const SSL *ssl, unsigned char *out,
                               size_t outlen);
  size_t SSL_get_server_random(const SSL *ssl, unsigned char *out,
                               size_t outlen);
  size_t SSL_SESSION_get_master_key(const SSL_SESSION *sess,
                                    unsigned char *out, size_t outlen);
  int SSL_SESSION_set1_master_key(SSL_SESSION *sess,
                                  const unsigned char *in, size_t len);
  uint8_t SSL_SESSION_get_max_fragment_length(const SSL_SESSION *sess);
  int SSL_set_ex_data(SSL *ssl, int idx, void *data);
  void *SSL_get_ex_data(const SSL *ssl, int idx);
  int SSL_SESSION_set_ex_data(SSL_SESSION *ss, int idx, void *data);
  void *SSL_SESSION_get_ex_data(const SSL_SESSION *ss, int idx);
  int SSL_CTX_set_ex_data(SSL_CTX *ssl, int idx, void *data);
  void *SSL_CTX_get_ex_data(const SSL_CTX *ssl, int idx);
  int SSL_get_ex_data_X509_STORE_CTX_idx(void);
  void SSL_CTX_set_default_read_buffer_len(SSL_CTX *ctx, size_t len);
  void SSL_set_default_read_buffer_len(SSL *s, size_t len);
  void SSL_CTX_set_tmp_dh_callback(SSL_CTX *ctx,
                                   DH *(*dh)(SSL *ssl, int is_export,
                                             int keylength));
  void SSL_set_tmp_dh_callback(SSL *ssl,
                               DH *(*dh)(SSL *ssl, int is_export,
                                         int keylength));
  const COMP_METHOD *SSL_get_current_compression(const SSL *s);
  const COMP_METHOD *SSL_get_current_expansion(const SSL *s);
  const char *SSL_COMP_get_name(const COMP_METHOD *comp);
  const char *SSL_COMP_get0_name(const SSL_COMP *comp);
  int SSL_COMP_get_id(const SSL_COMP *comp);
  struct stack_st_SSL_COMP *SSL_COMP_get_compression_methods(void);
  struct stack_st_SSL_COMP *SSL_COMP_set0_compression_methods(struct stack_st_SSL_COMP
                                                                  *meths);
  int SSL_COMP_add_compression_method(int id, COMP_METHOD *cm);
  const SSL_CIPHER *SSL_CIPHER_find(SSL *ssl, const unsigned char *ptr);
  int SSL_CIPHER_get_cipher_nid(const SSL_CIPHER *c);
  int SSL_CIPHER_get_digest_nid(const SSL_CIPHER *c);
  int SSL_bytes_to_cipher_list(SSL *s, const unsigned char *bytes, size_t len,
                               int isv2format, struct stack_st_SSL_CIPHER **sk,
                               struct stack_st_SSL_CIPHER **scsvs);
  int SSL_set_session_ticket_ext(SSL *s, void *ext_data, int ext_len);
  int SSL_set_session_ticket_ext_cb(SSL *s,
                                    tls_session_ticket_ext_cb_fn cb,
                                    void *arg);
  int SSL_set_session_secret_cb(SSL *s,
                                tls_session_secret_cb_fn session_secret_cb,
                                void *arg);
  void SSL_CTX_set_not_resumable_session_callback(SSL_CTX *ctx,
                                                  int (*cb)(SSL *ssl,
                                                            int
                                                                is_forward_secure));
  void SSL_set_not_resumable_session_callback(SSL *ssl,
                                              int (*cb)(SSL *ssl,
                                                        int is_forward_secure));
  void SSL_CTX_set_record_padding_callback(SSL_CTX *ctx,
                                           size_t (*cb)(SSL *ssl, int type,
                                                        size_t len, void *arg));
  void SSL_CTX_set_record_padding_callback_arg(SSL_CTX *ctx, void *arg);
  void *SSL_CTX_get_record_padding_callback_arg(const SSL_CTX *ctx);
  int SSL_CTX_set_block_padding(SSL_CTX *ctx, size_t block_size);
  void SSL_set_record_padding_callback(SSL *ssl,
                                       size_t (*cb)(SSL *ssl, int type,
                                                    size_t len, void *arg));
  void SSL_set_record_padding_callback_arg(SSL *ssl, void *arg);
  void *SSL_get_record_padding_callback_arg(const SSL *ssl);
  int SSL_set_block_padding(SSL *ssl, size_t block_size);
  int SSL_set_num_tickets(SSL *s, size_t num_tickets);
  size_t SSL_get_num_tickets(const SSL *s);
  int SSL_CTX_set_num_tickets(SSL_CTX *ctx, size_t num_tickets);
  size_t SSL_CTX_get_num_tickets(const SSL_CTX *ctx);
  int SSL_session_reused(const SSL *s);
  int SSL_is_server(const SSL *s);
  SSL_CONF_CTX *SSL_CONF_CTX_new(void);
  int SSL_CONF_CTX_finish(SSL_CONF_CTX *cctx);
  void SSL_CONF_CTX_free(SSL_CONF_CTX *cctx);
  unsigned int SSL_CONF_CTX_set_flags(SSL_CONF_CTX *cctx, unsigned int flags);
  unsigned int SSL_CONF_CTX_clear_flags(SSL_CONF_CTX *cctx,
                                        unsigned int flags);
  int SSL_CONF_CTX_set1_prefix(SSL_CONF_CTX *cctx, const char *pre);
  void SSL_CONF_CTX_set_ssl(SSL_CONF_CTX *cctx, SSL *ssl);
  void SSL_CONF_CTX_set_ssl_ctx(SSL_CONF_CTX *cctx, SSL_CTX *ctx);
  int SSL_CONF_cmd(SSL_CONF_CTX *cctx, const char *cmd, const char *value);
  int SSL_CONF_cmd_argv(SSL_CONF_CTX *cctx, int *pargc, char ***pargv);
  int SSL_CONF_cmd_value_type(SSL_CONF_CTX *cctx, const char *cmd);
  void SSL_add_ssl_module(void);
  int SSL_config(SSL *s, const char *name);
  int SSL_CTX_config(SSL_CTX *ctx, const char *name);
  int DTLSv1_listen(SSL *s, BIO_ADDR *client);
  typedef int (*ssl_ct_validation_cb)(const CT_POLICY_EVAL_CTX *ctx,
                                      const struct stack_st_SCT *scts, void *arg);
  int SSL_set_ct_validation_callback(SSL *s, ssl_ct_validation_cb callback,
                                     void *arg);
  int SSL_CTX_set_ct_validation_callback(SSL_CTX *ctx,
                                         ssl_ct_validation_cb callback,
                                         void *arg);
  enum
  {
    SSL_CT_VALIDATION_PERMISSIVE = 0,
    SSL_CT_VALIDATION_STRICT
  };
  int SSL_enable_ct(SSL *s, int validation_mode);
  int SSL_CTX_enable_ct(SSL_CTX *ctx, int validation_mode);
  int SSL_ct_is_enabled(const SSL *s);
  int SSL_CTX_ct_is_enabled(const SSL_CTX *ctx);
  const struct stack_st_SCT *SSL_get0_peer_scts(SSL *s);
  int SSL_CTX_set_default_ctlog_list_file(SSL_CTX *ctx);
  int SSL_CTX_set_ctlog_list_file(SSL_CTX *ctx, const char *path);
  void SSL_CTX_set0_ctlog_store(SSL_CTX *ctx, CTLOG_STORE *logs);
  const CTLOG_STORE *SSL_CTX_get0_ctlog_store(const SSL_CTX *ctx);
  void SSL_set_security_level(SSL *s, int level);
  int SSL_get_security_level(const SSL *s);
  void SSL_set_security_callback(SSL *s,
                                 int (*cb)(const SSL *s, const SSL_CTX *ctx,
                                           int op, int bits, int nid,
                                           void *other, void *ex));
  int (*SSL_get_security_callback(const SSL *s))(const SSL *s,
                                                 const SSL_CTX *ctx, int op,
                                                 int bits, int nid, void *other,
                                                 void *ex);
  void SSL_set0_security_ex_data(SSL *s, void *ex);
  void *SSL_get0_security_ex_data(const SSL *s);
  void SSL_CTX_set_security_level(SSL_CTX *ctx, int level);
  int SSL_CTX_get_security_level(const SSL_CTX *ctx);
  void SSL_CTX_set_security_callback(SSL_CTX *ctx,
                                     int (*cb)(const SSL *s, const SSL_CTX *ctx,
                                               int op, int bits, int nid,
                                               void *other, void *ex));
  int (*SSL_CTX_get_security_callback(const SSL_CTX *ctx))(const SSL *s,
                                                           const SSL_CTX *ctx,
                                                           int op, int bits,
                                                           int nid,
                                                           void *other,
                                                           void *ex);
  void SSL_CTX_set0_security_ex_data(SSL_CTX *ctx, void *ex);
  void *SSL_CTX_get0_security_ex_data(const SSL_CTX *ctx);
  int OPENSSL_init_ssl(uint64_t opts, const OPENSSL_INIT_SETTINGS *settings);
  int SSL_free_buffers(SSL *ssl);
  int SSL_alloc_buffers(SSL *ssl);
  typedef int SSL_TICKET_STATUS;
  typedef int SSL_TICKET_RETURN;
  typedef int (*SSL_CTX_generate_session_ticket_fn)(SSL *s, void *arg);
  typedef SSL_TICKET_RETURN (*SSL_CTX_decrypt_session_ticket_fn)(SSL *s, SSL_SESSION *ss,
                                                                 const unsigned char *keyname,
                                                                 size_t keyname_length,
                                                                 SSL_TICKET_STATUS status,
                                                                 void *arg);
  int SSL_CTX_set_session_ticket_cb(SSL_CTX *ctx,
                                    SSL_CTX_generate_session_ticket_fn gen_cb,
                                    SSL_CTX_decrypt_session_ticket_fn dec_cb,
                                    void *arg);
  int SSL_SESSION_set1_ticket_appdata(SSL_SESSION *ss, const void *data, size_t len);
  int SSL_SESSION_get0_ticket_appdata(SSL_SESSION *ss, void **data, size_t *len);
  extern const char SSL_version_str[];
  typedef unsigned int (*DTLS_timer_cb)(SSL *s, unsigned int timer_us);
  void DTLS_set_timer_cb(SSL *s, DTLS_timer_cb cb);
  typedef int (*SSL_allow_early_data_cb_fn)(SSL *s, void *arg);
  void SSL_CTX_set_allow_early_data_cb(SSL_CTX *ctx,
                                       SSL_allow_early_data_cb_fn cb,
                                       void *arg);
  void SSL_set_allow_early_data_cb(SSL *s,
                                   SSL_allow_early_data_cb_fn cb,
                                   void *arg);
  typedef enum ssl_encryption_level_t
  {
    ssl_encryption_initial = 0,
    ssl_encryption_early_data,
    ssl_encryption_handshake,
    ssl_encryption_application
  } OSSL_ENCRYPTION_LEVEL;
  struct ssl_quic_method_st
  {
    int (*set_encryption_secrets)(SSL *ssl, OSSL_ENCRYPTION_LEVEL level,
                                  const uint8_t *read_secret,
                                  const uint8_t *write_secret, size_t secret_len);
    int (*add_handshake_data)(SSL *ssl, OSSL_ENCRYPTION_LEVEL level,
                              const uint8_t *data, size_t len);
    int (*flush_flight)(SSL *ssl);
    int (*send_alert)(SSL *ssl, enum ssl_encryption_level_t level, uint8_t alert);
  };
  int SSL_CTX_set_quic_method(SSL_CTX *ctx, const SSL_QUIC_METHOD *quic_method);
  int SSL_set_quic_method(SSL *ssl, const SSL_QUIC_METHOD *quic_method);
  int SSL_set_quic_transport_params(SSL *ssl,
                                    const uint8_t *params,
                                    size_t params_len);
  void SSL_get_peer_quic_transport_params(const SSL *ssl,
                                          const uint8_t **out_params,
                                          size_t *out_params_len);
  size_t SSL_quic_max_handshake_flight_len(const SSL *ssl, OSSL_ENCRYPTION_LEVEL level);
  OSSL_ENCRYPTION_LEVEL SSL_quic_read_level(const SSL *ssl);
  OSSL_ENCRYPTION_LEVEL SSL_quic_write_level(const SSL *ssl);
  int SSL_provide_quic_data(SSL *ssl, OSSL_ENCRYPTION_LEVEL level,
                            const uint8_t *data, size_t len);
  int SSL_process_quic_post_handshake(SSL *ssl);
  int SSL_is_quic(SSL *ssl);
  void SSL_set_quic_early_data_enabled(SSL *ssl, int enabled);
  int SSL_CIPHER_get_prf_nid(const SSL_CIPHER *c);
}
extern "C" int ERR_load_KDF_strings(void);
extern "C"
{
}
namespace ngtcp2
{
  constexpr uint8_t HQ_ALPN[] = "\x5hq-29\x5hq-30\x5hq-31\x5hq-32";
  constexpr uint8_t HQ_ALPN_DRAFT29[] = "\x5hq-29";
  constexpr uint8_t HQ_ALPN_DRAFT30[] = "\x5hq-30";
  constexpr uint8_t HQ_ALPN_DRAFT31[] = "\x5hq-31";
  constexpr uint8_t HQ_ALPN_DRAFT32[] = "\x5hq-32";
  constexpr uint8_t H3_ALPN[] = "\x5h3-29\x5h3-30\x5h3-31\x5h3-32";
  constexpr uint8_t H3_ALPN_DRAFT29[] = "\x5h3-29";
  constexpr uint8_t H3_ALPN_DRAFT30[] = "\x5h3-30";
  constexpr uint8_t H3_ALPN_DRAFT31[] = "\x5h3-31";
  constexpr uint8_t H3_ALPN_DRAFT32[] = "\x5h3-32";
  constexpr uint32_t QUIC_VER_DRAFT29 = 0xff00001du;
  constexpr uint32_t QUIC_VER_DRAFT30 = 0xff00001eu;
  constexpr uint32_t QUIC_VER_DRAFT31 = 0xff00001fu;
  constexpr uint32_t QUIC_VER_DRAFT32 = 0xff000020u;
  enum class QUICErrorType
  {
    Application,
    Transport,
    TransportVersionNegotiation,
    TransportIdleTimeout,
  };
  struct QUICError
  {
    QUICError(QUICErrorType type, uint64_t code) : type(type), code(code) {}
    QUICErrorType type;
    uint64_t code;
  };
  QUICError quic_err_transport(int liberr);
  QUICError quic_err_idle_timeout();
  QUICError quic_err_tls(int alert);
  QUICError quic_err_app(int liberr);
  unsigned int msghdr_get_ecn(msghdr *msg, int family);
  void fd_set_ecn(int fd, int family, unsigned int ecn);
  void fd_set_recv_ecn(int fd, int family);
} // namespace ngtcp2
int ngtcp2_crypto_derive_initial_secrets(uint8_t *rx_secret, uint8_t *tx_secret,
                                         uint8_t *initial_secret,
                                         const ngtcp2_cid *client_dcid,
                                         ngtcp2_crypto_side side);
int ngtcp2_crypto_update_traffic_secret(uint8_t *dest,
                                        const ngtcp2_crypto_md *md,
                                        const uint8_t *secret,
                                        size_t secretlen);
int ngtcp2_crypto_set_local_transport_params(void *tls, const uint8_t *buf,
                                             size_t len);
int ngtcp2_crypto_set_remote_transport_params(ngtcp2_conn *conn, void *tls);
int ngtcp2_crypto_derive_and_install_initial_key(
    ngtcp2_conn *conn, uint8_t *rx_secret, uint8_t *tx_secret,
    uint8_t *initial_secret, uint8_t *rx_key, uint8_t *rx_iv, uint8_t *rx_hp,
    uint8_t *tx_key, uint8_t *tx_iv, uint8_t *tx_hp,
    const ngtcp2_cid *client_dcid);
int ngtcp2_crypto_cipher_ctx_encrypt_init(ngtcp2_crypto_cipher_ctx *cipher_ctx,
                                          const ngtcp2_crypto_cipher *cipher,
                                          const uint8_t *key);
void ngtcp2_crypto_cipher_ctx_free(ngtcp2_crypto_cipher_ctx *cipher_ctx);

namespace ngtcp2
{
  namespace util
  {
    template <typename T, size_t N1, size_t N2>
    constexpr nghttp3_nv make_nv(const T (&name)[N1], const T (&value)[N2])
    {
      return nghttp3_nv{(uint8_t *)name, (uint8_t *)value, N1 - 1, N2 - 1,
                        NGHTTP3_NV_FLAG_NONE};
    }
    template <typename T, size_t N, typename S>
    constexpr nghttp3_nv make_nv(const T (&name)[N], const S &value)
    {
      return nghttp3_nv{(uint8_t *)name, (uint8_t *)value.data(), N - 1,
                        value.size(), NGHTTP3_NV_FLAG_NONE};
    }
    template <typename S1, typename S2>
    constexpr nghttp3_nv make_nv(const S1 &name, const S2 &value)
    {
      return nghttp3_nv{(uint8_t *)name.data(), (uint8_t *)value.data(),
                        name.size(), value.size(), NGHTTP3_NV_FLAG_NONE};
    }
    std::string format_hex(uint8_t c);
    std::string format_hex(const uint8_t *s, size_t len);
    std::string format_hex(const std::string &s);
    template <size_t N>
    std::string format_hex(const uint8_t (&s)[N])
    {
      return format_hex(s, N);
    }
    std::string decode_hex(const std::string &s);
    std::string format_durationf(uint64_t ns);
    std::mt19937 make_mt19937();
    ngtcp2_tstamp timestamp(struct ev_loop *loop);
    bool numeric_host(const char *hostname);
    bool numeric_host(const char *hostname, int family);
    void hexdump(FILE *out, const uint8_t *src, size_t len);
    inline char lowcase(char c)
    {
      constexpr static unsigned char tbl[] = {
          0,
          1,
          2,
          3,
          4,
          5,
          6,
          7,
          8,
          9,
          10,
          11,
          12,
          13,
          14,
          15,
          16,
          17,
          18,
          19,
          20,
          21,
          22,
          23,
          24,
          25,
          26,
          27,
          28,
          29,
          30,
          31,
          32,
          33,
          34,
          35,
          36,
          37,
          38,
          39,
          40,
          41,
          42,
          43,
          44,
          45,
          46,
          47,
          48,
          49,
          50,
          51,
          52,
          53,
          54,
          55,
          56,
          57,
          58,
          59,
          60,
          61,
          62,
          63,
          64,
          'a',
          'b',
          'c',
          'd',
          'e',
          'f',
          'g',
          'h',
          'i',
          'j',
          'k',
          'l',
          'm',
          'n',
          'o',
          'p',
          'q',
          'r',
          's',
          't',
          'u',
          'v',
          'w',
          'x',
          'y',
          'z',
          91,
          92,
          93,
          94,
          95,
          96,
          97,
          98,
          99,
          100,
          101,
          102,
          103,
          104,
          105,
          106,
          107,
          108,
          109,
          110,
          111,
          112,
          113,
          114,
          115,
          116,
          117,
          118,
          119,
          120,
          121,
          122,
          123,
          124,
          125,
          126,
          127,
          128,
          129,
          130,
          131,
          132,
          133,
          134,
          135,
          136,
          137,
          138,
          139,
          140,
          141,
          142,
          143,
          144,
          145,
          146,
          147,
          148,
          149,
          150,
          151,
          152,
          153,
          154,
          155,
          156,
          157,
          158,
          159,
          160,
          161,
          162,
          163,
          164,
          165,
          166,
          167,
          168,
          169,
          170,
          171,
          172,
          173,
          174,
          175,
          176,
          177,
          178,
          179,
          180,
          181,
          182,
          183,
          184,
          185,
          186,
          187,
          188,
          189,
          190,
          191,
          192,
          193,
          194,
          195,
          196,
          197,
          198,
          199,
          200,
          201,
          202,
          203,
          204,
          205,
          206,
          207,
          208,
          209,
          210,
          211,
          212,
          213,
          214,
          215,
          216,
          217,
          218,
          219,
          220,
          221,
          222,
          223,
          224,
          225,
          226,
          227,
          228,
          229,
          230,
          231,
          232,
          233,
          234,
          235,
          236,
          237,
          238,
          239,
          240,
          241,
          242,
          243,
          244,
          245,
          246,
          247,
          248,
          249,
          250,
          251,
          252,
          253,
          254,
          255,
      };
      return tbl[static_cast<unsigned char>(c)];
    }
    struct CaseCmp
    {
      bool operator()(char lhs, char rhs) const
      {
        return lowcase(lhs) == lowcase(rhs);
      }
    };
    template <typename InputIterator1, typename InputIterator2>
    bool istarts_with(InputIterator1 first1, InputIterator1 last1,
                      InputIterator2 first2, InputIterator2 last2)
    {
      if (last1 - first1 < last2 - first2)
      {
        return false;
      }
      return std::equal(first2, last2, first1, CaseCmp());
    }
    template <typename S, typename T>
    bool istarts_with(const S &a, const T &b)
    {
      return istarts_with(a.begin(), a.end(), b.begin(), b.end());
    }
    template <typename T, typename CharT, size_t N>
    bool istarts_with_l(const T &a, const CharT (&b)[N])
    {
      return istarts_with(a.begin(), a.end(), b, b + N - 1);
    }
    std::string make_cid_key(const ngtcp2_cid *cid);
    std::string make_cid_key(const uint8_t *cid, size_t cidlen);
    std::string straddr(const sockaddr *sa, socklen_t salen);
    template <typename T, size_t N>
    bool streq_l(const T (&a)[N], const nghttp3_vec &b)
    {
      return N - 1 == b.len && memcmp(a, b.base, N - 1) == 0;
    }
    namespace
    {
      constexpr char B64_CHARS[] = {
          'A',
          'B',
          'C',
          'D',
          'E',
          'F',
          'G',
          'H',
          'I',
          'J',
          'K',
          'L',
          'M',
          'N',
          'O',
          'P',
          'Q',
          'R',
          'S',
          'T',
          'U',
          'V',
          'W',
          'X',
          'Y',
          'Z',
          'a',
          'b',
          'c',
          'd',
          'e',
          'f',
          'g',
          'h',
          'i',
          'j',
          'k',
          'l',
          'm',
          'n',
          'o',
          'p',
          'q',
          'r',
          's',
          't',
          'u',
          'v',
          'w',
          'x',
          'y',
          'z',
          '0',
          '1',
          '2',
          '3',
          '4',
          '5',
          '6',
          '7',
          '8',
          '9',
          '+',
          '/',
      };
    }
    template <typename InputIt>
    std::string b64encode(InputIt first, InputIt last)
    {
      std::string res;
      size_t len = last - first;
      if (len == 0)
      {
        return res;
      }
      size_t r = len % 3;
      res.resize((len + 2) / 3 * 4);
      auto j = last - r;
      auto p = std::begin(res);
      while (first != j)
      {
        uint32_t n = static_cast<uint8_t>(*first++) << 16;
        n += static_cast<uint8_t>(*first++) << 8;
        n += static_cast<uint8_t>(*first++);
        *p++ = B64_CHARS[n >> 18];
        *p++ = B64_CHARS[(n >> 12) & 0x3fu];
        *p++ = B64_CHARS[(n >> 6) & 0x3fu];
        *p++ = B64_CHARS[n & 0x3fu];
      }
      if (r == 2)
      {
        uint32_t n = static_cast<uint8_t>(*first++) << 16;
        n += static_cast<uint8_t>(*first++) << 8;
        *p++ = B64_CHARS[n >> 18];
        *p++ = B64_CHARS[(n >> 12) & 0x3fu];
        *p++ = B64_CHARS[(n >> 6) & 0x3fu];
        *p++ = '=';
      }
      else if (r == 1)
      {
        uint32_t n = static_cast<uint8_t>(*first++) << 16;
        *p++ = B64_CHARS[n >> 18];
        *p++ = B64_CHARS[(n >> 12) & 0x3fu];
        *p++ = '=';
        *p++ = '=';
      }
      return res;
    }
    int read_mime_types(std::unordered_map<std::string, std::string> &dest,
                        const char *filename);
    ngtcp2_crypto_level from_ossl_level(OSSL_ENCRYPTION_LEVEL ossl_level);
    OSSL_ENCRYPTION_LEVEL from_ngtcp2_level(ngtcp2_crypto_level crypto_level);
    template <typename T>
    std::string format_uint(T n)
    {
      std::string res;
      if (n == 0)
      {
        res = "0";
        return res;
      }
      size_t nlen = 0;
      for (auto t = n; t; t /= 10, ++nlen)
        ;
      res.resize(nlen);
      for (; n; n /= 10)
      {
        res[--nlen] = (n % 10) + '0';
      }
      return res;
    }
    template <typename T>
    std::string format_uint_iec(T n)
    {
      if (n >= (1 << 30) && (n & ((1 << 30) - 1)) == 0)
      {
        return format_uint(n / (1 << 30)) + 'G';
      }
      if (n >= (1 << 20) && (n & ((1 << 20) - 1)) == 0)
      {
        return format_uint(n / (1 << 20)) + 'M';
      }
      if (n >= (1 << 10) && (n & ((1 << 10) - 1)) == 0)
      {
        return format_uint(n / (1 << 10)) + 'K';
      }
      return format_uint(n);
    }
    std::string format_duration(ngtcp2_duration n);
    std::pair<uint64_t, int> parse_uint(const std::string_view &s);
    std::pair<uint64_t, int> parse_uint_iec(const std::string_view &s);
    std::pair<uint64_t, int> parse_duration(const std::string_view &s);
    int generate_secret(uint8_t *secret, size_t secretlen);
    std::string normalize_path(const std::string &path);
    constexpr bool is_digit(const char c) { return '0' <= c && c <= '9'; }
    constexpr bool is_hex_digit(const char c)
    {
      return is_digit(c) || ('A' <= c && c <= 'F') || ('a' <= c && c <= 'f');
    }
    constexpr uint32_t hex_to_uint(char c)
    {
      if (c <= '9')
      {
        return c - '0';
      }
      if (c <= 'Z')
      {
        return c - 'A' + 10;
      }
      if (c <= 'z')
      {
        return c - 'a' + 10;
      }
      return 256;
    }
    template <typename InputIt>
    std::string percent_decode(InputIt first, InputIt last)
    {
      std::string result;
      result.resize(last - first);
      auto p = std::begin(result);
      for (; first != last; ++first)
      {
        if (*first != '%')
        {
          *p++ = *first;
          continue;
        }
        if (first + 1 != last && first + 2 != last && is_hex_digit(*(first + 1)) &&
            is_hex_digit(*(first + 2)))
        {
          *p++ = (hex_to_uint(*(first + 1)) << 4) + hex_to_uint(*(first + 2));
          first += 2;
          continue;
        }
        *p++ = *first;
      }
      result.resize(p - std::begin(result));
      return result;
    }
  } // namespace util
  std::ostream &operator<<(std::ostream &os, const ngtcp2_cid &cid);
} // namespace ngtcp2

template <typename F, typename... T>
struct Defer
{
  Defer(F &&f, T &&... t)
      : f(std::bind(std::forward<F>(f), std::forward<T>(t)...)) {}
  Defer(Defer &&o) noexcept : f(std::move(o.f)) {}
  ~Defer() { f(); }
  using ResultType = typename std::result_of<typename std::decay<F>::type(
      typename std::decay<T>::type...)>::type;
  std::function<ResultType()> f;
};
template <typename F, typename... T>
Defer<F, T...> defer(F &&f, T &&... t)
{
  return Defer<F, T...>(std::forward<F>(f), std::forward<T>(t)...);
}
template <typename T, size_t N>
constexpr size_t array_size(T (&)[N])
{
  return N;
}
template <typename T, size_t N>
constexpr size_t str_size(T (&)[N])
{
  return N - 1;
}
constexpr unsigned long long operator"" _k(unsigned long long k)
{
  return k * 1024;
}
constexpr unsigned long long operator"" _m(unsigned long long m)
{
  return m * 1024 * 1024;
}
constexpr unsigned long long operator"" _g(unsigned long long g)
{
  return g * 1024 * 1024 * 1024;
}
void nghttp3_buf_init(nghttp3_buf *buf)
{
  buf->begin = buf->end = buf->pos = buf->last =
      __null;
}
void nghttp3_buf_wrap_init(nghttp3_buf *buf, uint8_t *src, size_t len)
{
  buf->begin = buf->pos = buf->last = src;
  buf->end = buf->begin + len;
}
void nghttp3_buf_free(nghttp3_buf *buf, const nghttp3_mem *mem)
{
  nghttp3_mem_free(mem, buf->begin);
}
size_t nghttp3_buf_left(const nghttp3_buf *buf)
{
  return (size_t)(buf->end - buf->last);
}
size_t nghttp3_buf_len(const nghttp3_buf *buf)
{
  return (size_t)(buf->last - buf->pos);
}
size_t nghttp3_buf_cap(const nghttp3_buf *buf)
{
  return (size_t)(buf->end - buf->begin);
}
void nghttp3_buf_reset(nghttp3_buf *buf) { buf->pos = buf->last = buf->begin; }
int nghttp3_buf_reserve(nghttp3_buf *buf, size_t size, const nghttp3_mem *mem)
{
  uint8_t *p;
  nghttp3_ssize pos_offset, last_offset;
  if ((size_t)(buf->end - buf->begin) >= size)
  {
    return 0;
  }
  pos_offset = buf->pos - buf->begin;
  last_offset = buf->last - buf->begin;
  p = nghttp3_mem_realloc(mem, buf->begin, size);
  if (p ==
      __null)
  {
    return NGHTTP3_ERR_NOMEM;
  }
  buf->begin = p;
  buf->end = p + size;
  buf->pos = p + pos_offset;
  buf->last = p + last_offset;
  return 0;
}
void nghttp3_buf_swap(nghttp3_buf *a, nghttp3_buf *b)
{
  nghttp3_buf c = *a;
  *a = *b;
  *b = c;
}
void nghttp3_typed_buf_init(nghttp3_typed_buf *tbuf, const nghttp3_buf *buf,
                            nghttp3_buf_type type)
{
  tbuf->buf = *buf;
  tbuf->type = type;
}
static int conn_remote_stream_uni(nghttp3_conn *conn, int64_t stream_id)
{
  if (conn->server)
  {
    return (stream_id & 0x03) == 0x02;
  }
  return (stream_id & 0x03) == 0x03;
}
static int conn_call_begin_headers(nghttp3_conn *conn, nghttp3_stream *stream)
{
  int rv;
  if (!conn->callbacks.begin_headers)
  {
    return 0;
  }
  rv = conn->callbacks.begin_headers(conn, stream->node.nid.id, conn->user_data,
                                     stream->user_data);
  if (rv != 0)
  {
    return NGHTTP3_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_end_headers(nghttp3_conn *conn, nghttp3_stream *stream)
{
  int rv;
  if (!conn->callbacks.end_headers)
  {
    return 0;
  }
  rv = conn->callbacks.end_headers(conn, stream->node.nid.id, conn->user_data,
                                   stream->user_data);
  if (rv != 0)
  {
    return NGHTTP3_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_begin_trailers(nghttp3_conn *conn,
                                    nghttp3_stream *stream)
{
  int rv;
  if (!conn->callbacks.begin_trailers)
  {
    return 0;
  }
  rv = conn->callbacks.begin_trailers(conn, stream->node.nid.id,
                                      conn->user_data, stream->user_data);
  if (rv != 0)
  {
    return NGHTTP3_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_end_trailers(nghttp3_conn *conn, nghttp3_stream *stream)
{
  int rv;
  if (!conn->callbacks.end_trailers)
  {
    return 0;
  }
  rv = conn->callbacks.end_trailers(conn, stream->node.nid.id, conn->user_data,
                                    stream->user_data);
  if (rv != 0)
  {
    return NGHTTP3_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_begin_push_promise(nghttp3_conn *conn,
                                        nghttp3_stream *stream,
                                        int64_t push_id)
{
  int rv;
  if (!conn->callbacks.begin_push_promise)
  {
    return 0;
  }
  rv = conn->callbacks.begin_push_promise(conn, stream->node.nid.id, push_id,
                                          conn->user_data, stream->user_data);
  if (rv != 0)
  {
    return NGHTTP3_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_end_push_promise(nghttp3_conn *conn,
                                      nghttp3_stream *stream, int64_t push_id)
{
  int rv;
  if (!conn->callbacks.end_push_promise)
  {
    return 0;
  }
  rv = conn->callbacks.end_push_promise(conn, stream->node.nid.id, push_id,
                                        conn->user_data, stream->user_data);
  if (rv != 0)
  {
    return NGHTTP3_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_end_stream(nghttp3_conn *conn, nghttp3_stream *stream)
{
  int rv;
  if (!conn->callbacks.end_stream)
  {
    return 0;
  }
  rv = conn->callbacks.end_stream(conn, stream->node.nid.id, conn->user_data,
                                  stream->user_data);
  if (rv != 0)
  {
    return NGHTTP3_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_cancel_push(nghttp3_conn *conn, int64_t push_id,
                                 nghttp3_stream *stream)
{
  int rv;
  if (!conn->callbacks.cancel_push)
  {
    return 0;
  }
  rv = conn->callbacks.cancel_push(
      conn, push_id, stream ? stream->node.nid.id : -1, conn->user_data,
      stream ? stream->user_data : __null);
  if (rv != 0)
  {
    return NGHTTP3_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_send_stop_sending(nghttp3_conn *conn,
                                       nghttp3_stream *stream,
                                       uint64_t app_error_code)
{
  int rv;
  if (!conn->callbacks.send_stop_sending)
  {
    return 0;
  }
  rv = conn->callbacks.send_stop_sending(conn, stream->node.nid.id,
                                         app_error_code, conn->user_data,
                                         stream->user_data);
  if (rv != 0)
  {
    return NGHTTP3_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_reset_stream(nghttp3_conn *conn, nghttp3_stream *stream,
                                  uint64_t app_error_code)
{
  int rv;
  if (!conn->callbacks.reset_stream)
  {
    return 0;
  }
  rv = conn->callbacks.reset_stream(conn, stream->node.nid.id, app_error_code,
                                    conn->user_data, stream->user_data);
  if (rv != 0)
  {
    return NGHTTP3_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_push_stream(nghttp3_conn *conn, int64_t push_id,
                                 nghttp3_stream *stream)
{
  int rv;
  if (!conn->callbacks.push_stream)
  {
    return 0;
  }
  rv = conn->callbacks.push_stream(conn, push_id, stream->node.nid.id,
                                   conn->user_data);
  if (rv != 0)
  {
    return NGHTTP3_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_deferred_consume(nghttp3_conn *conn,
                                      nghttp3_stream *stream,
                                      size_t nconsumed)
{
  int rv;
  if (nconsumed == 0 || !conn->callbacks.deferred_consume)
  {
    return 0;
  }
  rv = conn->callbacks.deferred_consume(conn, stream->node.nid.id, nconsumed,
                                        conn->user_data, stream->user_data);
  if (rv != 0)
  {
    return NGHTTP3_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int ricnt_less(const nghttp3_pq_entry *lhsx,
                      const nghttp3_pq_entry *rhsx)
{
  nghttp3_stream *lhs =
      ((nghttp3_stream *)(void *)((char *)(lhsx) -
                                  __builtin_offsetof(
                                      nghttp3_stream,
                                      qpack_blocked_pe)));
  nghttp3_stream *rhs =
      ((nghttp3_stream *)(void *)((char *)(rhsx) -
                                  __builtin_offsetof(
                                      nghttp3_stream,
                                      qpack_blocked_pe)));
  return lhs->qpack_sctx.ricnt < rhs->qpack_sctx.ricnt;
}
static int cycle_less(const nghttp3_pq_entry *lhsx,
                      const nghttp3_pq_entry *rhsx)
{
  const nghttp3_tnode *lhs = ((nghttp3_tnode *)(void *)((char *)(lhsx) -
                                                        __builtin_offsetof(
                                                            nghttp3_tnode,
                                                            pe)));
  const nghttp3_tnode *rhs = ((nghttp3_tnode *)(void *)((char *)(rhsx) -
                                                        __builtin_offsetof(
                                                            nghttp3_tnode,
                                                            pe)));
  if (lhs->cycle == rhs->cycle)
  {
    return lhs->seq < rhs->seq;
  }
  return rhs->cycle - lhs->cycle <= (1llu << 24);
}
static int conn_new(nghttp3_conn **pconn, int server,
                    const nghttp3_conn_callbacks *callbacks,
                    const nghttp3_conn_settings *settings,
                    const nghttp3_mem *mem, void *user_data)
{
  int rv;
  nghttp3_conn *conn;
  size_t i;
  conn = nghttp3_mem_calloc(mem, 1, sizeof(nghttp3_conn));
  if (conn ==
      __null)
  {
    return NGHTTP3_ERR_NOMEM;
  }
  rv = nghttp3_map_init(&conn->streams, mem);
  if (rv != 0)
  {
    goto streams_init_fail;
  }
  rv = nghttp3_map_init(&conn->pushes, mem);
  if (rv != 0)
  {
    goto pushes_init_fail;
  }
  rv = nghttp3_qpack_decoder_init(&conn->qdec,
                                  settings->qpack_max_table_capacity,
                                  settings->qpack_blocked_streams, mem);
  if (rv != 0)
  {
    goto qdec_init_fail;
  }
  rv = nghttp3_qpack_encoder_init(&conn->qenc, 0, 0, mem);
  if (rv != 0)
  {
    goto qenc_init_fail;
  }
  nghttp3_pq_init(&conn->qpack_blocked_streams, ricnt_less, mem);
  for (i = 0; i < (7 + 1); ++i)
  {
    nghttp3_pq_init(&conn->sched[i].spq, cycle_less, mem);
  }
  rv = nghttp3_idtr_init(&conn->remote.bidi.idtr, server, mem);
  if (rv != 0)
  {
    goto remote_bidi_idtr_init_fail;
  }
  rv = nghttp3_gaptr_init(&conn->remote.uni.push_idtr, mem);
  if (rv != 0)
  {
    goto push_idtr_init_fail;
  }
  conn->callbacks = *callbacks;
  conn->local.settings = *settings;
  nghttp3_conn_settings_default(&conn->remote.settings);
  conn->mem = mem;
  conn->user_data = user_data;
  conn->next_seq = 0;
  conn->server = server;
  conn->rx.goaway_id = ((1ull << 62) - 1) + 1;
  conn->tx.goaway_id = ((1ull << 62) - 1) + 1;
  conn->rx.max_stream_id_bidi = 0;
  conn->rx.max_push_id = 0;
  *pconn = conn;
  return 0;
push_idtr_init_fail:
  nghttp3_idtr_free(&conn->remote.bidi.idtr);
remote_bidi_idtr_init_fail:
  nghttp3_qpack_encoder_free(&conn->qenc);
qenc_init_fail:
  nghttp3_qpack_decoder_free(&conn->qdec);
qdec_init_fail:
  nghttp3_map_free(&conn->pushes);
pushes_init_fail:
  nghttp3_map_free(&conn->streams);
streams_init_fail:
  nghttp3_mem_free(mem, conn);
  return rv;
}
int nghttp3_conn_client_new(nghttp3_conn **pconn,
                            const nghttp3_conn_callbacks *callbacks,
                            const nghttp3_conn_settings *settings,
                            const nghttp3_mem *mem, void *user_data)
{
  int rv;
  rv = conn_new(pconn, 0, callbacks, settings, mem, user_data);
  if (rv != 0)
  {
    return rv;
  }
  (*pconn)->remote.uni.unsent_max_pushes = settings->max_pushes;
  return 0;
}
int nghttp3_conn_server_new(nghttp3_conn **pconn,
                            const nghttp3_conn_callbacks *callbacks,
                            const nghttp3_conn_settings *settings,
                            const nghttp3_mem *mem, void *user_data)
{
  int rv;
  rv = conn_new(pconn, 1, callbacks, settings, mem, user_data);
  if (rv != 0)
  {
    return rv;
  }
  return 0;
}
static int free_push_promise(nghttp3_map_entry *ent, void *ptr)
{
  nghttp3_push_promise *pp = ((nghttp3_push_promise *)(void *)((char *)(ent) -
                                                               __builtin_offsetof(
                                                                   nghttp3_push_promise,
                                                                   me)));
  const nghttp3_mem *mem = ptr;
  nghttp3_push_promise_del(pp, mem);
  return 0;
}
static int free_stream(nghttp3_map_entry *ent, void *ptr)
{
  nghttp3_stream *stream = ((nghttp3_stream *)(void *)((char *)(ent) -
                                                       __builtin_offsetof(
                                                           nghttp3_stream,
                                                           me)));
  (void)ptr;
  nghttp3_stream_del(stream);
  return 0;
}
void nghttp3_conn_del(nghttp3_conn *conn)
{
  size_t i;
  if (conn ==
      __null)
  {
    return;
  }
  nghttp3_buf_free(&conn->tx.qpack.ebuf, conn->mem);
  nghttp3_buf_free(&conn->tx.qpack.rbuf, conn->mem);
  nghttp3_gaptr_free(&conn->remote.uni.push_idtr);
  nghttp3_idtr_free(&conn->remote.bidi.idtr);
  for (i = 0; i < (7 + 1); ++i)
  {
    nghttp3_pq_free(&conn->sched[i].spq);
  }
  nghttp3_pq_free(&conn->qpack_blocked_streams);
  nghttp3_qpack_encoder_free(&conn->qenc);
  nghttp3_qpack_decoder_free(&conn->qdec);
  nghttp3_map_each_free(&conn->pushes, free_push_promise, (void *)conn->mem);
  nghttp3_map_free(&conn->pushes);
  nghttp3_map_each_free(&conn->streams, free_stream,
                        __null);
  nghttp3_map_free(&conn->streams);
  nghttp3_mem_free(conn->mem, conn);
}
nghttp3_ssize nghttp3_conn_read_stream(nghttp3_conn *conn, int64_t stream_id,
                                       const uint8_t *src, size_t srclen,
                                       int fin)
{
  nghttp3_stream *stream;
  size_t bidi_nproc;
  int rv;
  stream = nghttp3_conn_find_stream(conn, stream_id);
  if (stream ==
      __null)
  {
    if (conn->server)
    {
      if (nghttp3_client_stream_bidi(stream_id))
      {
        rv = nghttp3_idtr_open(&conn->remote.bidi.idtr, stream_id);
        assert(rv == 0);
        conn->rx.max_stream_id_bidi =
            ((conn->rx.max_stream_id_bidi) > (stream_id) ? (conn->rx.max_stream_id_bidi) : (stream_id));
        rv = nghttp3_conn_create_stream(conn, &stream, stream_id);
        if (rv != 0)
        {
          return rv;
        }
        if ((conn->flags & NGHTTP3_CONN_FLAG_GOAWAY_QUEUED) &&
            conn->tx.goaway_id <= stream_id)
        {
          stream->rstate.state = NGHTTP3_REQ_STREAM_STATE_IGN_REST;
          rv = nghttp3_conn_reject_stream(conn, stream);
          if (rv != 0)
          {
            return rv;
          }
        }
      }
      else
      {
        if (srclen == 0 && fin)
        {
          return 0;
        }
        rv = nghttp3_conn_create_stream(conn, &stream, stream_id);
        if (rv != 0)
        {
          return rv;
        }
      }
      stream->rx.hstate = NGHTTP3_HTTP_STATE_REQ_INITIAL;
      stream->tx.hstate = NGHTTP3_HTTP_STATE_REQ_INITIAL;
    }
    else if (nghttp3_stream_uni(stream_id))
    {
      if (srclen == 0 && fin)
      {
        return 0;
      }
      rv = nghttp3_conn_create_stream(conn, &stream, stream_id);
      if (rv != 0)
      {
        return rv;
      }
      stream->rx.hstate = NGHTTP3_HTTP_STATE_RESP_INITIAL;
      stream->tx.hstate = NGHTTP3_HTTP_STATE_RESP_INITIAL;
    }
    else
    {
      return NGHTTP3_ERR_H3_STREAM_CREATION_ERROR;
    }
  }
  else if (conn->server)
  {
    if (nghttp3_client_stream_bidi(stream_id))
    {
      if (stream->rx.hstate == NGHTTP3_HTTP_STATE_NONE)
      {
        stream->rx.hstate = NGHTTP3_HTTP_STATE_REQ_INITIAL;
        stream->tx.hstate = NGHTTP3_HTTP_STATE_REQ_INITIAL;
      }
    }
  }
  else if (nghttp3_stream_uni(stream_id) &&
           stream->type == NGHTTP3_STREAM_TYPE_PUSH)
  {
    if (stream->rx.hstate == NGHTTP3_HTTP_STATE_NONE)
    {
      stream->rx.hstate = NGHTTP3_HTTP_STATE_RESP_INITIAL;
      stream->tx.hstate = NGHTTP3_HTTP_STATE_RESP_INITIAL;
    }
  }
  if (srclen == 0 && !fin)
  {
    return 0;
  }
  if (nghttp3_stream_uni(stream_id))
  {
    return nghttp3_conn_read_uni(conn, stream, src, srclen, fin);
  }
  if (fin)
  {
    stream->flags |= NGHTTP3_STREAM_FLAG_READ_EOF;
  }
  return nghttp3_conn_read_bidi(conn, &bidi_nproc, stream, src, srclen, fin);
}
static nghttp3_ssize conn_read_type(nghttp3_conn *conn, nghttp3_stream *stream,
                                    const uint8_t *src, size_t srclen,
                                    int fin)
{
  nghttp3_stream_read_state *rstate = &stream->rstate;
  nghttp3_varint_read_state *rvint = &rstate->rvint;
  nghttp3_ssize nread;
  int64_t stream_type;
  assert(srclen);
  nread = nghttp3_read_varint(rvint, src, srclen, fin);
  if (nread < 0)
  {
    return NGHTTP3_ERR_H3_GENERAL_PROTOCOL_ERROR;
  }
  if (rvint->left)
  {
    return nread;
  }
  stream_type = rvint->acc;
  nghttp3_varint_read_state_reset(rvint);
  switch (stream_type)
  {
  case NGHTTP3_STREAM_TYPE_CONTROL:
    if (conn->flags & NGHTTP3_CONN_FLAG_CONTROL_OPENED)
    {
      return NGHTTP3_ERR_H3_STREAM_CREATION_ERROR;
    }
    conn->flags |= NGHTTP3_CONN_FLAG_CONTROL_OPENED;
    stream->type = NGHTTP3_STREAM_TYPE_CONTROL;
    rstate->state = NGHTTP3_CTRL_STREAM_STATE_FRAME_TYPE;
    break;
  case NGHTTP3_STREAM_TYPE_PUSH:
    if (conn->server)
    {
      return NGHTTP3_ERR_H3_STREAM_CREATION_ERROR;
    }
    stream->type = NGHTTP3_STREAM_TYPE_PUSH;
    rstate->state = NGHTTP3_PUSH_STREAM_STATE_PUSH_ID;
    break;
  case NGHTTP3_STREAM_TYPE_QPACK_ENCODER:
    if (conn->flags & NGHTTP3_CONN_FLAG_QPACK_ENCODER_OPENED)
    {
      return NGHTTP3_ERR_H3_STREAM_CREATION_ERROR;
    }
    conn->flags |= NGHTTP3_CONN_FLAG_QPACK_ENCODER_OPENED;
    stream->type = NGHTTP3_STREAM_TYPE_QPACK_ENCODER;
    break;
  case NGHTTP3_STREAM_TYPE_QPACK_DECODER:
    if (conn->flags & NGHTTP3_CONN_FLAG_QPACK_DECODER_OPENED)
    {
      return NGHTTP3_ERR_H3_STREAM_CREATION_ERROR;
    }
    conn->flags |= NGHTTP3_CONN_FLAG_QPACK_DECODER_OPENED;
    stream->type = NGHTTP3_STREAM_TYPE_QPACK_DECODER;
    break;
  default:
    stream->type = NGHTTP3_STREAM_TYPE_UNKNOWN;
    break;
  }
  stream->flags |= NGHTTP3_STREAM_FLAG_TYPE_IDENTIFIED;
  return nread;
}
static int conn_delete_stream(nghttp3_conn *conn, nghttp3_stream *stream);
nghttp3_ssize nghttp3_conn_read_uni(nghttp3_conn *conn, nghttp3_stream *stream,
                                    const uint8_t *src, size_t srclen,
                                    int fin)
{
  nghttp3_ssize nread = 0;
  nghttp3_ssize nconsumed = 0;
  size_t push_nproc;
  int rv;
  assert(srclen || fin);
  if (!(stream->flags & NGHTTP3_STREAM_FLAG_TYPE_IDENTIFIED))
  {
    if (srclen == 0 && fin)
    {
      if (stream->rstate.rvint.left)
      {
        return NGHTTP3_ERR_H3_GENERAL_PROTOCOL_ERROR;
      }
      rv = conn_delete_stream(conn, stream);
      assert(0 == rv);
      return 0;
    }
    nread = conn_read_type(conn, stream, src, srclen, fin);
    if (nread < 0)
    {
      return (int)nread;
    }
    if (!(stream->flags & NGHTTP3_STREAM_FLAG_TYPE_IDENTIFIED))
    {
      assert((size_t)nread == srclen);
      return (nghttp3_ssize)srclen;
    }
    src += nread;
    srclen -= (size_t)nread;
    if (srclen == 0)
    {
      return nread;
    }
  }
  switch (stream->type)
  {
  case NGHTTP3_STREAM_TYPE_CONTROL:
    if (fin)
    {
      return NGHTTP3_ERR_H3_CLOSED_CRITICAL_STREAM;
    }
    nconsumed = nghttp3_conn_read_control(conn, stream, src, srclen);
    break;
  case NGHTTP3_STREAM_TYPE_PUSH:
    if (fin)
    {
      stream->flags |= NGHTTP3_STREAM_FLAG_READ_EOF;
    }
    nconsumed =
        nghttp3_conn_read_push(conn, &push_nproc, stream, src, srclen, fin);
    break;
  case NGHTTP3_STREAM_TYPE_QPACK_ENCODER:
    if (fin)
    {
      return NGHTTP3_ERR_H3_CLOSED_CRITICAL_STREAM;
    }
    nconsumed = nghttp3_conn_read_qpack_encoder(conn, src, srclen);
    break;
  case NGHTTP3_STREAM_TYPE_QPACK_DECODER:
    if (fin)
    {
      return NGHTTP3_ERR_H3_CLOSED_CRITICAL_STREAM;
    }
    nconsumed = nghttp3_conn_read_qpack_decoder(conn, src, srclen);
    break;
  case NGHTTP3_STREAM_TYPE_UNKNOWN:
    nconsumed = (nghttp3_ssize)srclen;
    rv = conn_call_send_stop_sending(conn, stream,
                                     0x0103);
    if (rv != 0)
    {
      return rv;
    }
    break;
  default:
    assert(0);
  }
  if (nconsumed < 0)
  {
    return nconsumed;
  }
  return nread + nconsumed;
}
static int frame_fin(nghttp3_stream_read_state *rstate, size_t len)
{
  return (int64_t)len >= rstate->left;
}
nghttp3_ssize nghttp3_conn_read_control(nghttp3_conn *conn,
                                        nghttp3_stream *stream,
                                        const uint8_t *src, size_t srclen)
{
  const uint8_t *p = src, *end = src + srclen;
  int rv;
  nghttp3_stream_read_state *rstate = &stream->rstate;
  nghttp3_varint_read_state *rvint = &rstate->rvint;
  nghttp3_ssize nread;
  size_t nconsumed = 0;
  int busy = 0;
  size_t len;
  assert(srclen);
  for (; p != end || busy;)
  {
    busy = 0;
    switch (rstate->state)
    {
    case NGHTTP3_CTRL_STREAM_STATE_FRAME_TYPE:
      assert(end - p > 0);
      nread = nghttp3_read_varint(rvint, p, (size_t)(end - p), 0);
      if (nread < 0)
      {
        return NGHTTP3_ERR_H3_GENERAL_PROTOCOL_ERROR;
      }
      p += nread;
      nconsumed += (size_t)nread;
      if (rvint->left)
      {
        return (nghttp3_ssize)nconsumed;
      }
      rstate->fr.hd.type = rvint->acc;
      nghttp3_varint_read_state_reset(rvint);
      rstate->state = NGHTTP3_CTRL_STREAM_STATE_FRAME_LENGTH;
      if (p == end)
      {
        break;
      }
    case NGHTTP3_CTRL_STREAM_STATE_FRAME_LENGTH:
      assert(end - p > 0);
      nread = nghttp3_read_varint(rvint, p, (size_t)(end - p), 0);
      if (nread < 0)
      {
        return NGHTTP3_ERR_H3_FRAME_ERROR;
      }
      p += nread;
      nconsumed += (size_t)nread;
      if (rvint->left)
      {
        return (nghttp3_ssize)nconsumed;
      }
      rstate->left = rstate->fr.hd.length = rvint->acc;
      nghttp3_varint_read_state_reset(rvint);
      if (!(conn->flags & NGHTTP3_CONN_FLAG_SETTINGS_RECVED))
      {
        if (rstate->fr.hd.type != NGHTTP3_FRAME_SETTINGS)
        {
          return NGHTTP3_ERR_H3_MISSING_SETTINGS;
        }
        conn->flags |= NGHTTP3_CONN_FLAG_SETTINGS_RECVED;
      }
      else if (rstate->fr.hd.type == NGHTTP3_FRAME_SETTINGS)
      {
        return NGHTTP3_ERR_H3_FRAME_UNEXPECTED;
      }
      switch (rstate->fr.hd.type)
      {
      case NGHTTP3_FRAME_CANCEL_PUSH:
        if (rstate->left == 0)
        {
          return NGHTTP3_ERR_H3_FRAME_ERROR;
        }
        rstate->state = NGHTTP3_CTRL_STREAM_STATE_CANCEL_PUSH;
        break;
      case NGHTTP3_FRAME_SETTINGS:
        if (rstate->left == 0)
        {
          nghttp3_stream_read_state_reset(rstate);
          break;
        }
        rstate->state = NGHTTP3_CTRL_STREAM_STATE_SETTINGS;
        break;
      case NGHTTP3_FRAME_GOAWAY:
        if (rstate->left == 0)
        {
          return NGHTTP3_ERR_H3_FRAME_ERROR;
        }
        rstate->state = NGHTTP3_CTRL_STREAM_STATE_GOAWAY;
        break;
      case NGHTTP3_FRAME_MAX_PUSH_ID:
        if (!conn->server)
        {
          return NGHTTP3_ERR_H3_FRAME_UNEXPECTED;
        }
        if (rstate->left == 0)
        {
          return NGHTTP3_ERR_H3_FRAME_ERROR;
        }
        rstate->state = NGHTTP3_CTRL_STREAM_STATE_MAX_PUSH_ID;
        break;
      case NGHTTP3_FRAME_DATA:
      case NGHTTP3_FRAME_HEADERS:
      case NGHTTP3_FRAME_PUSH_PROMISE:
      case NGHTTP3_H2_FRAME_PRIORITY:
      case NGHTTP3_H2_FRAME_PING:
      case NGHTTP3_H2_FRAME_WINDOW_UPDATE:
      case NGHTTP3_H2_FRAME_CONTINUATION:
        return NGHTTP3_ERR_H3_FRAME_UNEXPECTED;
      default:
        busy = 1;
        rstate->state = NGHTTP3_CTRL_STREAM_STATE_IGN_FRAME;
        break;
      }
      break;
    case NGHTTP3_CTRL_STREAM_STATE_CANCEL_PUSH:
      len = (size_t)((rstate->left) < ((int64_t)(end - p)) ? (rstate->left) : ((int64_t)(end - p)));
      assert(len > 0);
      nread = nghttp3_read_varint(rvint, p, len, frame_fin(rstate, len));
      if (nread < 0)
      {
        return NGHTTP3_ERR_H3_FRAME_ERROR;
      }
      p += nread;
      nconsumed += (size_t)nread;
      rstate->left -= nread;
      if (rvint->left)
      {
        return (nghttp3_ssize)nconsumed;
      }
      rstate->fr.cancel_push.push_id = rvint->acc;
      nghttp3_varint_read_state_reset(rvint);
      if (conn->server)
      {
        rv = nghttp3_conn_on_server_cancel_push(conn, &rstate->fr.cancel_push);
      }
      else
      {
        rv = nghttp3_conn_on_client_cancel_push(conn, &rstate->fr.cancel_push);
      }
      if (rv != 0)
      {
        return rv;
      }
      nghttp3_stream_read_state_reset(rstate);
      break;
    case NGHTTP3_CTRL_STREAM_STATE_SETTINGS:
      for (; p != end;)
      {
        if (rstate->left == 0)
        {
          nghttp3_stream_read_state_reset(rstate);
          break;
        }
        len = (size_t)((rstate->left) < ((int64_t)(end - p)) ? (rstate->left) : ((int64_t)(end - p)));
        assert(len > 0);
        nread = nghttp3_read_varint(rvint, p, len, frame_fin(rstate, len));
        if (nread < 0)
        {
          return NGHTTP3_ERR_H3_FRAME_ERROR;
        }
        p += nread;
        nconsumed += (size_t)nread;
        rstate->left -= nread;
        if (rvint->left)
        {
          rstate->state = NGHTTP3_CTRL_STREAM_STATE_SETTINGS_ID;
          return (nghttp3_ssize)nconsumed;
        }
        rstate->fr.settings.iv[0].id = (uint64_t)rvint->acc;
        nghttp3_varint_read_state_reset(rvint);
        if (rstate->left == 0)
        {
          return NGHTTP3_ERR_H3_FRAME_ERROR;
        }
        len -= (size_t)nread;
        if (len == 0)
        {
          rstate->state = NGHTTP3_CTRL_STREAM_STATE_SETTINGS_VALUE;
          break;
        }
        nread = nghttp3_read_varint(rvint, p, len, frame_fin(rstate, len));
        if (nread < 0)
        {
          return NGHTTP3_ERR_H3_FRAME_ERROR;
        }
        p += nread;
        nconsumed += (size_t)nread;
        rstate->left -= nread;
        if (rvint->left)
        {
          rstate->state = NGHTTP3_CTRL_STREAM_STATE_SETTINGS_VALUE;
          return (nghttp3_ssize)nconsumed;
        }
        rstate->fr.settings.iv[0].value = (uint64_t)rvint->acc;
        nghttp3_varint_read_state_reset(rvint);
        rv =
            nghttp3_conn_on_settings_entry_received(conn, &rstate->fr.settings);
        if (rv != 0)
        {
          return rv;
        }
      }
      break;
    case NGHTTP3_CTRL_STREAM_STATE_SETTINGS_ID:
      len = (size_t)((rstate->left) < ((int64_t)(end - p)) ? (rstate->left) : ((int64_t)(end - p)));
      assert(len > 0);
      nread = nghttp3_read_varint(rvint, p, len, frame_fin(rstate, len));
      if (nread < 0)
      {
        return NGHTTP3_ERR_H3_FRAME_ERROR;
      }
      p += nread;
      nconsumed += (size_t)nread;
      rstate->left -= nread;
      if (rvint->left)
      {
        return (nghttp3_ssize)nconsumed;
      }
      rstate->fr.settings.iv[0].id = (uint64_t)rvint->acc;
      nghttp3_varint_read_state_reset(rvint);
      if (rstate->left == 0)
      {
        return NGHTTP3_ERR_H3_FRAME_ERROR;
      }
      rstate->state = NGHTTP3_CTRL_STREAM_STATE_SETTINGS_VALUE;
      if (p == end)
      {
        return (nghttp3_ssize)nconsumed;
      }
    case NGHTTP3_CTRL_STREAM_STATE_SETTINGS_VALUE:
      len = (size_t)((rstate->left) < ((int64_t)(end - p)) ? (rstate->left) : ((int64_t)(end - p)));
      assert(len > 0);
      nread = nghttp3_read_varint(rvint, p, len, frame_fin(rstate, len));
      if (nread < 0)
      {
        return NGHTTP3_ERR_H3_FRAME_ERROR;
      }
      p += nread;
      nconsumed += (size_t)nread;
      rstate->left -= nread;
      if (rvint->left)
      {
        return (nghttp3_ssize)nconsumed;
      }
      rstate->fr.settings.iv[0].value = (uint64_t)rvint->acc;
      nghttp3_varint_read_state_reset(rvint);
      rv = nghttp3_conn_on_settings_entry_received(conn, &rstate->fr.settings);
      if (rv != 0)
      {
        return rv;
      }
      if (rstate->left)
      {
        rstate->state = NGHTTP3_CTRL_STREAM_STATE_SETTINGS;
        break;
      }
      nghttp3_stream_read_state_reset(rstate);
      break;
    case NGHTTP3_CTRL_STREAM_STATE_GOAWAY:
      len = (size_t)((rstate->left) < ((int64_t)(end - p)) ? (rstate->left) : ((int64_t)(end - p)));
      assert(len > 0);
      nread = nghttp3_read_varint(rvint, p, len, frame_fin(rstate, len));
      if (nread < 0)
      {
        return NGHTTP3_ERR_H3_FRAME_ERROR;
      }
      p += nread;
      nconsumed += (size_t)nread;
      rstate->left -= nread;
      if (rvint->left)
      {
        return (nghttp3_ssize)nconsumed;
      }
      if (conn->server && !nghttp3_client_stream_bidi(rvint->acc))
      {
        return NGHTTP3_ERR_H3_ID_ERROR;
      }
      if (conn->rx.goaway_id < rvint->acc)
      {
        return NGHTTP3_ERR_H3_ID_ERROR;
      }
      conn->flags |= NGHTTP3_CONN_FLAG_GOAWAY_RECVED;
      conn->rx.goaway_id = rvint->acc;
      nghttp3_varint_read_state_reset(rvint);
      nghttp3_stream_read_state_reset(rstate);
      break;
    case NGHTTP3_CTRL_STREAM_STATE_MAX_PUSH_ID:
      len = (size_t)((rstate->left) < ((int64_t)(end - p)) ? (rstate->left) : ((int64_t)(end - p)));
      assert(len > 0);
      nread = nghttp3_read_varint(rvint, p, len, frame_fin(rstate, len));
      if (nread < 0)
      {
        return NGHTTP3_ERR_H3_FRAME_ERROR;
      }
      p += nread;
      nconsumed += (size_t)nread;
      rstate->left -= nread;
      if (rvint->left)
      {
        return (nghttp3_ssize)nconsumed;
      }
      if (conn->local.uni.max_pushes > (uint64_t)rvint->acc)
      {
        return NGHTTP3_ERR_H3_FRAME_ERROR;
      }
      conn->local.uni.max_pushes = (uint64_t)rvint->acc;
      nghttp3_varint_read_state_reset(rvint);
      nghttp3_stream_read_state_reset(rstate);
      break;
    case NGHTTP3_CTRL_STREAM_STATE_IGN_FRAME:
      len = (size_t)((rstate->left) < ((int64_t)(end - p)) ? (rstate->left) : ((int64_t)(end - p)));
      p += len;
      nconsumed += len;
      rstate->left -= (int64_t)len;
      if (rstate->left)
      {
        return (nghttp3_ssize)nconsumed;
      }
      nghttp3_stream_read_state_reset(rstate);
      break;
    default:
      assert(0);
    }
  }
  return (nghttp3_ssize)nconsumed;
}
nghttp3_ssize nghttp3_conn_read_push(nghttp3_conn *conn, size_t *pnproc,
                                     nghttp3_stream *stream, const uint8_t *src,
                                     size_t srclen, int fin)
{
  const uint8_t *p = src, *end = src ? src + srclen : src;
  int rv;
  nghttp3_stream_read_state *rstate = &stream->rstate;
  nghttp3_varint_read_state *rvint = &rstate->rvint;
  nghttp3_ssize nread;
  size_t nconsumed = 0;
  int busy = 0;
  size_t len;
  int64_t push_id;
  if (stream->flags & (NGHTTP3_STREAM_FLAG_QPACK_DECODE_BLOCKED |
                       NGHTTP3_STREAM_FLAG_PUSH_PROMISE_BLOCKED))
  {
    *pnproc = 0;
    if (srclen == 0)
    {
      return 0;
    }
    rv = nghttp3_stream_buffer_data(stream, p, (size_t)(end - p));
    if (rv != 0)
    {
      return rv;
    }
    return 0;
  }
  for (; p != end || busy;)
  {
    busy = 0;
    switch (rstate->state)
    {
    case NGHTTP3_PUSH_STREAM_STATE_PUSH_ID:
      assert(end - p > 0);
      nread = nghttp3_read_varint(rvint, p, (size_t)(end - p), fin);
      if (nread < 0)
      {
        return NGHTTP3_ERR_H3_GENERAL_PROTOCOL_ERROR;
      }
      p += nread;
      nconsumed += (size_t)nread;
      if (rvint->left)
      {
        goto almost_done;
      }
      push_id = rvint->acc;
      nghttp3_varint_read_state_reset(rvint);
      rv = nghttp3_conn_on_stream_push_id(conn, stream, push_id);
      if (rv != 0)
      {
        if (rv == NGHTTP3_ERR_IGNORE_STREAM)
        {
          rstate->state = NGHTTP3_PUSH_STREAM_STATE_IGN_REST;
          break;
        }
        return (nghttp3_ssize)rv;
      }
      rstate->state = NGHTTP3_PUSH_STREAM_STATE_FRAME_TYPE;
      if (stream->flags & NGHTTP3_STREAM_FLAG_PUSH_PROMISE_BLOCKED)
      {
        if (p != end)
        {
          rv = nghttp3_stream_buffer_data(stream, p, (size_t)(end - p));
          if (rv != 0)
          {
            return rv;
          }
        }
        *pnproc = (size_t)(p - src);
        return (nghttp3_ssize)nconsumed;
      }
      if (end == p)
      {
        goto almost_done;
      }
    case NGHTTP3_PUSH_STREAM_STATE_FRAME_TYPE:
      assert(end - p > 0);
      nread = nghttp3_read_varint(rvint, p, (size_t)(end - p), fin);
      if (nread < 0)
      {
        return NGHTTP3_ERR_H3_GENERAL_PROTOCOL_ERROR;
      }
      p += nread;
      nconsumed += (size_t)nread;
      if (rvint->left)
      {
        goto almost_done;
      }
      rstate->fr.hd.type = rvint->acc;
      nghttp3_varint_read_state_reset(rvint);
      rstate->state = NGHTTP3_PUSH_STREAM_STATE_FRAME_LENGTH;
      if (p == end)
      {
        goto almost_done;
      }
    case NGHTTP3_PUSH_STREAM_STATE_FRAME_LENGTH:
      assert(end - p > 0);
      nread = nghttp3_read_varint(rvint, p, (size_t)(end - p), fin);
      if (nread < 0)
      {
        return NGHTTP3_ERR_H3_FRAME_ERROR;
      }
      p += nread;
      nconsumed += (size_t)nread;
      if (rvint->left)
      {
        goto almost_done;
      }
      rstate->left = rstate->fr.hd.length = rvint->acc;
      nghttp3_varint_read_state_reset(rvint);
      switch (rstate->fr.hd.type)
      {
      case NGHTTP3_FRAME_DATA:
        rv = nghttp3_stream_transit_rx_http_state(
            stream, NGHTTP3_HTTP_EVENT_DATA_BEGIN);
        if (rv != 0)
        {
          return rv;
        }
        if (rstate->left == 0)
        {
          rv = nghttp3_stream_transit_rx_http_state(
              stream, NGHTTP3_HTTP_EVENT_DATA_END);
          assert(0 == rv);
          nghttp3_stream_read_state_reset(rstate);
          break;
        }
        rstate->state = NGHTTP3_PUSH_STREAM_STATE_DATA;
        break;
      case NGHTTP3_FRAME_HEADERS:
        rv = nghttp3_stream_transit_rx_http_state(
            stream, NGHTTP3_HTTP_EVENT_HEADERS_BEGIN);
        if (rv != 0)
        {
          return rv;
        }
        if (rstate->left == 0)
        {
          rv = nghttp3_stream_empty_headers_allowed(stream);
          if (rv != 0)
          {
            return rv;
          }
          rv = nghttp3_stream_transit_rx_http_state(
              stream, NGHTTP3_HTTP_EVENT_HEADERS_END);
          assert(0 == rv);
          nghttp3_stream_read_state_reset(rstate);
          break;
        }
        switch (stream->rx.hstate)
        {
        case NGHTTP3_HTTP_STATE_RESP_HEADERS_BEGIN:
          rv = conn_call_begin_headers(conn, stream);
          break;
        case NGHTTP3_HTTP_STATE_RESP_TRAILERS_BEGIN:
          rv = conn_call_begin_trailers(conn, stream);
          break;
        default:
          assert(0);
        }
        if (rv != 0)
        {
          return rv;
        }
        rstate->state = NGHTTP3_PUSH_STREAM_STATE_HEADERS;
        break;
      case NGHTTP3_FRAME_PUSH_PROMISE:
      case NGHTTP3_FRAME_CANCEL_PUSH:
      case NGHTTP3_FRAME_SETTINGS:
      case NGHTTP3_FRAME_GOAWAY:
      case NGHTTP3_FRAME_MAX_PUSH_ID:
      case NGHTTP3_H2_FRAME_PRIORITY:
      case NGHTTP3_H2_FRAME_PING:
      case NGHTTP3_H2_FRAME_WINDOW_UPDATE:
      case NGHTTP3_H2_FRAME_CONTINUATION:
        return NGHTTP3_ERR_H3_FRAME_UNEXPECTED;
      default:
        busy = 1;
        rstate->state = NGHTTP3_PUSH_STREAM_STATE_IGN_FRAME;
        break;
      }
      break;
    case NGHTTP3_PUSH_STREAM_STATE_DATA:
      len = (size_t)((rstate->left) < ((int64_t)(end - p)) ? (rstate->left) : ((int64_t)(end - p)));
      rv = nghttp3_conn_on_data(conn, stream, p, len);
      if (rv != 0)
      {
        return rv;
      }
      p += len;
      rstate->left -= (int64_t)len;
      if (rstate->left)
      {
        goto almost_done;
      }
      rv = nghttp3_stream_transit_rx_http_state(stream,
                                                NGHTTP3_HTTP_EVENT_DATA_END);
      assert(0 == rv);
      nghttp3_stream_read_state_reset(rstate);
      break;
    case NGHTTP3_PUSH_STREAM_STATE_HEADERS:
      len = (size_t)((rstate->left) < ((int64_t)(end - p)) ? (rstate->left) : ((int64_t)(end - p)));
      nread = nghttp3_conn_on_headers(conn, stream,
                                      __null, p, len,
                                      (int64_t)len == rstate->left);
      if (nread < 0)
      {
        return nread;
      }
      p += nread;
      nconsumed += (size_t)nread;
      rstate->left -= nread;
      if (stream->flags & NGHTTP3_STREAM_FLAG_QPACK_DECODE_BLOCKED)
      {
        if (p != end && nghttp3_stream_get_buffered_datalen(stream) == 0)
        {
          rv = nghttp3_stream_buffer_data(stream, p, (size_t)(end - p));
          if (rv != 0)
          {
            return rv;
          }
        }
        *pnproc = (size_t)(p - src);
        return (nghttp3_ssize)nconsumed;
      }
      if (rstate->left)
      {
        goto almost_done;
      }
      switch (stream->rx.hstate)
      {
      case NGHTTP3_HTTP_STATE_RESP_HEADERS_BEGIN:
        rv = nghttp3_http_on_response_headers(&stream->rx.http);
        if (rv != 0)
        {
          return rv;
        }
        rv = conn_call_end_headers(conn, stream);
        break;
      case NGHTTP3_HTTP_STATE_RESP_TRAILERS_BEGIN:
        rv = conn_call_end_trailers(conn, stream);
        break;
      default:
        assert(0);
      }
      if (rv != 0)
      {
        return rv;
      }
      rv = nghttp3_stream_transit_rx_http_state(stream,
                                                NGHTTP3_HTTP_EVENT_HEADERS_END);
      assert(0 == rv);
      nghttp3_stream_read_state_reset(rstate);
      break;
    case NGHTTP3_PUSH_STREAM_STATE_IGN_FRAME:
      len = (size_t)((rstate->left) < ((int64_t)(end - p)) ? (rstate->left) : ((int64_t)(end - p)));
      p += len;
      nconsumed += len;
      rstate->left -= (int64_t)len;
      if (rstate->left)
      {
        goto almost_done;
      }
      nghttp3_stream_read_state_reset(rstate);
      break;
    case NGHTTP3_PUSH_STREAM_STATE_IGN_REST:
      nconsumed += (size_t)(end - p);
      *pnproc = (size_t)(p - src);
      return (nghttp3_ssize)nconsumed;
    }
  }
almost_done:
  if (fin)
  {
    switch (rstate->state)
    {
    case NGHTTP3_PUSH_STREAM_STATE_FRAME_TYPE:
      if (rvint->left)
      {
        return NGHTTP3_ERR_H3_GENERAL_PROTOCOL_ERROR;
      }
      rv = nghttp3_stream_transit_rx_http_state(stream,
                                                NGHTTP3_HTTP_EVENT_MSG_END);
      if (rv != 0)
      {
        return rv;
      }
      break;
    case NGHTTP3_PUSH_STREAM_STATE_IGN_REST:
      break;
    default:
      return NGHTTP3_ERR_H3_FRAME_ERROR;
    }
  }
  *pnproc = (size_t)(p - src);
  return (nghttp3_ssize)nconsumed;
}
static void conn_delete_push_promise(nghttp3_conn *conn,
                                     nghttp3_push_promise *pp)
{
  int rv;
  rv = nghttp3_map_remove(&conn->pushes, (key_type)pp->node.nid.id);
  assert(0 == rv);
  if (!conn->server &&
      !(pp->flags & NGHTTP3_PUSH_PROMISE_FLAG_PUSH_ID_RECLAIMED))
  {
    ++conn->remote.uni.unsent_max_pushes;
  }
  nghttp3_push_promise_del(pp, conn->mem);
}
static int conn_delete_stream(nghttp3_conn *conn, nghttp3_stream *stream)
{
  int rv;
  if (nghttp3_stream_bidi_or_push(stream))
  {
    rv = nghttp3_http_on_remote_end_stream(stream);
    if (rv != 0)
    {
      return rv;
    }
  }
  rv = conn_call_deferred_consume(conn, stream,
                                  nghttp3_stream_get_buffered_datalen(stream));
  if (rv != 0)
  {
    return rv;
  }
  if (conn->callbacks.stream_close)
  {
    rv = conn->callbacks.stream_close(conn, stream->node.nid.id,
                                      stream->error_code, conn->user_data,
                                      stream->user_data);
    if (rv != 0)
    {
      return NGHTTP3_ERR_CALLBACK_FAILURE;
    }
  }
  rv = nghttp3_map_remove(&conn->streams, (key_type)stream->node.nid.id);
  assert(0 == rv);
  if (stream->pp)
  {
    assert(stream->type == NGHTTP3_STREAM_TYPE_PUSH);
    conn_delete_push_promise(conn, stream->pp);
  }
  nghttp3_stream_del(stream);
  return 0;
}
static int conn_process_blocked_stream_data(nghttp3_conn *conn,
                                            nghttp3_stream *stream)
{
  nghttp3_buf *buf;
  size_t nproc;
  nghttp3_ssize nconsumed;
  int rv;
  size_t len;
  for (;;)
  {
    len = ((&stream->inq)->len);
    if (len == 0)
    {
      break;
    }
    buf = nghttp3_ringbuf_get(&stream->inq, 0);
    if (nghttp3_stream_uni(stream->node.nid.id))
    {
      nconsumed = nghttp3_conn_read_push(
          conn, &nproc, stream, buf->pos, nghttp3_buf_len(buf),
          len == 1 && (stream->flags & NGHTTP3_STREAM_FLAG_READ_EOF));
    }
    else
    {
      nconsumed = nghttp3_conn_read_bidi(
          conn, &nproc, stream, buf->pos, nghttp3_buf_len(buf),
          len == 1 && (stream->flags & NGHTTP3_STREAM_FLAG_READ_EOF));
    }
    if (nconsumed < 0)
    {
      return (int)nconsumed;
    }
    buf->pos += nproc;
    rv = conn_call_deferred_consume(conn, stream, (size_t)nconsumed);
    if (rv != 0)
    {
      return 0;
    }
    if (nghttp3_buf_len(buf) == 0)
    {
      nghttp3_buf_free(buf, stream->mem);
      nghttp3_ringbuf_pop_front(&stream->inq);
    }
    if (stream->flags & NGHTTP3_STREAM_FLAG_QPACK_DECODE_BLOCKED)
    {
      break;
    }
  }
  if (!(stream->flags & NGHTTP3_STREAM_FLAG_QPACK_DECODE_BLOCKED) &&
      (stream->flags & NGHTTP3_STREAM_FLAG_CLOSED))
  {
    assert(stream->qpack_blocked_pe.index ==
           (18446744073709551615UL));
    rv = conn_delete_stream(conn, stream);
    if (rv != 0)
    {
      return rv;
    }
  }
  return 0;
}
nghttp3_ssize nghttp3_conn_read_qpack_encoder(nghttp3_conn *conn,
                                              const uint8_t *src,
                                              size_t srclen)
{
  nghttp3_ssize nconsumed =
      nghttp3_qpack_decoder_read_encoder(&conn->qdec, src, srclen);
  nghttp3_stream *stream;
  int rv;
  if (nconsumed < 0)
  {
    return nconsumed;
  }
  for (; !nghttp3_pq_empty(&conn->qpack_blocked_streams);)
  {
    stream = ((nghttp3_stream *)(void *)((char *)(nghttp3_pq_top(&conn->qpack_blocked_streams)) -
                                         __builtin_offsetof(
                                             nghttp3_stream,
                                             qpack_blocked_pe)));
    if (nghttp3_qpack_stream_context_get_ricnt(&stream->qpack_sctx) >
        nghttp3_qpack_decoder_get_icnt(&conn->qdec))
    {
      break;
    }
    nghttp3_conn_qpack_blocked_streams_pop(conn);
    stream->qpack_blocked_pe.index =
        (18446744073709551615UL);
    stream->flags &= (uint16_t)~NGHTTP3_STREAM_FLAG_QPACK_DECODE_BLOCKED;
    rv = conn_process_blocked_stream_data(conn, stream);
    if (rv != 0)
    {
      return rv;
    }
  }
  return nconsumed;
}
nghttp3_ssize nghttp3_conn_read_qpack_decoder(nghttp3_conn *conn,
                                              const uint8_t *src,
                                              size_t srclen)
{
  return nghttp3_qpack_encoder_read_decoder(&conn->qenc, src, srclen);
}
static int conn_update_stream_priority(nghttp3_conn *conn,
                                       nghttp3_stream *stream, uint8_t pri)
{
  if (stream->node.pri == pri)
  {
    return 0;
  }
  nghttp3_conn_unschedule_stream(conn, stream);
  stream->node.pri = pri;
  assert(nghttp3_stream_bidi_or_push(stream));
  if (nghttp3_stream_require_schedule(stream))
  {
    return nghttp3_conn_schedule_stream(conn, stream);
  }
  return 0;
}
nghttp3_ssize nghttp3_conn_read_bidi(nghttp3_conn *conn, size_t *pnproc,
                                     nghttp3_stream *stream, const uint8_t *src,
                                     size_t srclen, int fin)
{
  const uint8_t *p = src, *end = src ? src + srclen : src;
  int rv;
  nghttp3_stream_read_state *rstate = &stream->rstate;
  nghttp3_varint_read_state *rvint = &rstate->rvint;
  nghttp3_ssize nread;
  size_t nconsumed = 0;
  int busy = 0;
  size_t len;
  nghttp3_push_promise *pp;
  nghttp3_push_promise fake_pp = {{0}, {{0}, 0, {0}, 0, 0, 0}, {0}, __null, -1, 0};
  nghttp3_frame_entry frent;
  if (stream->flags & NGHTTP3_STREAM_FLAG_QPACK_DECODE_BLOCKED)
  {
    *pnproc = 0;
    if (srclen == 0)
    {
      return 0;
    }
    rv = nghttp3_stream_buffer_data(stream, p, (size_t)(end - p));
    if (rv != 0)
    {
      return rv;
    }
    return 0;
  }
  for (; p != end || busy;)
  {
    busy = 0;
    switch (rstate->state)
    {
    case NGHTTP3_REQ_STREAM_STATE_FRAME_TYPE:
      assert(end - p > 0);
      nread = nghttp3_read_varint(rvint, p, (size_t)(end - p), fin);
      if (nread < 0)
      {
        return NGHTTP3_ERR_H3_GENERAL_PROTOCOL_ERROR;
      }
      p += nread;
      nconsumed += (size_t)nread;
      if (rvint->left)
      {
        goto almost_done;
      }
      rstate->fr.hd.type = rvint->acc;
      nghttp3_varint_read_state_reset(rvint);
      rstate->state = NGHTTP3_REQ_STREAM_STATE_FRAME_LENGTH;
      if (p == end)
      {
        goto almost_done;
      }
    case NGHTTP3_REQ_STREAM_STATE_FRAME_LENGTH:
      assert(end - p > 0);
      nread = nghttp3_read_varint(rvint, p, (size_t)(end - p), fin);
      if (nread < 0)
      {
        return NGHTTP3_ERR_H3_FRAME_ERROR;
      }
      p += nread;
      nconsumed += (size_t)nread;
      if (rvint->left)
      {
        goto almost_done;
      }
      rstate->left = rstate->fr.hd.length = rvint->acc;
      nghttp3_varint_read_state_reset(rvint);
      switch (rstate->fr.hd.type)
      {
      case NGHTTP3_FRAME_DATA:
        rv = nghttp3_stream_transit_rx_http_state(
            stream, NGHTTP3_HTTP_EVENT_DATA_BEGIN);
        if (rv != 0)
        {
          return rv;
        }
        if (rstate->left == 0)
        {
          rv = nghttp3_stream_transit_rx_http_state(
              stream, NGHTTP3_HTTP_EVENT_DATA_END);
          assert(0 == rv);
          nghttp3_stream_read_state_reset(rstate);
          break;
        }
        rstate->state = NGHTTP3_REQ_STREAM_STATE_DATA;
        break;
      case NGHTTP3_FRAME_HEADERS:
        rv = nghttp3_stream_transit_rx_http_state(
            stream, NGHTTP3_HTTP_EVENT_HEADERS_BEGIN);
        if (rv != 0)
        {
          return rv;
        }
        if (rstate->left == 0)
        {
          rv = nghttp3_stream_empty_headers_allowed(stream);
          if (rv != 0)
          {
            return rv;
          }
          rv = nghttp3_stream_transit_rx_http_state(
              stream, NGHTTP3_HTTP_EVENT_HEADERS_END);
          assert(0 == rv);
          nghttp3_stream_read_state_reset(rstate);
          break;
        }
        switch (stream->rx.hstate)
        {
        case NGHTTP3_HTTP_STATE_REQ_HEADERS_BEGIN:
        case NGHTTP3_HTTP_STATE_RESP_HEADERS_BEGIN:
          rv = conn_call_begin_headers(conn, stream);
          break;
        case NGHTTP3_HTTP_STATE_REQ_TRAILERS_BEGIN:
        case NGHTTP3_HTTP_STATE_RESP_TRAILERS_BEGIN:
          rv = conn_call_begin_trailers(conn, stream);
          break;
        default:
          assert(0);
        }
        if (rv != 0)
        {
          return rv;
        }
        rstate->state = NGHTTP3_REQ_STREAM_STATE_HEADERS;
        break;
      case NGHTTP3_FRAME_PUSH_PROMISE:
        if (conn->server)
        {
          return NGHTTP3_ERR_H3_FRAME_UNEXPECTED;
        }
        if (rstate->left == 0)
        {
          return NGHTTP3_ERR_H3_FRAME_ERROR;
        }
        rstate->state = NGHTTP3_REQ_STREAM_STATE_PUSH_PROMISE_PUSH_ID;
        break;
      case NGHTTP3_FRAME_CANCEL_PUSH:
      case NGHTTP3_FRAME_SETTINGS:
      case NGHTTP3_FRAME_GOAWAY:
      case NGHTTP3_FRAME_MAX_PUSH_ID:
      case NGHTTP3_H2_FRAME_PRIORITY:
      case NGHTTP3_H2_FRAME_PING:
      case NGHTTP3_H2_FRAME_WINDOW_UPDATE:
      case NGHTTP3_H2_FRAME_CONTINUATION:
        return NGHTTP3_ERR_H3_FRAME_UNEXPECTED;
      default:
        busy = 1;
        rstate->state = NGHTTP3_REQ_STREAM_STATE_IGN_FRAME;
        break;
      }
      break;
    case NGHTTP3_REQ_STREAM_STATE_DATA:
      len = (size_t)((rstate->left) < ((int64_t)(end - p)) ? (rstate->left) : ((int64_t)(end - p)));
      rv = nghttp3_conn_on_data(conn, stream, p, len);
      if (rv != 0)
      {
        return rv;
      }
      p += len;
      rstate->left -= (int64_t)len;
      if (rstate->left)
      {
        goto almost_done;
      }
      rv = nghttp3_stream_transit_rx_http_state(stream,
                                                NGHTTP3_HTTP_EVENT_DATA_END);
      assert(0 == rv);
      nghttp3_stream_read_state_reset(rstate);
      break;
    case NGHTTP3_REQ_STREAM_STATE_PUSH_PROMISE_PUSH_ID:
      len = (size_t)((rstate->left) < ((int64_t)(end - p)) ? (rstate->left) : ((int64_t)(end - p)));
      nread = nghttp3_read_varint(rvint, p, (size_t)(end - p),
                                  (int64_t)len == rstate->left);
      if (nread < 0)
      {
        return NGHTTP3_ERR_H3_FRAME_ERROR;
      }
      p += nread;
      nconsumed += (size_t)nread;
      rstate->left -= nread;
      if (rvint->left)
      {
        goto almost_done;
      }
      rstate->fr.push_promise.push_id = rvint->acc;
      nghttp3_varint_read_state_reset(rvint);
      if (rstate->left == 0)
      {
        return NGHTTP3_ERR_H3_FRAME_ERROR;
      }
      rv = nghttp3_conn_on_push_promise_push_id(
          conn, rstate->fr.push_promise.push_id, stream);
      if (rv != 0)
      {
        if (rv == NGHTTP3_ERR_IGNORE_PUSH_PROMISE)
        {
          rstate->state = NGHTTP3_REQ_STREAM_STATE_IGN_PUSH_PROMISE;
          if (p == end)
          {
            goto almost_done;
          }
          break;
        }
        return rv;
      }
      rstate->state = NGHTTP3_REQ_STREAM_STATE_PUSH_PROMISE;
      if (p == end)
      {
        goto almost_done;
      }
    case NGHTTP3_REQ_STREAM_STATE_PUSH_PROMISE:
      pp =
          nghttp3_conn_find_push_promise(conn, rstate->fr.push_promise.push_id);
      assert(pp);
      len = (size_t)((rstate->left) < ((int64_t)(end - p)) ? (rstate->left) : ((int64_t)(end - p)));
      nread = nghttp3_conn_on_headers(conn, stream, pp, p, len,
                                      (int64_t)len == rstate->left);
      if (nread < 0)
      {
        return nread;
      }
      p += nread;
      nconsumed += (size_t)nread;
      rstate->left -= nread;
      if (stream->flags & NGHTTP3_STREAM_FLAG_QPACK_DECODE_BLOCKED)
      {
        if (p != end && nghttp3_stream_get_buffered_datalen(stream) == 0)
        {
          rv = nghttp3_stream_buffer_data(stream, p, (size_t)(end - p));
          if (rv != 0)
          {
            return rv;
          }
        }
        *pnproc = (size_t)(p - src);
        return (nghttp3_ssize)nconsumed;
      }
      if (rstate->left)
      {
        goto almost_done;
      }
      rv = nghttp3_http_on_request_headers(&pp->http);
      if (rv != 0)
      {
        return rv;
      }
      pp->flags |= NGHTTP3_PUSH_PROMISE_FLAG_RECVED;
      rv = conn_call_end_push_promise(conn, stream, pp->node.nid.id);
      if (rv != 0)
      {
        return rv;
      }
      pp =
          nghttp3_conn_find_push_promise(conn, rstate->fr.push_promise.push_id);
      if (!pp)
      {
        nghttp3_stream_read_state_reset(rstate);
        break;
      }
      if (!pp->stream && (pp->flags & NGHTTP3_PUSH_PROMISE_FLAG_CANCELLED))
      {
        if (pp->flags & NGHTTP3_PUSH_PROMISE_FLAG_RECV_CANCEL)
        {
          rv = conn_call_cancel_push(conn, pp->node.nid.id, pp->stream);
          if (rv != 0)
          {
            return rv;
          }
        }
        conn_delete_push_promise(conn, pp);
        nghttp3_stream_read_state_reset(rstate);
        break;
      }
      if (pp->stream)
      {
        ++conn->remote.uni.unsent_max_pushes;
        pp->flags |= NGHTTP3_PUSH_PROMISE_FLAG_PUSH_ID_RECLAIMED;
        if (!(pp->flags & NGHTTP3_PUSH_PROMISE_FLAG_SENT_CANCEL))
        {
          assert(pp->stream->flags & NGHTTP3_STREAM_FLAG_PUSH_PROMISE_BLOCKED);
          rv = conn_call_push_stream(conn, pp->node.nid.id, pp->stream);
          if (rv != 0)
          {
            return rv;
          }
          pp->stream->flags &=
              (uint16_t)~NGHTTP3_STREAM_FLAG_PUSH_PROMISE_BLOCKED;
          rv = conn_process_blocked_stream_data(conn, pp->stream);
          if (rv != 0)
          {
            return rv;
          }
        }
      }
      nghttp3_stream_read_state_reset(rstate);
      break;
    case NGHTTP3_REQ_STREAM_STATE_IGN_PUSH_PROMISE:
      len = (size_t)((rstate->left) < ((int64_t)(end - p)) ? (rstate->left) : ((int64_t)(end - p)));
      nread = nghttp3_conn_on_headers(conn, stream, &fake_pp, p, len,
                                      (int64_t)len == rstate->left);
      if (nread < 0)
      {
        return nread;
      }
      p += nread;
      nconsumed += (size_t)nread;
      rstate->left -= nread;
      if (stream->flags & NGHTTP3_STREAM_FLAG_QPACK_DECODE_BLOCKED)
      {
        if (p != end && nghttp3_stream_get_buffered_datalen(stream) == 0)
        {
          rv = nghttp3_stream_buffer_data(stream, p, (size_t)(end - p));
          if (rv != 0)
          {
            return rv;
          }
        }
        *pnproc = (size_t)(p - src);
        return (nghttp3_ssize)nconsumed;
      }
      if (rstate->left)
      {
        goto almost_done;
      }
      pp =
          nghttp3_conn_find_push_promise(conn, rstate->fr.push_promise.push_id);
      if (pp)
      {
        pp->flags |= NGHTTP3_PUSH_PROMISE_FLAG_RECVED;
        if ((conn->flags & NGHTTP3_CONN_FLAG_GOAWAY_QUEUED) &&
            conn->tx.goaway_id <= pp->node.nid.id)
        {
          if (pp->stream)
          {
            rv = nghttp3_conn_reject_push_stream(conn, pp->stream);
            if (rv != 0)
            {
              return rv;
            }
          }
          else
          {
            frent.fr.hd.type = NGHTTP3_FRAME_CANCEL_PUSH;
            frent.fr.cancel_push.push_id = pp->node.nid.id;
            rv = nghttp3_stream_frq_add(conn->tx.ctrl, &frent);
            if (rv != 0)
            {
              return rv;
            }
            conn_delete_push_promise(conn, pp);
          }
        }
      }
      nghttp3_stream_read_state_reset(rstate);
      break;
    case NGHTTP3_REQ_STREAM_STATE_HEADERS:
      len = (size_t)((rstate->left) < ((int64_t)(end - p)) ? (rstate->left) : ((int64_t)(end - p)));
      nread = nghttp3_conn_on_headers(conn, stream,
                                      __null, p, len,
                                      (int64_t)len == rstate->left);
      if (nread < 0)
      {
        return nread;
      }
      p += nread;
      nconsumed += (size_t)nread;
      rstate->left -= nread;
      if (stream->flags & NGHTTP3_STREAM_FLAG_QPACK_DECODE_BLOCKED)
      {
        if (p != end && nghttp3_stream_get_buffered_datalen(stream) == 0)
        {
          rv = nghttp3_stream_buffer_data(stream, p, (size_t)(end - p));
          if (rv != 0)
          {
            return rv;
          }
        }
        *pnproc = (size_t)(p - src);
        return (nghttp3_ssize)nconsumed;
      }
      if (rstate->left)
      {
        goto almost_done;
      }
      switch (stream->rx.hstate)
      {
      case NGHTTP3_HTTP_STATE_REQ_HEADERS_BEGIN:
        rv = nghttp3_http_on_request_headers(&stream->rx.http);
        break;
      case NGHTTP3_HTTP_STATE_RESP_HEADERS_BEGIN:
        rv = nghttp3_http_on_response_headers(&stream->rx.http);
        break;
      case NGHTTP3_HTTP_STATE_REQ_TRAILERS_BEGIN:
      case NGHTTP3_HTTP_STATE_RESP_TRAILERS_BEGIN:
        rv = 0;
        break;
      default:
        assert(0);
      }
      if (rv != 0)
      {
        return rv;
      }
      switch (stream->rx.hstate)
      {
      case NGHTTP3_HTTP_STATE_REQ_HEADERS_BEGIN:
        if (conn->server)
        {
          rv = conn_update_stream_priority(conn, stream, stream->rx.http.pri);
          if (rv != 0)
          {
            return rv;
          }
        }
      case NGHTTP3_HTTP_STATE_RESP_HEADERS_BEGIN:
        rv = conn_call_end_headers(conn, stream);
        break;
      case NGHTTP3_HTTP_STATE_REQ_TRAILERS_BEGIN:
      case NGHTTP3_HTTP_STATE_RESP_TRAILERS_BEGIN:
        rv = conn_call_end_trailers(conn, stream);
        break;
      default:
        assert(0);
      }
      if (rv != 0)
      {
        return rv;
      }
      rv = nghttp3_stream_transit_rx_http_state(stream,
                                                NGHTTP3_HTTP_EVENT_HEADERS_END);
      assert(0 == rv);
      nghttp3_stream_read_state_reset(rstate);
      break;
    case NGHTTP3_REQ_STREAM_STATE_IGN_FRAME:
      len = (size_t)((rstate->left) < ((int64_t)(end - p)) ? (rstate->left) : ((int64_t)(end - p)));
      p += len;
      nconsumed += len;
      rstate->left -= (int64_t)len;
      if (rstate->left)
      {
        goto almost_done;
      }
      nghttp3_stream_read_state_reset(rstate);
      break;
    case NGHTTP3_REQ_STREAM_STATE_IGN_REST:
      nconsumed += (size_t)(end - p);
      *pnproc = (size_t)(p - src);
      return (nghttp3_ssize)nconsumed;
    }
  }
almost_done:
  if (fin)
  {
    switch (rstate->state)
    {
    case NGHTTP3_REQ_STREAM_STATE_FRAME_TYPE:
      if (rvint->left)
      {
        return NGHTTP3_ERR_H3_GENERAL_PROTOCOL_ERROR;
      }
      rv = nghttp3_stream_transit_rx_http_state(stream,
                                                NGHTTP3_HTTP_EVENT_MSG_END);
      if (rv != 0)
      {
        return rv;
      }
      rv = conn_call_end_stream(conn, stream);
      if (rv != 0)
      {
        return rv;
      }
      break;
    case NGHTTP3_REQ_STREAM_STATE_IGN_REST:
      break;
    default:
      return NGHTTP3_ERR_H3_FRAME_ERROR;
    }
  }
  *pnproc = (size_t)(p - src);
  return (nghttp3_ssize)nconsumed;
}
int nghttp3_conn_on_data(nghttp3_conn *conn, nghttp3_stream *stream,
                         const uint8_t *data, size_t datalen)
{
  int rv;
  rv = nghttp3_http_on_data_chunk(stream, datalen);
  if (rv != 0)
  {
    return rv;
  }
  if (!conn->callbacks.recv_data)
  {
    return 0;
  }
  rv = conn->callbacks.recv_data(conn, stream->node.nid.id, data, datalen,
                                 conn->user_data, stream->user_data);
  if (rv != 0)
  {
    return NGHTTP3_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
int nghttp3_conn_on_push_promise_push_id(nghttp3_conn *conn, int64_t push_id,
                                         nghttp3_stream *stream)
{
  int rv;
  nghttp3_gaptr *push_idtr = &conn->remote.uni.push_idtr;
  nghttp3_push_promise *pp;
  if (conn->remote.uni.max_pushes <= (uint64_t)push_id)
  {
    return NGHTTP3_ERR_H3_ID_ERROR;
  }
  pp = nghttp3_conn_find_push_promise(conn, push_id);
  if (pp)
  {
    if ((pp->flags & NGHTTP3_PUSH_PROMISE_FLAG_BOUND) ||
        (pp->stream_id != -1 && pp->stream_id != stream->node.nid.id))
    {
      return NGHTTP3_ERR_IGNORE_PUSH_PROMISE;
    }
    if (pp->stream)
    {
      assert(pp->stream->flags & NGHTTP3_STREAM_FLAG_PUSH_PROMISE_BLOCKED);
    }
    else if (pp->flags & NGHTTP3_PUSH_PROMISE_FLAG_CANCELLED)
    {
    }
    else
    {
      return NGHTTP3_ERR_H3_FRAME_ERROR;
    }
    assert(pp->stream_id == -1);
    pp->stream_id = stream->node.nid.id;
    pp->flags |= NGHTTP3_PUSH_PROMISE_FLAG_BOUND;
  }
  else if (nghttp3_gaptr_is_pushed(push_idtr, (uint64_t)push_id, 1))
  {
    return NGHTTP3_ERR_IGNORE_PUSH_PROMISE;
  }
  else
  {
    rv = nghttp3_gaptr_push(push_idtr, (uint64_t)push_id, 1);
    if (rv != 0)
    {
      return rv;
    }
    rv = nghttp3_conn_create_push_promise(conn, &pp, push_id, &stream->node);
    if (rv != 0)
    {
      return rv;
    }
  }
  conn->rx.max_push_id = ((conn->rx.max_push_id) > (push_id) ? (conn->rx.max_push_id) : (push_id));
  if ((conn->flags & NGHTTP3_CONN_FLAG_GOAWAY_QUEUED) &&
      conn->tx.goaway_id <= push_id)
  {
    return NGHTTP3_ERR_IGNORE_PUSH_PROMISE;
  }
  rv = conn_call_begin_push_promise(conn, stream, push_id);
  if (rv != 0)
  {
    return rv;
  }
  return 0;
}
int nghttp3_conn_on_client_cancel_push(nghttp3_conn *conn,
                                       const nghttp3_frame_cancel_push *fr)
{
  nghttp3_push_promise *pp;
  nghttp3_gaptr *push_idtr = &conn->remote.uni.push_idtr;
  int rv;
  if (conn->remote.uni.max_pushes <= (uint64_t)fr->push_id)
  {
    return NGHTTP3_ERR_H3_ID_ERROR;
  }
  pp = nghttp3_conn_find_push_promise(conn, fr->push_id);
  if (pp ==
      __null)
  {
    if (nghttp3_gaptr_is_pushed(push_idtr, (uint64_t)fr->push_id, 1))
    {
      return 0;
    }
    rv = nghttp3_gaptr_push(push_idtr, (uint64_t)fr->push_id, 1);
    if (rv != 0)
    {
      return rv;
    }
    conn->rx.max_push_id = ((conn->rx.max_push_id) > (fr->push_id) ? (conn->rx.max_push_id) : (fr->push_id));
    rv = nghttp3_conn_create_push_promise(conn, &pp, fr->push_id,
                                          __null);
    if (rv != 0)
    {
      return rv;
    }
    pp->flags |= NGHTTP3_PUSH_PROMISE_FLAG_RECV_CANCEL;
    return 0;
  }
  if (pp->stream)
  {
    return 0;
  }
  if (pp->flags & NGHTTP3_PUSH_PROMISE_FLAG_RECVED)
  {
    rv = conn_call_cancel_push(conn, pp->node.nid.id, pp->stream);
    if (rv != 0)
    {
      return rv;
    }
    conn_delete_push_promise(conn, pp);
    return 0;
  }
  pp->flags |= NGHTTP3_PUSH_PROMISE_FLAG_RECV_CANCEL;
  return 0;
}
static nghttp3_pq *conn_get_sched_pq(nghttp3_conn *conn, nghttp3_tnode *tnode)
{
  uint32_t urgency = ((uint32_t)((tnode->pri) & ~(1 << 7)));
  assert(urgency < (7 + 1));
  return &conn->sched[urgency].spq;
}
int nghttp3_conn_on_server_cancel_push(nghttp3_conn *conn,
                                       const nghttp3_frame_cancel_push *fr)
{
  nghttp3_push_promise *pp;
  nghttp3_stream *stream;
  int rv;
  if (conn->local.uni.next_push_id <= fr->push_id)
  {
    return NGHTTP3_ERR_H3_ID_ERROR;
  }
  pp = nghttp3_conn_find_push_promise(conn, fr->push_id);
  if (pp ==
      __null)
  {
    return 0;
  }
  stream = pp->stream;
  rv = conn_call_cancel_push(conn, fr->push_id, stream);
  if (rv != 0)
  {
    return rv;
  }
  if (stream)
  {
    rv = nghttp3_conn_close_stream(conn, stream->node.nid.id,
                                   0x010c);
    if (rv != 0)
    {
      assert(NGHTTP3_ERR_STREAM_NOT_FOUND != rv);
      return rv;
    }
    return 0;
  }
  nghttp3_tnode_unschedule(&pp->node, conn_get_sched_pq(conn, &pp->node));
  conn_delete_push_promise(conn, pp);
  return 0;
}
int nghttp3_conn_on_stream_push_id(nghttp3_conn *conn, nghttp3_stream *stream,
                                   int64_t push_id)
{
  nghttp3_push_promise *pp;
  int rv;
  if (nghttp3_gaptr_is_pushed(&conn->remote.uni.push_idtr, (uint64_t)push_id,
                              1))
  {
    pp = nghttp3_conn_find_push_promise(conn, push_id);
    if (pp)
    {
      if (pp->stream)
      {
        return NGHTTP3_ERR_H3_ID_ERROR;
      }
      pp->stream = stream;
      stream->pp = pp;
      if (pp->flags & NGHTTP3_PUSH_PROMISE_FLAG_SENT_CANCEL)
      {
        rv = nghttp3_conn_cancel_push_stream(conn, stream);
        if (rv != 0)
        {
          return rv;
        }
        return NGHTTP3_ERR_IGNORE_STREAM;
      }
      if ((conn->flags & NGHTTP3_CONN_FLAG_GOAWAY_QUEUED) &&
          conn->tx.goaway_id <= push_id)
      {
        rv = nghttp3_conn_reject_push_stream(conn, stream);
        if (rv != 0)
        {
          return rv;
        }
        return NGHTTP3_ERR_IGNORE_STREAM;
      }
      if (pp->flags & NGHTTP3_PUSH_PROMISE_FLAG_RECVED)
      {
        ++conn->remote.uni.unsent_max_pushes;
        pp->flags |= NGHTTP3_PUSH_PROMISE_FLAG_PUSH_ID_RECLAIMED;
        return conn_call_push_stream(conn, push_id, stream);
      }
      stream->flags |= NGHTTP3_STREAM_FLAG_PUSH_PROMISE_BLOCKED;
      return 0;
    }
    rv = nghttp3_conn_cancel_push_stream(conn, stream);
    if (rv != 0)
    {
      return rv;
    }
    return NGHTTP3_ERR_IGNORE_STREAM;
  }
  if (conn->remote.uni.max_pushes <= (uint64_t)push_id)
  {
    return NGHTTP3_ERR_H3_ID_ERROR;
  }
  rv = nghttp3_gaptr_push(&conn->remote.uni.push_idtr, (uint64_t)push_id, 1);
  if (rv != 0)
  {
    return rv;
  }
  rv = nghttp3_conn_create_push_promise(conn, &pp, push_id,
                                        __null);
  if (rv != 0)
  {
    return rv;
  }
  pp->stream = stream;
  stream->pp = pp;
  stream->flags |= NGHTTP3_STREAM_FLAG_PUSH_PROMISE_BLOCKED;
  return 0;
}
static nghttp3_ssize conn_decode_headers(nghttp3_conn *conn,
                                         nghttp3_stream *stream,
                                         nghttp3_push_promise *pp,
                                         const uint8_t *src, size_t srclen,
                                         int fin)
{
  nghttp3_ssize nread;
  int rv;
  nghttp3_qpack_decoder *qdec = &conn->qdec;
  nghttp3_qpack_nv nv;
  uint8_t flags;
  nghttp3_buf buf;
  nghttp3_recv_header recv_header =
      __null;
  nghttp3_http_state *http;
  int request = 0;
  int trailers = 0;
  int ignore_pp = 0;
  if (pp)
  {
    request = 1;
    ignore_pp = pp->stream_id != stream->node.nid.id;
    if (ignore_pp)
    {
      http =
          __null;
    }
    else
    {
      http = &pp->http;
    }
  }
  else
  {
    switch (stream->rx.hstate)
    {
    case NGHTTP3_HTTP_STATE_REQ_HEADERS_BEGIN:
      request = 1;
    case NGHTTP3_HTTP_STATE_RESP_HEADERS_BEGIN:
      recv_header = conn->callbacks.recv_header;
      break;
    case NGHTTP3_HTTP_STATE_REQ_TRAILERS_BEGIN:
      request = 1;
    case NGHTTP3_HTTP_STATE_RESP_TRAILERS_BEGIN:
      trailers = 1;
      recv_header = conn->callbacks.recv_trailer;
      break;
    default:
      assert(0);
    }
    http = &stream->rx.http;
  }
  nghttp3_buf_wrap_init(&buf, (uint8_t *)src, srclen);
  buf.last = buf.end;
  for (;;)
  {
    nread = nghttp3_qpack_decoder_read_request(qdec, &stream->qpack_sctx, &nv,
                                               &flags, buf.pos,
                                               nghttp3_buf_len(&buf), fin);
    if (nread < 0)
    {
      return (int)nread;
    }
    buf.pos += nread;
    if (flags & NGHTTP3_QPACK_DECODE_FLAG_BLOCKED)
    {
      if (conn->local.settings.qpack_blocked_streams <=
          nghttp3_pq_size(&conn->qpack_blocked_streams))
      {
        return NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED;
      }
      stream->flags |= NGHTTP3_STREAM_FLAG_QPACK_DECODE_BLOCKED;
      rv = nghttp3_conn_qpack_blocked_streams_push(conn, stream);
      if (rv != 0)
      {
        return rv;
      }
      break;
    }
    if (flags & NGHTTP3_QPACK_DECODE_FLAG_FINAL)
    {
      nghttp3_qpack_stream_context_reset(&stream->qpack_sctx);
      break;
    }
    if (nread == 0)
    {
      break;
    }
    if (flags & NGHTTP3_QPACK_DECODE_FLAG_EMIT)
    {
      if (ignore_pp)
      {
        nghttp3_rcbuf_decref(nv.name);
        nghttp3_rcbuf_decref(nv.value);
        continue;
      }
      assert(http);
      rv = nghttp3_http_on_header(http, stream->rstate.fr.hd.type, &nv, request,
                                  trailers);
      switch (rv)
      {
      case NGHTTP3_ERR_MALFORMED_HTTP_HEADER:
        break;
      case NGHTTP3_ERR_REMOVE_HTTP_HEADER:
        rv = 0;
        break;
      case 0:
        if (pp)
        {
          if (conn->callbacks.recv_push_promise)
          {
            rv = conn->callbacks.recv_push_promise(
                conn, stream->node.nid.id, pp->node.nid.id, nv.token, nv.name,
                nv.value, nv.flags, conn->user_data, stream->user_data);
          }
          break;
        }
        if (recv_header)
        {
          rv = recv_header(conn, stream->node.nid.id, nv.token, nv.name,
                           nv.value, nv.flags, conn->user_data,
                           stream->user_data);
        }
        break;
      default:
        assert(0);
      }
      nghttp3_rcbuf_decref(nv.name);
      nghttp3_rcbuf_decref(nv.value);
      if (rv != 0)
      {
        return rv;
      }
    }
  }
  return buf.pos - src;
}
nghttp3_ssize nghttp3_conn_on_headers(nghttp3_conn *conn,
                                      nghttp3_stream *stream,
                                      nghttp3_push_promise *pp,
                                      const uint8_t *src, size_t srclen,
                                      int fin)
{
  if (srclen == 0 && !fin)
  {
    return 0;
  }
  return conn_decode_headers(conn, stream, pp, src, srclen, fin);
}
int nghttp3_conn_on_settings_entry_received(nghttp3_conn *conn,
                                            const nghttp3_frame_settings *fr)
{
  const nghttp3_settings_entry *ent = &fr->iv[0];
  nghttp3_conn_settings *dest = &conn->remote.settings;
  int rv;
  size_t max_table_capacity =
      (18446744073709551615UL);
  size_t max_blocked_streams =
      (18446744073709551615UL);
  switch (ent->id)
  {
  case 0x06:
    dest->max_field_section_size = ent->value;
    break;
  case 0x01:
    dest->qpack_max_table_capacity = (size_t)ent->value;
    max_table_capacity =
        ((max_table_capacity) < (dest->qpack_max_table_capacity) ? (max_table_capacity) : (dest->qpack_max_table_capacity));
    rv = nghttp3_qpack_encoder_set_hard_max_dtable_size(&conn->qenc,
                                                        max_table_capacity);
    if (rv != 0)
    {
      return rv;
    }
    rv = nghttp3_qpack_encoder_set_max_dtable_size(&conn->qenc,
                                                   max_table_capacity);
    if (rv != 0)
    {
      return rv;
    }
    break;
  case 0x07:
    dest->qpack_blocked_streams = (size_t)ent->value;
    max_blocked_streams =
        ((max_blocked_streams) < (dest->qpack_blocked_streams) ? (max_blocked_streams) : (dest->qpack_blocked_streams));
    rv =
        nghttp3_qpack_encoder_set_max_blocked(&conn->qenc, max_blocked_streams);
    if (rv != 0)
    {
      return rv;
    }
    break;
  case 0x2:
  case 0x3:
  case 0x4:
  case 0x5:
    return NGHTTP3_ERR_H3_SETTINGS_ERROR;
  default:
    break;
  }
  return 0;
}
static int conn_stream_acked_data(nghttp3_stream *stream, int64_t stream_id,
                                  size_t datalen, void *user_data)
{
  nghttp3_conn *conn = stream->conn;
  int rv;
  if (!conn->callbacks.acked_stream_data)
  {
    return 0;
  }
  rv = conn->callbacks.acked_stream_data(conn, stream_id, datalen,
                                         conn->user_data, user_data);
  if (rv != 0)
  {
    return NGHTTP3_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
int nghttp3_conn_create_stream(nghttp3_conn *conn, nghttp3_stream **pstream,
                               int64_t stream_id)
{
  nghttp3_stream *stream;
  int rv;
  nghttp3_stream_callbacks callbacks = {
      conn_stream_acked_data,
  };
  rv = nghttp3_stream_new(&stream, stream_id, conn->next_seq, &callbacks,
                          conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  stream->conn = conn;
  rv = nghttp3_map_insert(&conn->streams, &stream->me);
  if (rv != 0)
  {
    nghttp3_stream_del(stream);
    return rv;
  }
  ++conn->next_seq;
  *pstream = stream;
  return 0;
}
int nghttp3_conn_create_push_promise(nghttp3_conn *conn,
                                     nghttp3_push_promise **ppp,
                                     int64_t push_id,
                                     nghttp3_tnode *assoc_tnode)
{
  nghttp3_push_promise *pp;
  int rv;
  rv = nghttp3_push_promise_new(&pp, push_id, conn->next_seq, assoc_tnode,
                                conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  rv = nghttp3_map_insert(&conn->pushes, &pp->me);
  if (rv != 0)
  {
    nghttp3_push_promise_del(pp, conn->mem);
    return rv;
  }
  ++conn->next_seq;
  *ppp = pp;
  return 0;
}
nghttp3_stream *nghttp3_conn_find_stream(nghttp3_conn *conn,
                                         int64_t stream_id)
{
  nghttp3_map_entry *me;
  me = nghttp3_map_find(&conn->streams, (key_type)stream_id);
  if (me ==
      __null)
  {
    return __null;
  }
  return ((nghttp3_stream *)(void *)((char *)(me) -
                                     __builtin_offsetof(
                                         nghttp3_stream,
                                         me)));
}
nghttp3_push_promise *nghttp3_conn_find_push_promise(nghttp3_conn *conn,
                                                     int64_t push_id)
{
  nghttp3_map_entry *me;
  me = nghttp3_map_find(&conn->pushes, (key_type)push_id);
  if (me ==
      __null)
  {
    return __null;
  }
  return ((nghttp3_push_promise *)(void *)((char *)(me) -
                                           __builtin_offsetof(
                                               nghttp3_push_promise,
                                               me)));
}
int nghttp3_conn_bind_control_stream(nghttp3_conn *conn, int64_t stream_id)
{
  nghttp3_stream *stream;
  nghttp3_frame_entry frent;
  int rv;
  assert(!conn->server || nghttp3_server_stream_uni(stream_id));
  assert(conn->server || nghttp3_client_stream_uni(stream_id));
  if (conn->tx.ctrl)
  {
    return NGHTTP3_ERR_INVALID_STATE;
  }
  rv = nghttp3_conn_create_stream(conn, &stream, stream_id);
  if (rv != 0)
  {
    return rv;
  }
  stream->type = NGHTTP3_STREAM_TYPE_CONTROL;
  conn->tx.ctrl = stream;
  rv = nghttp3_stream_write_stream_type(stream);
  if (rv != 0)
  {
    return rv;
  }
  frent.fr.hd.type = NGHTTP3_FRAME_SETTINGS;
  frent.aux.settings.local_settings = &conn->local.settings;
  return nghttp3_stream_frq_add(stream, &frent);
}
int nghttp3_conn_bind_qpack_streams(nghttp3_conn *conn, int64_t qenc_stream_id,
                                    int64_t qdec_stream_id)
{
  nghttp3_stream *stream;
  int rv;
  assert(!conn->server || nghttp3_server_stream_uni(qenc_stream_id));
  assert(!conn->server || nghttp3_server_stream_uni(qdec_stream_id));
  assert(conn->server || nghttp3_client_stream_uni(qenc_stream_id));
  assert(conn->server || nghttp3_client_stream_uni(qdec_stream_id));
  if (conn->tx.qenc || conn->tx.qdec)
  {
    return NGHTTP3_ERR_INVALID_STATE;
  }
  rv = nghttp3_conn_create_stream(conn, &stream, qenc_stream_id);
  if (rv != 0)
  {
    return rv;
  }
  stream->type = NGHTTP3_STREAM_TYPE_QPACK_ENCODER;
  conn->tx.qenc = stream;
  rv = nghttp3_stream_write_stream_type(stream);
  if (rv != 0)
  {
    return rv;
  }
  rv = nghttp3_conn_create_stream(conn, &stream, qdec_stream_id);
  if (rv != 0)
  {
    return rv;
  }
  stream->type = NGHTTP3_STREAM_TYPE_QPACK_DECODER;
  conn->tx.qdec = stream;
  return nghttp3_stream_write_stream_type(stream);
}
static nghttp3_ssize conn_writev_stream(nghttp3_conn *conn, int64_t *pstream_id,
                                        int *pfin, nghttp3_vec *vec,
                                        size_t veccnt, nghttp3_stream *stream)
{
  int rv;
  nghttp3_ssize n;
  assert(veccnt > 0);
  if (!(stream->flags & NGHTTP3_STREAM_FLAG_READ_DATA_BLOCKED))
  {
    rv = nghttp3_stream_fill_outq(stream);
    if (rv != 0)
    {
      return rv;
    }
  }
  if (!nghttp3_stream_uni(stream->node.nid.id) && conn->tx.qenc &&
      !nghttp3_stream_is_blocked(conn->tx.qenc))
  {
    n = nghttp3_stream_writev(conn->tx.qenc, pfin, vec, veccnt);
    if (n < 0)
    {
      return n;
    }
    if (n)
    {
      *pstream_id = conn->tx.qenc->node.nid.id;
      return n;
    }
  }
  n = nghttp3_stream_writev(stream, pfin, vec, veccnt);
  if (n < 0)
  {
    return n;
  }
  if (n == 0 && *pfin == 0)
  {
    return 0;
  }
  *pstream_id = stream->node.nid.id;
  return n;
}
nghttp3_ssize nghttp3_conn_writev_stream(nghttp3_conn *conn,
                                         int64_t *pstream_id, int *pfin,
                                         nghttp3_vec *vec, size_t veccnt)
{
  nghttp3_ssize ncnt;
  nghttp3_stream *stream;
  int rv;
  *pstream_id = -1;
  *pfin = 0;
  if (veccnt == 0)
  {
    return 0;
  }
  if (conn->tx.ctrl && !nghttp3_stream_is_blocked(conn->tx.ctrl))
  {
    if (!(conn->flags & NGHTTP3_CONN_FLAG_MAX_PUSH_ID_QUEUED) &&
        !(conn->flags & NGHTTP3_CONN_FLAG_GOAWAY_QUEUED) &&
        conn->remote.uni.unsent_max_pushes > conn->remote.uni.max_pushes)
    {
      rv = nghttp3_conn_submit_max_push_id(conn);
      if (rv != 0)
      {
        return rv;
      }
    }
    ncnt =
        conn_writev_stream(conn, pstream_id, pfin, vec, veccnt, conn->tx.ctrl);
    if (ncnt)
    {
      return ncnt;
    }
  }
  if (conn->tx.qdec && !nghttp3_stream_is_blocked(conn->tx.qdec))
  {
    rv = nghttp3_stream_write_qpack_decoder_stream(conn->tx.qdec);
    if (rv != 0)
    {
      return rv;
    }
    ncnt =
        conn_writev_stream(conn, pstream_id, pfin, vec, veccnt, conn->tx.qdec);
    if (ncnt)
    {
      return ncnt;
    }
  }
  if (conn->tx.qenc && !nghttp3_stream_is_blocked(conn->tx.qenc))
  {
    ncnt =
        conn_writev_stream(conn, pstream_id, pfin, vec, veccnt, conn->tx.qenc);
    if (ncnt)
    {
      return ncnt;
    }
  }
  stream = nghttp3_conn_get_next_tx_stream(conn);
  if (stream ==
      __null)
  {
    return 0;
  }
  ncnt = conn_writev_stream(conn, pstream_id, pfin, vec, veccnt, stream);
  if (ncnt < 0)
  {
    return ncnt;
  }
  if (nghttp3_stream_bidi_or_push(stream) &&
      !nghttp3_stream_require_schedule(stream))
  {
    nghttp3_conn_unschedule_stream(conn, stream);
  }
  return ncnt;
}
nghttp3_stream *nghttp3_conn_get_next_tx_stream(nghttp3_conn *conn)
{
  size_t i;
  nghttp3_tnode *tnode;
  nghttp3_pq *pq;
  for (i = 0; i < (7 + 1); ++i)
  {
    pq = &conn->sched[i].spq;
    if (nghttp3_pq_empty(pq))
    {
      continue;
    }
    tnode = ((nghttp3_tnode *)(void *)((char *)(nghttp3_pq_top(pq)) -
                                       __builtin_offsetof(
                                           nghttp3_tnode,
                                           pe)));
    if (tnode->nid.type == NGHTTP3_NODE_ID_TYPE_PUSH)
    {
      return ((nghttp3_push_promise *)(void *)((char *)(tnode) -
                                               __builtin_offsetof(
                                                   nghttp3_push_promise,
                                                   node)))
          ->stream;
    }
    return ((nghttp3_stream *)(void *)((char *)(tnode) -
                                       __builtin_offsetof(
                                           nghttp3_stream,
                                           node)));
  }
  return __null;
}
int nghttp3_conn_add_write_offset(nghttp3_conn *conn, int64_t stream_id,
                                  size_t n)
{
  nghttp3_stream *stream = nghttp3_conn_find_stream(conn, stream_id);
  int rv;
  if (stream ==
      __null)
  {
    return NGHTTP3_ERR_STREAM_NOT_FOUND;
  }
  rv = nghttp3_stream_add_outq_offset(stream, n);
  if (rv != 0)
  {
    return rv;
  }
  stream->unscheduled_nwrite += n;
  if (!nghttp3_stream_bidi_or_push(stream))
  {
    return 0;
  }
  if (!nghttp3_stream_require_schedule(stream))
  {
    nghttp3_conn_unschedule_stream(conn, stream);
    return 0;
  }
  if (stream->unscheduled_nwrite < 800)
  {
    return 0;
  }
  return nghttp3_conn_schedule_stream(conn, stream);
}
int nghttp3_conn_add_ack_offset(nghttp3_conn *conn, int64_t stream_id,
                                uint64_t n)
{
  nghttp3_stream *stream = nghttp3_conn_find_stream(conn, stream_id);
  if (stream ==
      __null)
  {
    return NGHTTP3_ERR_STREAM_NOT_FOUND;
  }
  return nghttp3_stream_add_ack_offset(stream, n);
}
static int conn_submit_headers_data(nghttp3_conn *conn, nghttp3_stream *stream,
                                    const nghttp3_nv *nva, size_t nvlen,
                                    const nghttp3_data_reader *dr)
{
  int rv;
  nghttp3_nv *nnva;
  nghttp3_frame_entry frent;
  rv = nghttp3_nva_copy(&nnva, nva, nvlen, conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  frent.fr.hd.type = NGHTTP3_FRAME_HEADERS;
  frent.fr.headers.nva = nnva;
  frent.fr.headers.nvlen = nvlen;
  rv = nghttp3_stream_frq_add(stream, &frent);
  if (rv != 0)
  {
    nghttp3_nva_del(nnva, conn->mem);
    return rv;
  }
  if (dr)
  {
    frent.fr.hd.type = NGHTTP3_FRAME_DATA;
    frent.aux.data.dr = *dr;
    rv = nghttp3_stream_frq_add(stream, &frent);
    if (rv != 0)
    {
      return rv;
    }
  }
  if (nghttp3_stream_require_schedule(stream))
  {
    return nghttp3_conn_schedule_stream(conn, stream);
  }
  return 0;
}
static nghttp3_tnode *stream_get_dependency_node(nghttp3_stream *stream)
{
  if (stream->pp)
  {
    assert(stream->type == NGHTTP3_STREAM_TYPE_PUSH);
    return &stream->pp->node;
  }
  return &stream->node;
}
int nghttp3_conn_schedule_stream(nghttp3_conn *conn, nghttp3_stream *stream)
{
  int rv;
  rv = nghttp3_tnode_schedule(stream_get_dependency_node(stream),
                              conn_get_sched_pq(conn, &stream->node),
                              stream->unscheduled_nwrite);
  if (rv != 0)
  {
    return rv;
  }
  stream->unscheduled_nwrite = 0;
  return 0;
}
int nghttp3_conn_ensure_stream_scheduled(nghttp3_conn *conn,
                                         nghttp3_stream *stream)
{
  if (nghttp3_tnode_is_scheduled(stream_get_dependency_node(stream)))
  {
    return 0;
  }
  return nghttp3_conn_schedule_stream(conn, stream);
}
void nghttp3_conn_unschedule_stream(nghttp3_conn *conn,
                                    nghttp3_stream *stream)
{
  nghttp3_tnode_unschedule(stream_get_dependency_node(stream),
                           conn_get_sched_pq(conn, &stream->node));
}
int nghttp3_conn_submit_request(nghttp3_conn *conn, int64_t stream_id,
                                const nghttp3_nv *nva, size_t nvlen,
                                const nghttp3_data_reader *dr,
                                void *stream_user_data)
{
  nghttp3_stream *stream;
  int rv;
  assert(!conn->server);
  assert(conn->tx.qenc);
  assert(nghttp3_client_stream_bidi(stream_id));
  if (nghttp3_stream_uni(stream_id))
  {
    return NGHTTP3_ERR_INVALID_ARGUMENT;
  }
  if (conn->flags & NGHTTP3_CONN_FLAG_GOAWAY_RECVED)
  {
    return NGHTTP3_ERR_CONN_CLOSING;
  }
  stream = nghttp3_conn_find_stream(conn, stream_id);
  if (stream !=
      __null)
  {
    return NGHTTP3_ERR_STREAM_IN_USE;
  }
  rv = nghttp3_conn_create_stream(conn, &stream, stream_id);
  if (rv != 0)
  {
    return rv;
  }
  stream->rx.hstate = NGHTTP3_HTTP_STATE_RESP_INITIAL;
  stream->tx.hstate = NGHTTP3_HTTP_STATE_REQ_END;
  stream->user_data = stream_user_data;
  nghttp3_http_record_request_method(stream, nva, nvlen);
  if (dr ==
      __null)
  {
    stream->flags |= NGHTTP3_STREAM_FLAG_WRITE_END_STREAM;
  }
  return conn_submit_headers_data(conn, stream, nva, nvlen, dr);
}
int nghttp3_conn_submit_info(nghttp3_conn *conn, int64_t stream_id,
                             const nghttp3_nv *nva, size_t nvlen)
{
  nghttp3_stream *stream;
  assert(conn->server);
  assert(conn->tx.qenc);
  stream = nghttp3_conn_find_stream(conn, stream_id);
  if (stream ==
      __null)
  {
    return NGHTTP3_ERR_STREAM_NOT_FOUND;
  }
  return conn_submit_headers_data(conn, stream, nva, nvlen,
                                  __null);
}
int nghttp3_conn_submit_response(nghttp3_conn *conn, int64_t stream_id,
                                 const nghttp3_nv *nva, size_t nvlen,
                                 const nghttp3_data_reader *dr)
{
  nghttp3_stream *stream;
  assert(conn->server);
  assert(conn->tx.qenc);
  stream = nghttp3_conn_find_stream(conn, stream_id);
  if (stream ==
      __null)
  {
    return NGHTTP3_ERR_STREAM_NOT_FOUND;
  }
  if (dr ==
      __null)
  {
    stream->flags |= NGHTTP3_STREAM_FLAG_WRITE_END_STREAM;
  }
  return conn_submit_headers_data(conn, stream, nva, nvlen, dr);
}
int nghttp3_conn_submit_trailers(nghttp3_conn *conn, int64_t stream_id,
                                 const nghttp3_nv *nva, size_t nvlen)
{
  nghttp3_stream *stream;
  assert(conn->tx.qenc);
  stream = nghttp3_conn_find_stream(conn, stream_id);
  if (stream ==
      __null)
  {
    return NGHTTP3_ERR_STREAM_NOT_FOUND;
  }
  if (stream->flags & NGHTTP3_STREAM_FLAG_WRITE_END_STREAM)
  {
    return NGHTTP3_ERR_INVALID_STATE;
  }
  stream->flags |= NGHTTP3_STREAM_FLAG_WRITE_END_STREAM;
  return conn_submit_headers_data(conn, stream, nva, nvlen,
                                  __null);
}
int nghttp3_conn_submit_push_promise(nghttp3_conn *conn, int64_t *ppush_id,
                                     int64_t stream_id, const nghttp3_nv *nva,
                                     size_t nvlen)
{
  nghttp3_stream *stream;
  int rv;
  nghttp3_nv *nnva;
  nghttp3_frame_entry frent;
  int64_t push_id;
  nghttp3_push_promise *pp;
  assert(conn->server);
  assert(conn->tx.qenc);
  assert(nghttp3_client_stream_bidi(stream_id));
  if (conn->flags & NGHTTP3_CONN_FLAG_GOAWAY_RECVED)
  {
    return NGHTTP3_ERR_CONN_CLOSING;
  }
  stream = nghttp3_conn_find_stream(conn, stream_id);
  if (stream ==
      __null)
  {
    return NGHTTP3_ERR_STREAM_NOT_FOUND;
  }
  if (conn->local.uni.max_pushes <= (uint64_t)conn->local.uni.next_push_id)
  {
    return NGHTTP3_ERR_PUSH_ID_BLOCKED;
  }
  push_id = conn->local.uni.next_push_id;
  rv = nghttp3_conn_create_push_promise(conn, &pp, push_id, &stream->node);
  if (rv != 0)
  {
    return rv;
  }
  ++conn->local.uni.next_push_id;
  rv = nghttp3_nva_copy(&nnva, nva, nvlen, conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  frent.fr.hd.type = NGHTTP3_FRAME_PUSH_PROMISE;
  frent.fr.push_promise.push_id = push_id;
  frent.fr.push_promise.nva = nnva;
  frent.fr.push_promise.nvlen = nvlen;
  rv = nghttp3_stream_frq_add(stream, &frent);
  if (rv != 0)
  {
    nghttp3_nva_del(nnva, conn->mem);
    return rv;
  }
  *ppush_id = push_id;
  if (nghttp3_stream_require_schedule(stream))
  {
    return nghttp3_conn_schedule_stream(conn, stream);
  }
  return 0;
}
int nghttp3_conn_bind_push_stream(nghttp3_conn *conn, int64_t push_id,
                                  int64_t stream_id)
{
  nghttp3_push_promise *pp;
  nghttp3_stream *stream;
  int rv;
  assert(conn->server);
  assert(nghttp3_server_stream_uni(stream_id));
  pp = nghttp3_conn_find_push_promise(conn, push_id);
  if (pp ==
      __null)
  {
    return NGHTTP3_ERR_INVALID_ARGUMENT;
  }
  assert(
      __null == nghttp3_conn_find_stream(conn, stream_id));
  rv = nghttp3_conn_create_stream(conn, &stream, stream_id);
  if (rv != 0)
  {
    return rv;
  }
  stream->type = NGHTTP3_STREAM_TYPE_PUSH;
  stream->pp = pp;
  pp->stream = stream;
  rv = nghttp3_stream_write_stream_type_push_id(stream);
  if (rv != 0)
  {
    return rv;
  }
  return 0;
}
int nghttp3_conn_cancel_push(nghttp3_conn *conn, int64_t push_id)
{
  if (conn->server)
  {
    return nghttp3_conn_server_cancel_push(conn, push_id);
  }
  return nghttp3_conn_client_cancel_push(conn, push_id);
}
int nghttp3_conn_server_cancel_push(nghttp3_conn *conn, int64_t push_id)
{
  nghttp3_push_promise *pp;
  nghttp3_frame_entry frent;
  int rv;
  assert(conn->tx.ctrl);
  pp = nghttp3_conn_find_push_promise(conn, push_id);
  if (pp ==
      __null)
  {
    return NGHTTP3_ERR_INVALID_ARGUMENT;
  }
  if (!(pp->flags & NGHTTP3_PUSH_PROMISE_FLAG_SENT_CANCEL))
  {
    frent.fr.hd.type = NGHTTP3_FRAME_CANCEL_PUSH;
    frent.fr.cancel_push.push_id = push_id;
    rv = nghttp3_stream_frq_add(conn->tx.ctrl, &frent);
    if (rv != 0)
    {
      return rv;
    }
    pp->flags |= NGHTTP3_PUSH_PROMISE_FLAG_SENT_CANCEL;
  }
  if (pp->stream)
  {
    rv = conn_call_reset_stream(conn, pp->stream, 0x010c);
    if (rv != 0)
    {
      return rv;
    }
  }
  nghttp3_tnode_unschedule(&pp->node, conn_get_sched_pq(conn, &pp->node));
  conn_delete_push_promise(conn, pp);
  return 0;
}
int nghttp3_conn_client_cancel_push(nghttp3_conn *conn, int64_t push_id)
{
  nghttp3_push_promise *pp;
  nghttp3_frame_entry frent;
  int rv;
  pp = nghttp3_conn_find_push_promise(conn, push_id);
  if (pp ==
      __null)
  {
    return NGHTTP3_ERR_INVALID_ARGUMENT;
  }
  if (pp->flags & NGHTTP3_PUSH_PROMISE_FLAG_SENT_CANCEL)
  {
    return 0;
  }
  if (!(pp->flags & NGHTTP3_PUSH_PROMISE_FLAG_RECVED))
  {
    return NGHTTP3_ERR_INVALID_STATE;
  }
  if (pp->stream)
  {
    pp->flags |= NGHTTP3_PUSH_PROMISE_FLAG_SENT_CANCEL;
    return nghttp3_conn_cancel_push_stream(conn, pp->stream);
  }
  frent.fr.hd.type = NGHTTP3_FRAME_CANCEL_PUSH;
  frent.fr.cancel_push.push_id = push_id;
  rv = nghttp3_stream_frq_add(conn->tx.ctrl, &frent);
  if (rv != 0)
  {
    return rv;
  }
  conn_delete_push_promise(conn, pp);
  return 0;
}
int nghttp3_conn_submit_shutdown_notice(nghttp3_conn *conn)
{
  nghttp3_frame_entry frent;
  int rv;
  assert(conn->tx.ctrl);
  frent.fr.hd.type = NGHTTP3_FRAME_GOAWAY;
  frent.fr.goaway.id = conn->server ? (1ull << 62) - 4 : (1ull << 62) - 1;
  assert(frent.fr.goaway.id <= conn->tx.goaway_id);
  rv = nghttp3_stream_frq_add(conn->tx.ctrl, &frent);
  if (rv != 0)
  {
    return rv;
  }
  conn->tx.goaway_id = frent.fr.goaway.id;
  conn->flags |= NGHTTP3_CONN_FLAG_GOAWAY_QUEUED;
  return 0;
}
int nghttp3_conn_shutdown(nghttp3_conn *conn)
{
  nghttp3_frame_entry frent;
  int rv;
  assert(conn->tx.ctrl);
  frent.fr.hd.type = NGHTTP3_FRAME_GOAWAY;
  if (conn->server)
  {
    frent.fr.goaway.id =
        (((1ll << 62) - 4) < (conn->rx.max_stream_id_bidi + 4) ? ((1ll << 62) - 4) : (conn->rx.max_stream_id_bidi + 4));
  }
  else
  {
    frent.fr.goaway.id = (((1ll << 62) - 1) < (conn->rx.max_push_id + 1) ? ((1ll << 62) - 1) : (conn->rx.max_push_id + 1));
  }
  assert(frent.fr.goaway.id <= conn->tx.goaway_id);
  rv = nghttp3_stream_frq_add(conn->tx.ctrl, &frent);
  if (rv != 0)
  {
    return rv;
  }
  conn->tx.goaway_id = frent.fr.goaway.id;
  conn->flags |= NGHTTP3_CONN_FLAG_GOAWAY_QUEUED;
  return 0;
}
int nghttp3_conn_reject_stream(nghttp3_conn *conn, nghttp3_stream *stream)
{
  int rv;
  rv = nghttp3_qpack_decoder_cancel_stream(&conn->qdec, stream->node.nid.id);
  if (rv != 0)
  {
    return rv;
  }
  rv = conn_call_send_stop_sending(conn, stream, 0x010b);
  if (rv != 0)
  {
    return rv;
  }
  return conn_call_reset_stream(conn, stream, 0x010b);
}
static int conn_reject_push_stream(nghttp3_conn *conn, nghttp3_stream *stream,
                                   uint64_t app_error_code)
{
  int rv;
  rv = nghttp3_qpack_decoder_cancel_stream(&conn->qdec, stream->node.nid.id);
  if (rv != 0)
  {
    return rv;
  }
  return conn_call_send_stop_sending(conn, stream, app_error_code);
}
int nghttp3_conn_reject_push_stream(nghttp3_conn *conn,
                                    nghttp3_stream *stream)
{
  return conn_reject_push_stream(conn, stream, 0x010b);
}
int nghttp3_conn_cancel_push_stream(nghttp3_conn *conn,
                                    nghttp3_stream *stream)
{
  return conn_reject_push_stream(conn, stream, 0x010c);
}
int nghttp3_conn_block_stream(nghttp3_conn *conn, int64_t stream_id)
{
  nghttp3_stream *stream = nghttp3_conn_find_stream(conn, stream_id);
  if (stream ==
      __null)
  {
    return NGHTTP3_ERR_STREAM_NOT_FOUND;
  }
  stream->flags |= NGHTTP3_STREAM_FLAG_FC_BLOCKED;
  stream->unscheduled_nwrite = 0;
  if (nghttp3_stream_bidi_or_push(stream))
  {
    nghttp3_conn_unschedule_stream(conn, stream);
  }
  return 0;
}
int nghttp3_conn_unblock_stream(nghttp3_conn *conn, int64_t stream_id)
{
  nghttp3_stream *stream = nghttp3_conn_find_stream(conn, stream_id);
  if (stream ==
      __null)
  {
    return NGHTTP3_ERR_STREAM_NOT_FOUND;
  }
  stream->flags &= (uint16_t)~NGHTTP3_STREAM_FLAG_FC_BLOCKED;
  if (nghttp3_stream_bidi_or_push(stream) &&
      nghttp3_stream_require_schedule(stream))
  {
    return nghttp3_conn_ensure_stream_scheduled(conn, stream);
  }
  return 0;
}
int nghttp3_conn_resume_stream(nghttp3_conn *conn, int64_t stream_id)
{
  nghttp3_stream *stream = nghttp3_conn_find_stream(conn, stream_id);
  if (stream ==
      __null)
  {
    return NGHTTP3_ERR_STREAM_NOT_FOUND;
  }
  stream->flags &= (uint16_t)~NGHTTP3_STREAM_FLAG_READ_DATA_BLOCKED;
  if (nghttp3_stream_bidi_or_push(stream) &&
      nghttp3_stream_require_schedule(stream))
  {
    return nghttp3_conn_ensure_stream_scheduled(conn, stream);
  }
  return 0;
}
int nghttp3_conn_close_stream(nghttp3_conn *conn, int64_t stream_id,
                              uint64_t app_error_code)
{
  nghttp3_stream *stream = nghttp3_conn_find_stream(conn, stream_id);
  if (stream ==
      __null)
  {
    return NGHTTP3_ERR_STREAM_NOT_FOUND;
  }
  if (nghttp3_stream_uni(stream_id) &&
      stream->type != NGHTTP3_STREAM_TYPE_PUSH &&
      stream->type != NGHTTP3_STREAM_TYPE_UNKNOWN)
  {
    return NGHTTP3_ERR_H3_CLOSED_CRITICAL_STREAM;
  }
  stream->error_code = app_error_code;
  nghttp3_conn_unschedule_stream(conn, stream);
  if (stream->qpack_blocked_pe.index ==
          (18446744073709551615UL) &&
      (conn->server || !stream->pp ||
       (stream->pp->flags & NGHTTP3_PUSH_PROMISE_FLAG_RECVED)))
  {
    return conn_delete_stream(conn, stream);
  }
  stream->flags |= NGHTTP3_STREAM_FLAG_CLOSED;
  return 0;
}
int nghttp3_conn_reset_stream(nghttp3_conn *conn, int64_t stream_id)
{
  nghttp3_stream *stream;
  stream = nghttp3_conn_find_stream(conn, stream_id);
  if (stream)
  {
    stream->flags |= NGHTTP3_STREAM_FLAG_RESET;
  }
  return nghttp3_qpack_decoder_cancel_stream(&conn->qdec, stream_id);
}
int nghttp3_conn_qpack_blocked_streams_push(nghttp3_conn *conn,
                                            nghttp3_stream *stream)
{
  assert(stream->qpack_blocked_pe.index ==
         (18446744073709551615UL));
  return nghttp3_pq_push(&conn->qpack_blocked_streams,
                         &stream->qpack_blocked_pe);
}
void nghttp3_conn_qpack_blocked_streams_pop(nghttp3_conn *conn)
{
  assert(!nghttp3_pq_empty(&conn->qpack_blocked_streams));
  nghttp3_pq_pop(&conn->qpack_blocked_streams);
}
void nghttp3_conn_set_max_client_streams_bidi(nghttp3_conn *conn,
                                              uint64_t max_streams)
{
  assert(conn->server);
  assert(conn->remote.bidi.max_client_streams <= max_streams);
  conn->remote.bidi.max_client_streams = max_streams;
}
void nghttp3_conn_set_max_concurrent_streams(nghttp3_conn *conn,
                                             size_t max_concurrent_streams)
{
  nghttp3_qpack_decoder_set_max_concurrent_streams(&conn->qdec,
                                                   max_concurrent_streams);
}
int nghttp3_conn_submit_max_push_id(nghttp3_conn *conn)
{
  nghttp3_frame_entry frent;
  int rv;
  assert(conn->tx.ctrl);
  assert(!(conn->flags & NGHTTP3_CONN_FLAG_MAX_PUSH_ID_QUEUED));
  frent.fr.hd.type = NGHTTP3_FRAME_MAX_PUSH_ID;
  rv = nghttp3_stream_frq_add(conn->tx.ctrl, &frent);
  if (rv != 0)
  {
    return rv;
  }
  conn->flags |= NGHTTP3_CONN_FLAG_MAX_PUSH_ID_QUEUED;
  return 0;
}
int nghttp3_conn_set_stream_user_data(nghttp3_conn *conn, int64_t stream_id,
                                      void *stream_user_data)
{
  nghttp3_stream *stream = nghttp3_conn_find_stream(conn, stream_id);
  if (stream ==
      __null)
  {
    return NGHTTP3_ERR_STREAM_NOT_FOUND;
  }
  stream->user_data = stream_user_data;
  return 0;
}
int64_t nghttp3_conn_get_frame_payload_left(nghttp3_conn *conn,
                                            int64_t stream_id)
{
  nghttp3_stream *stream = nghttp3_conn_find_stream(conn, stream_id);
  if (stream ==
      __null)
  {
    return NGHTTP3_ERR_STREAM_NOT_FOUND;
  }
  return stream->rstate.left;
}
int nghttp3_conn_get_stream_priority(nghttp3_conn *conn, nghttp3_pri *dest,
                                     int64_t stream_id)
{
  nghttp3_stream *stream = nghttp3_conn_find_stream(conn, stream_id);
  assert(conn->server);
  if (stream ==
      __null)
  {
    return NGHTTP3_ERR_STREAM_NOT_FOUND;
  }
  dest->urgency = ((uint32_t)((stream->rx.http.pri) & ~(1 << 7)));
  dest->inc = (((stream->rx.http.pri) & (1 << 7)) != 0);
  return 0;
}
int nghttp3_conn_set_stream_priority(nghttp3_conn *conn, int64_t stream_id,
                                     const nghttp3_pri *pri)
{
  nghttp3_stream *stream = nghttp3_conn_find_stream(conn, stream_id);
  assert(conn->server);
  assert(pri->urgency < (7 + 1));
  assert(pri->inc == 0 || pri->inc == 1);
  if (stream ==
      __null)
  {
    return NGHTTP3_ERR_STREAM_NOT_FOUND;
  }
  stream->rx.http.pri = nghttp3_pri_to_uint8(pri);
  return conn_update_stream_priority(conn, stream, stream->rx.http.pri);
}
int nghttp3_conn_is_remote_qpack_encoder_stream(nghttp3_conn *conn,
                                                int64_t stream_id)
{
  nghttp3_stream *stream;
  if (!conn_remote_stream_uni(conn, stream_id))
  {
    return 0;
  }
  stream = nghttp3_conn_find_stream(conn, stream_id);
  return stream && stream->type == NGHTTP3_STREAM_TYPE_QPACK_ENCODER;
}
void nghttp3_conn_settings_default(nghttp3_conn_settings *settings)
{
  memset(settings, 0, sizeof(nghttp3_conn_settings));
  settings->max_field_section_size = ((1ull << 62) - 1);
}
int nghttp3_push_promise_new(nghttp3_push_promise **ppp, int64_t push_id,
                             uint64_t seq, nghttp3_tnode *assoc_tnode,
                             const nghttp3_mem *mem)
{
  nghttp3_push_promise *pp;
  nghttp3_node_id nid;
  pp = nghttp3_mem_calloc(mem, 1, sizeof(nghttp3_push_promise));
  if (pp ==
      __null)
  {
    return NGHTTP3_ERR_NOMEM;
  }
  nghttp3_tnode_init(
      &pp->node, nghttp3_node_id_init(&nid, NGHTTP3_NODE_ID_TYPE_PUSH, push_id),
      seq, 1);
  pp->me.key = (key_type)push_id;
  pp->node.nid.id = push_id;
  pp->http.status_code = -1;
  pp->http.content_length = -1;
  if (assoc_tnode)
  {
    assert(assoc_tnode->nid.type == NGHTTP3_NODE_ID_TYPE_STREAM);
    pp->stream_id = assoc_tnode->nid.id;
    pp->flags |= NGHTTP3_PUSH_PROMISE_FLAG_BOUND;
  }
  else
  {
    pp->stream_id = -1;
  }
  *ppp = pp;
  return 0;
}
void nghttp3_push_promise_del(nghttp3_push_promise *pp,
                              const nghttp3_mem *mem)
{
  if (pp ==
      __null)
  {
    return;
  }
  nghttp3_tnode_free(&pp->node);
  nghttp3_mem_free(mem, pp);
}
int64_t nghttp3_get_varint(size_t *plen, const uint8_t *p)
{
  union
  {
    char b[8];
    uint16_t n16;
    uint32_t n32;
    uint64_t n64;
  } n;
  *plen = 1u << (*p >> 6);
  switch (*plen)
  {
  case 1:
    return (int64_t)*p;
  case 2:
    memcpy(&n, p, 2);
    n.b[0] &= 0x3f;
    return (int64_t)ntohs(n.n16);
  case 4:
    memcpy(&n, p, 4);
    n.b[0] &= 0x3f;
    return (int64_t)ntohl(n.n32);
  case 8:
    memcpy(&n, p, 8);
    n.b[0] &= 0x3f;
    return (int64_t)((uint64_t)(ntohl((uint32_t)(n.n64))) << 32 | ntohl((uint32_t)((n.n64) >> 32)));
  }
  assert(0);
}
int64_t nghttp3_get_varint_fb(const uint8_t *p) { return *p & 0x3f; }
size_t nghttp3_get_varint_len(const uint8_t *p) { return 1u << (*p >> 6); }
uint8_t *nghttp3_put_uint64be(uint8_t *p, uint64_t n)
{
  n = ((uint64_t)(ntohl((uint32_t)(n))) << 32 | ntohl((uint32_t)((n) >> 32)));
  return nghttp3_cpymem(p, (const uint8_t *)&n, sizeof(n));
}
uint8_t *nghttp3_put_uint48be(uint8_t *p, uint64_t n)
{
  n = ((uint64_t)(ntohl((uint32_t)(n))) << 32 | ntohl((uint32_t)((n) >> 32)));
  return nghttp3_cpymem(p, ((const uint8_t *)&n) + 2, 6);
}
uint8_t *nghttp3_put_uint32be(uint8_t *p, uint32_t n)
{
  n = htonl(n);
  return nghttp3_cpymem(p, (const uint8_t *)&n, sizeof(n));
}
uint8_t *nghttp3_put_uint24be(uint8_t *p, uint32_t n)
{
  n = htonl(n);
  return nghttp3_cpymem(p, ((const uint8_t *)&n) + 1, 3);
}
uint8_t *nghttp3_put_uint16be(uint8_t *p, uint16_t n)
{
  n = htons(n);
  return nghttp3_cpymem(p, (const uint8_t *)&n, sizeof(n));
}
uint8_t *nghttp3_put_varint(uint8_t *p, int64_t n)
{
  uint8_t *rv;
  if (n < 64)
  {
    *p++ = (uint8_t)n;
    return p;
  }
  if (n < 16384)
  {
    rv = nghttp3_put_uint16be(p, (uint16_t)n);
    *p |= 0x40;
    return rv;
  }
  if (n < 1073741824)
  {
    rv = nghttp3_put_uint32be(p, (uint32_t)n);
    *p |= 0x80;
    return rv;
  }
  assert(n < 4611686018427387904LL);
  rv = nghttp3_put_uint64be(p, (uint64_t)n);
  *p |= 0xc0;
  return rv;
}
size_t nghttp3_put_varint_len(int64_t n)
{
  if (n < 64)
  {
    return 1;
  }
  if (n < 16384)
  {
    return 2;
  }
  if (n < 1073741824)
  {
    return 4;
  }
  assert(n < 4611686018427387904LL);
  return 8;
}
uint64_t nghttp3_ord_stream_id(int64_t stream_id)
{
  return (uint64_t)(stream_id >> 2) + 1;
}
uint8_t nghttp3_pri_to_uint8(const nghttp3_pri *pri)
{
  return (uint8_t)((uint32_t)pri->inc << 7 | pri->urgency);
}
void nghttp3_set_debug_vprintf_callback(
    nghttp3_debug_vprintf_callback debug_vprintf_callback)
{
  (void)debug_vprintf_callback;
}
const char *nghttp3_strerror(int liberr)
{
  switch (liberr)
  {
  case NGHTTP3_ERR_INVALID_ARGUMENT:
    return "ERR_INVALID_ARGUMENT";
  case NGHTTP3_ERR_NOBUF:
    return "ERR_NOBUF";
  case NGHTTP3_ERR_INVALID_STATE:
    return "ERR_INVALID_STATE";
  case NGHTTP3_ERR_WOULDBLOCK:
    return "ERR_WOULDBLOCK";
  case NGHTTP3_ERR_STREAM_IN_USE:
    return "ERR_STREAM_IN_USE";
  case NGHTTP3_ERR_PUSH_ID_BLOCKED:
    return "ERR_PUSH_ID_BLOCKED";
  case NGHTTP3_ERR_MALFORMED_HTTP_HEADER:
    return "ERR_MALFORMED_HTTP_HEADER";
  case NGHTTP3_ERR_REMOVE_HTTP_HEADER:
    return "ERR_REMOVE_HTTP_HEADER";
  case NGHTTP3_ERR_MALFORMED_HTTP_MESSAGING:
    return "ERR_MALFORMED_HTTP_MESSAGING";
  case NGHTTP3_ERR_QPACK_FATAL:
    return "ERR_QPACK_FATAL";
  case NGHTTP3_ERR_QPACK_HEADER_TOO_LARGE:
    return "ERR_QPACK_HEADER_TOO_LARGE";
  case NGHTTP3_ERR_IGNORE_STREAM:
    return "ERR_IGNORE_STREAM";
  case NGHTTP3_ERR_STREAM_NOT_FOUND:
    return "ERR_STREAM_NOT_FOUND";
  case NGHTTP3_ERR_IGNORE_PUSH_PROMISE:
    return "ERR_IGNORE_PUSH_PROMISE";
  case NGHTTP3_ERR_CONN_CLOSING:
    return "ERR_CONN_CLOSING";
  case NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED:
    return "ERR_QPACK_DECOMPRESSION_FAILED";
  case NGHTTP3_ERR_QPACK_ENCODER_STREAM_ERROR:
    return "ERR_QPACK_ENCODER_STREAM_ERROR";
  case NGHTTP3_ERR_QPACK_DECODER_STREAM_ERROR:
    return "ERR_QPACK_DECODER_STREAM_ERROR";
  case NGHTTP3_ERR_H3_FRAME_UNEXPECTED:
    return "ERR_H3_FRAME_UNEXPECTED";
  case NGHTTP3_ERR_H3_FRAME_ERROR:
    return "ERR_H3_FRAME_ERROR";
  case NGHTTP3_ERR_H3_MISSING_SETTINGS:
    return "ERR_H3_MISSING_SETTINGS";
  case NGHTTP3_ERR_H3_INTERNAL_ERROR:
    return "ERR_H3_INTERNAL_ERROR";
  case NGHTTP3_ERR_H3_CLOSED_CRITICAL_STREAM:
    return "ERR_CLOSED_CRITICAL_STREAM";
  case NGHTTP3_ERR_H3_GENERAL_PROTOCOL_ERROR:
    return "ERR_H3_GENERAL_PROTOCOL_ERROR";
  case NGHTTP3_ERR_H3_ID_ERROR:
    return "ERR_H3_ID_ERROR";
  case NGHTTP3_ERR_H3_SETTINGS_ERROR:
    return "ERR_H3_SETTINGS_ERROR";
  case NGHTTP3_ERR_H3_STREAM_CREATION_ERROR:
    return "ERR_H3_STREAM_CREATION_ERROR";
  case NGHTTP3_ERR_NOMEM:
    return "ERR_NOMEM";
  case NGHTTP3_ERR_CALLBACK_FAILURE:
    return "ERR_CALLBACK_FAILURE";
  default:
    return "(unknown)";
  }
}
uint64_t nghttp3_err_infer_quic_app_error_code(int liberr)
{
  switch (liberr)
  {
  case 0:
    return 0x0100;
  case NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED:
    return 0x0200;
  case NGHTTP3_ERR_QPACK_ENCODER_STREAM_ERROR:
    return 0x0201;
  case NGHTTP3_ERR_QPACK_DECODER_STREAM_ERROR:
    return 0x0202;
  case NGHTTP3_ERR_H3_FRAME_UNEXPECTED:
    return 0x0105;
  case NGHTTP3_ERR_H3_FRAME_ERROR:
    return 0x0106;
  case NGHTTP3_ERR_H3_MISSING_SETTINGS:
    return 0x010a;
  case NGHTTP3_ERR_H3_INTERNAL_ERROR:
    return 0x0102;
  case NGHTTP3_ERR_H3_CLOSED_CRITICAL_STREAM:
    return 0x0104;
  case NGHTTP3_ERR_H3_GENERAL_PROTOCOL_ERROR:
    return 0x0101;
  case NGHTTP3_ERR_H3_ID_ERROR:
    return 0x0108;
  case NGHTTP3_ERR_H3_SETTINGS_ERROR:
    return 0x0109;
  case NGHTTP3_ERR_H3_STREAM_CREATION_ERROR:
    return 0x0103;
  default:
    return 0x0101;
  }
}
uint8_t *nghttp3_frame_write_hd(uint8_t *p, const nghttp3_frame_hd *hd)
{
  p = nghttp3_put_varint(p, hd->type);
  p = nghttp3_put_varint(p, hd->length);
  return p;
}
size_t nghttp3_frame_write_hd_len(const nghttp3_frame_hd *hd)
{
  return nghttp3_put_varint_len(hd->type) + nghttp3_put_varint_len(hd->length);
}
uint8_t *nghttp3_frame_write_settings(uint8_t *p,
                                      const nghttp3_frame_settings *fr)
{
  size_t i;
  p = nghttp3_frame_write_hd(p, &fr->hd);
  for (i = 0; i < fr->niv; ++i)
  {
    p = nghttp3_put_varint(p, (int64_t)fr->iv[i].id);
    p = nghttp3_put_varint(p, (int64_t)fr->iv[i].value);
  }
  return p;
}
size_t nghttp3_frame_write_settings_len(int64_t *ppayloadlen,
                                        const nghttp3_frame_settings *fr)
{
  size_t payloadlen = 0;
  size_t i;
  for (i = 0; i < fr->niv; ++i)
  {
    payloadlen += nghttp3_put_varint_len((int64_t)fr->iv[i].id) +
                  nghttp3_put_varint_len((int64_t)fr->iv[i].value);
  }
  *ppayloadlen = (int64_t)payloadlen;
  return nghttp3_put_varint_len(NGHTTP3_FRAME_SETTINGS) +
         nghttp3_put_varint_len((int64_t)payloadlen) + payloadlen;
}
uint8_t *nghttp3_frame_write_cancel_push(uint8_t *p,
                                         const nghttp3_frame_cancel_push *fr)
{
  p = nghttp3_frame_write_hd(p, &fr->hd);
  p = nghttp3_put_varint(p, fr->push_id);
  return p;
}
size_t
nghttp3_frame_write_cancel_push_len(int64_t *ppayloadlen,
                                    const nghttp3_frame_cancel_push *fr)
{
  size_t payloadlen = nghttp3_put_varint_len(fr->push_id);
  *ppayloadlen = (int64_t)payloadlen;
  return nghttp3_put_varint_len(NGHTTP3_FRAME_CANCEL_PUSH) +
         nghttp3_put_varint_len((int64_t)payloadlen) + payloadlen;
}
uint8_t *nghttp3_frame_write_max_push_id(uint8_t *p,
                                         const nghttp3_frame_max_push_id *fr)
{
  p = nghttp3_frame_write_hd(p, &fr->hd);
  p = nghttp3_put_varint(p, fr->push_id);
  return p;
}
size_t
nghttp3_frame_write_max_push_id_len(int64_t *ppayloadlen,
                                    const nghttp3_frame_max_push_id *fr)
{
  size_t payloadlen = nghttp3_put_varint_len(fr->push_id);
  *ppayloadlen = (int64_t)payloadlen;
  return nghttp3_put_varint_len(NGHTTP3_FRAME_MAX_PUSH_ID) +
         nghttp3_put_varint_len((int64_t)payloadlen) + payloadlen;
}
uint8_t *nghttp3_frame_write_goaway(uint8_t *p,
                                    const nghttp3_frame_goaway *fr)
{
  p = nghttp3_frame_write_hd(p, &fr->hd);
  p = nghttp3_put_varint(p, fr->id);
  return p;
}
size_t nghttp3_frame_write_goaway_len(int64_t *ppayloadlen,
                                      const nghttp3_frame_goaway *fr)
{
  size_t payloadlen = nghttp3_put_varint_len(fr->id);
  *ppayloadlen = (int64_t)payloadlen;
  return nghttp3_put_varint_len(NGHTTP3_FRAME_GOAWAY) +
         nghttp3_put_varint_len((int64_t)payloadlen) + payloadlen;
}
int nghttp3_nva_copy(nghttp3_nv **pnva, const nghttp3_nv *nva, size_t nvlen,
                     const nghttp3_mem *mem)
{
  size_t i;
  uint8_t *data =
      __null;
  size_t buflen = 0;
  nghttp3_nv *p;
  if (nvlen == 0)
  {
    *pnva =
        __null;
    return 0;
  }
  for (i = 0; i < nvlen; ++i)
  {
    if ((nva[i].flags & NGHTTP3_NV_FLAG_NO_COPY_NAME) == 0)
    {
      buflen += nva[i].namelen + 1;
    }
    if ((nva[i].flags & NGHTTP3_NV_FLAG_NO_COPY_VALUE) == 0)
    {
      buflen += nva[i].valuelen + 1;
    }
  }
  buflen += sizeof(nghttp3_nv) * nvlen;
  *pnva = nghttp3_mem_malloc(mem, buflen);
  if (*pnva ==
      __null)
  {
    return NGHTTP3_ERR_NOMEM;
  }
  p = *pnva;
  data = (uint8_t *)(*pnva) + sizeof(nghttp3_nv) * nvlen;
  for (i = 0; i < nvlen; ++i)
  {
    p->flags = nva[i].flags;
    if (nva[i].flags & NGHTTP3_NV_FLAG_NO_COPY_NAME)
    {
      p->name = nva[i].name;
      p->namelen = nva[i].namelen;
    }
    else
    {
      if (nva[i].namelen)
      {
        memcpy(data, nva[i].name, nva[i].namelen);
      }
      p->name = data;
      p->namelen = nva[i].namelen;
      data[p->namelen] = '\0';
      nghttp3_downcase(p->name, p->namelen);
      data += nva[i].namelen + 1;
    }
    if (nva[i].flags & NGHTTP3_NV_FLAG_NO_COPY_VALUE)
    {
      p->value = nva[i].value;
      p->valuelen = nva[i].valuelen;
    }
    else
    {
      if (nva[i].valuelen)
      {
        memcpy(data, nva[i].value, nva[i].valuelen);
      }
      p->value = data;
      p->valuelen = nva[i].valuelen;
      data[p->valuelen] = '\0';
      data += nva[i].valuelen + 1;
    }
    ++p;
  }
  return 0;
}
void nghttp3_nva_del(nghttp3_nv *nva, const nghttp3_mem *mem)
{
  nghttp3_mem_free(mem, nva);
}
void nghttp3_frame_headers_free(nghttp3_frame_headers *fr,
                                const nghttp3_mem *mem)
{
  if (fr ==
      __null)
  {
    return;
  }
  nghttp3_nva_del(fr->nva, mem);
}
void nghttp3_frame_push_promise_free(nghttp3_frame_push_promise *fr,
                                     const nghttp3_mem *mem)
{
  if (fr ==
      __null)
  {
    return;
  }
  nghttp3_nva_del(fr->nva, mem);
}
int nghttp3_gaptr_init(nghttp3_gaptr *gaptr, const nghttp3_mem *mem)
{
  int rv;
  nghttp3_range range = {0,
                         (18446744073709551615UL)};
  rv = nghttp3_ksl_init(&gaptr->gap, nghttp3_ksl_range_compar,
                        sizeof(nghttp3_range), mem);
  if (rv != 0)
  {
    return rv;
  }
  rv = nghttp3_ksl_insert(&gaptr->gap,
                          __null, &range,
                          __null);
  if (rv != 0)
  {
    nghttp3_ksl_free(&gaptr->gap);
    return rv;
  }
  gaptr->mem = mem;
  return 0;
}
void nghttp3_gaptr_free(nghttp3_gaptr *gaptr)
{
  if (gaptr ==
      __null)
  {
    return;
  }
  nghttp3_ksl_free(&gaptr->gap);
}
int nghttp3_gaptr_push(nghttp3_gaptr *gaptr, uint64_t offset, size_t datalen)
{
  int rv;
  nghttp3_range k, m, l, r, q = {offset, offset + datalen};
  nghttp3_ksl_it it;
  it = nghttp3_ksl_lower_bound_compar(&gaptr->gap, &q,
                                      nghttp3_ksl_range_exclusive_compar);
  for (; !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                            __null);)
  {
    k = *(nghttp3_range *)((nghttp3_ksl_key *)((nghttp3_ksl_node *)(void *)(((&it)->blk)->nodes + ((&it)->ksl)->nodelen * ((&it)->i)))->key);
    m = nghttp3_range_intersect(&q, &k);
    if (!nghttp3_range_len(&m))
    {
      break;
    }
    if (nghttp3_range_eq(&k, &m))
    {
      nghttp3_ksl_remove(&gaptr->gap, &it, &k);
      continue;
    }
    nghttp3_range_cut(&l, &r, &k, &m);
    if (nghttp3_range_len(&l))
    {
      nghttp3_ksl_update_key(&gaptr->gap, &k, &l);
      if (nghttp3_range_len(&r))
      {
        rv = nghttp3_ksl_insert(&gaptr->gap, &it, &r,
                                __null);
        if (rv != 0)
        {
          return rv;
        }
      }
    }
    else if (nghttp3_range_len(&r))
    {
      nghttp3_ksl_update_key(&gaptr->gap, &k, &r);
    }
    (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0);
  }
  return 0;
}
uint64_t nghttp3_gaptr_first_gap_offset(nghttp3_gaptr *gaptr)
{
  nghttp3_ksl_it it = nghttp3_ksl_begin(&gaptr->gap);
  return ((nghttp3_range *)((nghttp3_ksl_key *)((nghttp3_ksl_node *)(void *)(((&it)->blk)->nodes + ((&it)->ksl)->nodelen * ((&it)->i)))->key))->begin;
}
nghttp3_ksl_it nghttp3_gaptr_get_first_gap_after(nghttp3_gaptr *gaptr,
                                                 uint64_t offset)
{
  nghttp3_range q = {offset, offset + 1};
  return nghttp3_ksl_lower_bound_compar(&gaptr->gap, &q,
                                        nghttp3_ksl_range_exclusive_compar);
}
int nghttp3_gaptr_is_pushed(nghttp3_gaptr *gaptr, uint64_t offset,
                            size_t datalen)
{
  nghttp3_range q = {offset, offset + datalen};
  nghttp3_ksl_it it = nghttp3_ksl_lower_bound_compar(
      &gaptr->gap, &q, nghttp3_ksl_range_exclusive_compar);
  nghttp3_range m =
      nghttp3_range_intersect(&q, (nghttp3_range *)((nghttp3_ksl_key *)((nghttp3_ksl_node *)(void *)(((&it)->blk)->nodes + ((&it)->ksl)->nodelen * ((&it)->i)))->key));
  return nghttp3_range_len(&m) == 0;
}
static uint8_t downcase(uint8_t c)
{
  return 'A' <= c && c <= 'Z' ? (uint8_t)(c - 'A' + 'a') : c;
}
static int memieq(const void *a, const void *b, size_t n)
{
  size_t i;
  const uint8_t *aa = a, *bb = b;
  for (i = 0; i < n; ++i)
  {
    if (downcase(aa[i]) != downcase(bb[i]))
    {
      return 0;
    }
  }
  return 1;
}
static int64_t parse_uint(const uint8_t *s, size_t len)
{
  int64_t n = 0;
  size_t i;
  if (len == 0)
  {
    return -1;
  }
  for (i = 0; i < len; ++i)
  {
    if ('0' <= s[i] && s[i] <= '9')
    {
      if (n >
          (9223372036854775807L) / 10)
      {
        return -1;
      }
      n *= 10;
      if (n >
          (9223372036854775807L) - (s[i] - '0'))
      {
        return -1;
      }
      n += s[i] - '0';
      continue;
    }
    return -1;
  }
  return n;
}
static int lws(const uint8_t *s, size_t n)
{
  size_t i;
  for (i = 0; i < n; ++i)
  {
    if (s[i] != ' ' && s[i] != '\t')
    {
      return 0;
    }
  }
  return 1;
}
static int check_pseudo_header(nghttp3_http_state *http,
                               const nghttp3_qpack_nv *nv, int flag)
{
  if (http->flags & flag)
  {
    return 0;
  }
  if (lws(nv->value->base, nv->value->len))
  {
    return 0;
  }
  http->flags = (uint16_t)(http->flags | flag);
  return 1;
}
static int expect_response_body(nghttp3_http_state *http)
{
  return (http->flags & NGHTTP3_HTTP_FLAG_METH_HEAD) == 0 &&
         http->status_code / 100 != 1 && http->status_code != 304 &&
         http->status_code != 204;
}
static int check_path(nghttp3_http_state *http)
{
  return (http->flags & NGHTTP3_HTTP_FLAG_SCHEME_HTTP) == 0 ||
         ((http->flags & NGHTTP3_HTTP_FLAG_PATH_REGULAR) ||
          ((http->flags & NGHTTP3_HTTP_FLAG_METH_OPTIONS) &&
           (http->flags & NGHTTP3_HTTP_FLAG_PATH_ASTERISK)));
}
int nghttp3_http_parse_priority(nghttp3_pri *dest, const uint8_t *value,
                                size_t len)
{
  nghttp3_pri pri = *dest;
  const uint8_t *p = value, *end = value + len;
  for (;;)
  {
    for (; p != end && (*p == ' ' || *p == '\t'); ++p)
      ;
    if (p == end)
    {
      break;
    }
    switch (*p)
    {
    case 'u':
      ++p;
      if (p + 2 > end || *p++ != '=')
      {
        return NGHTTP3_ERR_INVALID_ARGUMENT;
      }
      if (!('0' <= *p && *p <= '7'))
      {
        return NGHTTP3_ERR_INVALID_ARGUMENT;
      }
      pri.urgency = (uint32_t)(*p++ - '0');
      if (p == end)
      {
        goto fin;
      }
      if (*p++ != ',')
      {
        return NGHTTP3_ERR_INVALID_ARGUMENT;
      }
      break;
    case 'i':
      ++p;
      if (p == end)
      {
        pri.inc = 1;
        goto fin;
      }
      if (*p == ',')
      {
        pri.inc = 1;
        ++p;
        break;
      }
      if (p + 3 > end || *p != '=' || *(p + 1) != '?' ||
          (*(p + 2) != '0' && *(p + 2) != '1'))
      {
        return NGHTTP3_ERR_INVALID_ARGUMENT;
      }
      pri.inc = *(p + 2) == '1';
      p += 3;
      if (p == end)
      {
        goto fin;
      }
      if (*p++ != ',')
      {
        return NGHTTP3_ERR_INVALID_ARGUMENT;
      }
      break;
    default:
      return NGHTTP3_ERR_INVALID_ARGUMENT;
    }
    if (p == end)
    {
      return NGHTTP3_ERR_INVALID_ARGUMENT;
    }
  }
fin:
  *dest = pri;
  return 0;
}
static int http_request_on_header(nghttp3_http_state *http, int64_t frame_type,
                                  nghttp3_qpack_nv *nv, int trailers,
                                  int connect_protocol)
{
  nghttp3_pri pri;
  if (nv->name->base[0] == ':')
  {
    if (trailers ||
        (http->flags & NGHTTP3_HTTP_FLAG_PSEUDO_HEADER_DISALLOWED))
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
  }
  switch (nv->token)
  {
  case NGHTTP3_QPACK_TOKEN__AUTHORITY:
    if (!check_pseudo_header(http, nv, NGHTTP3_HTTP_FLAG__AUTHORITY))
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    break;
  case NGHTTP3_QPACK_TOKEN__METHOD:
    if (!check_pseudo_header(http, nv, NGHTTP3_HTTP_FLAG__METHOD))
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    switch (nv->value->len)
    {
    case 4:
      if (((sizeof(("HEAD")) - 1) == (nv->value->len) && memcmp(("HEAD"), (nv->value->base), (nv->value->len)) == 0))
      {
        http->flags |= NGHTTP3_HTTP_FLAG_METH_HEAD;
      }
      break;
    case 7:
      switch (nv->value->base[6])
      {
      case 'T':
        if (((sizeof(("CONNECT")) - 1) == (nv->value->len) && memcmp(("CONNECT"), (nv->value->base), (nv->value->len)) == 0))
        {
          if (frame_type == NGHTTP3_FRAME_PUSH_PROMISE)
          {
            return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
          }
          http->flags |= NGHTTP3_HTTP_FLAG_METH_CONNECT;
        }
        break;
      case 'S':
        if (((sizeof(("OPTIONS")) - 1) == (nv->value->len) && memcmp(("OPTIONS"), (nv->value->base), (nv->value->len)) == 0))
        {
          http->flags |= NGHTTP3_HTTP_FLAG_METH_OPTIONS;
        }
        break;
      }
      break;
    }
    break;
  case NGHTTP3_QPACK_TOKEN__PATH:
    if (!check_pseudo_header(http, nv, NGHTTP3_HTTP_FLAG__PATH))
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    if (nv->value->base[0] == '/')
    {
      http->flags |= NGHTTP3_HTTP_FLAG_PATH_REGULAR;
    }
    else if (nv->value->len == 1 && nv->value->base[0] == '*')
    {
      http->flags |= NGHTTP3_HTTP_FLAG_PATH_ASTERISK;
    }
    break;
  case NGHTTP3_QPACK_TOKEN__SCHEME:
    if (!check_pseudo_header(http, nv, NGHTTP3_HTTP_FLAG__SCHEME))
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    if ((nv->value->len == 4 && memieq("http", nv->value->base, 4)) ||
        (nv->value->len == 5 && memieq("https", nv->value->base, 5)))
    {
      http->flags |= NGHTTP3_HTTP_FLAG_SCHEME_HTTP;
    }
    break;
  case NGHTTP3_QPACK_TOKEN__PROTOCOL:
    if (!connect_protocol)
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    if (!check_pseudo_header(http, nv, NGHTTP3_HTTP_FLAG__PROTOCOL))
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    break;
  case NGHTTP3_QPACK_TOKEN_HOST:
    if (!check_pseudo_header(http, nv, NGHTTP3_HTTP_FLAG_HOST))
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    break;
  case NGHTTP3_QPACK_TOKEN_CONTENT_LENGTH:
  {
    if (trailers)
    {
      return NGHTTP3_ERR_REMOVE_HTTP_HEADER;
    }
    if (http->content_length != -1)
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    http->content_length = parse_uint(nv->value->base, nv->value->len);
    if (http->content_length == -1)
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    break;
  }
  case NGHTTP3_QPACK_TOKEN_CONNECTION:
  case NGHTTP3_QPACK_TOKEN_KEEP_ALIVE:
  case NGHTTP3_QPACK_TOKEN_PROXY_CONNECTION:
  case NGHTTP3_QPACK_TOKEN_TRANSFER_ENCODING:
  case NGHTTP3_QPACK_TOKEN_UPGRADE:
    return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
  case NGHTTP3_QPACK_TOKEN_TE:
    if (!((sizeof(("trailers")) - 1) == (nv->value->len) && memieq(("trailers"), (nv->value->base), (nv->value->len))))
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    break;
  case NGHTTP3_QPACK_TOKEN_PRIORITY:
    pri.urgency = ((uint32_t)((http->pri) & ~(1 << 7)));
    pri.inc = (((http->pri) & (1 << 7)) != 0);
    if (nghttp3_http_parse_priority(&pri, nv->value->base, nv->value->len) ==
        0)
    {
      http->pri = nghttp3_pri_to_uint8(&pri);
    }
    break;
  default:
    if (nv->name->base[0] == ':')
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
  }
  if (nv->name->base[0] != ':')
  {
    http->flags |= NGHTTP3_HTTP_FLAG_PSEUDO_HEADER_DISALLOWED;
  }
  return 0;
}
static int http_response_on_header(nghttp3_http_state *http,
                                   nghttp3_qpack_nv *nv, int trailers)
{
  if (nv->name->base[0] == ':')
  {
    if (trailers ||
        (http->flags & NGHTTP3_HTTP_FLAG_PSEUDO_HEADER_DISALLOWED))
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
  }
  switch (nv->token)
  {
  case NGHTTP3_QPACK_TOKEN__STATUS:
  {
    if (!check_pseudo_header(http, nv, NGHTTP3_HTTP_FLAG__STATUS))
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    if (nv->value->len != 3)
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    http->status_code = (int16_t)parse_uint(nv->value->base, nv->value->len);
    if (http->status_code < 100 || http->status_code == 101)
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    break;
  }
  case NGHTTP3_QPACK_TOKEN_CONTENT_LENGTH:
  {
    if (trailers)
    {
      return NGHTTP3_ERR_REMOVE_HTTP_HEADER;
    }
    if (http->status_code == 204)
    {
      if (http->content_length != -1)
      {
        return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
      }
      if (!((sizeof(("0")) - 1) == (nv->value->len) && memieq(("0"), (nv->value->base), (nv->value->len))))
      {
        return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
      }
      http->content_length = 0;
      return NGHTTP3_ERR_REMOVE_HTTP_HEADER;
    }
    if (http->status_code / 100 == 1)
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    if (http->status_code / 100 == 2 &&
        (http->flags & NGHTTP3_HTTP_FLAG_METH_CONNECT))
    {
      return NGHTTP3_ERR_REMOVE_HTTP_HEADER;
    }
    if (http->content_length != -1)
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    http->content_length = parse_uint(nv->value->base, nv->value->len);
    if (http->content_length == -1)
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    break;
  }
  case NGHTTP3_QPACK_TOKEN_CONNECTION:
  case NGHTTP3_QPACK_TOKEN_KEEP_ALIVE:
  case NGHTTP3_QPACK_TOKEN_PROXY_CONNECTION:
  case NGHTTP3_QPACK_TOKEN_TRANSFER_ENCODING:
  case NGHTTP3_QPACK_TOKEN_UPGRADE:
    return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
  case NGHTTP3_QPACK_TOKEN_TE:
    if (!((sizeof(("trailers")) - 1) == (nv->value->len) && memieq(("trailers"), (nv->value->base), (nv->value->len))))
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    break;
  default:
    if (nv->name->base[0] == ':')
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
  }
  if (nv->name->base[0] != ':')
  {
    http->flags |= NGHTTP3_HTTP_FLAG_PSEUDO_HEADER_DISALLOWED;
  }
  return 0;
}
static char VALID_AUTHORITY_CHARS[] = {
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 1, 0, 0,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 0,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    0, 1, 0, 0,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    0, 1, 0, 1,
    0, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 0,
    0, 0, 1, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0};
static int check_authority(const uint8_t *value, size_t len)
{
  const uint8_t *last;
  for (last = value + len; value != last; ++value)
  {
    if (!VALID_AUTHORITY_CHARS[*value])
    {
      return 0;
    }
  }
  return 1;
}
static int check_scheme(const uint8_t *value, size_t len)
{
  const uint8_t *last;
  if (len == 0)
  {
    return 0;
  }
  if (!(('A' <= *value && *value <= 'Z') || ('a' <= *value && *value <= 'z')))
  {
    return 0;
  }
  last = value + len;
  ++value;
  for (; value != last; ++value)
  {
    if (!(('A' <= *value && *value <= 'Z') ||
          ('a' <= *value && *value <= 'z') ||
          ('0' <= *value && *value <= '9') || *value == '+' || *value == '-' ||
          *value == '.'))
    {
      return 0;
    }
  }
  return 1;
}
int nghttp3_http_on_header(nghttp3_http_state *http, int64_t frame_type,
                           nghttp3_qpack_nv *nv, int request, int trailers)
{
  int rv;
  size_t i;
  uint8_t c;
  if (!nghttp3_check_header_name(nv->name->base, nv->name->len))
  {
    if (nv->name->len > 0 && nv->name->base[0] == ':')
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    for (i = 0; i < nv->name->len; ++i)
    {
      c = nv->name->base[i];
      if ('A' <= c && c <= 'Z')
      {
        return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
      }
    }
    http->flags |= NGHTTP3_HTTP_FLAG_PSEUDO_HEADER_DISALLOWED;
    return NGHTTP3_ERR_REMOVE_HTTP_HEADER;
  }
  if (nv->token == NGHTTP3_QPACK_TOKEN__AUTHORITY ||
      nv->token == NGHTTP3_QPACK_TOKEN_HOST)
  {
    rv = check_authority(nv->value->base, nv->value->len);
  }
  else if (nv->token == NGHTTP3_QPACK_TOKEN__SCHEME)
  {
    rv = check_scheme(nv->value->base, nv->value->len);
  }
  else
  {
    rv = nghttp3_check_header_value(nv->value->base, nv->value->len);
  }
  if (rv == 0)
  {
    assert(nv->name->len > 0);
    if (nv->name->base[0] == ':')
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    http->flags |= NGHTTP3_HTTP_FLAG_PSEUDO_HEADER_DISALLOWED;
    return NGHTTP3_ERR_REMOVE_HTTP_HEADER;
  }
  if (request)
  {
    return http_request_on_header(http, frame_type, nv, trailers,
                                  0);
  }
  return http_response_on_header(http, nv, trailers);
}
int nghttp3_http_on_request_headers(nghttp3_http_state *http)
{
  if (!(http->flags & NGHTTP3_HTTP_FLAG__PROTOCOL) &&
      (http->flags & NGHTTP3_HTTP_FLAG_METH_CONNECT))
  {
    if ((http->flags & (NGHTTP3_HTTP_FLAG__SCHEME | NGHTTP3_HTTP_FLAG__PATH)) ||
        (http->flags & NGHTTP3_HTTP_FLAG__AUTHORITY) == 0)
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    http->content_length = -1;
  }
  else
  {
    if ((http->flags & NGHTTP3_HTTP_FLAG_REQ_HEADERS) !=
            NGHTTP3_HTTP_FLAG_REQ_HEADERS ||
        (http->flags &
         (NGHTTP3_HTTP_FLAG__AUTHORITY | NGHTTP3_HTTP_FLAG_HOST)) == 0)
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    if ((http->flags & NGHTTP3_HTTP_FLAG__PROTOCOL) &&
        ((http->flags & NGHTTP3_HTTP_FLAG_METH_CONNECT) == 0 ||
         (http->flags & NGHTTP3_HTTP_FLAG__AUTHORITY) == 0))
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
    if (!check_path(http))
    {
      return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
    }
  }
  return 0;
}
int nghttp3_http_on_response_headers(nghttp3_http_state *http)
{
  if ((http->flags & NGHTTP3_HTTP_FLAG__STATUS) == 0)
  {
    return NGHTTP3_ERR_MALFORMED_HTTP_HEADER;
  }
  if (http->status_code / 100 == 1)
  {
    http->flags = (uint16_t)((http->flags & NGHTTP3_HTTP_FLAG_METH_ALL) |
                             NGHTTP3_HTTP_FLAG_EXPECT_FINAL_RESPONSE);
    http->content_length = -1;
    http->status_code = -1;
    return 0;
  }
  http->flags =
      (uint16_t)(http->flags & ~NGHTTP3_HTTP_FLAG_EXPECT_FINAL_RESPONSE);
  if (!expect_response_body(http))
  {
    http->content_length = 0;
  }
  else if (http->flags & NGHTTP3_HTTP_FLAG_METH_CONNECT)
  {
    http->content_length = -1;
  }
  return 0;
}
int nghttp3_http_on_remote_end_stream(nghttp3_stream *stream)
{
  if (stream->flags & NGHTTP3_STREAM_FLAG_RESET)
  {
    return 0;
  }
  if ((stream->rx.http.flags & NGHTTP3_HTTP_FLAG_EXPECT_FINAL_RESPONSE) ||
      (stream->rx.http.content_length != -1 &&
       stream->rx.http.content_length != stream->rx.http.recv_content_length))
  {
    return NGHTTP3_ERR_MALFORMED_HTTP_MESSAGING;
  }
  return 0;
}
int nghttp3_http_on_data_chunk(nghttp3_stream *stream, size_t n)
{
  stream->rx.http.recv_content_length += (int64_t)n;
  if ((stream->rx.http.flags & NGHTTP3_HTTP_FLAG_EXPECT_FINAL_RESPONSE) ||
      (stream->rx.http.content_length != -1 &&
       stream->rx.http.recv_content_length > stream->rx.http.content_length))
  {
    return NGHTTP3_ERR_MALFORMED_HTTP_MESSAGING;
  }
  return 0;
}
void nghttp3_http_record_request_method(nghttp3_stream *stream,
                                        const nghttp3_nv *nva, size_t nvlen)
{
  size_t i;
  const nghttp3_nv *nv;
  for (i = 0; i < nvlen; ++i)
  {
    nv = &nva[i];
    if (!(nv->namelen == 7 && nv->name[6] == 'd' &&
          memcmp(":metho", nv->name, nv->namelen - 1) == 0))
    {
      continue;
    }
    if (((sizeof(("CONNECT")) - 1) == (nv->valuelen) && memcmp(("CONNECT"), (nv->value), (nv->valuelen)) == 0))
    {
      stream->rx.http.flags |= NGHTTP3_HTTP_FLAG_METH_CONNECT;
      return;
    }
    if (((sizeof(("HEAD")) - 1) == (nv->valuelen) && memcmp(("HEAD"), (nv->value), (nv->valuelen)) == 0))
    {
      stream->rx.http.flags |= NGHTTP3_HTTP_FLAG_METH_HEAD;
      return;
    }
    return;
  }
}
static const int VALID_HD_NAME_CHARS[] = {
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 1, 0, 1,
    1, 1, 1, 1,
    0, 0, 1, 1,
    0, 1, 1, 0,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 0,
    1, 0, 1, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0};
int nghttp3_check_header_name(const uint8_t *name, size_t len)
{
  const uint8_t *last;
  if (len == 0)
  {
    return 0;
  }
  if (*name == ':')
  {
    if (len == 1)
    {
      return 0;
    }
    ++name;
    --len;
  }
  for (last = name + len; name != last; ++name)
  {
    if (!VALID_HD_NAME_CHARS[*name])
    {
      return 0;
    }
  }
  return 1;
}
static const int VALID_HD_VALUE_CHARS[] = {
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 1, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    0, 0, 0, 0,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 0,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1,
    1, 1, 1, 1};
int nghttp3_check_header_value(const uint8_t *value, size_t len)
{
  const uint8_t *last;
  for (last = value + len; value != last; ++value)
  {
    if (!VALID_HD_VALUE_CHARS[*value])
    {
      return 0;
    }
  }
  return 1;
}
int nghttp3_idtr_init(nghttp3_idtr *idtr, int server, const nghttp3_mem *mem)
{
  int rv;
  rv = nghttp3_gaptr_init(&idtr->gap, mem);
  if (rv != 0)
  {
    return rv;
  }
  idtr->server = server;
  idtr->mem = mem;
  return 0;
}
void nghttp3_idtr_free(nghttp3_idtr *idtr)
{
  if (idtr ==
      __null)
  {
    return;
  }
  nghttp3_gaptr_free(&idtr->gap);
}
static uint64_t id_from_stream_id(int64_t stream_id)
{
  return (uint64_t)(stream_id >> 2);
}
int nghttp3_idtr_open(nghttp3_idtr *idtr, int64_t stream_id)
{
  uint64_t q;
  assert((idtr->server && (stream_id % 2)) ||
         (!idtr->server && (stream_id % 2)) == 0);
  q = id_from_stream_id(stream_id);
  if (nghttp3_gaptr_is_pushed(&idtr->gap, q, 1))
  {
    return NGHTTP3_ERR_STREAM_IN_USE;
  }
  return nghttp3_gaptr_push(&idtr->gap, q, 1);
}
int nghttp3_idtr_is_open(nghttp3_idtr *idtr, int64_t stream_id)
{
  uint64_t q;
  assert((idtr->server && (stream_id % 2)) ||
         (!idtr->server && (stream_id % 2)) == 0);
  q = id_from_stream_id(stream_id);
  return nghttp3_gaptr_is_pushed(&idtr->gap, q, 1);
}
uint64_t nghttp3_idtr_first_gap(nghttp3_idtr *idtr)
{
  return nghttp3_gaptr_first_gap_offset(&idtr->gap);
}
static size_t ksl_nodelen(size_t keylen)
{
  return (sizeof(nghttp3_ksl_node) + keylen - sizeof(uint64_t) + 0xf) &
         (size_t)~0xf;
}
static size_t ksl_blklen(size_t nodelen)
{
  return sizeof(nghttp3_ksl_blk) + nodelen * (2 * 16 - 1) -
         sizeof(uint64_t);
}
static void ksl_node_set_key(nghttp3_ksl *ksl, nghttp3_ksl_node *node,
                             const void *key)
{
  memcpy(node->key, key, ksl->keylen);
}
int nghttp3_ksl_init(nghttp3_ksl *ksl, nghttp3_ksl_compar compar, size_t keylen,
                     const nghttp3_mem *mem)
{
  size_t nodelen = ksl_nodelen(keylen);
  size_t blklen = ksl_blklen(nodelen);
  nghttp3_ksl_blk *head;
  ksl->head = nghttp3_mem_malloc(mem, blklen);
  if (!ksl->head)
  {
    return NGHTTP3_ERR_NOMEM;
  }
  ksl->front = ksl->back = ksl->head;
  ksl->compar = compar;
  ksl->keylen = keylen;
  ksl->nodelen = nodelen;
  ksl->n = 0;
  ksl->mem = mem;
  head = ksl->head;
  head->next = head->prev =
      __null;
  head->n = 0;
  head->leaf = 1;
  return 0;
}
static void ksl_free_blk(nghttp3_ksl *ksl, nghttp3_ksl_blk *blk)
{
  size_t i;
  if (!blk->leaf)
  {
    for (i = 0; i < blk->n; ++i)
    {
      ksl_free_blk(ksl, ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)))->blk);
    }
  }
  nghttp3_mem_free(ksl->mem, blk);
}
void nghttp3_ksl_free(nghttp3_ksl *ksl)
{
  if (!ksl)
  {
    return;
  }
  ksl_free_blk(ksl, ksl->head);
}
static nghttp3_ksl_blk *ksl_split_blk(nghttp3_ksl *ksl, nghttp3_ksl_blk *blk)
{
  nghttp3_ksl_blk *rblk;
  rblk = nghttp3_mem_malloc(ksl->mem, ksl_blklen(ksl->nodelen));
  if (rblk ==
      __null)
  {
    return __null;
  }
  rblk->next = blk->next;
  blk->next = rblk;
  if (rblk->next)
  {
    rblk->next->prev = rblk;
  }
  else if (ksl->back == blk)
  {
    ksl->back = rblk;
  }
  rblk->prev = blk;
  rblk->leaf = blk->leaf;
  rblk->n = blk->n / 2;
  memcpy(rblk->nodes, blk->nodes + ksl->nodelen * (blk->n - rblk->n),
         ksl->nodelen * rblk->n);
  blk->n -= rblk->n;
  assert(blk->n >= (16 - 1));
  assert(rblk->n >= (16 - 1));
  return rblk;
}
static int ksl_split_node(nghttp3_ksl *ksl, nghttp3_ksl_blk *blk, size_t i)
{
  nghttp3_ksl_node *node;
  nghttp3_ksl_blk *lblk = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)))->blk, *rblk;
  rblk = ksl_split_blk(ksl, lblk);
  if (rblk ==
      __null)
  {
    return NGHTTP3_ERR_NOMEM;
  }
  memmove(blk->nodes + (i + 2) * ksl->nodelen,
          blk->nodes + (i + 1) * ksl->nodelen,
          ksl->nodelen * (blk->n - (i + 1)));
  node = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i + 1)));
  node->blk = rblk;
  ++blk->n;
  ksl_node_set_key(ksl, node,
                   ((nghttp3_ksl_node *)(void *)((rblk)->nodes + (ksl)->nodelen * (rblk->n - 1)))->key);
  node = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)));
  ksl_node_set_key(ksl, node,
                   ((nghttp3_ksl_node *)(void *)((lblk)->nodes + (ksl)->nodelen * (lblk->n - 1)))->key);
  return 0;
}
static int ksl_split_head(nghttp3_ksl *ksl)
{
  nghttp3_ksl_blk *rblk =
                      __null,
                  *lblk, *nhead = __null;
  nghttp3_ksl_node *node;
  rblk = ksl_split_blk(ksl, ksl->head);
  if (rblk ==
      __null)
  {
    return NGHTTP3_ERR_NOMEM;
  }
  lblk = ksl->head;
  nhead = nghttp3_mem_malloc(ksl->mem, ksl_blklen(ksl->nodelen));
  if (nhead ==
      __null)
  {
    nghttp3_mem_free(ksl->mem, rblk);
    return NGHTTP3_ERR_NOMEM;
  }
  nhead->next = nhead->prev =
      __null;
  nhead->n = 2;
  nhead->leaf = 0;
  node = ((nghttp3_ksl_node *)(void *)((nhead)->nodes + (ksl)->nodelen * (0)));
  ksl_node_set_key(ksl, node,
                   ((nghttp3_ksl_node *)(void *)((lblk)->nodes + (ksl)->nodelen * (lblk->n - 1)))->key);
  node->blk = lblk;
  node = ((nghttp3_ksl_node *)(void *)((nhead)->nodes + (ksl)->nodelen * (1)));
  ksl_node_set_key(ksl, node,
                   ((nghttp3_ksl_node *)(void *)((rblk)->nodes + (ksl)->nodelen * (rblk->n - 1)))->key);
  node->blk = rblk;
  ksl->head = nhead;
  return 0;
}
static void ksl_insert_node(nghttp3_ksl *ksl, nghttp3_ksl_blk *blk, size_t i,
                            const nghttp3_ksl_key *key, void *data)
{
  nghttp3_ksl_node *node;
  assert(blk->n < (2 * 16 - 1));
  memmove(blk->nodes + (i + 1) * ksl->nodelen, blk->nodes + i * ksl->nodelen,
          ksl->nodelen * (blk->n - i));
  node = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)));
  ksl_node_set_key(ksl, node, key);
  node->data = data;
  ++blk->n;
}
static size_t ksl_bsearch(nghttp3_ksl *ksl, nghttp3_ksl_blk *blk,
                          const nghttp3_ksl_key *key,
                          nghttp3_ksl_compar compar)
{
  nghttp3_ssize left = -1, right = (nghttp3_ssize)blk->n, mid;
  nghttp3_ksl_node *node;
  while (right - left > 1)
  {
    mid = (left + right) / 2;
    node = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * ((size_t)mid)));
    if (compar((nghttp3_ksl_key *)node->key, key))
    {
      left = mid;
    }
    else
    {
      right = mid;
    }
  }
  return (size_t)right;
}
int nghttp3_ksl_insert(nghttp3_ksl *ksl, nghttp3_ksl_it *it,
                       const nghttp3_ksl_key *key, void *data)
{
  nghttp3_ksl_blk *blk = ksl->head;
  nghttp3_ksl_node *node;
  size_t i;
  int rv;
  if (blk->n == (2 * 16 - 1))
  {
    rv = ksl_split_head(ksl);
    if (rv != 0)
    {
      return rv;
    }
    blk = ksl->head;
  }
  for (;;)
  {
    i = ksl_bsearch(ksl, blk, key, ksl->compar);
    if (blk->leaf)
    {
      if (i < blk->n &&
          !ksl->compar(key, ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)))->key))
      {
        if (it)
        {
          *it = nghttp3_ksl_end(ksl);
        }
        return NGHTTP3_ERR_INVALID_ARGUMENT;
      }
      ksl_insert_node(ksl, blk, i, key, data);
      ++ksl->n;
      if (it)
      {
        nghttp3_ksl_it_init(it, ksl, blk, i);
      }
      return 0;
    }
    if (i == blk->n)
    {
      for (; !blk->leaf;)
      {
        node = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (blk->n - 1)));
        if (node->blk->n == (2 * 16 - 1))
        {
          rv = ksl_split_node(ksl, blk, blk->n - 1);
          if (rv != 0)
          {
            return rv;
          }
          node = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (blk->n - 1)));
        }
        ksl_node_set_key(ksl, node, key);
        blk = node->blk;
      }
      ksl_insert_node(ksl, blk, blk->n, key, data);
      ++ksl->n;
      if (it)
      {
        nghttp3_ksl_it_init(it, ksl, blk, blk->n - 1);
      }
      return 0;
    }
    node = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)));
    if (node->blk->n == (2 * 16 - 1))
    {
      rv = ksl_split_node(ksl, blk, i);
      if (rv != 0)
      {
        return rv;
      }
      if (ksl->compar((nghttp3_ksl_key *)node->key, key))
      {
        node = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i + 1)));
        if (ksl->compar((nghttp3_ksl_key *)node->key, key))
        {
          ksl_node_set_key(ksl, node, key);
        }
      }
    }
    blk = node->blk;
  }
}
static void ksl_remove_node(nghttp3_ksl *ksl, nghttp3_ksl_blk *blk, size_t i)
{
  memmove(blk->nodes + i * ksl->nodelen, blk->nodes + (i + 1) * ksl->nodelen,
          ksl->nodelen * (blk->n - (i + 1)));
  --blk->n;
}
static nghttp3_ksl_blk *ksl_merge_node(nghttp3_ksl *ksl, nghttp3_ksl_blk *blk,
                                       size_t i)
{
  nghttp3_ksl_blk *lblk, *rblk;
  assert(i + 1 < blk->n);
  lblk = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)))->blk;
  rblk = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i + 1)))->blk;
  assert(lblk->n + rblk->n < (2 * 16 - 1));
  memcpy(lblk->nodes + ksl->nodelen * lblk->n, rblk->nodes,
         ksl->nodelen * rblk->n);
  lblk->n += rblk->n;
  lblk->next = rblk->next;
  if (lblk->next)
  {
    lblk->next->prev = lblk;
  }
  else if (ksl->back == rblk)
  {
    ksl->back = lblk;
  }
  nghttp3_mem_free(ksl->mem, rblk);
  if (ksl->head == blk && blk->n == 2)
  {
    nghttp3_mem_free(ksl->mem, ksl->head);
    ksl->head = lblk;
  }
  else
  {
    ksl_remove_node(ksl, blk, i + 1);
    ksl_node_set_key(ksl, ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i))),
                     ((nghttp3_ksl_node *)(void *)((lblk)->nodes + (ksl)->nodelen * (lblk->n - 1)))->key);
  }
  return lblk;
}
static void ksl_shift_left(nghttp3_ksl *ksl, nghttp3_ksl_blk *blk, size_t i)
{
  nghttp3_ksl_node *lnode, *rnode, *dest, *src;
  assert(i > 0);
  lnode = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i - 1)));
  rnode = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)));
  assert(lnode->blk->n < (2 * 16 - 1));
  assert(rnode->blk->n > (16 - 1));
  dest = ((nghttp3_ksl_node *)(void *)((lnode->blk)->nodes + (ksl)->nodelen * (lnode->blk->n)));
  src = ((nghttp3_ksl_node *)(void *)((rnode->blk)->nodes + (ksl)->nodelen * (0)));
  memcpy(dest, src, ksl->nodelen);
  ksl_node_set_key(ksl, lnode, dest->key);
  ++lnode->blk->n;
  --rnode->blk->n;
  memmove(rnode->blk->nodes, rnode->blk->nodes + ksl->nodelen,
          ksl->nodelen * rnode->blk->n);
}
static void ksl_shift_right(nghttp3_ksl *ksl, nghttp3_ksl_blk *blk, size_t i)
{
  nghttp3_ksl_node *lnode, *rnode, *dest, *src;
  assert(i < blk->n - 1);
  lnode = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)));
  rnode = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i + 1)));
  assert(lnode->blk->n > (16 - 1));
  assert(rnode->blk->n < (2 * 16 - 1));
  memmove(rnode->blk->nodes + ksl->nodelen, rnode->blk->nodes,
          ksl->nodelen * rnode->blk->n);
  ++rnode->blk->n;
  dest = ((nghttp3_ksl_node *)(void *)((rnode->blk)->nodes + (ksl)->nodelen * (0)));
  src = ((nghttp3_ksl_node *)(void *)((lnode->blk)->nodes + (ksl)->nodelen * (lnode->blk->n - 1)));
  memcpy(dest, src, ksl->nodelen);
  --lnode->blk->n;
  ksl_node_set_key(
      ksl, lnode,
      ((nghttp3_ksl_node *)(void *)((lnode->blk)->nodes + (ksl)->nodelen * (lnode->blk->n - 1)))->key);
}
static int key_equal(nghttp3_ksl_compar compar, const nghttp3_ksl_key *lhs,
                     const nghttp3_ksl_key *rhs)
{
  return !compar(lhs, rhs) && !compar(rhs, lhs);
}
int nghttp3_ksl_remove(nghttp3_ksl *ksl, nghttp3_ksl_it *it,
                       const nghttp3_ksl_key *key)
{
  nghttp3_ksl_blk *blk = ksl->head;
  nghttp3_ksl_node *node;
  size_t i;
  if (!blk->leaf && blk->n == 2 &&
      ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (0)))->blk->n == (16 - 1) &&
      ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (1)))->blk->n == (16 - 1))
  {
    blk = ksl_merge_node(ksl, ksl->head, 0);
  }
  for (;;)
  {
    i = ksl_bsearch(ksl, blk, key, ksl->compar);
    if (i == blk->n)
    {
      if (it)
      {
        *it = nghttp3_ksl_end(ksl);
      }
      return NGHTTP3_ERR_INVALID_ARGUMENT;
    }
    if (blk->leaf)
    {
      if (ksl->compar(key, ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)))->key))
      {
        if (it)
        {
          *it = nghttp3_ksl_end(ksl);
        }
        return NGHTTP3_ERR_INVALID_ARGUMENT;
      }
      ksl_remove_node(ksl, blk, i);
      --ksl->n;
      if (it)
      {
        if (blk->n == i && blk->next)
        {
          nghttp3_ksl_it_init(it, ksl, blk->next, 0);
        }
        else
        {
          nghttp3_ksl_it_init(it, ksl, blk, i);
        }
      }
      return 0;
    }
    node = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)));
    if (node->blk->n == (16 - 1))
    {
      if (i > 0 && ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i - 1)))->blk->n >
                       (16 - 1))
      {
        ksl_shift_right(ksl, blk, i - 1);
        blk = node->blk;
      }
      else if (i + 1 < blk->n &&
               ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i + 1)))->blk->n >
                   (16 - 1))
      {
        ksl_shift_left(ksl, blk, i + 1);
        blk = node->blk;
      }
      else if (i > 0)
      {
        blk = ksl_merge_node(ksl, blk, i - 1);
      }
      else
      {
        assert(i + 1 < blk->n);
        blk = ksl_merge_node(ksl, blk, i);
      }
    }
    else
    {
      blk = node->blk;
    }
  }
}
nghttp3_ksl_it nghttp3_ksl_lower_bound(nghttp3_ksl *ksl,
                                       const nghttp3_ksl_key *key)
{
  nghttp3_ksl_blk *blk = ksl->head;
  nghttp3_ksl_it it;
  size_t i;
  for (;;)
  {
    i = ksl_bsearch(ksl, blk, key, ksl->compar);
    if (blk->leaf)
    {
      if (i == blk->n && blk->next)
      {
        blk = blk->next;
        i = 0;
      }
      nghttp3_ksl_it_init(&it, ksl, blk, i);
      return it;
    }
    if (i == blk->n)
    {
      for (; !blk->leaf; blk = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (blk->n - 1)))->blk)
        ;
      if (blk->next)
      {
        blk = blk->next;
        i = 0;
      }
      else
      {
        i = blk->n;
      }
      nghttp3_ksl_it_init(&it, ksl, blk, i);
      return it;
    }
    blk = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)))->blk;
  }
}
nghttp3_ksl_it nghttp3_ksl_lower_bound_compar(nghttp3_ksl *ksl,
                                              const nghttp3_ksl_key *key,
                                              nghttp3_ksl_compar compar)
{
  nghttp3_ksl_blk *blk = ksl->head;
  nghttp3_ksl_it it;
  size_t i;
  for (;;)
  {
    i = ksl_bsearch(ksl, blk, key, compar);
    if (blk->leaf)
    {
      if (i == blk->n && blk->next)
      {
        blk = blk->next;
        i = 0;
      }
      nghttp3_ksl_it_init(&it, ksl, blk, i);
      return it;
    }
    if (i == blk->n)
    {
      for (; !blk->leaf; blk = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (blk->n - 1)))->blk)
        ;
      if (blk->next)
      {
        blk = blk->next;
        i = 0;
      }
      else
      {
        i = blk->n;
      }
      nghttp3_ksl_it_init(&it, ksl, blk, i);
      return it;
    }
    blk = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)))->blk;
  }
}
void nghttp3_ksl_update_key(nghttp3_ksl *ksl, const nghttp3_ksl_key *old_key,
                            const nghttp3_ksl_key *new_key)
{
  nghttp3_ksl_blk *blk = ksl->head;
  nghttp3_ksl_node *node;
  size_t i;
  for (;;)
  {
    i = ksl_bsearch(ksl, blk, old_key, ksl->compar);
    assert(i < blk->n);
    node = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)));
    if (blk->leaf)
    {
      assert(key_equal(ksl->compar, (nghttp3_ksl_key *)node->key, old_key));
      ksl_node_set_key(ksl, node, new_key);
      return;
    }
    if (key_equal(ksl->compar, (nghttp3_ksl_key *)node->key, old_key) ||
        ksl->compar((nghttp3_ksl_key *)node->key, new_key))
    {
      ksl_node_set_key(ksl, node, new_key);
    }
    blk = node->blk;
  }
}
static void ksl_print(nghttp3_ksl *ksl, nghttp3_ksl_blk *blk, size_t level)
{
  size_t i;
  nghttp3_ksl_node *node;
  fprintf(
      stderr, "LV=%zu n=%zu\n", level, blk->n);
  if (blk->leaf)
  {
    for (i = 0; i < blk->n; ++i)
    {
      node = ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)));
      fprintf(
          stderr, " %"
                  "l"
                  "d",
          *(int64_t *)(void *)node->key);
    }
    fprintf(
        stderr, "\n");
    return;
  }
  for (i = 0; i < blk->n; ++i)
  {
    ksl_print(ksl, ((nghttp3_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)))->blk, level + 1);
  }
}
size_t nghttp3_ksl_len(nghttp3_ksl *ksl) { return ksl->n; }
void nghttp3_ksl_clear(nghttp3_ksl *ksl)
{
  size_t i;
  nghttp3_ksl_blk *head;
  if (!ksl->head->leaf)
  {
    for (i = 0; i < ksl->head->n; ++i)
    {
      ksl_free_blk(ksl, ((nghttp3_ksl_node *)(void *)((ksl->head)->nodes + (ksl)->nodelen * (i)))->blk);
    }
  }
  ksl->front = ksl->back = ksl->head;
  ksl->n = 0;
  head = ksl->head;
  head->next = head->prev =
      __null;
  head->n = 0;
  head->leaf = 1;
}
void nghttp3_ksl_print(nghttp3_ksl *ksl) { ksl_print(ksl, ksl->head, 0); }
nghttp3_ksl_it nghttp3_ksl_begin(const nghttp3_ksl *ksl)
{
  nghttp3_ksl_it it;
  nghttp3_ksl_it_init(&it, ksl, ksl->front, 0);
  return it;
}
nghttp3_ksl_it nghttp3_ksl_end(const nghttp3_ksl *ksl)
{
  nghttp3_ksl_it it;
  nghttp3_ksl_it_init(&it, ksl, ksl->back, ksl->back->n);
  return it;
}
void nghttp3_ksl_it_init(nghttp3_ksl_it *it, const nghttp3_ksl *ksl,
                         nghttp3_ksl_blk *blk, size_t i)
{
  it->ksl = ksl;
  it->blk = blk;
  it->i = i;
}
void *nghttp3_ksl_it_get(const nghttp3_ksl_it *it)
{
  assert(it->i < it->blk->n);
  return ((nghttp3_ksl_node *)(void *)((it->blk)->nodes + (it->ksl)->nodelen * (it->i)))->data;
}
void nghttp3_ksl_it_prev(nghttp3_ksl_it *it)
{
  assert(!nghttp3_ksl_it_begin(it));
  if (it->i == 0)
  {
    it->blk = it->blk->prev;
    it->i = it->blk->n - 1;
  }
  else
  {
    --it->i;
  }
}
int nghttp3_ksl_it_begin(const nghttp3_ksl_it *it)
{
  return it->i == 0 && it->blk->prev ==
                           __null;
}
int nghttp3_ksl_range_compar(const nghttp3_ksl_key *lhs,
                             const nghttp3_ksl_key *rhs)
{
  const nghttp3_range *a = lhs, *b = rhs;
  return a->begin < b->begin;
}
int nghttp3_ksl_range_exclusive_compar(const nghttp3_ksl_key *lhs,
                                       const nghttp3_ksl_key *rhs)
{
  const nghttp3_range *a = lhs, *b = rhs;
  return a->begin < b->begin &&
         !(((a->begin) > (b->begin) ? (a->begin) : (b->begin)) < ((a->end) < (b->end) ? (a->end) : (b->end)));
}
int nghttp3_map_init(nghttp3_map *map, const nghttp3_mem *mem)
{
  map->mem = mem;
  map->tablelen = 256;
  map->table =
      nghttp3_mem_calloc(mem, map->tablelen, sizeof(nghttp3_map_bucket));
  if (map->table ==
      __null)
  {
    return NGHTTP3_ERR_NOMEM;
  }
  map->size = 0;
  return 0;
}
void nghttp3_map_free(nghttp3_map *map)
{
  size_t i;
  nghttp3_map_bucket *bkt;
  if (!map)
  {
    return;
  }
  for (i = 0; i < map->tablelen; ++i)
  {
    bkt = &map->table[i];
    if (bkt->ksl)
    {
      nghttp3_ksl_free(bkt->ksl);
      nghttp3_mem_free(map->mem, bkt->ksl);
    }
  }
  nghttp3_mem_free(map->mem, map->table);
}
void nghttp3_map_each_free(nghttp3_map *map,
                           int (*func)(nghttp3_map_entry *entry, void *ptr),
                           void *ptr)
{
  uint32_t i;
  nghttp3_map_bucket *bkt;
  nghttp3_ksl_it it;
  for (i = 0; i < map->tablelen; ++i)
  {
    bkt = &map->table[i];
    if (bkt->ptr)
    {
      func(bkt->ptr, ptr);
      bkt->ptr =
          __null;
      assert(bkt->ksl ==
                 __null ||
             nghttp3_ksl_len(bkt->ksl) == 0);
      continue;
    }
    if (bkt->ksl)
    {
      for (it = nghttp3_ksl_begin(bkt->ksl); !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                                                __null);
           (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
      {
        func(nghttp3_ksl_it_get(&it), ptr);
      }
      nghttp3_ksl_free(bkt->ksl);
      nghttp3_mem_free(map->mem, bkt->ksl);
      bkt->ksl =
          __null;
    }
  }
}
int nghttp3_map_each(nghttp3_map *map,
                     int (*func)(nghttp3_map_entry *entry, void *ptr),
                     void *ptr)
{
  int rv;
  uint32_t i;
  nghttp3_map_bucket *bkt;
  nghttp3_ksl_it it;
  for (i = 0; i < map->tablelen; ++i)
  {
    bkt = &map->table[i];
    if (bkt->ptr)
    {
      rv = func(bkt->ptr, ptr);
      if (rv != 0)
      {
        return rv;
      }
      assert(bkt->ksl ==
                 __null ||
             nghttp3_ksl_len(bkt->ksl) == 0);
      continue;
    }
    if (bkt->ksl)
    {
      for (it = nghttp3_ksl_begin(bkt->ksl); !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                                                __null);
           (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
      {
        rv = func(nghttp3_ksl_it_get(&it), ptr);
        if (rv != 0)
        {
          return rv;
        }
      }
    }
  }
  return 0;
}
void nghttp3_map_entry_init(nghttp3_map_entry *entry, key_type key)
{
  entry->key = key;
  entry->next =
      __null;
}
static uint32_t hash(key_type key, uint32_t mod)
{
  uint8_t *p, *end;
  uint32_t h = 0x811C9DC5u;
  key = ((uint64_t)(ntohl((uint32_t)(key))) << 32 | ntohl((uint32_t)((key) >> 32)));
  p = (uint8_t *)&key;
  end = p + sizeof(key_type);
  for (; p != end;)
  {
    h ^= *p++;
    h += (h << 1) + (h << 4) + (h << 7) + (h << 8) + (h << 24);
  }
  return h & (mod - 1);
}
static int less(const nghttp3_ksl_key *lhs, const nghttp3_ksl_key *rhs)
{
  return *(key_type *)lhs < *(key_type *)rhs;
}
static int map_insert(nghttp3_map *map, nghttp3_map_bucket *table,
                      uint32_t tablelen, nghttp3_map_entry *entry)
{
  uint32_t h = hash(entry->key, tablelen);
  nghttp3_map_bucket *bkt = &table[h];
  const nghttp3_mem *mem = map->mem;
  int rv;
  if (bkt->ptr ==
          __null &&
      (bkt->ksl ==
           __null ||
       nghttp3_ksl_len(bkt->ksl) == 0))
  {
    bkt->ptr = entry;
    return 0;
  }
  if (!bkt->ksl)
  {
    bkt->ksl = nghttp3_mem_malloc(mem, sizeof(*bkt->ksl));
    if (bkt->ksl ==
        __null)
    {
      return NGHTTP3_ERR_NOMEM;
    }
    nghttp3_ksl_init(bkt->ksl, less, sizeof(key_type), mem);
  }
  if (bkt->ptr)
  {
    rv = nghttp3_ksl_insert(bkt->ksl,
                            __null, &bkt->ptr->key, bkt->ptr);
    if (rv != 0)
    {
      return rv;
    }
    bkt->ptr =
        __null;
  }
  return nghttp3_ksl_insert(bkt->ksl,
                            __null, &entry->key, entry);
}
static int map_resize(nghttp3_map *map, uint32_t new_tablelen)
{
  uint32_t i;
  nghttp3_map_bucket *new_table;
  nghttp3_map_bucket *bkt;
  nghttp3_ksl_it it;
  int rv;
  new_table =
      nghttp3_mem_calloc(map->mem, new_tablelen, sizeof(nghttp3_map_bucket));
  if (new_table ==
      __null)
  {
    return NGHTTP3_ERR_NOMEM;
  }
  for (i = 0; i < map->tablelen; ++i)
  {
    bkt = &map->table[i];
    if (bkt->ptr)
    {
      rv = map_insert(map, new_table, new_tablelen, bkt->ptr);
      if (rv != 0)
      {
        goto fail;
      }
      assert(bkt->ksl ==
                 __null ||
             nghttp3_ksl_len(bkt->ksl) == 0);
      continue;
    }
    if (bkt->ksl)
    {
      for (it = nghttp3_ksl_begin(bkt->ksl); !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                                                __null);
           (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
      {
        rv = map_insert(map, new_table, new_tablelen, nghttp3_ksl_it_get(&it));
        if (rv != 0)
        {
          goto fail;
        }
      }
    }
  }
  for (i = 0; i < map->tablelen; ++i)
  {
    bkt = &map->table[i];
    if (bkt->ksl)
    {
      nghttp3_ksl_free(bkt->ksl);
      nghttp3_mem_free(map->mem, bkt->ksl);
    }
  }
  nghttp3_mem_free(map->mem, map->table);
  map->tablelen = new_tablelen;
  map->table = new_table;
  return 0;
fail:
  for (i = 0; i < new_tablelen; ++i)
  {
    bkt = &new_table[i];
    if (bkt->ksl)
    {
      nghttp3_ksl_free(bkt->ksl);
      nghttp3_mem_free(map->mem, bkt->ksl);
    }
  }
  return rv;
}
int nghttp3_map_insert(nghttp3_map *map, nghttp3_map_entry *new_entry)
{
  int rv;
  if ((map->size + 1) * 4 > map->tablelen * 3)
  {
    rv = map_resize(map, map->tablelen * 2);
    if (rv != 0)
    {
      return rv;
    }
  }
  rv = map_insert(map, map->table, map->tablelen, new_entry);
  if (rv != 0)
  {
    return rv;
  }
  ++map->size;
  return 0;
}
nghttp3_map_entry *nghttp3_map_find(nghttp3_map *map, key_type key)
{
  nghttp3_map_bucket *bkt = &map->table[hash(key, map->tablelen)];
  nghttp3_ksl_it it;
  if (bkt->ptr)
  {
    if (bkt->ptr->key == key)
    {
      return bkt->ptr;
    }
    return __null;
  }
  if (bkt->ksl)
  {
    it = nghttp3_ksl_lower_bound(bkt->ksl, &key);
    if (((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                          __null) ||
        *(key_type *)((nghttp3_ksl_key *)((nghttp3_ksl_node *)(void *)(((&it)->blk)->nodes + ((&it)->ksl)->nodelen * ((&it)->i)))->key) != key)
    {
      return __null;
    }
    return nghttp3_ksl_it_get(&it);
  }
  return __null;
}
int nghttp3_map_remove(nghttp3_map *map, key_type key)
{
  nghttp3_map_bucket *bkt = &map->table[hash(key, map->tablelen)];
  int rv;
  if (bkt->ptr)
  {
    if (bkt->ptr->key == key)
    {
      bkt->ptr =
          __null;
      --map->size;
      return 0;
    }
    return NGHTTP3_ERR_INVALID_ARGUMENT;
  }
  if (bkt->ksl)
  {
    rv = nghttp3_ksl_remove(bkt->ksl,
                            __null, &key);
    if (rv != 0)
    {
      return rv;
    }
    --map->size;
    return 0;
  }
  return NGHTTP3_ERR_INVALID_ARGUMENT;
}
void nghttp3_map_clear(nghttp3_map *map)
{
  uint32_t i;
  nghttp3_map_bucket *bkt;
  for (i = 0; i < map->tablelen; ++i)
  {
    bkt = &map->table[i];
    bkt->ptr =
        __null;
    if (bkt->ksl)
    {
      nghttp3_ksl_free(bkt->ksl);
      nghttp3_mem_free(map->mem, bkt->ksl);
      bkt->ksl =
          __null;
    }
  }
  map->size = 0;
}
size_t nghttp3_map_size(nghttp3_map *map) { return map->size; }
static void *default_malloc(size_t size, void *mem_user_data)
{
  (void)mem_user_data;
  return malloc(size);
}
static void default_free(void *ptr, void *mem_user_data)
{
  (void)mem_user_data;
  free(ptr);
}
static void *default_calloc(size_t nmemb, size_t size, void *mem_user_data)
{
  (void)mem_user_data;
  return calloc(nmemb, size);
}
static void *default_realloc(void *ptr, size_t size, void *mem_user_data)
{
  (void)mem_user_data;
  return realloc(ptr, size);
}
static nghttp3_mem mem_default = {
    __null, default_malloc, default_free,
    default_calloc, default_realloc};
const nghttp3_mem *nghttp3_mem_default(void) { return &mem_default; }
void *nghttp3_mem_malloc(const nghttp3_mem *mem, size_t size)
{
  return mem->malloc(size, mem->mem_user_data);
}
void nghttp3_mem_free(const nghttp3_mem *mem, void *ptr)
{
  mem->free(ptr, mem->mem_user_data);
}
void nghttp3_mem_free2(const nghttp3_free free_func, void *ptr,
                       void *mem_user_data)
{
  free_func(ptr, mem_user_data);
}
void *nghttp3_mem_calloc(const nghttp3_mem *mem, size_t nmemb, size_t size)
{
  return mem->calloc(nmemb, size, mem->mem_user_data);
}
void *nghttp3_mem_realloc(const nghttp3_mem *mem, void *ptr, size_t size)
{
  return mem->realloc(ptr, size, mem->mem_user_data);
}
void nghttp3_pq_init(nghttp3_pq *pq, nghttp3_less less,
                     const nghttp3_mem *mem)
{
  pq->mem = mem;
  pq->capacity = 0;
  pq->q =
      __null;
  pq->length = 0;
  pq->less = less;
}
void nghttp3_pq_free(nghttp3_pq *pq)
{
  nghttp3_mem_free(pq->mem, pq->q);
  pq->q =
      __null;
}
static void swap(nghttp3_pq *pq, size_t i, size_t j)
{
  nghttp3_pq_entry *a = pq->q[i];
  nghttp3_pq_entry *b = pq->q[j];
  pq->q[i] = b;
  b->index = i;
  pq->q[j] = a;
  a->index = j;
}
static void bubble_up(nghttp3_pq *pq, size_t index)
{
  size_t parent;
  while (index != 0)
  {
    parent = (index - 1) / 2;
    if (!pq->less(pq->q[index], pq->q[parent]))
    {
      return;
    }
    swap(pq, parent, index);
    index = parent;
  }
}
int nghttp3_pq_push(nghttp3_pq *pq, nghttp3_pq_entry *item)
{
  if (pq->capacity <= pq->length)
  {
    void *nq;
    size_t ncapacity;
    ncapacity = ((4) > ((pq->capacity * 2)) ? (4) : ((pq->capacity * 2)));
    nq = nghttp3_mem_realloc(pq->mem, pq->q,
                             ncapacity * sizeof(nghttp3_pq_entry *));
    if (nq ==
        __null)
    {
      return NGHTTP3_ERR_NOMEM;
    }
    pq->capacity = ncapacity;
    pq->q = nq;
  }
  pq->q[pq->length] = item;
  item->index = pq->length;
  ++pq->length;
  bubble_up(pq, pq->length - 1);
  return 0;
}
nghttp3_pq_entry *nghttp3_pq_top(const nghttp3_pq *pq)
{
  assert(pq->length);
  return pq->q[0];
}
static void bubble_down(nghttp3_pq *pq, size_t index)
{
  size_t i, j, minindex;
  for (;;)
  {
    j = index * 2 + 1;
    minindex = index;
    for (i = 0; i < 2; ++i, ++j)
    {
      if (j >= pq->length)
      {
        break;
      }
      if (pq->less(pq->q[j], pq->q[minindex]))
      {
        minindex = j;
      }
    }
    if (minindex == index)
    {
      return;
    }
    swap(pq, index, minindex);
    index = minindex;
  }
}
void nghttp3_pq_pop(nghttp3_pq *pq)
{
  if (pq->length > 0)
  {
    pq->q[0] = pq->q[pq->length - 1];
    pq->q[0]->index = 0;
    --pq->length;
    bubble_down(pq, 0);
  }
}
void nghttp3_pq_remove(nghttp3_pq *pq, nghttp3_pq_entry *item)
{
  assert(pq->q[item->index] == item);
  if (item->index == 0)
  {
    nghttp3_pq_pop(pq);
    return;
  }
  if (item->index == pq->length - 1)
  {
    --pq->length;
    return;
  }
  pq->q[item->index] = pq->q[pq->length - 1];
  pq->q[item->index]->index = item->index;
  --pq->length;
  if (pq->less(item, pq->q[item->index]))
  {
    bubble_down(pq, item->index);
  }
  else
  {
    bubble_up(pq, item->index);
  }
}
int nghttp3_pq_empty(const nghttp3_pq *pq) { return pq->length == 0; }
size_t nghttp3_pq_size(const nghttp3_pq *pq) { return pq->length; }
int nghttp3_pq_each(const nghttp3_pq *pq, nghttp3_pq_item_cb fun, void *arg)
{
  size_t i;
  if (pq->length == 0)
  {
    return 0;
  }
  for (i = 0; i < pq->length; ++i)
  {
    if ((*fun)(pq->q[i], arg))
    {
      return 1;
    }
  }
  return 0;
}
void nghttp3_pq_clear(nghttp3_pq *pq) { pq->length = 0; }
static nghttp3_qpack_static_entry token_stable[] = {
    {0, NGHTTP3_QPACK_TOKEN__AUTHORITY, 3153725150u},
    {15, NGHTTP3_QPACK_TOKEN__METHOD, 695666056u},
    {16, NGHTTP3_QPACK_TOKEN__METHOD, 695666056u},
    {17, NGHTTP3_QPACK_TOKEN__METHOD, 695666056u},
    {18, NGHTTP3_QPACK_TOKEN__METHOD, 695666056u},
    {19, NGHTTP3_QPACK_TOKEN__METHOD, 695666056u},
    {20, NGHTTP3_QPACK_TOKEN__METHOD, 695666056u},
    {21, NGHTTP3_QPACK_TOKEN__METHOD, 695666056u},
    {1, NGHTTP3_QPACK_TOKEN__PATH, 3292848686u},
    {22, NGHTTP3_QPACK_TOKEN__SCHEME, 2510477674u},
    {23, NGHTTP3_QPACK_TOKEN__SCHEME, 2510477674u},
    {24, NGHTTP3_QPACK_TOKEN__STATUS, 4000288983u},
    {25, NGHTTP3_QPACK_TOKEN__STATUS, 4000288983u},
    {26, NGHTTP3_QPACK_TOKEN__STATUS, 4000288983u},
    {27, NGHTTP3_QPACK_TOKEN__STATUS, 4000288983u},
    {28, NGHTTP3_QPACK_TOKEN__STATUS, 4000288983u},
    {63, NGHTTP3_QPACK_TOKEN__STATUS, 4000288983u},
    {64, NGHTTP3_QPACK_TOKEN__STATUS, 4000288983u},
    {65, NGHTTP3_QPACK_TOKEN__STATUS, 4000288983u},
    {66, NGHTTP3_QPACK_TOKEN__STATUS, 4000288983u},
    {67, NGHTTP3_QPACK_TOKEN__STATUS, 4000288983u},
    {68, NGHTTP3_QPACK_TOKEN__STATUS, 4000288983u},
    {69, NGHTTP3_QPACK_TOKEN__STATUS, 4000288983u},
    {70, NGHTTP3_QPACK_TOKEN__STATUS, 4000288983u},
    {71, NGHTTP3_QPACK_TOKEN__STATUS, 4000288983u},
    {29, NGHTTP3_QPACK_TOKEN_ACCEPT, 136609321u},
    {30, NGHTTP3_QPACK_TOKEN_ACCEPT, 136609321u},
    {31, NGHTTP3_QPACK_TOKEN_ACCEPT_ENCODING, 3379649177u},
    {72, NGHTTP3_QPACK_TOKEN_ACCEPT_LANGUAGE, 1979086614u},
    {32, NGHTTP3_QPACK_TOKEN_ACCEPT_RANGES, 1713753958u},
    {73, NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_CREDENTIALS, 901040780u},
    {74, NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_CREDENTIALS, 901040780u},
    {33, NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_HEADERS, 1524311232u},
    {34, NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_HEADERS, 1524311232u},
    {75, NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_HEADERS, 1524311232u},
    {76, NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_METHODS, 2175229868u},
    {77, NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_METHODS, 2175229868u},
    {78, NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_METHODS, 2175229868u},
    {35, NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_ORIGIN, 2710797292u},
    {79, NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_EXPOSE_HEADERS, 2449824425u},
    {80, NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_REQUEST_HEADERS, 3599549072u},
    {81, NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_REQUEST_METHOD, 2417078055u},
    {82, NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_REQUEST_METHOD, 2417078055u},
    {2, NGHTTP3_QPACK_TOKEN_AGE, 742476188u},
    {83, NGHTTP3_QPACK_TOKEN_ALT_SVC, 2148877059u},
    {84, NGHTTP3_QPACK_TOKEN_AUTHORIZATION, 2436257726u},
    {36, NGHTTP3_QPACK_TOKEN_CACHE_CONTROL, 1355326669u},
    {37, NGHTTP3_QPACK_TOKEN_CACHE_CONTROL, 1355326669u},
    {38, NGHTTP3_QPACK_TOKEN_CACHE_CONTROL, 1355326669u},
    {39, NGHTTP3_QPACK_TOKEN_CACHE_CONTROL, 1355326669u},
    {40, NGHTTP3_QPACK_TOKEN_CACHE_CONTROL, 1355326669u},
    {41, NGHTTP3_QPACK_TOKEN_CACHE_CONTROL, 1355326669u},
    {3, NGHTTP3_QPACK_TOKEN_CONTENT_DISPOSITION, 3889184348u},
    {42, NGHTTP3_QPACK_TOKEN_CONTENT_ENCODING, 65203592u},
    {43, NGHTTP3_QPACK_TOKEN_CONTENT_ENCODING, 65203592u},
    {4, NGHTTP3_QPACK_TOKEN_CONTENT_LENGTH, 1308181789u},
    {85, NGHTTP3_QPACK_TOKEN_CONTENT_SECURITY_POLICY, 1569039836u},
    {44, NGHTTP3_QPACK_TOKEN_CONTENT_TYPE, 4244048277u},
    {45, NGHTTP3_QPACK_TOKEN_CONTENT_TYPE, 4244048277u},
    {46, NGHTTP3_QPACK_TOKEN_CONTENT_TYPE, 4244048277u},
    {47, NGHTTP3_QPACK_TOKEN_CONTENT_TYPE, 4244048277u},
    {48, NGHTTP3_QPACK_TOKEN_CONTENT_TYPE, 4244048277u},
    {49, NGHTTP3_QPACK_TOKEN_CONTENT_TYPE, 4244048277u},
    {50, NGHTTP3_QPACK_TOKEN_CONTENT_TYPE, 4244048277u},
    {51, NGHTTP3_QPACK_TOKEN_CONTENT_TYPE, 4244048277u},
    {52, NGHTTP3_QPACK_TOKEN_CONTENT_TYPE, 4244048277u},
    {53, NGHTTP3_QPACK_TOKEN_CONTENT_TYPE, 4244048277u},
    {54, NGHTTP3_QPACK_TOKEN_CONTENT_TYPE, 4244048277u},
    {5, NGHTTP3_QPACK_TOKEN_COOKIE, 2007449791u},
    {6, NGHTTP3_QPACK_TOKEN_DATE, 3564297305u},
    {86, NGHTTP3_QPACK_TOKEN_EARLY_DATA, 4080895051u},
    {7, NGHTTP3_QPACK_TOKEN_ETAG, 113792960u},
    {87, NGHTTP3_QPACK_TOKEN_EXPECT_CT, 1183214960u},
    {88, NGHTTP3_QPACK_TOKEN_FORWARDED, 1485178027u},
    {8, NGHTTP3_QPACK_TOKEN_IF_MODIFIED_SINCE, 2213050793u},
    {9, NGHTTP3_QPACK_TOKEN_IF_NONE_MATCH, 2536202615u},
    {89, NGHTTP3_QPACK_TOKEN_IF_RANGE, 2340978238u},
    {10, NGHTTP3_QPACK_TOKEN_LAST_MODIFIED, 3226950251u},
    {11, NGHTTP3_QPACK_TOKEN_LINK, 232457833u},
    {12, NGHTTP3_QPACK_TOKEN_LOCATION, 200649126u},
    {90, NGHTTP3_QPACK_TOKEN_ORIGIN, 3649018447u},
    {91, NGHTTP3_QPACK_TOKEN_PURPOSE, 4212263681u},
    {55, NGHTTP3_QPACK_TOKEN_RANGE, 4208725202u},
    {13, NGHTTP3_QPACK_TOKEN_REFERER, 3969579366u},
    {92, NGHTTP3_QPACK_TOKEN_SERVER, 1085029842u},
    {14, NGHTTP3_QPACK_TOKEN_SET_COOKIE, 1848371000u},
    {56, NGHTTP3_QPACK_TOKEN_STRICT_TRANSPORT_SECURITY, 4138147361u},
    {57, NGHTTP3_QPACK_TOKEN_STRICT_TRANSPORT_SECURITY, 4138147361u},
    {58, NGHTTP3_QPACK_TOKEN_STRICT_TRANSPORT_SECURITY, 4138147361u},
    {93, NGHTTP3_QPACK_TOKEN_TIMING_ALLOW_ORIGIN, 2432297564u},
    {94, NGHTTP3_QPACK_TOKEN_UPGRADE_INSECURE_REQUESTS, 2479169413u},
    {95, NGHTTP3_QPACK_TOKEN_USER_AGENT, 606444526u},
    {59, NGHTTP3_QPACK_TOKEN_VARY, 1085005381u},
    {60, NGHTTP3_QPACK_TOKEN_VARY, 1085005381u},
    {61, NGHTTP3_QPACK_TOKEN_X_CONTENT_TYPE_OPTIONS, 3644557769u},
    {96, NGHTTP3_QPACK_TOKEN_X_FORWARDED_FOR, 2914187656u},
    {97, NGHTTP3_QPACK_TOKEN_X_FRAME_OPTIONS, 3993834824u},
    {98, NGHTTP3_QPACK_TOKEN_X_FRAME_OPTIONS, 3993834824u},
    {62, NGHTTP3_QPACK_TOKEN_X_XSS_PROTECTION, 2501058888u},
};
static nghttp3_qpack_static_header stable[] = {
    {{__null,
      __null, (uint8_t *)(":authority"), sizeof((":authority")) - 1, -1},
     {__null,
      __null, (uint8_t *)(""), sizeof(("")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__AUTHORITY},
    {{__null,
      __null, (uint8_t *)(":path"), sizeof((":path")) - 1, -1},
     {__null,
      __null, (uint8_t *)("/"), sizeof(("/")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__PATH},
    {{__null,
      __null, (uint8_t *)("age"), sizeof(("age")) - 1, -1},
     {__null,
      __null, (uint8_t *)("0"), sizeof(("0")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_AGE},
    {{__null,
      __null, (uint8_t *)("content-disposition"), sizeof(("content-disposition")) - 1, -1},
     {__null,
      __null, (uint8_t *)(""), sizeof(("")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CONTENT_DISPOSITION},
    {{__null,
      __null, (uint8_t *)("content-length"), sizeof(("content-length")) - 1, -1},
     {__null,
      __null, (uint8_t *)("0"), sizeof(("0")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CONTENT_LENGTH},
    {{__null,
      __null, (uint8_t *)("cookie"), sizeof(("cookie")) - 1, -1},
     {__null,
      __null, (uint8_t *)(""), sizeof(("")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_COOKIE},
    {{__null,
      __null, (uint8_t *)("date"), sizeof(("date")) - 1, -1},
     {__null,
      __null, (uint8_t *)(""), sizeof(("")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_DATE},
    {{__null,
      __null, (uint8_t *)("etag"), sizeof(("etag")) - 1, -1},
     {__null,
      __null, (uint8_t *)(""), sizeof(("")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_ETAG},
    {{__null,
      __null, (uint8_t *)("if-modified-since"), sizeof(("if-modified-since")) - 1, -1},
     {__null,
      __null, (uint8_t *)(""), sizeof(("")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_IF_MODIFIED_SINCE},
    {{__null,
      __null, (uint8_t *)("if-none-match"), sizeof(("if-none-match")) - 1, -1},
     {__null,
      __null, (uint8_t *)(""), sizeof(("")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_IF_NONE_MATCH},
    {{__null,
      __null, (uint8_t *)("last-modified"), sizeof(("last-modified")) - 1, -1},
     {__null,
      __null, (uint8_t *)(""), sizeof(("")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_LAST_MODIFIED},
    {{__null,
      __null, (uint8_t *)("link"), sizeof(("link")) - 1, -1},
     {__null,
      __null, (uint8_t *)(""), sizeof(("")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_LINK},
    {{__null,
      __null, (uint8_t *)("location"), sizeof(("location")) - 1, -1},
     {__null,
      __null, (uint8_t *)(""), sizeof(("")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_LOCATION},
    {{__null,
      __null, (uint8_t *)("referer"), sizeof(("referer")) - 1, -1},
     {__null,
      __null, (uint8_t *)(""), sizeof(("")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_REFERER},
    {{__null,
      __null, (uint8_t *)("set-cookie"), sizeof(("set-cookie")) - 1, -1},
     {__null,
      __null, (uint8_t *)(""), sizeof(("")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_SET_COOKIE},
    {{__null,
      __null, (uint8_t *)(":method"), sizeof((":method")) - 1, -1},
     {__null,
      __null, (uint8_t *)("CONNECT"), sizeof(("CONNECT")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__METHOD},
    {{__null,
      __null, (uint8_t *)(":method"), sizeof((":method")) - 1, -1},
     {__null,
      __null, (uint8_t *)("DELETE"), sizeof(("DELETE")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__METHOD},
    {{__null,
      __null, (uint8_t *)(":method"), sizeof((":method")) - 1, -1},
     {__null,
      __null, (uint8_t *)("GET"), sizeof(("GET")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__METHOD},
    {{__null,
      __null, (uint8_t *)(":method"), sizeof((":method")) - 1, -1},
     {__null,
      __null, (uint8_t *)("HEAD"), sizeof(("HEAD")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__METHOD},
    {{__null,
      __null, (uint8_t *)(":method"), sizeof((":method")) - 1, -1},
     {__null,
      __null, (uint8_t *)("OPTIONS"), sizeof(("OPTIONS")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__METHOD},
    {{__null,
      __null, (uint8_t *)(":method"), sizeof((":method")) - 1, -1},
     {__null,
      __null, (uint8_t *)("POST"), sizeof(("POST")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__METHOD},
    {{__null,
      __null, (uint8_t *)(":method"), sizeof((":method")) - 1, -1},
     {__null,
      __null, (uint8_t *)("PUT"), sizeof(("PUT")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__METHOD},
    {{__null,
      __null, (uint8_t *)(":scheme"), sizeof((":scheme")) - 1, -1},
     {__null,
      __null, (uint8_t *)("http"), sizeof(("http")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__SCHEME},
    {{__null,
      __null, (uint8_t *)(":scheme"), sizeof((":scheme")) - 1, -1},
     {__null,
      __null, (uint8_t *)("https"), sizeof(("https")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__SCHEME},
    {{__null,
      __null, (uint8_t *)(":status"), sizeof((":status")) - 1, -1},
     {__null,
      __null, (uint8_t *)("103"), sizeof(("103")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__STATUS},
    {{__null,
      __null, (uint8_t *)(":status"), sizeof((":status")) - 1, -1},
     {__null,
      __null, (uint8_t *)("200"), sizeof(("200")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__STATUS},
    {{__null,
      __null, (uint8_t *)(":status"), sizeof((":status")) - 1, -1},
     {__null,
      __null, (uint8_t *)("304"), sizeof(("304")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__STATUS},
    {{__null,
      __null, (uint8_t *)(":status"), sizeof((":status")) - 1, -1},
     {__null,
      __null, (uint8_t *)("404"), sizeof(("404")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__STATUS},
    {{__null,
      __null, (uint8_t *)(":status"), sizeof((":status")) - 1, -1},
     {__null,
      __null, (uint8_t *)("503"), sizeof(("503")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__STATUS},
    {{__null,
      __null, (uint8_t *)("accept"), sizeof(("accept")) - 1, -1},
     {__null,
      __null, (uint8_t *)("*/*"), sizeof(("*/*")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_ACCEPT},
    {{__null,
      __null, (uint8_t *)("accept"), sizeof(("accept")) - 1, -1},
     {__null,
      __null, (uint8_t *)("application/dns-message"), sizeof(("application/dns-message")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_ACCEPT},
    {{__null,
      __null, (uint8_t *)("accept-encoding"), sizeof(("accept-encoding")) - 1, -1},
     {__null,
      __null, (uint8_t *)("gzip, deflate, br"), sizeof(("gzip, deflate, br")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_ACCEPT_ENCODING},
    {{__null,
      __null, (uint8_t *)("accept-ranges"), sizeof(("accept-ranges")) - 1, -1},
     {__null,
      __null, (uint8_t *)("bytes"), sizeof(("bytes")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_ACCEPT_RANGES},
    {{__null,
      __null, (uint8_t *)("access-control-allow-headers"), sizeof(("access-control-allow-headers")) - 1, -1},
     {__null,
      __null, (uint8_t *)("cache-control"), sizeof(("cache-control")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_HEADERS},
    {{__null,
      __null, (uint8_t *)("access-control-allow-headers"), sizeof(("access-control-allow-headers")) - 1, -1},
     {__null,
      __null, (uint8_t *)("content-type"), sizeof(("content-type")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_HEADERS},
    {{__null,
      __null, (uint8_t *)("access-control-allow-origin"), sizeof(("access-control-allow-origin")) - 1, -1},
     {__null,
      __null, (uint8_t *)("*"), sizeof(("*")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_ORIGIN},
    {{__null,
      __null, (uint8_t *)("cache-control"), sizeof(("cache-control")) - 1, -1},
     {__null,
      __null, (uint8_t *)("max-age=0"), sizeof(("max-age=0")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CACHE_CONTROL},
    {{__null,
      __null, (uint8_t *)("cache-control"), sizeof(("cache-control")) - 1, -1},
     {__null,
      __null, (uint8_t *)("max-age=2592000"), sizeof(("max-age=2592000")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CACHE_CONTROL},
    {{__null,
      __null, (uint8_t *)("cache-control"), sizeof(("cache-control")) - 1, -1},
     {__null,
      __null, (uint8_t *)("max-age=604800"), sizeof(("max-age=604800")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CACHE_CONTROL},
    {{__null,
      __null, (uint8_t *)("cache-control"), sizeof(("cache-control")) - 1, -1},
     {__null,
      __null, (uint8_t *)("no-cache"), sizeof(("no-cache")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CACHE_CONTROL},
    {{__null,
      __null, (uint8_t *)("cache-control"), sizeof(("cache-control")) - 1, -1},
     {__null,
      __null, (uint8_t *)("no-store"), sizeof(("no-store")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CACHE_CONTROL},
    {{__null,
      __null, (uint8_t *)("cache-control"), sizeof(("cache-control")) - 1, -1},
     {__null,
      __null, (uint8_t *)("public, max-age=31536000"), sizeof(("public, max-age=31536000")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CACHE_CONTROL},
    {{__null,
      __null, (uint8_t *)("content-encoding"), sizeof(("content-encoding")) - 1, -1},
     {__null,
      __null, (uint8_t *)("br"), sizeof(("br")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CONTENT_ENCODING},
    {{__null,
      __null, (uint8_t *)("content-encoding"), sizeof(("content-encoding")) - 1, -1},
     {__null,
      __null, (uint8_t *)("gzip"), sizeof(("gzip")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CONTENT_ENCODING},
    {{__null,
      __null, (uint8_t *)("content-type"), sizeof(("content-type")) - 1, -1},
     {__null,
      __null, (uint8_t *)("application/dns-message"), sizeof(("application/dns-message")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CONTENT_TYPE},
    {{__null,
      __null, (uint8_t *)("content-type"), sizeof(("content-type")) - 1, -1},
     {__null,
      __null, (uint8_t *)("application/javascript"), sizeof(("application/javascript")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CONTENT_TYPE},
    {{__null,
      __null, (uint8_t *)("content-type"), sizeof(("content-type")) - 1, -1},
     {__null,
      __null, (uint8_t *)("application/json"), sizeof(("application/json")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CONTENT_TYPE},
    {{__null,
      __null, (uint8_t *)("content-type"), sizeof(("content-type")) - 1, -1},
     {__null,
      __null, (uint8_t *)("application/x-www-form-urlencoded"), sizeof(("application/x-www-form-urlencoded")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CONTENT_TYPE},
    {{__null,
      __null, (uint8_t *)("content-type"), sizeof(("content-type")) - 1, -1},
     {__null,
      __null, (uint8_t *)("image/gif"), sizeof(("image/gif")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CONTENT_TYPE},
    {{__null,
      __null, (uint8_t *)("content-type"), sizeof(("content-type")) - 1, -1},
     {__null,
      __null, (uint8_t *)("image/jpeg"), sizeof(("image/jpeg")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CONTENT_TYPE},
    {{__null,
      __null, (uint8_t *)("content-type"), sizeof(("content-type")) - 1, -1},
     {__null,
      __null, (uint8_t *)("image/png"), sizeof(("image/png")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CONTENT_TYPE},
    {{__null,
      __null, (uint8_t *)("content-type"), sizeof(("content-type")) - 1, -1},
     {__null,
      __null, (uint8_t *)("text/css"), sizeof(("text/css")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CONTENT_TYPE},
    {{__null,
      __null, (uint8_t *)("content-type"), sizeof(("content-type")) - 1, -1},
     {__null,
      __null, (uint8_t *)("text/html; charset=utf-8"), sizeof(("text/html; charset=utf-8")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CONTENT_TYPE},
    {{__null,
      __null, (uint8_t *)("content-type"), sizeof(("content-type")) - 1, -1},
     {__null,
      __null, (uint8_t *)("text/plain"), sizeof(("text/plain")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CONTENT_TYPE},
    {{__null,
      __null, (uint8_t *)("content-type"), sizeof(("content-type")) - 1, -1},
     {__null,
      __null, (uint8_t *)("text/plain;charset=utf-8"), sizeof(("text/plain;charset=utf-8")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CONTENT_TYPE},
    {{__null,
      __null, (uint8_t *)("range"), sizeof(("range")) - 1, -1},
     {__null,
      __null, (uint8_t *)("bytes=0-"), sizeof(("bytes=0-")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_RANGE},
    {{__null,
      __null, (uint8_t *)("strict-transport-security"), sizeof(("strict-transport-security")) - 1, -1},
     {__null,
      __null, (uint8_t *)("max-age=31536000"), sizeof(("max-age=31536000")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_STRICT_TRANSPORT_SECURITY},
    {{__null,
      __null, (uint8_t *)("strict-transport-security"), sizeof(("strict-transport-security")) - 1, -1},
     {__null,
      __null, (uint8_t *)("max-age=31536000; includesubdomains"), sizeof(("max-age=31536000; includesubdomains")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_STRICT_TRANSPORT_SECURITY},
    {{__null,
      __null, (uint8_t *)("strict-transport-security"), sizeof(("strict-transport-security")) - 1, -1},
     {__null,
      __null, (uint8_t *)("max-age=31536000; includesubdomains; preload"), sizeof(("max-age=31536000; includesubdomains; preload")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_STRICT_TRANSPORT_SECURITY},
    {{__null,
      __null, (uint8_t *)("vary"), sizeof(("vary")) - 1, -1},
     {__null,
      __null, (uint8_t *)("accept-encoding"), sizeof(("accept-encoding")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_VARY},
    {{__null,
      __null, (uint8_t *)("vary"), sizeof(("vary")) - 1, -1},
     {__null,
      __null, (uint8_t *)("origin"), sizeof(("origin")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_VARY},
    {{__null,
      __null, (uint8_t *)("x-content-type-options"), sizeof(("x-content-type-options")) - 1, -1},
     {__null,
      __null, (uint8_t *)("nosniff"), sizeof(("nosniff")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_X_CONTENT_TYPE_OPTIONS},
    {{__null,
      __null, (uint8_t *)("x-xss-protection"), sizeof(("x-xss-protection")) - 1, -1},
     {__null,
      __null, (uint8_t *)("1; mode=block"), sizeof(("1; mode=block")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_X_XSS_PROTECTION},
    {{__null,
      __null, (uint8_t *)(":status"), sizeof((":status")) - 1, -1},
     {__null,
      __null, (uint8_t *)("100"), sizeof(("100")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__STATUS},
    {{__null,
      __null, (uint8_t *)(":status"), sizeof((":status")) - 1, -1},
     {__null,
      __null, (uint8_t *)("204"), sizeof(("204")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__STATUS},
    {{__null,
      __null, (uint8_t *)(":status"), sizeof((":status")) - 1, -1},
     {__null,
      __null, (uint8_t *)("206"), sizeof(("206")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__STATUS},
    {{__null,
      __null, (uint8_t *)(":status"), sizeof((":status")) - 1, -1},
     {__null,
      __null, (uint8_t *)("302"), sizeof(("302")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__STATUS},
    {{__null,
      __null, (uint8_t *)(":status"), sizeof((":status")) - 1, -1},
     {__null,
      __null, (uint8_t *)("400"), sizeof(("400")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__STATUS},
    {{__null,
      __null, (uint8_t *)(":status"), sizeof((":status")) - 1, -1},
     {__null,
      __null, (uint8_t *)("403"), sizeof(("403")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__STATUS},
    {{__null,
      __null, (uint8_t *)(":status"), sizeof((":status")) - 1, -1},
     {__null,
      __null, (uint8_t *)("421"), sizeof(("421")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__STATUS},
    {{__null,
      __null, (uint8_t *)(":status"), sizeof((":status")) - 1, -1},
     {__null,
      __null, (uint8_t *)("425"), sizeof(("425")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__STATUS},
    {{__null,
      __null, (uint8_t *)(":status"), sizeof((":status")) - 1, -1},
     {__null,
      __null, (uint8_t *)("500"), sizeof(("500")) - 1, -1},
     NGHTTP3_QPACK_TOKEN__STATUS},
    {{__null,
      __null, (uint8_t *)("accept-language"), sizeof(("accept-language")) - 1, -1},
     {__null,
      __null, (uint8_t *)(""), sizeof(("")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_ACCEPT_LANGUAGE},
    {{__null,
      __null, (uint8_t *)("access-control-allow-credentials"), sizeof(("access-control-allow-credentials")) - 1, -1},
     {__null,
      __null, (uint8_t *)("FALSE"), sizeof(("FALSE")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_CREDENTIALS},
    {{__null,
      __null, (uint8_t *)("access-control-allow-credentials"), sizeof(("access-control-allow-credentials")) - 1, -1},
     {__null,
      __null, (uint8_t *)("TRUE"), sizeof(("TRUE")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_CREDENTIALS},
    {{__null,
      __null, (uint8_t *)("access-control-allow-headers"), sizeof(("access-control-allow-headers")) - 1, -1},
     {__null,
      __null, (uint8_t *)("*"), sizeof(("*")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_HEADERS},
    {{__null,
      __null, (uint8_t *)("access-control-allow-methods"), sizeof(("access-control-allow-methods")) - 1, -1},
     {__null,
      __null, (uint8_t *)("get"), sizeof(("get")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_METHODS},
    {{__null,
      __null, (uint8_t *)("access-control-allow-methods"), sizeof(("access-control-allow-methods")) - 1, -1},
     {__null,
      __null, (uint8_t *)("get, post, options"), sizeof(("get, post, options")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_METHODS},
    {{__null,
      __null, (uint8_t *)("access-control-allow-methods"), sizeof(("access-control-allow-methods")) - 1, -1},
     {__null,
      __null, (uint8_t *)("options"), sizeof(("options")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_METHODS},
    {{__null,
      __null, (uint8_t *)("access-control-expose-headers"), sizeof(("access-control-expose-headers")) - 1, -1},
     {__null,
      __null, (uint8_t *)("content-length"), sizeof(("content-length")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_EXPOSE_HEADERS},
    {{__null,
      __null, (uint8_t *)("access-control-request-headers"), sizeof(("access-control-request-headers")) - 1, -1},
     {__null,
      __null, (uint8_t *)("content-type"), sizeof(("content-type")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_REQUEST_HEADERS},
    {{__null,
      __null, (uint8_t *)("access-control-request-method"), sizeof(("access-control-request-method")) - 1, -1},
     {__null,
      __null, (uint8_t *)("get"), sizeof(("get")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_REQUEST_METHOD},
    {{__null,
      __null, (uint8_t *)("access-control-request-method"), sizeof(("access-control-request-method")) - 1, -1},
     {__null,
      __null, (uint8_t *)("post"), sizeof(("post")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_REQUEST_METHOD},
    {{__null,
      __null, (uint8_t *)("alt-svc"), sizeof(("alt-svc")) - 1, -1},
     {__null,
      __null, (uint8_t *)("clear"), sizeof(("clear")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_ALT_SVC},
    {{__null,
      __null, (uint8_t *)("authorization"), sizeof(("authorization")) - 1, -1},
     {__null,
      __null, (uint8_t *)(""), sizeof(("")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_AUTHORIZATION},
    {{__null,
      __null, (uint8_t *)("content-security-policy"), sizeof(("content-security-policy")) - 1, -1},
     {__null,
      __null, (uint8_t *)("script-src 'none'; object-src 'none'; base-uri 'none'"), sizeof(("script-src 'none'; object-src 'none'; base-uri 'none'")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_CONTENT_SECURITY_POLICY},
    {{__null,
      __null, (uint8_t *)("early-data"), sizeof(("early-data")) - 1, -1},
     {__null,
      __null, (uint8_t *)("1"), sizeof(("1")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_EARLY_DATA},
    {{__null,
      __null, (uint8_t *)("expect-ct"), sizeof(("expect-ct")) - 1, -1},
     {__null,
      __null, (uint8_t *)(""), sizeof(("")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_EXPECT_CT},
    {{__null,
      __null, (uint8_t *)("forwarded"), sizeof(("forwarded")) - 1, -1},
     {__null,
      __null, (uint8_t *)(""), sizeof(("")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_FORWARDED},
    {{__null,
      __null, (uint8_t *)("if-range"), sizeof(("if-range")) - 1, -1},
     {__null,
      __null, (uint8_t *)(""), sizeof(("")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_IF_RANGE},
    {{__null,
      __null, (uint8_t *)("origin"), sizeof(("origin")) - 1, -1},
     {__null,
      __null, (uint8_t *)(""), sizeof(("")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_ORIGIN},
    {{__null,
      __null, (uint8_t *)("purpose"), sizeof(("purpose")) - 1, -1},
     {__null,
      __null, (uint8_t *)("prefetch"), sizeof(("prefetch")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_PURPOSE},
    {{__null,
      __null, (uint8_t *)("server"), sizeof(("server")) - 1, -1},
     {__null,
      __null, (uint8_t *)(""), sizeof(("")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_SERVER},
    {{__null,
      __null, (uint8_t *)("timing-allow-origin"), sizeof(("timing-allow-origin")) - 1, -1},
     {__null,
      __null, (uint8_t *)("*"), sizeof(("*")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_TIMING_ALLOW_ORIGIN},
    {{__null,
      __null, (uint8_t *)("upgrade-insecure-requests"), sizeof(("upgrade-insecure-requests")) - 1, -1},
     {__null,
      __null, (uint8_t *)("1"), sizeof(("1")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_UPGRADE_INSECURE_REQUESTS},
    {{__null,
      __null, (uint8_t *)("user-agent"), sizeof(("user-agent")) - 1, -1},
     {__null,
      __null, (uint8_t *)(""), sizeof(("")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_USER_AGENT},
    {{__null,
      __null, (uint8_t *)("x-forwarded-for"), sizeof(("x-forwarded-for")) - 1, -1},
     {__null,
      __null, (uint8_t *)(""), sizeof(("")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_X_FORWARDED_FOR},
    {{__null,
      __null, (uint8_t *)("x-frame-options"), sizeof(("x-frame-options")) - 1, -1},
     {__null,
      __null, (uint8_t *)("deny"), sizeof(("deny")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_X_FRAME_OPTIONS},
    {{__null,
      __null, (uint8_t *)("x-frame-options"), sizeof(("x-frame-options")) - 1, -1},
     {__null,
      __null, (uint8_t *)("sameorigin"), sizeof(("sameorigin")) - 1, -1},
     NGHTTP3_QPACK_TOKEN_X_FRAME_OPTIONS},
};
static int memeq(const void *s1, const void *s2, size_t n)
{
  return n == 0 || memcmp(s1, s2, n) == 0;
}
static int32_t qpack_lookup_token(const uint8_t *name, size_t namelen)
{
  switch (namelen)
  {
  case 2:
    switch (name[1])
    {
    case 'e':
      if (memeq("t", name, 1))
      {
        return NGHTTP3_QPACK_TOKEN_TE;
      }
      break;
    }
    break;
  case 3:
    switch (name[2])
    {
    case 'e':
      if (memeq("ag", name, 2))
      {
        return NGHTTP3_QPACK_TOKEN_AGE;
      }
      break;
    }
    break;
  case 4:
    switch (name[3])
    {
    case 'e':
      if (memeq("dat", name, 3))
      {
        return NGHTTP3_QPACK_TOKEN_DATE;
      }
      break;
    case 'g':
      if (memeq("eta", name, 3))
      {
        return NGHTTP3_QPACK_TOKEN_ETAG;
      }
      break;
    case 'k':
      if (memeq("lin", name, 3))
      {
        return NGHTTP3_QPACK_TOKEN_LINK;
      }
      break;
    case 't':
      if (memeq("hos", name, 3))
      {
        return NGHTTP3_QPACK_TOKEN_HOST;
      }
      break;
    case 'y':
      if (memeq("var", name, 3))
      {
        return NGHTTP3_QPACK_TOKEN_VARY;
      }
      break;
    }
    break;
  case 5:
    switch (name[4])
    {
    case 'e':
      if (memeq("rang", name, 4))
      {
        return NGHTTP3_QPACK_TOKEN_RANGE;
      }
      break;
    case 'h':
      if (memeq(":pat", name, 4))
      {
        return NGHTTP3_QPACK_TOKEN__PATH;
      }
      break;
    }
    break;
  case 6:
    switch (name[5])
    {
    case 'e':
      if (memeq("cooki", name, 5))
      {
        return NGHTTP3_QPACK_TOKEN_COOKIE;
      }
      break;
    case 'n':
      if (memeq("origi", name, 5))
      {
        return NGHTTP3_QPACK_TOKEN_ORIGIN;
      }
      break;
    case 'r':
      if (memeq("serve", name, 5))
      {
        return NGHTTP3_QPACK_TOKEN_SERVER;
      }
      break;
    case 't':
      if (memeq("accep", name, 5))
      {
        return NGHTTP3_QPACK_TOKEN_ACCEPT;
      }
      break;
    }
    break;
  case 7:
    switch (name[6])
    {
    case 'c':
      if (memeq("alt-sv", name, 6))
      {
        return NGHTTP3_QPACK_TOKEN_ALT_SVC;
      }
      break;
    case 'd':
      if (memeq(":metho", name, 6))
      {
        return NGHTTP3_QPACK_TOKEN__METHOD;
      }
      break;
    case 'e':
      if (memeq(":schem", name, 6))
      {
        return NGHTTP3_QPACK_TOKEN__SCHEME;
      }
      if (memeq("purpos", name, 6))
      {
        return NGHTTP3_QPACK_TOKEN_PURPOSE;
      }
      if (memeq("upgrad", name, 6))
      {
        return NGHTTP3_QPACK_TOKEN_UPGRADE;
      }
      break;
    case 'r':
      if (memeq("refere", name, 6))
      {
        return NGHTTP3_QPACK_TOKEN_REFERER;
      }
      break;
    case 's':
      if (memeq(":statu", name, 6))
      {
        return NGHTTP3_QPACK_TOKEN__STATUS;
      }
      break;
    }
    break;
  case 8:
    switch (name[7])
    {
    case 'e':
      if (memeq("if-rang", name, 7))
      {
        return NGHTTP3_QPACK_TOKEN_IF_RANGE;
      }
      break;
    case 'n':
      if (memeq("locatio", name, 7))
      {
        return NGHTTP3_QPACK_TOKEN_LOCATION;
      }
      break;
    case 'y':
      if (memeq("priorit", name, 7))
      {
        return NGHTTP3_QPACK_TOKEN_PRIORITY;
      }
      break;
    }
    break;
  case 9:
    switch (name[8])
    {
    case 'd':
      if (memeq("forwarde", name, 8))
      {
        return NGHTTP3_QPACK_TOKEN_FORWARDED;
      }
      break;
    case 'l':
      if (memeq(":protoco", name, 8))
      {
        return NGHTTP3_QPACK_TOKEN__PROTOCOL;
      }
      break;
    case 't':
      if (memeq("expect-c", name, 8))
      {
        return NGHTTP3_QPACK_TOKEN_EXPECT_CT;
      }
      break;
    }
    break;
  case 10:
    switch (name[9])
    {
    case 'a':
      if (memeq("early-dat", name, 9))
      {
        return NGHTTP3_QPACK_TOKEN_EARLY_DATA;
      }
      break;
    case 'e':
      if (memeq("keep-aliv", name, 9))
      {
        return NGHTTP3_QPACK_TOKEN_KEEP_ALIVE;
      }
      if (memeq("set-cooki", name, 9))
      {
        return NGHTTP3_QPACK_TOKEN_SET_COOKIE;
      }
      break;
    case 'n':
      if (memeq("connectio", name, 9))
      {
        return NGHTTP3_QPACK_TOKEN_CONNECTION;
      }
      break;
    case 't':
      if (memeq("user-agen", name, 9))
      {
        return NGHTTP3_QPACK_TOKEN_USER_AGENT;
      }
      break;
    case 'y':
      if (memeq(":authorit", name, 9))
      {
        return NGHTTP3_QPACK_TOKEN__AUTHORITY;
      }
      break;
    }
    break;
  case 12:
    switch (name[11])
    {
    case 'e':
      if (memeq("content-typ", name, 11))
      {
        return NGHTTP3_QPACK_TOKEN_CONTENT_TYPE;
      }
      break;
    }
    break;
  case 13:
    switch (name[12])
    {
    case 'd':
      if (memeq("last-modifie", name, 12))
      {
        return NGHTTP3_QPACK_TOKEN_LAST_MODIFIED;
      }
      break;
    case 'h':
      if (memeq("if-none-matc", name, 12))
      {
        return NGHTTP3_QPACK_TOKEN_IF_NONE_MATCH;
      }
      break;
    case 'l':
      if (memeq("cache-contro", name, 12))
      {
        return NGHTTP3_QPACK_TOKEN_CACHE_CONTROL;
      }
      break;
    case 'n':
      if (memeq("authorizatio", name, 12))
      {
        return NGHTTP3_QPACK_TOKEN_AUTHORIZATION;
      }
      break;
    case 's':
      if (memeq("accept-range", name, 12))
      {
        return NGHTTP3_QPACK_TOKEN_ACCEPT_RANGES;
      }
      break;
    }
    break;
  case 14:
    switch (name[13])
    {
    case 'h':
      if (memeq("content-lengt", name, 13))
      {
        return NGHTTP3_QPACK_TOKEN_CONTENT_LENGTH;
      }
      break;
    }
    break;
  case 15:
    switch (name[14])
    {
    case 'e':
      if (memeq("accept-languag", name, 14))
      {
        return NGHTTP3_QPACK_TOKEN_ACCEPT_LANGUAGE;
      }
      break;
    case 'g':
      if (memeq("accept-encodin", name, 14))
      {
        return NGHTTP3_QPACK_TOKEN_ACCEPT_ENCODING;
      }
      break;
    case 'r':
      if (memeq("x-forwarded-fo", name, 14))
      {
        return NGHTTP3_QPACK_TOKEN_X_FORWARDED_FOR;
      }
      break;
    case 's':
      if (memeq("x-frame-option", name, 14))
      {
        return NGHTTP3_QPACK_TOKEN_X_FRAME_OPTIONS;
      }
      break;
    }
    break;
  case 16:
    switch (name[15])
    {
    case 'g':
      if (memeq("content-encodin", name, 15))
      {
        return NGHTTP3_QPACK_TOKEN_CONTENT_ENCODING;
      }
      break;
    case 'n':
      if (memeq("proxy-connectio", name, 15))
      {
        return NGHTTP3_QPACK_TOKEN_PROXY_CONNECTION;
      }
      if (memeq("x-xss-protectio", name, 15))
      {
        return NGHTTP3_QPACK_TOKEN_X_XSS_PROTECTION;
      }
      break;
    }
    break;
  case 17:
    switch (name[16])
    {
    case 'e':
      if (memeq("if-modified-sinc", name, 16))
      {
        return NGHTTP3_QPACK_TOKEN_IF_MODIFIED_SINCE;
      }
      break;
    case 'g':
      if (memeq("transfer-encodin", name, 16))
      {
        return NGHTTP3_QPACK_TOKEN_TRANSFER_ENCODING;
      }
      break;
    }
    break;
  case 19:
    switch (name[18])
    {
    case 'n':
      if (memeq("content-dispositio", name, 18))
      {
        return NGHTTP3_QPACK_TOKEN_CONTENT_DISPOSITION;
      }
      if (memeq("timing-allow-origi", name, 18))
      {
        return NGHTTP3_QPACK_TOKEN_TIMING_ALLOW_ORIGIN;
      }
      break;
    }
    break;
  case 22:
    switch (name[21])
    {
    case 's':
      if (memeq("x-content-type-option", name, 21))
      {
        return NGHTTP3_QPACK_TOKEN_X_CONTENT_TYPE_OPTIONS;
      }
      break;
    }
    break;
  case 23:
    switch (name[22])
    {
    case 'y':
      if (memeq("content-security-polic", name, 22))
      {
        return NGHTTP3_QPACK_TOKEN_CONTENT_SECURITY_POLICY;
      }
      break;
    }
    break;
  case 25:
    switch (name[24])
    {
    case 's':
      if (memeq("upgrade-insecure-request", name, 24))
      {
        return NGHTTP3_QPACK_TOKEN_UPGRADE_INSECURE_REQUESTS;
      }
      break;
    case 'y':
      if (memeq("strict-transport-securit", name, 24))
      {
        return NGHTTP3_QPACK_TOKEN_STRICT_TRANSPORT_SECURITY;
      }
      break;
    }
    break;
  case 27:
    switch (name[26])
    {
    case 'n':
      if (memeq("access-control-allow-origi", name, 26))
      {
        return NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_ORIGIN;
      }
      break;
    }
    break;
  case 28:
    switch (name[27])
    {
    case 's':
      if (memeq("access-control-allow-header", name, 27))
      {
        return NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_HEADERS;
      }
      if (memeq("access-control-allow-method", name, 27))
      {
        return NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_METHODS;
      }
      break;
    }
    break;
  case 29:
    switch (name[28])
    {
    case 'd':
      if (memeq("access-control-request-metho", name, 28))
      {
        return NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_REQUEST_METHOD;
      }
      break;
    case 's':
      if (memeq("access-control-expose-header", name, 28))
      {
        return NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_EXPOSE_HEADERS;
      }
      break;
    }
    break;
  case 30:
    switch (name[29])
    {
    case 's':
      if (memeq("access-control-request-header", name, 29))
      {
        return NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_REQUEST_HEADERS;
      }
      break;
    }
    break;
  case 32:
    switch (name[31])
    {
    case 's':
      if (memeq("access-control-allow-credential", name, 31))
      {
        return NGHTTP3_QPACK_TOKEN_ACCESS_CONTROL_ALLOW_CREDENTIALS;
      }
      break;
    }
    break;
  }
  return -1;
}
static size_t table_space(size_t namelen, size_t valuelen)
{
  return 32 + namelen + valuelen;
}
static int qpack_nv_name_eq(const nghttp3_qpack_nv *a, const nghttp3_nv *b)
{
  return a->name->len == b->namelen &&
         memeq(a->name->base, b->name, b->namelen);
}
static int qpack_nv_value_eq(const nghttp3_qpack_nv *a, const nghttp3_nv *b)
{
  return a->value->len == b->valuelen &&
         memeq(a->value->base, b->value, b->valuelen);
}
static void qpack_map_init(nghttp3_qpack_map *map)
{
  memset(map, 0, sizeof(nghttp3_qpack_map));
}
static void qpack_map_insert(nghttp3_qpack_map *map, nghttp3_qpack_entry *ent)
{
  nghttp3_qpack_entry **bucket;
  bucket = &map->table[ent->hash & (64 - 1)];
  if (*bucket ==
      __null)
  {
    *bucket = ent;
    return;
  }
  ent->map_next = *bucket;
  *bucket = ent;
}
static void qpack_map_remove(nghttp3_qpack_map *map, nghttp3_qpack_entry *ent)
{
  nghttp3_qpack_entry **dst;
  dst = &map->table[ent->hash & (64 - 1)];
  for (; *dst; dst = &(*dst)->map_next)
  {
    if (*dst != ent)
    {
      continue;
    }
    *dst = ent->map_next;
    ent->map_next =
        __null;
    return;
  }
}
static int qpack_context_can_reference(nghttp3_qpack_context *ctx,
                                       uint64_t absidx)
{
  nghttp3_qpack_entry *ent = nghttp3_qpack_context_dtable_get(ctx, absidx);
  return ctx->dtable_sum - ent->sum <= ctx->max_dtable_size;
}
static void encoder_qpack_map_find(nghttp3_qpack_encoder *encoder,
                                   int *exact_match,
                                   nghttp3_qpack_entry **pmatch,
                                   nghttp3_qpack_entry **ppb_match,
                                   const nghttp3_nv *nv, int32_t token,
                                   uint32_t hash, uint64_t krcnt,
                                   int allow_blocking, int name_only)
{
  nghttp3_qpack_entry *p;
  *exact_match = 0;
  *pmatch =
      __null;
  *ppb_match =
      __null;
  for (p = encoder->dtable_map.table[hash & (64 - 1)]; p;
       p = p->map_next)
  {
    if (token != p->nv.token ||
        (token == -1 && (hash != p->hash || !qpack_nv_name_eq(&p->nv, nv))) ||
        !qpack_context_can_reference(&encoder->ctx, p->absidx))
    {
      continue;
    }
    if (allow_blocking || p->absidx + 1 <= krcnt)
    {
      if (!*pmatch)
      {
        *pmatch = p;
        if (name_only)
        {
          return;
        }
      }
      if (qpack_nv_value_eq(&p->nv, nv))
      {
        *pmatch = p;
        *exact_match = 1;
        return;
      }
    }
    else if (!*ppb_match && qpack_nv_value_eq(&p->nv, nv))
    {
      *ppb_match = p;
    }
  }
}
static int qpack_context_init(nghttp3_qpack_context *ctx,
                              size_t max_dtable_size, size_t max_blocked,
                              const nghttp3_mem *mem)
{
  int rv;
  size_t len = 4096 / 32;
  size_t len2;
  for (len2 = 1; len2 < len; len2 <<= 1)
    ;
  rv = nghttp3_ringbuf_init(&ctx->dtable, len2, sizeof(nghttp3_qpack_entry *),
                            mem);
  if (rv != 0)
  {
    return rv;
  }
  ctx->mem = mem;
  ctx->dtable_size = 0;
  ctx->dtable_sum = 0;
  ctx->hard_max_dtable_size = max_dtable_size;
  ctx->max_dtable_size = 0;
  ctx->max_blocked = max_blocked;
  ctx->next_absidx = 0;
  ctx->bad = 0;
  return 0;
}
static void qpack_context_free(nghttp3_qpack_context *ctx)
{
  nghttp3_qpack_entry *ent;
  size_t i, len = ((&ctx->dtable)->len);
  for (i = 0; i < len; ++i)
  {
    ent = *(nghttp3_qpack_entry **)nghttp3_ringbuf_get(&ctx->dtable, i);
    nghttp3_qpack_entry_free(ent);
    nghttp3_mem_free(ctx->mem, ent);
  }
  nghttp3_ringbuf_free(&ctx->dtable);
}
static int ref_min_cnt_less(const nghttp3_pq_entry *lhsx,
                            const nghttp3_pq_entry *rhsx)
{
  nghttp3_qpack_header_block_ref *lhs =
      ((nghttp3_qpack_header_block_ref *)(void *)((char *)(lhsx) -
                                                  __builtin_offsetof(
                                                      nghttp3_qpack_header_block_ref,
                                                      min_cnts_pe)));
  nghttp3_qpack_header_block_ref *rhs =
      ((nghttp3_qpack_header_block_ref *)(void *)((char *)(rhsx) -
                                                  __builtin_offsetof(
                                                      nghttp3_qpack_header_block_ref,
                                                      min_cnts_pe)));
  return lhs->min_cnt < rhs->min_cnt;
}
typedef struct
{
  uint64_t max_cnt;
  uint64_t id;
} nghttp3_blocked_streams_key;
static int max_cnt_greater(const nghttp3_ksl_key *lhs,
                           const nghttp3_ksl_key *rhs)
{
  const nghttp3_blocked_streams_key *a = lhs;
  const nghttp3_blocked_streams_key *b = rhs;
  return a->max_cnt > b->max_cnt || (a->max_cnt == b->max_cnt && a->id < b->id);
}
int nghttp3_qpack_encoder_init(nghttp3_qpack_encoder *encoder,
                               size_t max_dtable_size, size_t max_blocked,
                               const nghttp3_mem *mem)
{
  int rv;
  rv = qpack_context_init(&encoder->ctx, max_dtable_size, max_blocked, mem);
  if (rv != 0)
  {
    return rv;
  }
  rv = nghttp3_map_init(&encoder->streams, mem);
  if (rv != 0)
  {
    goto streams_init_fail;
  }
  rv = nghttp3_ksl_init(&encoder->blocked_streams, max_cnt_greater,
                        sizeof(nghttp3_blocked_streams_key), mem);
  if (rv != 0)
  {
    goto blocked_streams_init_fail;
  }
  qpack_map_init(&encoder->dtable_map);
  nghttp3_pq_init(&encoder->min_cnts, ref_min_cnt_less, mem);
  encoder->krcnt = 0;
  encoder->state = NGHTTP3_QPACK_DS_STATE_OPCODE;
  encoder->opcode = 0;
  encoder->min_dtable_update =
      (18446744073709551615UL);
  encoder->last_max_dtable_update = 0;
  encoder->flags = NGHTTP3_QPACK_ENCODER_FLAG_NONE;
  nghttp3_qpack_read_state_reset(&encoder->rstate);
  return 0;
blocked_streams_init_fail:
  nghttp3_map_free(&encoder->streams);
streams_init_fail:
  qpack_context_free(&encoder->ctx);
  return rv;
}
static int map_stream_free(nghttp3_map_entry *entry, void *ptr)
{
  const nghttp3_mem *mem = ptr;
  nghttp3_qpack_stream *stream =
      ((nghttp3_qpack_stream *)(void *)((char *)(entry) -
                                        __builtin_offsetof(
                                            nghttp3_qpack_stream,
                                            me)));
  nghttp3_qpack_stream_del(stream, mem);
  return 0;
}
void nghttp3_qpack_encoder_free(nghttp3_qpack_encoder *encoder)
{
  nghttp3_pq_free(&encoder->min_cnts);
  nghttp3_ksl_free(&encoder->blocked_streams);
  nghttp3_map_each_free(&encoder->streams, map_stream_free,
                        (void *)encoder->ctx.mem);
  nghttp3_map_free(&encoder->streams);
  qpack_context_free(&encoder->ctx);
}
int nghttp3_qpack_encoder_set_max_dtable_size(nghttp3_qpack_encoder *encoder,
                                              size_t max_dtable_size)
{
  if (encoder->ctx.hard_max_dtable_size < max_dtable_size)
  {
    return NGHTTP3_ERR_INVALID_ARGUMENT;
  }
  if (encoder->ctx.max_dtable_size == max_dtable_size)
  {
    return 0;
  }
  encoder->flags |= NGHTTP3_QPACK_ENCODER_FLAG_PENDING_SET_DTABLE_CAP;
  if (encoder->min_dtable_update > max_dtable_size)
  {
    encoder->min_dtable_update = max_dtable_size;
    encoder->ctx.max_dtable_size = max_dtable_size;
  }
  encoder->last_max_dtable_update = max_dtable_size;
  return 0;
}
int nghttp3_qpack_encoder_set_hard_max_dtable_size(
    nghttp3_qpack_encoder *encoder, size_t hard_max_dtable_size)
{
  if (encoder->ctx.hard_max_dtable_size)
  {
    return NGHTTP3_ERR_INVALID_STATE;
  }
  encoder->ctx.hard_max_dtable_size = hard_max_dtable_size;
  return 0;
}
int nghttp3_qpack_encoder_set_max_blocked(nghttp3_qpack_encoder *encoder,
                                          size_t max_blocked)
{
  if (encoder->ctx.max_blocked)
  {
    return NGHTTP3_ERR_INVALID_STATE;
  }
  encoder->ctx.max_blocked = max_blocked;
  return 0;
}
uint64_t nghttp3_qpack_encoder_get_min_cnt(nghttp3_qpack_encoder *encoder)
{
  assert(!nghttp3_pq_empty(&encoder->min_cnts));
  return ((nghttp3_qpack_header_block_ref *)(void *)((char *)(nghttp3_pq_top(&encoder->min_cnts)) -
                                                     __builtin_offsetof(
                                                         nghttp3_qpack_header_block_ref,
                                                         min_cnts_pe)))
      ->min_cnt;
}
void nghttp3_qpack_encoder_shrink_dtable(nghttp3_qpack_encoder *encoder)
{
  nghttp3_ringbuf *dtable = &encoder->ctx.dtable;
  const nghttp3_mem *mem = encoder->ctx.mem;
  uint64_t min_cnt =
      (18446744073709551615UL);
  size_t len;
  nghttp3_qpack_entry *ent;
  if (encoder->ctx.dtable_size <= encoder->ctx.max_dtable_size)
  {
    return;
  }
  if (!nghttp3_pq_empty(&encoder->min_cnts))
  {
    min_cnt = nghttp3_qpack_encoder_get_min_cnt(encoder);
  }
  for (; encoder->ctx.dtable_size > encoder->ctx.max_dtable_size;)
  {
    len = ((dtable)->len);
    ent = *(nghttp3_qpack_entry **)nghttp3_ringbuf_get(dtable, len - 1);
    if (ent->absidx + 1 == min_cnt)
    {
      return;
    }
    encoder->ctx.dtable_size -=
        table_space(ent->nv.name->len, ent->nv.value->len);
    nghttp3_ringbuf_pop_back(dtable);
    qpack_map_remove(&encoder->dtable_map, ent);
    nghttp3_qpack_entry_free(ent);
    nghttp3_mem_free(mem, ent);
  }
}
static int qpack_encoder_add_stream_ref(nghttp3_qpack_encoder *encoder,
                                        int64_t stream_id,
                                        nghttp3_qpack_stream *stream,
                                        uint64_t max_cnt, uint64_t min_cnt)
{
  nghttp3_qpack_header_block_ref *ref;
  const nghttp3_mem *mem = encoder->ctx.mem;
  uint64_t prev_max_cnt = 0;
  int rv;
  if (stream ==
      __null)
  {
    rv = nghttp3_qpack_stream_new(&stream, stream_id, mem);
    if (rv != 0)
    {
      assert(rv == NGHTTP3_ERR_NOMEM);
      return rv;
    }
    rv = nghttp3_map_insert(&encoder->streams, &stream->me);
    if (rv != 0)
    {
      assert(rv == NGHTTP3_ERR_NOMEM);
      nghttp3_qpack_stream_del(stream, mem);
      return rv;
    }
  }
  else
  {
    prev_max_cnt = nghttp3_qpack_stream_get_max_cnt(stream);
    if (nghttp3_qpack_encoder_stream_is_blocked(encoder, stream) &&
        max_cnt > prev_max_cnt)
    {
      nghttp3_qpack_encoder_unblock_stream(encoder, stream);
    }
  }
  rv = nghttp3_qpack_header_block_ref_new(&ref, max_cnt, min_cnt, mem);
  if (rv != 0)
  {
    return rv;
  }
  rv = nghttp3_qpack_stream_add_ref(stream, ref);
  if (rv != 0)
  {
    nghttp3_qpack_header_block_ref_del(ref, mem);
    return rv;
  }
  if (max_cnt > prev_max_cnt &&
      nghttp3_qpack_encoder_stream_is_blocked(encoder, stream))
  {
    rv = nghttp3_qpack_encoder_block_stream(encoder, stream);
    if (rv != 0)
    {
      return rv;
    }
  }
  return nghttp3_pq_push(&encoder->min_cnts, &ref->min_cnts_pe);
}
static void qpack_encoder_remove_stream(nghttp3_qpack_encoder *encoder,
                                        nghttp3_qpack_stream *stream)
{
  size_t i, len;
  nghttp3_qpack_header_block_ref *ref;
  nghttp3_map_remove(&encoder->streams, stream->me.key);
  len = ((&stream->refs)->len);
  for (i = 0; i < len; ++i)
  {
    ref = *(nghttp3_qpack_header_block_ref **)nghttp3_ringbuf_get(&stream->refs,
                                                                  i);
    assert(ref->min_cnts_pe.index !=
           (18446744073709551615UL));
    nghttp3_pq_remove(&encoder->min_cnts, &ref->min_cnts_pe);
  }
}
static int reserve_buf_internal(nghttp3_buf *buf, size_t extra_size,
                                size_t min_size, const nghttp3_mem *mem)
{
  size_t left = nghttp3_buf_left(buf);
  size_t n = min_size, need;
  if (left >= extra_size)
  {
    return 0;
  }
  need = nghttp3_buf_cap(buf) + extra_size - left;
  for (; n < need; n *= 2)
    ;
  return nghttp3_buf_reserve(buf, n, mem);
}
static int reserve_buf_small(nghttp3_buf *buf, size_t extra_size,
                             const nghttp3_mem *mem)
{
  return reserve_buf_internal(buf, extra_size, 32, mem);
}
static int reserve_buf(nghttp3_buf *buf, size_t extra_size,
                       const nghttp3_mem *mem)
{
  return reserve_buf_internal(buf, extra_size, 32, mem);
}
int nghttp3_qpack_encoder_encode(nghttp3_qpack_encoder *encoder,
                                 nghttp3_buf *pbuf, nghttp3_buf *rbuf,
                                 nghttp3_buf *ebuf, int64_t stream_id,
                                 const nghttp3_nv *nva, size_t nvlen)
{
  size_t i;
  uint64_t max_cnt = 0, min_cnt =
                            (18446744073709551615UL);
  uint64_t base;
  int rv = 0;
  int allow_blocking;
  int blocked_stream;
  nghttp3_qpack_stream *stream;
  if (encoder->ctx.bad)
  {
    return NGHTTP3_ERR_QPACK_FATAL;
  }
  rv = nghttp3_qpack_encoder_process_dtable_update(encoder, ebuf);
  if (rv != 0)
  {
    goto fail;
  }
  base = encoder->ctx.next_absidx;
  stream = nghttp3_qpack_encoder_find_stream(encoder, stream_id);
  blocked_stream =
      stream && nghttp3_qpack_encoder_stream_is_blocked(encoder, stream);
  allow_blocking =
      blocked_stream ||
      encoder->ctx.max_blocked > nghttp3_ksl_len(&encoder->blocked_streams);
  do
  {
  } while (0);
  for (i = 0; i < nvlen; ++i)
  {
    rv = nghttp3_qpack_encoder_encode_nv(encoder, &max_cnt, &min_cnt, rbuf,
                                         ebuf, &nva[i], base, allow_blocking);
    if (rv != 0)
    {
      goto fail;
    }
  }
  nghttp3_qpack_encoder_write_field_section_prefix(encoder, pbuf, max_cnt,
                                                   base);
  if (!max_cnt)
  {
    return 0;
  }
  rv = qpack_encoder_add_stream_ref(encoder, stream_id, stream, max_cnt,
                                    min_cnt);
  if (rv != 0)
  {
    goto fail;
  }
  return 0;
fail:
  encoder->ctx.bad = 1;
  return rv;
}
static int qpack_write_number(nghttp3_buf *rbuf, uint8_t fb, uint64_t num,
                              size_t prefix, const nghttp3_mem *mem)
{
  int rv;
  size_t len = nghttp3_qpack_put_varint_len(num, prefix);
  uint8_t *p;
  rv = reserve_buf(rbuf, len, mem);
  if (rv != 0)
  {
    return rv;
  }
  p = rbuf->last;
  *p = fb;
  p = nghttp3_qpack_put_varint(p, num, prefix);
  assert((size_t)(p - rbuf->last) == len);
  rbuf->last = p;
  return 0;
}
int nghttp3_qpack_encoder_process_dtable_update(nghttp3_qpack_encoder *encoder,
                                                nghttp3_buf *ebuf)
{
  int rv;
  nghttp3_qpack_encoder_shrink_dtable(encoder);
  if (encoder->ctx.max_dtable_size < encoder->ctx.dtable_size ||
      !(encoder->flags & NGHTTP3_QPACK_ENCODER_FLAG_PENDING_SET_DTABLE_CAP))
  {
    return 0;
  }
  if (encoder->min_dtable_update < encoder->last_max_dtable_update)
  {
    rv = nghttp3_qpack_encoder_write_set_dtable_cap(encoder, ebuf,
                                                    encoder->min_dtable_update);
    if (rv != 0)
    {
      return rv;
    }
  }
  rv = nghttp3_qpack_encoder_write_set_dtable_cap(
      encoder, ebuf, encoder->last_max_dtable_update);
  if (rv != 0)
  {
    return rv;
  }
  encoder->flags &= (uint8_t)~NGHTTP3_QPACK_ENCODER_FLAG_PENDING_SET_DTABLE_CAP;
  encoder->min_dtable_update =
      (18446744073709551615UL);
  encoder->ctx.max_dtable_size = encoder->last_max_dtable_update;
  return 0;
}
int nghttp3_qpack_encoder_write_set_dtable_cap(nghttp3_qpack_encoder *encoder,
                                               nghttp3_buf *ebuf, size_t cap)
{
  do
  {
  } while (0);
  return qpack_write_number(ebuf, 0x20, cap, 5, encoder->ctx.mem);
}
nghttp3_qpack_stream *
nghttp3_qpack_encoder_find_stream(nghttp3_qpack_encoder *encoder,
                                  int64_t stream_id)
{
  nghttp3_map_entry *me =
      nghttp3_map_find(&encoder->streams, (uint64_t)stream_id);
  return me ==
                 __null
             ? __null
             : ((nghttp3_qpack_stream *)(void *)((char *)(me) -
                                                 __builtin_offsetof(
                                                     nghttp3_qpack_stream,
                                                     me)));
}
int nghttp3_qpack_encoder_stream_is_blocked(nghttp3_qpack_encoder *encoder,
                                            nghttp3_qpack_stream *stream)
{
  return stream && encoder->krcnt < nghttp3_qpack_stream_get_max_cnt(stream);
}
static nghttp3_qpack_indexing_mode
qpack_encoder_decide_indexing_mode(nghttp3_qpack_encoder *encoder,
                                   const nghttp3_nv *nv, int32_t token)
{
  if (nv->flags & NGHTTP3_NV_FLAG_NEVER_INDEX)
  {
    return NGHTTP3_QPACK_INDEXING_MODE_NEVER;
  }
  switch (token)
  {
  case NGHTTP3_QPACK_TOKEN_AUTHORIZATION:
    return NGHTTP3_QPACK_INDEXING_MODE_NEVER;
  case NGHTTP3_QPACK_TOKEN_COOKIE:
    if (nv->valuelen < 20)
    {
      return NGHTTP3_QPACK_INDEXING_MODE_NEVER;
    }
    break;
  case -1:
  case NGHTTP3_QPACK_TOKEN__PATH:
  case NGHTTP3_QPACK_TOKEN_AGE:
  case NGHTTP3_QPACK_TOKEN_CONTENT_LENGTH:
  case NGHTTP3_QPACK_TOKEN_ETAG:
  case NGHTTP3_QPACK_TOKEN_IF_MODIFIED_SINCE:
  case NGHTTP3_QPACK_TOKEN_IF_NONE_MATCH:
  case NGHTTP3_QPACK_TOKEN_LOCATION:
  case NGHTTP3_QPACK_TOKEN_SET_COOKIE:
    return NGHTTP3_QPACK_INDEXING_MODE_LITERAL;
  case NGHTTP3_QPACK_TOKEN_HOST:
  case NGHTTP3_QPACK_TOKEN_TE:
  case NGHTTP3_QPACK_TOKEN__PROTOCOL:
  case NGHTTP3_QPACK_TOKEN_PRIORITY:
    break;
  default:
    if (token >= 1000)
    {
      return NGHTTP3_QPACK_INDEXING_MODE_LITERAL;
    }
  }
  if (table_space(nv->namelen, nv->valuelen) >
      encoder->ctx.max_dtable_size * 3 / 4)
  {
    return NGHTTP3_QPACK_INDEXING_MODE_LITERAL;
  }
  return NGHTTP3_QPACK_INDEXING_MODE_STORE;
}
static int qpack_encoder_can_index(nghttp3_qpack_encoder *encoder, size_t need,
                                   uint64_t min_cnt)
{
  size_t avail = 0;
  size_t len;
  uint64_t gmin_cnt;
  nghttp3_qpack_entry *min_ent, *last_ent;
  nghttp3_ringbuf *dtable = &encoder->ctx.dtable;
  if (encoder->ctx.max_dtable_size > encoder->ctx.dtable_size)
  {
    avail = encoder->ctx.max_dtable_size - encoder->ctx.dtable_size;
    if (need <= avail)
    {
      return 1;
    }
  }
  if (!nghttp3_pq_empty(&encoder->min_cnts))
  {
    gmin_cnt = nghttp3_qpack_encoder_get_min_cnt(encoder);
    min_cnt = ((min_cnt) < (gmin_cnt) ? (min_cnt) : (gmin_cnt));
  }
  if (min_cnt ==
      (18446744073709551615UL))
  {
    return encoder->ctx.max_dtable_size >= need;
  }
  min_ent = nghttp3_qpack_context_dtable_get(&encoder->ctx, min_cnt - 1);
  len = ((&encoder->ctx.dtable)->len);
  assert(len);
  last_ent = *(nghttp3_qpack_entry **)nghttp3_ringbuf_get(dtable, len - 1);
  if (min_ent == last_ent)
  {
    return 0;
  }
  return avail + min_ent->sum - last_ent->sum >= need;
}
static int qpack_encoder_can_index_nv(nghttp3_qpack_encoder *encoder,
                                      const nghttp3_nv *nv, uint64_t min_cnt)
{
  return qpack_encoder_can_index(
      encoder, table_space(nv->namelen, nv->valuelen), min_cnt);
}
static int qpack_encoder_can_index_duplicate(nghttp3_qpack_encoder *encoder,
                                             uint64_t absidx,
                                             uint64_t min_cnt)
{
  nghttp3_qpack_entry *ent =
      nghttp3_qpack_context_dtable_get(&encoder->ctx, absidx);
  return qpack_encoder_can_index(
      encoder, table_space(ent->nv.name->len, ent->nv.value->len), min_cnt);
}
static int qpack_context_check_draining(nghttp3_qpack_context *ctx,
                                        uint64_t absidx)
{
  const size_t safe =
      ctx->max_dtable_size - ((512) < (ctx->max_dtable_size * 1 / 8) ? (512) : (ctx->max_dtable_size * 1 / 8));
  nghttp3_qpack_entry *ent = nghttp3_qpack_context_dtable_get(ctx, absidx);
  return ctx->dtable_sum - ent->sum > safe;
}
int nghttp3_qpack_encoder_encode_nv(nghttp3_qpack_encoder *encoder,
                                    uint64_t *pmax_cnt, uint64_t *pmin_cnt,
                                    nghttp3_buf *rbuf, nghttp3_buf *ebuf,
                                    const nghttp3_nv *nv, uint64_t base,
                                    int allow_blocking)
{
  uint32_t hash = 0;
  int32_t token;
  nghttp3_qpack_indexing_mode indexing_mode;
  nghttp3_qpack_lookup_result sres = {-1, 0, -1}, dres = {-1, 0, -1};
  nghttp3_qpack_entry *new_ent =
      __null;
  int static_entry;
  int just_index = 0;
  int rv;
  token = qpack_lookup_token(nv->name, nv->namelen);
  static_entry = token != -1 && (size_t)token < (sizeof(token_stable) / sizeof(*(token_stable)));
  if (static_entry)
  {
    hash = token_stable[token].hash;
  }
  else
  {
    switch (token)
    {
    case NGHTTP3_QPACK_TOKEN_HOST:
      hash = 2952701295u;
      break;
    case NGHTTP3_QPACK_TOKEN_TE:
      hash = 1011170994u;
      break;
    case NGHTTP3_QPACK_TOKEN__PROTOCOL:
      hash = 1128642621u;
      break;
    case NGHTTP3_QPACK_TOKEN_PRIORITY:
      hash = 2498028297u;
      break;
    }
  }
  indexing_mode = qpack_encoder_decide_indexing_mode(encoder, nv, token);
  if (static_entry)
  {
    sres = nghttp3_qpack_lookup_stable(nv, token, indexing_mode);
    if (sres.index != -1 && sres.name_value_match)
    {
      return nghttp3_qpack_encoder_write_static_indexed(encoder, rbuf,
                                                        (size_t)sres.index);
    }
  }
  if (hash &&
      nghttp3_map_size(&encoder->streams) < 2000)
  {
    dres = nghttp3_qpack_encoder_lookup_dtable(encoder, nv, token, hash,
                                               indexing_mode, encoder->krcnt,
                                               allow_blocking);
    just_index = indexing_mode == NGHTTP3_QPACK_INDEXING_MODE_STORE &&
                 dres.pb_index == -1;
  }
  if (dres.index != -1 && dres.name_value_match)
  {
    if (allow_blocking &&
        qpack_context_check_draining(&encoder->ctx, (size_t)dres.index) &&
        qpack_encoder_can_index_duplicate(encoder, (size_t)dres.index,
                                          *pmin_cnt))
    {
      rv = nghttp3_qpack_encoder_write_duplicate_insert(encoder, ebuf,
                                                        (size_t)dres.index);
      if (rv != 0)
      {
        return rv;
      }
      rv = nghttp3_qpack_encoder_dtable_duplicate_add(encoder,
                                                      (size_t)dres.index);
      if (rv != 0)
      {
        return rv;
      }
      new_ent = nghttp3_qpack_context_dtable_top(&encoder->ctx);
      dres.index = (nghttp3_ssize)new_ent->absidx;
    }
    *pmax_cnt = ((*pmax_cnt) > ((size_t)(dres.index + 1)) ? (*pmax_cnt) : ((size_t)(dres.index + 1)));
    *pmin_cnt = ((*pmin_cnt) < ((size_t)(dres.index + 1)) ? (*pmin_cnt) : ((size_t)(dres.index + 1)));
    return nghttp3_qpack_encoder_write_dynamic_indexed(
        encoder, rbuf, (size_t)dres.index, base);
  }
  if (sres.index != -1)
  {
    if (just_index && qpack_encoder_can_index_nv(encoder, nv, *pmin_cnt))
    {
      rv = nghttp3_qpack_encoder_write_static_insert(encoder, ebuf,
                                                     (size_t)sres.index, nv);
      if (rv != 0)
      {
        return rv;
      }
      rv = nghttp3_qpack_encoder_dtable_static_add(encoder, (size_t)sres.index,
                                                   nv, hash);
      if (rv != 0)
      {
        return rv;
      }
      if (allow_blocking)
      {
        new_ent = nghttp3_qpack_context_dtable_top(&encoder->ctx);
        *pmax_cnt = ((*pmax_cnt) > (new_ent->absidx + 1) ? (*pmax_cnt) : (new_ent->absidx + 1));
        *pmin_cnt = ((*pmin_cnt) < (new_ent->absidx + 1) ? (*pmin_cnt) : (new_ent->absidx + 1));
        return nghttp3_qpack_encoder_write_dynamic_indexed(
            encoder, rbuf, new_ent->absidx, base);
      }
    }
    return nghttp3_qpack_encoder_write_static_indexed_name(
        encoder, rbuf, (size_t)sres.index, nv);
  }
  if (dres.index != -1)
  {
    if (just_index &&
        qpack_encoder_can_index_nv(
            encoder, nv,
            allow_blocking ? *pmin_cnt
                           : (((size_t)dres.index + 1) < (*pmin_cnt) ? ((size_t)dres.index + 1) : (*pmin_cnt))))
    {
      rv = nghttp3_qpack_encoder_write_dynamic_insert(encoder, ebuf,
                                                      (size_t)dres.index, nv);
      if (rv != 0)
      {
        return rv;
      }
      if (!allow_blocking)
      {
        *pmin_cnt = ((*pmin_cnt) < ((size_t)dres.index + 1) ? (*pmin_cnt) : ((size_t)dres.index + 1));
      }
      rv = nghttp3_qpack_encoder_dtable_dynamic_add(encoder, (size_t)dres.index,
                                                    nv, hash);
      if (rv != 0)
      {
        return rv;
      }
      if (allow_blocking)
      {
        new_ent = nghttp3_qpack_context_dtable_top(&encoder->ctx);
        *pmax_cnt = ((*pmax_cnt) > (new_ent->absidx + 1) ? (*pmax_cnt) : (new_ent->absidx + 1));
        *pmin_cnt = ((*pmin_cnt) < (new_ent->absidx + 1) ? (*pmin_cnt) : (new_ent->absidx + 1));
        return nghttp3_qpack_encoder_write_dynamic_indexed(
            encoder, rbuf, new_ent->absidx, base);
      }
    }
    *pmax_cnt = ((*pmax_cnt) > ((size_t)(dres.index + 1)) ? (*pmax_cnt) : ((size_t)(dres.index + 1)));
    *pmin_cnt = ((*pmin_cnt) < ((size_t)(dres.index + 1)) ? (*pmin_cnt) : ((size_t)(dres.index + 1)));
    return nghttp3_qpack_encoder_write_dynamic_indexed_name(
        encoder, rbuf, (size_t)dres.index, base, nv);
  }
  if (just_index && qpack_encoder_can_index_nv(encoder, nv, *pmin_cnt))
  {
    rv = nghttp3_qpack_encoder_dtable_literal_add(encoder, nv, token, hash);
    if (rv != 0)
    {
      return rv;
    }
    rv = nghttp3_qpack_encoder_write_literal_insert(encoder, ebuf, nv);
    if (rv != 0)
    {
      return rv;
    }
    if (allow_blocking)
    {
      new_ent = nghttp3_qpack_context_dtable_top(&encoder->ctx);
      *pmax_cnt = ((*pmax_cnt) > (new_ent->absidx + 1) ? (*pmax_cnt) : (new_ent->absidx + 1));
      *pmin_cnt = ((*pmin_cnt) < (new_ent->absidx + 1) ? (*pmin_cnt) : (new_ent->absidx + 1));
      return nghttp3_qpack_encoder_write_dynamic_indexed(encoder, rbuf,
                                                         new_ent->absidx, base);
    }
  }
  return nghttp3_qpack_encoder_write_literal(encoder, rbuf, nv);
}
nghttp3_qpack_lookup_result
nghttp3_qpack_lookup_stable(const nghttp3_nv *nv, int32_t token,
                            nghttp3_qpack_indexing_mode indexing_mode)
{
  nghttp3_qpack_lookup_result res = {(nghttp3_ssize)token_stable[token].absidx,
                                     0, -1};
  nghttp3_qpack_static_entry *ent;
  nghttp3_qpack_static_header *hdr;
  size_t i;
  assert(token >= 0);
  if (indexing_mode == NGHTTP3_QPACK_INDEXING_MODE_NEVER)
  {
    return res;
  }
  for (i = (size_t)token;
       i < (sizeof(token_stable) / sizeof(*(token_stable))) && token_stable[i].token == token;
       ++i)
  {
    ent = &token_stable[i];
    hdr = &stable[ent->absidx];
    if (hdr->value.len == nv->valuelen &&
        memeq(hdr->value.base, nv->value, nv->valuelen))
    {
      res.index = (nghttp3_ssize)ent->absidx;
      res.name_value_match = 1;
      return res;
    }
  }
  return res;
}
nghttp3_qpack_lookup_result nghttp3_qpack_encoder_lookup_dtable(
    nghttp3_qpack_encoder *encoder, const nghttp3_nv *nv, int32_t token,
    uint32_t hash, nghttp3_qpack_indexing_mode indexing_mode, uint64_t krcnt,
    int allow_blocking)
{
  nghttp3_qpack_lookup_result res = {-1, 0, -1};
  int exact_match = 0;
  nghttp3_qpack_entry *match, *pb_match;
  encoder_qpack_map_find(encoder, &exact_match, &match, &pb_match, nv, token,
                         hash, krcnt, allow_blocking,
                         indexing_mode == NGHTTP3_QPACK_INDEXING_MODE_NEVER);
  if (match)
  {
    res.index = (nghttp3_ssize)match->absidx;
    res.name_value_match = exact_match;
  }
  if (pb_match)
  {
    res.pb_index = (nghttp3_ssize)pb_match->absidx;
  }
  return res;
}
int nghttp3_qpack_header_block_ref_new(nghttp3_qpack_header_block_ref **pref,
                                       uint64_t max_cnt, uint64_t min_cnt,
                                       const nghttp3_mem *mem)
{
  nghttp3_qpack_header_block_ref *ref =
      nghttp3_mem_malloc(mem, sizeof(nghttp3_qpack_header_block_ref));
  if (ref ==
      __null)
  {
    return NGHTTP3_ERR_NOMEM;
  }
  ref->max_cnts_pe.index =
      (18446744073709551615UL);
  ref->min_cnts_pe.index =
      (18446744073709551615UL);
  ref->max_cnt = max_cnt;
  ref->min_cnt = min_cnt;
  *pref = ref;
  return 0;
}
void nghttp3_qpack_header_block_ref_del(nghttp3_qpack_header_block_ref *ref,
                                        const nghttp3_mem *mem)
{
  nghttp3_mem_free(mem, ref);
}
static int ref_max_cnt_greater(const nghttp3_pq_entry *lhsx,
                               const nghttp3_pq_entry *rhsx)
{
  const nghttp3_qpack_header_block_ref *lhs =
      ((nghttp3_qpack_header_block_ref *)(void *)((char *)(lhsx) -
                                                  __builtin_offsetof(
                                                      nghttp3_qpack_header_block_ref,
                                                      max_cnts_pe)));
  const nghttp3_qpack_header_block_ref *rhs =
      ((nghttp3_qpack_header_block_ref *)(void *)((char *)(rhsx) -
                                                  __builtin_offsetof(
                                                      nghttp3_qpack_header_block_ref,
                                                      max_cnts_pe)));
  return lhs->max_cnt > rhs->max_cnt;
}
int nghttp3_qpack_stream_new(nghttp3_qpack_stream **pstream, int64_t stream_id,
                             const nghttp3_mem *mem)
{
  int rv;
  nghttp3_qpack_stream *stream;
  stream = nghttp3_mem_malloc(mem, sizeof(nghttp3_qpack_stream));
  if (stream ==
      __null)
  {
    return NGHTTP3_ERR_NOMEM;
  }
  rv = nghttp3_ringbuf_init(&stream->refs, 4,
                            sizeof(nghttp3_qpack_header_block_ref *), mem);
  if (rv != 0)
  {
    nghttp3_mem_free(mem, stream);
    return rv;
  }
  nghttp3_pq_init(&stream->max_cnts, ref_max_cnt_greater, mem);
  stream->me.next =
      __null;
  stream->me.key = (uint64_t)stream_id;
  *pstream = stream;
  return 0;
}
void nghttp3_qpack_stream_del(nghttp3_qpack_stream *stream,
                              const nghttp3_mem *mem)
{
  nghttp3_qpack_header_block_ref *ref;
  size_t i, len;
  if (stream ==
      __null)
  {
    return;
  }
  nghttp3_pq_free(&stream->max_cnts);
  len = ((&stream->refs)->len);
  for (i = 0; i < len; ++i)
  {
    ref = *(nghttp3_qpack_header_block_ref **)nghttp3_ringbuf_get(&stream->refs,
                                                                  i);
    nghttp3_qpack_header_block_ref_del(ref, mem);
  }
  nghttp3_ringbuf_free(&stream->refs);
  nghttp3_mem_free(mem, stream);
}
uint64_t nghttp3_qpack_stream_get_max_cnt(const nghttp3_qpack_stream *stream)
{
  nghttp3_qpack_header_block_ref *ref;
  if (nghttp3_pq_empty(&stream->max_cnts))
  {
    return 0;
  }
  ref = ((nghttp3_qpack_header_block_ref *)(void *)((char *)(nghttp3_pq_top(&stream->max_cnts)) -
                                                    __builtin_offsetof(
                                                        nghttp3_qpack_header_block_ref,
                                                        max_cnts_pe)));
  return ref->max_cnt;
}
int nghttp3_qpack_stream_add_ref(nghttp3_qpack_stream *stream,
                                 nghttp3_qpack_header_block_ref *ref)
{
  nghttp3_qpack_header_block_ref **dest;
  int rv;
  if (nghttp3_ringbuf_full(&stream->refs))
  {
    rv = nghttp3_ringbuf_reserve(&stream->refs,
                                 ((&stream->refs)->len) * 2);
    if (rv != 0)
    {
      return rv;
    }
  }
  dest = nghttp3_ringbuf_push_back(&stream->refs);
  *dest = ref;
  return nghttp3_pq_push(&stream->max_cnts, &ref->max_cnts_pe);
}
void nghttp3_qpack_stream_pop_ref(nghttp3_qpack_stream *stream)
{
  nghttp3_qpack_header_block_ref *ref;
  assert(((&stream->refs)->len));
  ref =
      *(nghttp3_qpack_header_block_ref **)nghttp3_ringbuf_get(&stream->refs, 0);
  assert(ref->max_cnts_pe.index !=
         (18446744073709551615UL));
  nghttp3_pq_remove(&stream->max_cnts, &ref->max_cnts_pe);
  nghttp3_ringbuf_pop_front(&stream->refs);
}
int nghttp3_qpack_encoder_write_static_indexed(nghttp3_qpack_encoder *encoder,
                                               nghttp3_buf *rbuf,
                                               uint64_t absidx)
{
  do
  {
  } while (0);
  return qpack_write_number(rbuf, 0xc0, absidx, 6, encoder->ctx.mem);
}
int nghttp3_qpack_encoder_write_dynamic_indexed(nghttp3_qpack_encoder *encoder,
                                                nghttp3_buf *rbuf,
                                                uint64_t absidx,
                                                uint64_t base)
{
  do
  {
  } while (0);
  if (absidx < base)
  {
    return qpack_write_number(rbuf, 0x80, base - absidx - 1, 6,
                              encoder->ctx.mem);
  }
  return qpack_write_number(rbuf, 0x10, absidx - base, 4, encoder->ctx.mem);
}
static int qpack_encoder_write_indexed_name(nghttp3_qpack_encoder *encoder,
                                            nghttp3_buf *buf, uint8_t fb,
                                            uint64_t nameidx, size_t prefix,
                                            const nghttp3_nv *nv)
{
  int rv;
  size_t len = nghttp3_qpack_put_varint_len(nameidx, prefix);
  uint8_t *p;
  size_t hlen;
  int h = 0;
  hlen = nghttp3_qpack_huffman_encode_count(nv->value, nv->valuelen);
  if (hlen < nv->valuelen)
  {
    h = 1;
    len += nghttp3_qpack_put_varint_len(hlen, 7) + hlen;
  }
  else
  {
    len += nghttp3_qpack_put_varint_len(nv->valuelen, 7) + nv->valuelen;
  }
  rv = reserve_buf(buf, len, encoder->ctx.mem);
  if (rv != 0)
  {
    return rv;
  }
  p = buf->last;
  *p = fb;
  p = nghttp3_qpack_put_varint(p, nameidx, prefix);
  if (h)
  {
    *p = 0x80;
    p = nghttp3_qpack_put_varint(p, hlen, 7);
    p = nghttp3_qpack_huffman_encode(p, nv->value, nv->valuelen);
  }
  else
  {
    *p = 0;
    p = nghttp3_qpack_put_varint(p, nv->valuelen, 7);
    if (nv->valuelen)
    {
      p = nghttp3_cpymem(p, nv->value, nv->valuelen);
    }
  }
  assert((size_t)(p - buf->last) == len);
  buf->last = p;
  return 0;
}
int nghttp3_qpack_encoder_write_static_indexed_name(
    nghttp3_qpack_encoder *encoder, nghttp3_buf *rbuf, uint64_t absidx,
    const nghttp3_nv *nv)
{
  uint8_t fb =
      (uint8_t)(0x50 | ((nv->flags & NGHTTP3_NV_FLAG_NEVER_INDEX) ? 0x20 : 0));
  do
  {
  } while (0);
  return qpack_encoder_write_indexed_name(encoder, rbuf, fb, absidx, 4, nv);
}
int nghttp3_qpack_encoder_write_dynamic_indexed_name(
    nghttp3_qpack_encoder *encoder, nghttp3_buf *rbuf, uint64_t absidx,
    uint64_t base, const nghttp3_nv *nv)
{
  uint8_t fb;
  do
  {
  } while (0);
  if (absidx < base)
  {
    fb = (uint8_t)(0x40 |
                   ((nv->flags & NGHTTP3_NV_FLAG_NEVER_INDEX) ? 0x20 : 0));
    return qpack_encoder_write_indexed_name(encoder, rbuf, fb,
                                            base - absidx - 1, 4, nv);
  }
  fb = (nv->flags & NGHTTP3_NV_FLAG_NEVER_INDEX) ? 0x08 : 0;
  return qpack_encoder_write_indexed_name(encoder, rbuf, fb, absidx - base, 3,
                                          nv);
}
static int qpack_encoder_write_literal(nghttp3_qpack_encoder *encoder,
                                       nghttp3_buf *buf, uint8_t fb,
                                       size_t prefix, const nghttp3_nv *nv)
{
  int rv;
  size_t len;
  uint8_t *p;
  size_t nhlen, vhlen;
  int nh = 0, vh = 0;
  nhlen = nghttp3_qpack_huffman_encode_count(nv->name, nv->namelen);
  if (nhlen < nv->namelen)
  {
    nh = 1;
    len = nghttp3_qpack_put_varint_len(nhlen, prefix) + nhlen;
  }
  else
  {
    len = nghttp3_qpack_put_varint_len(nv->namelen, prefix) + nv->namelen;
  }
  vhlen = nghttp3_qpack_huffman_encode_count(nv->value, nv->valuelen);
  if (vhlen < nv->valuelen)
  {
    vh = 1;
    len += nghttp3_qpack_put_varint_len(vhlen, 7) + vhlen;
  }
  else
  {
    len += nghttp3_qpack_put_varint_len(nv->valuelen, 7) + nv->valuelen;
  }
  rv = reserve_buf(buf, len, encoder->ctx.mem);
  if (rv != 0)
  {
    return rv;
  }
  p = buf->last;
  *p = fb;
  if (nh)
  {
    *p |= (uint8_t)(1 << prefix);
    p = nghttp3_qpack_put_varint(p, nhlen, prefix);
    p = nghttp3_qpack_huffman_encode(p, nv->name, nv->namelen);
  }
  else
  {
    p = nghttp3_qpack_put_varint(p, nv->namelen, prefix);
    if (nv->namelen)
    {
      p = nghttp3_cpymem(p, nv->name, nv->namelen);
    }
  }
  *p = 0;
  if (vh)
  {
    *p |= 0x80;
    p = nghttp3_qpack_put_varint(p, vhlen, 7);
    p = nghttp3_qpack_huffman_encode(p, nv->value, nv->valuelen);
  }
  else
  {
    p = nghttp3_qpack_put_varint(p, nv->valuelen, 7);
    if (nv->valuelen)
    {
      p = nghttp3_cpymem(p, nv->value, nv->valuelen);
    }
  }
  assert((size_t)(p - buf->last) == len);
  buf->last = p;
  return 0;
}
int nghttp3_qpack_encoder_write_literal(nghttp3_qpack_encoder *encoder,
                                        nghttp3_buf *rbuf,
                                        const nghttp3_nv *nv)
{
  uint8_t fb =
      (uint8_t)(0x20 | ((nv->flags & NGHTTP3_NV_FLAG_NEVER_INDEX) ? 0x10 : 0));
  do
  {
  } while (0);
  return qpack_encoder_write_literal(encoder, rbuf, fb, 3, nv);
}
int nghttp3_qpack_encoder_write_static_insert(nghttp3_qpack_encoder *encoder,
                                              nghttp3_buf *ebuf,
                                              uint64_t absidx,
                                              const nghttp3_nv *nv)
{
  do
  {
  } while (0);
  return qpack_encoder_write_indexed_name(encoder, ebuf, 0xc0, absidx, 6, nv);
}
int nghttp3_qpack_encoder_write_dynamic_insert(nghttp3_qpack_encoder *encoder,
                                               nghttp3_buf *ebuf,
                                               uint64_t absidx,
                                               const nghttp3_nv *nv)
{
  do
  {
  } while (0);
  return qpack_encoder_write_indexed_name(
      encoder, ebuf, 0x80, encoder->ctx.next_absidx - absidx - 1, 6, nv);
}
int nghttp3_qpack_encoder_write_duplicate_insert(nghttp3_qpack_encoder *encoder,
                                                 nghttp3_buf *ebuf,
                                                 uint64_t absidx)
{
  uint64_t idx = encoder->ctx.next_absidx - absidx - 1;
  size_t len = nghttp3_qpack_put_varint_len(idx, 5);
  uint8_t *p;
  int rv;
  do
  {
  } while (0);
  rv = reserve_buf(ebuf, len, encoder->ctx.mem);
  if (rv != 0)
  {
    return rv;
  }
  p = ebuf->last;
  *p = 0;
  p = nghttp3_qpack_put_varint(p, idx, 5);
  assert((size_t)(p - ebuf->last) == len);
  ebuf->last = p;
  return 0;
}
int nghttp3_qpack_encoder_write_literal_insert(nghttp3_qpack_encoder *encoder,
                                               nghttp3_buf *ebuf,
                                               const nghttp3_nv *nv)
{
  do
  {
  } while (0);
  return qpack_encoder_write_literal(encoder, ebuf, 0x40, 5, nv);
}
int nghttp3_qpack_context_dtable_add(nghttp3_qpack_context *ctx,
                                     nghttp3_qpack_nv *qnv,
                                     nghttp3_qpack_map *dtable_map,
                                     uint32_t hash)
{
  nghttp3_qpack_entry *new_ent, **p, *ent;
  const nghttp3_mem *mem = ctx->mem;
  size_t space;
  size_t i;
  int rv;
  space = table_space(qnv->name->len, qnv->value->len);
  assert(space <= ctx->max_dtable_size);
  while (ctx->dtable_size + space > ctx->max_dtable_size)
  {
    i = ((&ctx->dtable)->len);
    assert(i);
    ent = *(nghttp3_qpack_entry **)nghttp3_ringbuf_get(&ctx->dtable, i - 1);
    ctx->dtable_size -= table_space(ent->nv.name->len, ent->nv.value->len);
    nghttp3_ringbuf_pop_back(&ctx->dtable);
    if (dtable_map)
    {
      qpack_map_remove(dtable_map, ent);
    }
    nghttp3_qpack_entry_free(ent);
    nghttp3_mem_free(mem, ent);
  }
  new_ent = nghttp3_mem_malloc(mem, sizeof(nghttp3_qpack_entry));
  if (new_ent ==
      __null)
  {
    return NGHTTP3_ERR_NOMEM;
  }
  nghttp3_qpack_entry_init(new_ent, qnv, ctx->dtable_sum, ctx->next_absidx++,
                           hash);
  if (nghttp3_ringbuf_full(&ctx->dtable))
  {
    rv = nghttp3_ringbuf_reserve(&ctx->dtable,
                                 ((&ctx->dtable)->len) * 2);
    if (rv != 0)
    {
      goto fail;
    }
  }
  p = nghttp3_ringbuf_push_front(&ctx->dtable);
  *p = new_ent;
  if (dtable_map)
  {
    qpack_map_insert(dtable_map, new_ent);
  }
  ctx->dtable_size += space;
  ctx->dtable_sum += space;
  return 0;
fail:
  nghttp3_qpack_entry_free(new_ent);
  nghttp3_mem_free(mem, new_ent);
  return rv;
}
int nghttp3_qpack_encoder_dtable_static_add(nghttp3_qpack_encoder *encoder,
                                            uint64_t absidx,
                                            const nghttp3_nv *nv,
                                            uint32_t hash)
{
  const nghttp3_qpack_static_header *shd;
  nghttp3_qpack_nv qnv;
  const nghttp3_mem *mem = encoder->ctx.mem;
  int rv;
  rv = nghttp3_rcbuf_new2(&qnv.value, nv->value, nv->valuelen, mem);
  if (rv != 0)
  {
    return rv;
  }
  assert((sizeof(stable) / sizeof(*(stable))) > absidx);
  shd = &stable[absidx];
  qnv.name = (nghttp3_rcbuf *)&shd->name;
  qnv.token = shd->token;
  qnv.flags = NGHTTP3_NV_FLAG_NONE;
  rv = nghttp3_qpack_context_dtable_add(&encoder->ctx, &qnv,
                                        &encoder->dtable_map, hash);
  nghttp3_rcbuf_decref(qnv.value);
  return rv;
}
int nghttp3_qpack_encoder_dtable_dynamic_add(nghttp3_qpack_encoder *encoder,
                                             uint64_t absidx,
                                             const nghttp3_nv *nv,
                                             uint32_t hash)
{
  nghttp3_qpack_nv qnv;
  nghttp3_qpack_entry *ent;
  const nghttp3_mem *mem = encoder->ctx.mem;
  int rv;
  rv = nghttp3_rcbuf_new2(&qnv.value, nv->value, nv->valuelen, mem);
  if (rv != 0)
  {
    return rv;
  }
  ent = nghttp3_qpack_context_dtable_get(&encoder->ctx, absidx);
  qnv.name = ent->nv.name;
  qnv.token = ent->nv.token;
  qnv.flags = NGHTTP3_NV_FLAG_NONE;
  nghttp3_rcbuf_incref(qnv.name);
  rv = nghttp3_qpack_context_dtable_add(&encoder->ctx, &qnv,
                                        &encoder->dtable_map, hash);
  nghttp3_rcbuf_decref(qnv.value);
  nghttp3_rcbuf_decref(qnv.name);
  return rv;
}
int nghttp3_qpack_encoder_dtable_duplicate_add(nghttp3_qpack_encoder *encoder,
                                               uint64_t absidx)
{
  nghttp3_qpack_nv qnv;
  nghttp3_qpack_entry *ent;
  int rv;
  ent = nghttp3_qpack_context_dtable_get(&encoder->ctx, absidx);
  qnv = ent->nv;
  nghttp3_rcbuf_incref(qnv.name);
  nghttp3_rcbuf_incref(qnv.value);
  rv = nghttp3_qpack_context_dtable_add(&encoder->ctx, &qnv,
                                        &encoder->dtable_map, ent->hash);
  nghttp3_rcbuf_decref(qnv.name);
  nghttp3_rcbuf_decref(qnv.value);
  return rv;
}
int nghttp3_qpack_encoder_dtable_literal_add(nghttp3_qpack_encoder *encoder,
                                             const nghttp3_nv *nv,
                                             int32_t token, uint32_t hash)
{
  nghttp3_qpack_nv qnv;
  const nghttp3_mem *mem = encoder->ctx.mem;
  int rv;
  rv = nghttp3_rcbuf_new2(&qnv.name, nv->name, nv->namelen, mem);
  if (rv != 0)
  {
    return rv;
  }
  rv = nghttp3_rcbuf_new2(&qnv.value, nv->value, nv->valuelen, mem);
  if (rv != 0)
  {
    nghttp3_rcbuf_decref(qnv.name);
    return rv;
  }
  qnv.token = token;
  qnv.flags = NGHTTP3_NV_FLAG_NONE;
  rv = nghttp3_qpack_context_dtable_add(&encoder->ctx, &qnv,
                                        &encoder->dtable_map, hash);
  nghttp3_rcbuf_decref(qnv.value);
  nghttp3_rcbuf_decref(qnv.name);
  return rv;
}
nghttp3_qpack_entry *
nghttp3_qpack_context_dtable_get(nghttp3_qpack_context *ctx, uint64_t absidx)
{
  size_t relidx;
  assert(ctx->next_absidx > absidx);
  assert(ctx->next_absidx - absidx - 1 < ((&ctx->dtable)->len));
  relidx = (size_t)(ctx->next_absidx - absidx - 1);
  return *(nghttp3_qpack_entry **)nghttp3_ringbuf_get(&ctx->dtable, relidx);
}
nghttp3_qpack_entry *
nghttp3_qpack_context_dtable_top(nghttp3_qpack_context *ctx)
{
  assert(((&ctx->dtable)->len));
  return *(nghttp3_qpack_entry **)nghttp3_ringbuf_get(&ctx->dtable, 0);
}
void nghttp3_qpack_entry_init(nghttp3_qpack_entry *ent, nghttp3_qpack_nv *qnv,
                              size_t sum, uint64_t absidx, uint32_t hash)
{
  ent->nv = *qnv;
  ent->map_next =
      __null;
  ent->sum = sum;
  ent->absidx = absidx;
  ent->hash = hash;
  nghttp3_rcbuf_incref(ent->nv.name);
  nghttp3_rcbuf_incref(ent->nv.value);
}
void nghttp3_qpack_entry_free(nghttp3_qpack_entry *ent)
{
  nghttp3_rcbuf_decref(ent->nv.value);
  nghttp3_rcbuf_decref(ent->nv.name);
}
int nghttp3_qpack_encoder_block_stream(nghttp3_qpack_encoder *encoder,
                                       nghttp3_qpack_stream *stream)
{
  nghttp3_blocked_streams_key bsk = {
      ((nghttp3_qpack_header_block_ref *)(void *)((char *)(nghttp3_pq_top(&stream->max_cnts)) -
                                                  __builtin_offsetof(
                                                      nghttp3_qpack_header_block_ref,
                                                      max_cnts_pe)))
          ->max_cnt,
      stream->me.key};
  return nghttp3_ksl_insert(&encoder->blocked_streams,
                            __null, &bsk, stream);
}
void nghttp3_qpack_encoder_unblock_stream(nghttp3_qpack_encoder *encoder,
                                          nghttp3_qpack_stream *stream)
{
  nghttp3_blocked_streams_key bsk = {
      ((nghttp3_qpack_header_block_ref *)(void *)((char *)(nghttp3_pq_top(&stream->max_cnts)) -
                                                  __builtin_offsetof(
                                                      nghttp3_qpack_header_block_ref,
                                                      max_cnts_pe)))
          ->max_cnt,
      stream->me.key};
  nghttp3_ksl_it it;
  it = nghttp3_ksl_lower_bound(&encoder->blocked_streams, &bsk);
  assert(!((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                            __null));
  assert(nghttp3_ksl_it_get(&it) == stream);
  nghttp3_ksl_remove(&encoder->blocked_streams,
                     __null, &bsk);
}
void nghttp3_qpack_encoder_unblock(nghttp3_qpack_encoder *encoder,
                                   uint64_t max_cnt)
{
  nghttp3_blocked_streams_key bsk = {max_cnt, 0};
  nghttp3_ksl_it it;
  it = nghttp3_ksl_lower_bound(&encoder->blocked_streams, &bsk);
  for (; !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                            __null);)
  {
    bsk = *(nghttp3_blocked_streams_key *)((nghttp3_ksl_key *)((nghttp3_ksl_node *)(void *)(((&it)->blk)->nodes + ((&it)->ksl)->nodelen * ((&it)->i)))->key);
    nghttp3_ksl_remove(&encoder->blocked_streams, &it, &bsk);
  }
}
void nghttp3_qpack_encoder_ack_header(nghttp3_qpack_encoder *encoder,
                                      int64_t stream_id)
{
  nghttp3_qpack_stream *stream =
      nghttp3_qpack_encoder_find_stream(encoder, stream_id);
  const nghttp3_mem *mem = encoder->ctx.mem;
  nghttp3_qpack_header_block_ref *ref;
  if (stream ==
      __null)
  {
    return;
  }
  assert(((&stream->refs)->len));
  ref =
      *(nghttp3_qpack_header_block_ref **)nghttp3_ringbuf_get(&stream->refs, 0);
  do
  {
  } while (0);
  if (encoder->krcnt < ref->max_cnt)
  {
    encoder->krcnt = ref->max_cnt;
    nghttp3_qpack_encoder_unblock(encoder, ref->max_cnt);
  }
  nghttp3_qpack_stream_pop_ref(stream);
  assert(ref->min_cnts_pe.index !=
         (18446744073709551615UL));
  nghttp3_pq_remove(&encoder->min_cnts, &ref->min_cnts_pe);
  nghttp3_qpack_header_block_ref_del(ref, mem);
  if (((&stream->refs)->len))
  {
    return;
  }
  qpack_encoder_remove_stream(encoder, stream);
  nghttp3_qpack_stream_del(stream, mem);
}
int nghttp3_qpack_encoder_add_insert_count(nghttp3_qpack_encoder *encoder,
                                           uint64_t n)
{
  if (encoder->ctx.next_absidx - encoder->krcnt < n)
  {
    return NGHTTP3_ERR_QPACK_DECODER_STREAM_ERROR;
  }
  encoder->krcnt += n;
  nghttp3_qpack_encoder_unblock(encoder, encoder->krcnt);
  return 0;
}
void nghttp3_qpack_encoder_ack_everything(nghttp3_qpack_encoder *encoder)
{
  encoder->krcnt = encoder->ctx.next_absidx;
  nghttp3_ksl_clear(&encoder->blocked_streams);
  nghttp3_pq_clear(&encoder->min_cnts);
  nghttp3_map_each_free(&encoder->streams, map_stream_free,
                        (void *)encoder->ctx.mem);
}
void nghttp3_qpack_encoder_cancel_stream(nghttp3_qpack_encoder *encoder,
                                         int64_t stream_id)
{
  nghttp3_qpack_stream *stream =
      nghttp3_qpack_encoder_find_stream(encoder, stream_id);
  const nghttp3_mem *mem = encoder->ctx.mem;
  if (stream ==
      __null)
  {
    return;
  }
  if (nghttp3_qpack_encoder_stream_is_blocked(encoder, stream))
  {
    nghttp3_qpack_encoder_unblock_stream(encoder, stream);
  }
  qpack_encoder_remove_stream(encoder, stream);
  nghttp3_qpack_stream_del(stream, mem);
}
size_t nghttp3_qpack_encoder_get_num_blocked(nghttp3_qpack_encoder *encoder)
{
  return nghttp3_ksl_len(&encoder->blocked_streams);
}
int nghttp3_qpack_encoder_write_field_section_prefix(
    nghttp3_qpack_encoder *encoder, nghttp3_buf *pbuf, uint64_t ricnt,
    uint64_t base)
{
  size_t max_ents =
      encoder->ctx.hard_max_dtable_size / 32;
  uint64_t encricnt = ricnt == 0 ? 0 : (ricnt % (2 * max_ents)) + 1;
  int sign = base < ricnt;
  uint64_t delta_base = sign ? ricnt - base - 1 : base - ricnt;
  size_t len = nghttp3_qpack_put_varint_len(encricnt, 8) +
               nghttp3_qpack_put_varint_len(delta_base, 7);
  uint8_t *p;
  int rv;
  do
  {
  } while (0);
  rv = reserve_buf(pbuf, len, encoder->ctx.mem);
  if (rv != 0)
  {
    return rv;
  }
  p = pbuf->last;
  p = nghttp3_qpack_put_varint(p, encricnt, 8);
  if (sign)
  {
    *p = 0x80;
  }
  else
  {
    *p = 0;
  }
  p = nghttp3_qpack_put_varint(p, delta_base, 7);
  assert((size_t)(p - pbuf->last) == len);
  pbuf->last = p;
  return 0;
}
static nghttp3_ssize qpack_read_varint(int *fin,
                                       nghttp3_qpack_read_state *rstate,
                                       const uint8_t *begin,
                                       const uint8_t *end)
{
  uint64_t k = (uint8_t)((1 << rstate->prefix) - 1);
  uint64_t n = rstate->left;
  uint64_t add;
  const uint8_t *p = begin;
  size_t shift = rstate->shift;
  rstate->shift = 0;
  *fin = 0;
  if (n == 0)
  {
    if (((*p) & k) != k)
    {
      rstate->left = (*p) & k;
      *fin = 1;
      return 1;
    }
    n = k;
    if (++p == end)
    {
      rstate->left = n;
      return (nghttp3_ssize)(p - begin);
    }
  }
  for (; p != end; ++p, shift += 7)
  {
    add = (*p) & 0x7f;
    if (shift > 62)
    {
      return NGHTTP3_ERR_QPACK_FATAL;
    }
    if ((((1ull << 62) - 1) >> shift) < add)
    {
      return NGHTTP3_ERR_QPACK_FATAL;
    }
    add <<= shift;
    if (((1ull << 62) - 1) - add < n)
    {
      return NGHTTP3_ERR_QPACK_FATAL;
    }
    n += add;
    if (((*p) & (1 << 7)) == 0)
    {
      break;
    }
  }
  rstate->shift = shift;
  if (p == end)
  {
    rstate->left = n;
    return (nghttp3_ssize)(p - begin);
  }
  rstate->left = n;
  *fin = 1;
  return (nghttp3_ssize)(p + 1 - begin);
}
nghttp3_ssize nghttp3_qpack_encoder_read_decoder(nghttp3_qpack_encoder *encoder,
                                                 const uint8_t *src,
                                                 size_t srclen)
{
  const uint8_t *p = src, *end;
  int rv;
  nghttp3_ssize nread;
  int rfin;
  if (encoder->ctx.bad)
  {
    return NGHTTP3_ERR_QPACK_FATAL;
  }
  if (srclen == 0)
  {
    return 0;
  }
  end = src + srclen;
  for (; p != end;)
  {
    switch (encoder->state)
    {
    case NGHTTP3_QPACK_DS_STATE_OPCODE:
      if ((*p) & 0x80)
      {
        do
        {
        } while (0);
        encoder->opcode = NGHTTP3_QPACK_DS_OPCODE_SECTION_ACK;
        encoder->rstate.prefix = 7;
      }
      else if ((*p) & 0x40)
      {
        do
        {
        } while (0);
        encoder->opcode = NGHTTP3_QPACK_DS_OPCODE_STREAM_CANCEL;
        encoder->rstate.prefix = 6;
      }
      else
      {
        do
        {
        } while (0);
        encoder->opcode = NGHTTP3_QPACK_DS_OPCODE_ICNT_INCREMENT;
        encoder->rstate.prefix = 6;
      }
      encoder->state = NGHTTP3_QPACK_DS_STATE_READ_NUMBER;
    case NGHTTP3_QPACK_DS_STATE_READ_NUMBER:
      nread = qpack_read_varint(&rfin, &encoder->rstate, p, end);
      if (nread < 0)
      {
        assert(nread == NGHTTP3_ERR_QPACK_FATAL);
        rv = NGHTTP3_ERR_QPACK_DECODER_STREAM_ERROR;
        goto fail;
      }
      p += nread;
      if (!rfin)
      {
        return p - src;
      }
      switch (encoder->opcode)
      {
      case NGHTTP3_QPACK_DS_OPCODE_ICNT_INCREMENT:
        rv = nghttp3_qpack_encoder_add_insert_count(encoder,
                                                    encoder->rstate.left);
        if (rv != 0)
        {
          goto fail;
        }
        break;
      case NGHTTP3_QPACK_DS_OPCODE_SECTION_ACK:
        nghttp3_qpack_encoder_ack_header(encoder,
                                         (int64_t)encoder->rstate.left);
        break;
      case NGHTTP3_QPACK_DS_OPCODE_STREAM_CANCEL:
        nghttp3_qpack_encoder_cancel_stream(encoder,
                                            (int64_t)encoder->rstate.left);
        break;
      default:
        assert(0);
        break;
      }
      encoder->state = NGHTTP3_QPACK_DS_STATE_OPCODE;
      nghttp3_qpack_read_state_reset(&encoder->rstate);
      break;
    default:
      assert(0);
      break;
    }
  }
  return p - src;
fail:
  encoder->ctx.bad = 1;
  return rv;
}
size_t nghttp3_qpack_put_varint_len(uint64_t n, size_t prefix)
{
  size_t k = (size_t)((1 << prefix) - 1);
  size_t len = 0;
  if (n < k)
  {
    return 1;
  }
  n -= k;
  ++len;
  for (; n >= 128; n >>= 7, ++len)
    ;
  return len + 1;
}
uint8_t *nghttp3_qpack_put_varint(uint8_t *buf, uint64_t n, size_t prefix)
{
  size_t k = (size_t)((1 << prefix) - 1);
  *buf = (uint8_t)(*buf & ~k);
  if (n < k)
  {
    *buf = (uint8_t)(*buf | n);
    return buf + 1;
  }
  *buf = (uint8_t)(*buf | k);
  ++buf;
  n -= k;
  for (; n >= 128; n >>= 7)
  {
    *buf++ = (uint8_t)((1 << 7) | (n & 0x7f));
  }
  *buf++ = (uint8_t)n;
  return buf;
}
void nghttp3_qpack_read_state_free(nghttp3_qpack_read_state *rstate)
{
  nghttp3_rcbuf_decref(rstate->value);
  nghttp3_rcbuf_decref(rstate->name);
}
void nghttp3_qpack_read_state_reset(nghttp3_qpack_read_state *rstate)
{
  rstate->name =
      __null;
  rstate->value =
      __null;
  nghttp3_buf_init(&rstate->namebuf);
  nghttp3_buf_init(&rstate->valuebuf);
  rstate->left = 0;
  rstate->prefix = 0;
  rstate->shift = 0;
  rstate->absidx = 0;
  rstate->never = 0;
  rstate->dynamic = 0;
  rstate->huffman_encoded = 0;
}
int nghttp3_qpack_decoder_init(nghttp3_qpack_decoder *decoder,
                               size_t max_dtable_size, size_t max_blocked,
                               const nghttp3_mem *mem)
{
  int rv;
  rv = qpack_context_init(&decoder->ctx, max_dtable_size, max_blocked, mem);
  if (rv != 0)
  {
    return rv;
  }
  decoder->state = NGHTTP3_QPACK_ES_STATE_OPCODE;
  decoder->opcode = 0;
  decoder->written_icnt = 0;
  decoder->max_concurrent_streams = 0;
  nghttp3_qpack_read_state_reset(&decoder->rstate);
  nghttp3_buf_init(&decoder->dbuf);
  return 0;
}
void nghttp3_qpack_decoder_free(nghttp3_qpack_decoder *decoder)
{
  nghttp3_buf_free(&decoder->dbuf, decoder->ctx.mem);
  nghttp3_qpack_read_state_free(&decoder->rstate);
  qpack_context_free(&decoder->ctx);
}
static nghttp3_ssize qpack_read_huffman_string(nghttp3_qpack_read_state *rstate,
                                               nghttp3_buf *dest,
                                               const uint8_t *begin,
                                               const uint8_t *end)
{
  nghttp3_ssize nwrite;
  size_t len = (size_t)(end - begin);
  int fin = 0;
  if (len >= rstate->left)
  {
    len = (size_t)rstate->left;
    fin = 1;
  }
  nwrite = nghttp3_qpack_huffman_decode(&rstate->huffman_ctx, dest->last, begin,
                                        len, fin);
  if (nwrite < 0)
  {
    return nwrite;
  }
  if (nghttp3_qpack_huffman_decode_failure_state(&rstate->huffman_ctx))
  {
    return NGHTTP3_ERR_QPACK_FATAL;
  }
  dest->last += nwrite;
  rstate->left -= len;
  return (nghttp3_ssize)len;
}
static nghttp3_ssize qpack_read_string(nghttp3_qpack_read_state *rstate,
                                       nghttp3_buf *dest, const uint8_t *begin,
                                       const uint8_t *end)
{
  size_t len = (size_t)(end - begin);
  size_t n = (size_t)(((uint64_t)len) < (rstate->left) ? ((uint64_t)len) : (rstate->left));
  dest->last = nghttp3_cpymem(dest->last, begin, n);
  rstate->left -= n;
  return (nghttp3_ssize)n;
}
static int qpack_decoder_validate_index(nghttp3_qpack_decoder *decoder,
                                        nghttp3_qpack_read_state *rstate)
{
  if (rstate->dynamic)
  {
    return rstate->absidx < decoder->ctx.next_absidx &&
                   decoder->ctx.next_absidx - rstate->absidx - 1 <
                       ((&decoder->ctx.dtable)->len)
               ? 0
               : NGHTTP3_ERR_QPACK_FATAL;
  }
  return rstate->absidx < (sizeof(stable) / sizeof(*(stable))) ? 0
                                                               : NGHTTP3_ERR_QPACK_FATAL;
}
static void qpack_read_state_check_huffman(nghttp3_qpack_read_state *rstate,
                                           const uint8_t b)
{
  rstate->huffman_encoded = (b & (1 << rstate->prefix)) != 0;
}
static void qpack_read_state_terminate_name(nghttp3_qpack_read_state *rstate)
{
  *rstate->namebuf.last = '\0';
  rstate->name->len = nghttp3_buf_len(&rstate->namebuf);
}
static void qpack_read_state_terminate_value(nghttp3_qpack_read_state *rstate)
{
  *rstate->valuebuf.last = '\0';
  rstate->value->len = nghttp3_buf_len(&rstate->valuebuf);
}
nghttp3_ssize nghttp3_qpack_decoder_read_encoder(nghttp3_qpack_decoder *decoder,
                                                 const uint8_t *src,
                                                 size_t srclen)
{
  const uint8_t *p = src, *end;
  int rv;
  int busy = 0;
  const nghttp3_mem *mem = decoder->ctx.mem;
  nghttp3_ssize nread;
  int rfin;
  if (decoder->ctx.bad)
  {
    return NGHTTP3_ERR_QPACK_FATAL;
  }
  if (srclen == 0)
  {
    return 0;
  }
  end = src + srclen;
  for (; p != end || busy;)
  {
    busy = 0;
    switch (decoder->state)
    {
    case NGHTTP3_QPACK_ES_STATE_OPCODE:
      if ((*p) & 0x80)
      {
        do
        {
        } while (0);
        decoder->opcode = NGHTTP3_QPACK_ES_OPCODE_INSERT_INDEXED;
        decoder->rstate.dynamic = !((*p) & 0x40);
        decoder->rstate.prefix = 6;
        decoder->state = NGHTTP3_QPACK_ES_STATE_READ_INDEX;
      }
      else if ((*p) & 0x40)
      {
        do
        {
        } while (0);
        decoder->opcode = NGHTTP3_QPACK_ES_OPCODE_INSERT;
        decoder->rstate.dynamic = 0;
        decoder->rstate.prefix = 5;
        decoder->state = NGHTTP3_QPACK_ES_STATE_CHECK_NAME_HUFFMAN;
      }
      else if ((*p) & 0x20)
      {
        do
        {
        } while (0);
        decoder->opcode = NGHTTP3_QPACK_ES_OPCODE_SET_DTABLE_CAP;
        decoder->rstate.prefix = 5;
        decoder->state = NGHTTP3_QPACK_ES_STATE_READ_INDEX;
      }
      else if (!((*p) & 0x20))
      {
        do
        {
        } while (0);
        decoder->opcode = NGHTTP3_QPACK_ES_OPCODE_DUPLICATE;
        decoder->rstate.dynamic = 1;
        decoder->rstate.prefix = 5;
        decoder->state = NGHTTP3_QPACK_ES_STATE_READ_INDEX;
      }
      else
      {
        do
        {
        } while (0);
        rv = NGHTTP3_ERR_QPACK_ENCODER_STREAM_ERROR;
        goto fail;
      }
      break;
    case NGHTTP3_QPACK_ES_STATE_READ_INDEX:
      nread = qpack_read_varint(&rfin, &decoder->rstate, p, end);
      if (nread < 0)
      {
        assert(NGHTTP3_ERR_QPACK_FATAL == nread);
        rv = NGHTTP3_ERR_QPACK_ENCODER_STREAM_ERROR;
        goto fail;
      }
      p += nread;
      if (!rfin)
      {
        return p - src;
      }
      if (decoder->opcode == NGHTTP3_QPACK_ES_OPCODE_SET_DTABLE_CAP)
      {
        if (decoder->rstate.left > decoder->ctx.hard_max_dtable_size)
        {
          rv = NGHTTP3_ERR_QPACK_ENCODER_STREAM_ERROR;
          goto fail;
        }
        do
        {
        } while (0);
        nghttp3_qpack_decoder_set_dtable_cap(decoder,
                                             (size_t)decoder->rstate.left);
        decoder->state = NGHTTP3_QPACK_ES_STATE_OPCODE;
        nghttp3_qpack_read_state_reset(&decoder->rstate);
        break;
      }
      rv = nghttp3_qpack_decoder_rel2abs(decoder, &decoder->rstate);
      if (rv < 0)
      {
        goto fail;
      }
      if (decoder->opcode == NGHTTP3_QPACK_ES_OPCODE_DUPLICATE)
      {
        rv = nghttp3_qpack_decoder_dtable_duplicate_add(decoder);
        if (rv != 0)
        {
          goto fail;
        }
        decoder->state = NGHTTP3_QPACK_ES_STATE_OPCODE;
        nghttp3_qpack_read_state_reset(&decoder->rstate);
        break;
      }
      if (decoder->opcode == NGHTTP3_QPACK_ES_OPCODE_INSERT_INDEXED)
      {
        decoder->rstate.prefix = 7;
        decoder->state = NGHTTP3_QPACK_ES_STATE_CHECK_VALUE_HUFFMAN;
        break;
      }
      assert(0);
      break;
    case NGHTTP3_QPACK_ES_STATE_CHECK_NAME_HUFFMAN:
      qpack_read_state_check_huffman(&decoder->rstate, *p);
      decoder->state = NGHTTP3_QPACK_ES_STATE_READ_NAMELEN;
      decoder->rstate.left = 0;
      decoder->rstate.shift = 0;
    case NGHTTP3_QPACK_ES_STATE_READ_NAMELEN:
      nread = qpack_read_varint(&rfin, &decoder->rstate, p, end);
      if (nread < 0)
      {
        assert(NGHTTP3_ERR_QPACK_FATAL == nread);
        rv = NGHTTP3_ERR_QPACK_ENCODER_STREAM_ERROR;
        goto fail;
      }
      p += nread;
      if (!rfin)
      {
        return p - src;
      }
      if (decoder->rstate.left > 256)
      {
        rv = NGHTTP3_ERR_QPACK_HEADER_TOO_LARGE;
        goto fail;
      }
      if (decoder->rstate.huffman_encoded)
      {
        decoder->state = NGHTTP3_QPACK_ES_STATE_READ_NAME_HUFFMAN;
        nghttp3_qpack_huffman_decode_context_init(&decoder->rstate.huffman_ctx);
        rv = nghttp3_rcbuf_new(&decoder->rstate.name,
                               (size_t)decoder->rstate.left * 2 + 1, mem);
      }
      else
      {
        decoder->state = NGHTTP3_QPACK_ES_STATE_READ_NAME;
        rv = nghttp3_rcbuf_new(&decoder->rstate.name,
                               (size_t)decoder->rstate.left + 1, mem);
      }
      if (rv != 0)
      {
        goto fail;
      }
      nghttp3_buf_wrap_init(&decoder->rstate.namebuf,
                            decoder->rstate.name->base,
                            decoder->rstate.name->len);
      break;
    case NGHTTP3_QPACK_ES_STATE_READ_NAME_HUFFMAN:
      nread = qpack_read_huffman_string(&decoder->rstate,
                                        &decoder->rstate.namebuf, p, end);
      if (nread < 0)
      {
        assert(NGHTTP3_ERR_QPACK_FATAL == nread);
        rv = NGHTTP3_ERR_QPACK_ENCODER_STREAM_ERROR;
        goto fail;
      }
      p += nread;
      if (decoder->rstate.left)
      {
        return p - src;
      }
      qpack_read_state_terminate_name(&decoder->rstate);
      decoder->state = NGHTTP3_QPACK_ES_STATE_CHECK_VALUE_HUFFMAN;
      decoder->rstate.prefix = 7;
      break;
    case NGHTTP3_QPACK_ES_STATE_READ_NAME:
      nread =
          qpack_read_string(&decoder->rstate, &decoder->rstate.namebuf, p, end);
      if (nread < 0)
      {
        rv = (int)nread;
        goto fail;
      }
      p += nread;
      if (decoder->rstate.left)
      {
        return p - src;
      }
      qpack_read_state_terminate_name(&decoder->rstate);
      decoder->state = NGHTTP3_QPACK_ES_STATE_CHECK_VALUE_HUFFMAN;
      decoder->rstate.prefix = 7;
      break;
    case NGHTTP3_QPACK_ES_STATE_CHECK_VALUE_HUFFMAN:
      qpack_read_state_check_huffman(&decoder->rstate, *p);
      decoder->state = NGHTTP3_QPACK_ES_STATE_READ_VALUELEN;
      decoder->rstate.left = 0;
      decoder->rstate.shift = 0;
    case NGHTTP3_QPACK_ES_STATE_READ_VALUELEN:
      nread = qpack_read_varint(&rfin, &decoder->rstate, p, end);
      if (nread < 0)
      {
        assert(NGHTTP3_ERR_QPACK_FATAL == nread);
        rv = NGHTTP3_ERR_QPACK_ENCODER_STREAM_ERROR;
        goto fail;
      }
      p += nread;
      if (!rfin)
      {
        return p - src;
      }
      if (decoder->rstate.left > 65536)
      {
        rv = NGHTTP3_ERR_QPACK_HEADER_TOO_LARGE;
        goto fail;
      }
      if (decoder->rstate.huffman_encoded)
      {
        decoder->state = NGHTTP3_QPACK_ES_STATE_READ_VALUE_HUFFMAN;
        nghttp3_qpack_huffman_decode_context_init(&decoder->rstate.huffman_ctx);
        rv = nghttp3_rcbuf_new(&decoder->rstate.value,
                               (size_t)decoder->rstate.left * 2 + 1, mem);
      }
      else
      {
        decoder->state = NGHTTP3_QPACK_ES_STATE_READ_VALUE;
        rv = nghttp3_rcbuf_new(&decoder->rstate.value,
                               (size_t)decoder->rstate.left + 1, mem);
      }
      if (rv != 0)
      {
        goto fail;
      }
      nghttp3_buf_wrap_init(&decoder->rstate.valuebuf,
                            decoder->rstate.value->base,
                            decoder->rstate.value->len);
      busy = 1;
      break;
    case NGHTTP3_QPACK_ES_STATE_READ_VALUE_HUFFMAN:
      nread = qpack_read_huffman_string(&decoder->rstate,
                                        &decoder->rstate.valuebuf, p, end);
      if (nread < 0)
      {
        assert(NGHTTP3_ERR_QPACK_FATAL == nread);
        rv = NGHTTP3_ERR_QPACK_ENCODER_STREAM_ERROR;
        goto fail;
      }
      p += nread;
      if (decoder->rstate.left)
      {
        return p - src;
      }
      qpack_read_state_terminate_value(&decoder->rstate);
      switch (decoder->opcode)
      {
      case NGHTTP3_QPACK_ES_OPCODE_INSERT_INDEXED:
        rv = nghttp3_qpack_decoder_dtable_indexed_add(decoder);
        break;
      case NGHTTP3_QPACK_ES_OPCODE_INSERT:
        rv = nghttp3_qpack_decoder_dtable_literal_add(decoder);
        break;
      default:
        assert(0);
      }
      if (rv != 0)
      {
        goto fail;
      }
      decoder->state = NGHTTP3_QPACK_ES_STATE_OPCODE;
      nghttp3_qpack_read_state_reset(&decoder->rstate);
      break;
    case NGHTTP3_QPACK_ES_STATE_READ_VALUE:
      nread = qpack_read_string(&decoder->rstate, &decoder->rstate.valuebuf, p,
                                end);
      if (nread < 0)
      {
        rv = (int)nread;
        goto fail;
      }
      p += nread;
      if (decoder->rstate.left)
      {
        return p - src;
      }
      qpack_read_state_terminate_value(&decoder->rstate);
      switch (decoder->opcode)
      {
      case NGHTTP3_QPACK_ES_OPCODE_INSERT_INDEXED:
        rv = nghttp3_qpack_decoder_dtable_indexed_add(decoder);
        break;
      case NGHTTP3_QPACK_ES_OPCODE_INSERT:
        rv = nghttp3_qpack_decoder_dtable_literal_add(decoder);
        break;
      default:
        assert(0);
      }
      if (rv != 0)
      {
        goto fail;
      }
      decoder->state = NGHTTP3_QPACK_ES_STATE_OPCODE;
      nghttp3_qpack_read_state_reset(&decoder->rstate);
      break;
    }
  }
  return p - src;
fail:
  decoder->ctx.bad = 1;
  return rv;
}
void nghttp3_qpack_decoder_set_dtable_cap(nghttp3_qpack_decoder *decoder,
                                          size_t cap)
{
  nghttp3_qpack_entry *ent;
  size_t i;
  nghttp3_qpack_context *ctx = &decoder->ctx;
  const nghttp3_mem *mem = ctx->mem;
  ctx->max_dtable_size = cap;
  while (ctx->dtable_size > cap)
  {
    i = ((&ctx->dtable)->len);
    assert(i);
    ent = *(nghttp3_qpack_entry **)nghttp3_ringbuf_get(&ctx->dtable, i - 1);
    ctx->dtable_size -= table_space(ent->nv.name->len, ent->nv.value->len);
    nghttp3_ringbuf_pop_back(&ctx->dtable);
    nghttp3_qpack_entry_free(ent);
    nghttp3_mem_free(mem, ent);
  }
}
int nghttp3_qpack_decoder_dtable_indexed_add(nghttp3_qpack_decoder *decoder)
{
  do
  {
  } while (0);
  if (decoder->rstate.dynamic)
  {
    return nghttp3_qpack_decoder_dtable_dynamic_add(decoder);
  }
  return nghttp3_qpack_decoder_dtable_static_add(decoder);
}
int nghttp3_qpack_decoder_dtable_static_add(nghttp3_qpack_decoder *decoder)
{
  nghttp3_qpack_nv qnv;
  int rv;
  const nghttp3_qpack_static_header *shd;
  shd = &stable[decoder->rstate.absidx];
  if (table_space(shd->name.len, decoder->rstate.value->len) >
      decoder->ctx.max_dtable_size)
  {
    return NGHTTP3_ERR_QPACK_ENCODER_STREAM_ERROR;
  }
  qnv.name = (nghttp3_rcbuf *)&shd->name;
  qnv.value = decoder->rstate.value;
  qnv.token = shd->token;
  qnv.flags = NGHTTP3_NV_FLAG_NONE;
  rv = nghttp3_qpack_context_dtable_add(&decoder->ctx, &qnv,
                                        __null, 0);
  nghttp3_rcbuf_decref(qnv.value);
  return rv;
}
int nghttp3_qpack_decoder_dtable_dynamic_add(nghttp3_qpack_decoder *decoder)
{
  nghttp3_qpack_nv qnv;
  int rv;
  nghttp3_qpack_entry *ent;
  ent = nghttp3_qpack_context_dtable_get(&decoder->ctx, decoder->rstate.absidx);
  if (table_space(ent->nv.name->len, decoder->rstate.value->len) >
      decoder->ctx.max_dtable_size)
  {
    return NGHTTP3_ERR_QPACK_ENCODER_STREAM_ERROR;
  }
  qnv.name = ent->nv.name;
  qnv.value = decoder->rstate.value;
  qnv.token = ent->nv.token;
  qnv.flags = NGHTTP3_NV_FLAG_NONE;
  nghttp3_rcbuf_incref(qnv.name);
  rv = nghttp3_qpack_context_dtable_add(&decoder->ctx, &qnv,
                                        __null, 0);
  nghttp3_rcbuf_decref(qnv.value);
  nghttp3_rcbuf_decref(qnv.name);
  return rv;
}
int nghttp3_qpack_decoder_dtable_duplicate_add(nghttp3_qpack_decoder *decoder)
{
  int rv;
  nghttp3_qpack_entry *ent;
  nghttp3_qpack_nv qnv;
  do
  {
  } while (0);
  ent = nghttp3_qpack_context_dtable_get(&decoder->ctx, decoder->rstate.absidx);
  if (table_space(ent->nv.name->len, ent->nv.value->len) >
      decoder->ctx.max_dtable_size)
  {
    return NGHTTP3_ERR_QPACK_ENCODER_STREAM_ERROR;
  }
  qnv = ent->nv;
  nghttp3_rcbuf_incref(qnv.name);
  nghttp3_rcbuf_incref(qnv.value);
  rv = nghttp3_qpack_context_dtable_add(&decoder->ctx, &qnv,
                                        __null, 0);
  nghttp3_rcbuf_decref(qnv.value);
  nghttp3_rcbuf_decref(qnv.name);
  return rv;
}
int nghttp3_qpack_decoder_dtable_literal_add(nghttp3_qpack_decoder *decoder)
{
  nghttp3_qpack_nv qnv;
  int rv;
  do
  {
  } while (0);
  if (table_space(decoder->rstate.name->len, decoder->rstate.value->len) >
      decoder->ctx.max_dtable_size)
  {
    return NGHTTP3_ERR_QPACK_ENCODER_STREAM_ERROR;
  }
  qnv.name = decoder->rstate.name;
  qnv.value = decoder->rstate.value;
  qnv.token = qpack_lookup_token(qnv.name->base, qnv.name->len);
  qnv.flags = NGHTTP3_NV_FLAG_NONE;
  rv = nghttp3_qpack_context_dtable_add(&decoder->ctx, &qnv,
                                        __null, 0);
  nghttp3_rcbuf_decref(qnv.value);
  nghttp3_rcbuf_decref(qnv.name);
  return rv;
}
void nghttp3_qpack_decoder_set_max_concurrent_streams(
    nghttp3_qpack_decoder *decoder, size_t max_concurrent_streams)
{
  decoder->max_concurrent_streams =
      ((decoder->max_concurrent_streams) > (max_concurrent_streams) ? (decoder->max_concurrent_streams) : (max_concurrent_streams));
}
void nghttp3_qpack_stream_context_init(nghttp3_qpack_stream_context *sctx,
                                       int64_t stream_id,
                                       const nghttp3_mem *mem)
{
  nghttp3_qpack_read_state_reset(&sctx->rstate);
  sctx->mem = mem;
  sctx->rstate.prefix = 8;
  sctx->state = NGHTTP3_QPACK_RS_STATE_RICNT;
  sctx->opcode = 0;
  sctx->stream_id = stream_id;
  sctx->ricnt = 0;
  sctx->dbase_sign = 0;
  sctx->base = 0;
}
void nghttp3_qpack_stream_context_free(nghttp3_qpack_stream_context *sctx)
{
  nghttp3_qpack_read_state_free(&sctx->rstate);
}
void nghttp3_qpack_stream_context_reset(nghttp3_qpack_stream_context *sctx)
{
  nghttp3_qpack_stream_context_init(sctx, sctx->stream_id, sctx->mem);
}
uint64_t
nghttp3_qpack_stream_context_get_ricnt(nghttp3_qpack_stream_context *sctx)
{
  return sctx->ricnt;
}
nghttp3_ssize
nghttp3_qpack_decoder_read_request(nghttp3_qpack_decoder *decoder,
                                   nghttp3_qpack_stream_context *sctx,
                                   nghttp3_qpack_nv *nv, uint8_t *pflags,
                                   const uint8_t *src, size_t srclen, int fin)
{
  const uint8_t *p = src, *end = src ? src + srclen : src;
  int rv;
  int busy = 0;
  nghttp3_ssize nread;
  int rfin;
  const nghttp3_mem *mem = decoder->ctx.mem;
  if (decoder->ctx.bad)
  {
    return NGHTTP3_ERR_QPACK_FATAL;
  }
  *pflags = NGHTTP3_QPACK_DECODE_FLAG_NONE;
  for (; p != end || busy;)
  {
    busy = 0;
    switch (sctx->state)
    {
    case NGHTTP3_QPACK_RS_STATE_RICNT:
      nread = qpack_read_varint(&rfin, &sctx->rstate, p, end);
      if (nread < 0)
      {
        assert(NGHTTP3_ERR_QPACK_FATAL == nread);
        rv = NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED;
        goto fail;
      }
      p += nread;
      if (!rfin)
      {
        goto almost_ok;
      }
      rv = nghttp3_qpack_decoder_reconstruct_ricnt(decoder, &sctx->ricnt,
                                                   sctx->rstate.left);
      if (rv != 0)
      {
        goto fail;
      }
      sctx->state = NGHTTP3_QPACK_RS_STATE_DBASE_SIGN;
      break;
    case NGHTTP3_QPACK_RS_STATE_DBASE_SIGN:
      if ((*p) & 0x80)
      {
        sctx->dbase_sign = 1;
      }
      sctx->state = NGHTTP3_QPACK_RS_STATE_DBASE;
      sctx->rstate.left = 0;
      sctx->rstate.prefix = 7;
      sctx->rstate.shift = 0;
    case NGHTTP3_QPACK_RS_STATE_DBASE:
      nread = qpack_read_varint(&rfin, &sctx->rstate, p, end);
      if (nread < 0)
      {
        assert(NGHTTP3_ERR_QPACK_FATAL == nread);
        rv = NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED;
        goto fail;
      }
      p += nread;
      if (!rfin)
      {
        goto almost_ok;
      }
      if (sctx->dbase_sign)
      {
        if (sctx->ricnt < sctx->rstate.left)
        {
          rv = NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED;
          goto fail;
        }
        sctx->base = sctx->ricnt - sctx->rstate.left - 1;
      }
      else
      {
        sctx->base = sctx->ricnt + sctx->rstate.left;
      }
      do
      {
      } while (0);
      if (sctx->ricnt > decoder->ctx.next_absidx)
      {
        do
        {
        } while (0);
        sctx->state = NGHTTP3_QPACK_RS_STATE_BLOCKED;
        *pflags |= NGHTTP3_QPACK_DECODE_FLAG_BLOCKED;
        return p - src;
      }
      sctx->state = NGHTTP3_QPACK_RS_STATE_OPCODE;
      sctx->rstate.left = 0;
      sctx->rstate.shift = 0;
      break;
    case NGHTTP3_QPACK_RS_STATE_OPCODE:
      assert(sctx->rstate.left == 0);
      assert(sctx->rstate.shift == 0);
      if ((*p) & 0x80)
      {
        do
        {
        } while (0);
        sctx->opcode = NGHTTP3_QPACK_RS_OPCODE_INDEXED;
        sctx->rstate.dynamic = !((*p) & 0x40);
        sctx->rstate.prefix = 6;
        sctx->state = NGHTTP3_QPACK_RS_STATE_READ_INDEX;
      }
      else if ((*p) & 0x40)
      {
        do
        {
        } while (0);
        sctx->opcode = NGHTTP3_QPACK_RS_OPCODE_INDEXED_NAME;
        sctx->rstate.never = (*p) & 0x20;
        sctx->rstate.dynamic = !((*p) & 0x10);
        sctx->rstate.prefix = 4;
        sctx->state = NGHTTP3_QPACK_RS_STATE_READ_INDEX;
      }
      else if ((*p) & 0x20)
      {
        do
        {
        } while (0);
        sctx->opcode = NGHTTP3_QPACK_RS_OPCODE_LITERAL;
        sctx->rstate.never = (*p) & 0x10;
        sctx->rstate.dynamic = 0;
        sctx->rstate.prefix = 3;
        sctx->state = NGHTTP3_QPACK_RS_STATE_CHECK_NAME_HUFFMAN;
      }
      else if ((*p) & 0x10)
      {
        do
        {
        } while (0);
        sctx->opcode = NGHTTP3_QPACK_RS_OPCODE_INDEXED_PB;
        sctx->rstate.dynamic = 1;
        sctx->rstate.prefix = 4;
        sctx->state = NGHTTP3_QPACK_RS_STATE_READ_INDEX;
      }
      else
      {
        do
        {
        } while (0);
        sctx->opcode = NGHTTP3_QPACK_RS_OPCODE_INDEXED_NAME_PB;
        sctx->rstate.never = (*p) & 0x08;
        sctx->rstate.dynamic = 1;
        sctx->rstate.prefix = 3;
        sctx->state = NGHTTP3_QPACK_RS_STATE_READ_INDEX;
      }
      break;
    case NGHTTP3_QPACK_RS_STATE_READ_INDEX:
      nread = qpack_read_varint(&rfin, &sctx->rstate, p, end);
      if (nread < 0)
      {
        assert(NGHTTP3_ERR_QPACK_FATAL == nread);
        rv = NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED;
        goto fail;
      }
      p += nread;
      if (!rfin)
      {
        goto almost_ok;
      }
      switch (sctx->opcode)
      {
      case NGHTTP3_QPACK_RS_OPCODE_INDEXED:
        rv = nghttp3_qpack_decoder_brel2abs(decoder, sctx);
        if (rv != 0)
        {
          goto fail;
        }
        nghttp3_qpack_decoder_emit_indexed(decoder, sctx, nv);
        *pflags |= NGHTTP3_QPACK_DECODE_FLAG_EMIT;
        sctx->state = NGHTTP3_QPACK_RS_STATE_OPCODE;
        nghttp3_qpack_read_state_reset(&sctx->rstate);
        return p - src;
      case NGHTTP3_QPACK_RS_OPCODE_INDEXED_PB:
        rv = nghttp3_qpack_decoder_pbrel2abs(decoder, sctx);
        if (rv != 0)
        {
          goto fail;
        }
        nghttp3_qpack_decoder_emit_indexed(decoder, sctx, nv);
        *pflags |= NGHTTP3_QPACK_DECODE_FLAG_EMIT;
        sctx->state = NGHTTP3_QPACK_RS_STATE_OPCODE;
        nghttp3_qpack_read_state_reset(&sctx->rstate);
        return p - src;
      case NGHTTP3_QPACK_RS_OPCODE_INDEXED_NAME:
        rv = nghttp3_qpack_decoder_brel2abs(decoder, sctx);
        if (rv != 0)
        {
          goto fail;
        }
        sctx->rstate.prefix = 7;
        sctx->state = NGHTTP3_QPACK_RS_STATE_CHECK_VALUE_HUFFMAN;
        break;
      case NGHTTP3_QPACK_RS_OPCODE_INDEXED_NAME_PB:
        rv = nghttp3_qpack_decoder_pbrel2abs(decoder, sctx);
        if (rv != 0)
        {
          goto fail;
        }
        sctx->rstate.prefix = 7;
        sctx->state = NGHTTP3_QPACK_RS_STATE_CHECK_VALUE_HUFFMAN;
        break;
      default:
        assert(0);
      }
      break;
    case NGHTTP3_QPACK_RS_STATE_CHECK_NAME_HUFFMAN:
      qpack_read_state_check_huffman(&sctx->rstate, *p);
      sctx->state = NGHTTP3_QPACK_RS_STATE_READ_NAMELEN;
      sctx->rstate.left = 0;
      sctx->rstate.shift = 0;
    case NGHTTP3_QPACK_RS_STATE_READ_NAMELEN:
      nread = qpack_read_varint(&rfin, &sctx->rstate, p, end);
      if (nread < 0)
      {
        assert(NGHTTP3_ERR_QPACK_FATAL == nread);
        rv = NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED;
        goto fail;
      }
      p += nread;
      if (!rfin)
      {
        goto almost_ok;
      }
      if (sctx->rstate.left > 256)
      {
        rv = NGHTTP3_ERR_QPACK_HEADER_TOO_LARGE;
        goto fail;
      }
      if (sctx->rstate.huffman_encoded)
      {
        sctx->state = NGHTTP3_QPACK_RS_STATE_READ_NAME_HUFFMAN;
        nghttp3_qpack_huffman_decode_context_init(&sctx->rstate.huffman_ctx);
        rv = nghttp3_rcbuf_new(&sctx->rstate.name,
                               (size_t)sctx->rstate.left * 2 + 1, mem);
      }
      else
      {
        sctx->state = NGHTTP3_QPACK_RS_STATE_READ_NAME;
        rv = nghttp3_rcbuf_new(&sctx->rstate.name,
                               (size_t)sctx->rstate.left + 1, mem);
      }
      if (rv != 0)
      {
        goto fail;
      }
      nghttp3_buf_wrap_init(&sctx->rstate.namebuf, sctx->rstate.name->base,
                            sctx->rstate.name->len);
      break;
    case NGHTTP3_QPACK_RS_STATE_READ_NAME_HUFFMAN:
      nread = qpack_read_huffman_string(&sctx->rstate, &sctx->rstate.namebuf, p,
                                        end);
      if (nread < 0)
      {
        assert(NGHTTP3_ERR_QPACK_FATAL == nread);
        rv = NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED;
        goto fail;
      }
      p += nread;
      if (sctx->rstate.left)
      {
        goto almost_ok;
      }
      qpack_read_state_terminate_name(&sctx->rstate);
      sctx->state = NGHTTP3_QPACK_RS_STATE_CHECK_VALUE_HUFFMAN;
      sctx->rstate.prefix = 7;
      break;
    case NGHTTP3_QPACK_RS_STATE_READ_NAME:
      nread = qpack_read_string(&sctx->rstate, &sctx->rstate.namebuf, p, end);
      if (nread < 0)
      {
        rv = (int)nread;
        goto fail;
      }
      p += nread;
      if (sctx->rstate.left)
      {
        goto almost_ok;
      }
      qpack_read_state_terminate_name(&sctx->rstate);
      sctx->state = NGHTTP3_QPACK_RS_STATE_CHECK_VALUE_HUFFMAN;
      sctx->rstate.prefix = 7;
      break;
    case NGHTTP3_QPACK_RS_STATE_CHECK_VALUE_HUFFMAN:
      qpack_read_state_check_huffman(&sctx->rstate, *p);
      sctx->state = NGHTTP3_QPACK_RS_STATE_READ_VALUELEN;
      sctx->rstate.left = 0;
      sctx->rstate.shift = 0;
    case NGHTTP3_QPACK_RS_STATE_READ_VALUELEN:
      nread = qpack_read_varint(&rfin, &sctx->rstate, p, end);
      if (nread < 0)
      {
        assert(NGHTTP3_ERR_QPACK_FATAL == nread);
        rv = NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED;
        goto fail;
      }
      p += nread;
      if (!rfin)
      {
        goto almost_ok;
      }
      if (sctx->rstate.left > 65536)
      {
        rv = NGHTTP3_ERR_QPACK_HEADER_TOO_LARGE;
        goto fail;
      }
      if (sctx->rstate.huffman_encoded)
      {
        sctx->state = NGHTTP3_QPACK_RS_STATE_READ_VALUE_HUFFMAN;
        nghttp3_qpack_huffman_decode_context_init(&sctx->rstate.huffman_ctx);
        rv = nghttp3_rcbuf_new(&sctx->rstate.value,
                               (size_t)sctx->rstate.left * 2 + 1, mem);
      }
      else
      {
        sctx->state = NGHTTP3_QPACK_RS_STATE_READ_VALUE;
        rv = nghttp3_rcbuf_new(&sctx->rstate.value,
                               (size_t)sctx->rstate.left + 1, mem);
      }
      if (rv != 0)
      {
        goto fail;
      }
      nghttp3_buf_wrap_init(&sctx->rstate.valuebuf, sctx->rstate.value->base,
                            sctx->rstate.value->len);
      busy = 1;
      break;
    case NGHTTP3_QPACK_RS_STATE_READ_VALUE_HUFFMAN:
      nread = qpack_read_huffman_string(&sctx->rstate, &sctx->rstate.valuebuf,
                                        p, end);
      if (nread < 0)
      {
        assert(NGHTTP3_ERR_QPACK_FATAL == nread);
        rv = NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED;
        goto fail;
      }
      p += nread;
      if (sctx->rstate.left)
      {
        goto almost_ok;
      }
      qpack_read_state_terminate_value(&sctx->rstate);
      switch (sctx->opcode)
      {
      case NGHTTP3_QPACK_RS_OPCODE_INDEXED_NAME:
      case NGHTTP3_QPACK_RS_OPCODE_INDEXED_NAME_PB:
        nghttp3_qpack_decoder_emit_indexed_name(decoder, sctx, nv);
        break;
      case NGHTTP3_QPACK_RS_OPCODE_LITERAL:
        nghttp3_qpack_decoder_emit_literal(decoder, sctx, nv);
        break;
      default:
        assert(0);
      }
      *pflags |= NGHTTP3_QPACK_DECODE_FLAG_EMIT;
      sctx->state = NGHTTP3_QPACK_RS_STATE_OPCODE;
      nghttp3_qpack_read_state_reset(&sctx->rstate);
      return p - src;
    case NGHTTP3_QPACK_RS_STATE_READ_VALUE:
      nread = qpack_read_string(&sctx->rstate, &sctx->rstate.valuebuf, p, end);
      if (nread < 0)
      {
        rv = (int)nread;
        goto fail;
      }
      p += nread;
      if (sctx->rstate.left)
      {
        goto almost_ok;
      }
      qpack_read_state_terminate_value(&sctx->rstate);
      switch (sctx->opcode)
      {
      case NGHTTP3_QPACK_RS_OPCODE_INDEXED_NAME:
      case NGHTTP3_QPACK_RS_OPCODE_INDEXED_NAME_PB:
        nghttp3_qpack_decoder_emit_indexed_name(decoder, sctx, nv);
        break;
      case NGHTTP3_QPACK_RS_OPCODE_LITERAL:
        nghttp3_qpack_decoder_emit_literal(decoder, sctx, nv);
        break;
      default:
        assert(0);
      }
      *pflags |= NGHTTP3_QPACK_DECODE_FLAG_EMIT;
      sctx->state = NGHTTP3_QPACK_RS_STATE_OPCODE;
      nghttp3_qpack_read_state_reset(&sctx->rstate);
      return p - src;
    case NGHTTP3_QPACK_RS_STATE_BLOCKED:
      if (sctx->ricnt > decoder->ctx.next_absidx)
      {
        do
        {
        } while (0);
        *pflags |= NGHTTP3_QPACK_DECODE_FLAG_BLOCKED;
        return p - src;
      }
      sctx->state = NGHTTP3_QPACK_RS_STATE_OPCODE;
      nghttp3_qpack_read_state_reset(&sctx->rstate);
      break;
    }
  }
almost_ok:
  if (fin)
  {
    if (sctx->state != NGHTTP3_QPACK_RS_STATE_OPCODE)
    {
      rv = NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED;
      goto fail;
    }
    *pflags |= NGHTTP3_QPACK_DECODE_FLAG_FINAL;
    if (sctx->ricnt)
    {
      rv = nghttp3_qpack_decoder_write_section_ack(decoder, sctx);
      if (rv != 0)
      {
        goto fail;
      }
    }
  }
  return p - src;
fail:
  decoder->ctx.bad = 1;
  return rv;
}
static int qpack_decoder_dbuf_overflow(nghttp3_qpack_decoder *decoder)
{
  size_t limit = ((decoder->max_concurrent_streams) > (100) ? (decoder->max_concurrent_streams) : (100));
  return nghttp3_buf_len(&decoder->dbuf) > limit * 2 * 10;
}
int nghttp3_qpack_decoder_write_section_ack(
    nghttp3_qpack_decoder *decoder, const nghttp3_qpack_stream_context *sctx)
{
  nghttp3_buf *dbuf = &decoder->dbuf;
  uint8_t *p;
  int rv;
  if (qpack_decoder_dbuf_overflow(decoder))
  {
    return NGHTTP3_ERR_QPACK_FATAL;
  }
  rv = reserve_buf_small(
      dbuf, nghttp3_qpack_put_varint_len((uint64_t)sctx->stream_id, 7),
      decoder->ctx.mem);
  if (rv != 0)
  {
    return rv;
  }
  p = dbuf->last;
  *p = 0x80;
  dbuf->last = nghttp3_qpack_put_varint(p, (uint64_t)sctx->stream_id, 7);
  if (decoder->written_icnt < sctx->ricnt)
  {
    decoder->written_icnt = sctx->ricnt;
  }
  return 0;
}
size_t
nghttp3_qpack_decoder_get_decoder_streamlen(nghttp3_qpack_decoder *decoder)
{
  uint64_t n;
  size_t len = 0;
  if (decoder->written_icnt < decoder->ctx.next_absidx)
  {
    n = decoder->ctx.next_absidx - decoder->written_icnt;
    len = nghttp3_qpack_put_varint_len(n, 6);
  }
  return nghttp3_buf_len(&decoder->dbuf) + len;
}
void nghttp3_qpack_decoder_write_decoder(nghttp3_qpack_decoder *decoder,
                                         nghttp3_buf *dbuf)
{
  uint8_t *p;
  uint64_t n = 0;
  size_t len = 0;
  if (decoder->written_icnt < decoder->ctx.next_absidx)
  {
    n = decoder->ctx.next_absidx - decoder->written_icnt;
    len = nghttp3_qpack_put_varint_len(n, 6);
  }
  assert(nghttp3_buf_left(dbuf) >= nghttp3_buf_len(&decoder->dbuf) + len);
  if (nghttp3_buf_len(&decoder->dbuf))
  {
    dbuf->last = nghttp3_cpymem(dbuf->last, decoder->dbuf.pos,
                                nghttp3_buf_len(&decoder->dbuf));
  }
  if (n)
  {
    p = dbuf->last;
    *p = 0;
    dbuf->last = nghttp3_qpack_put_varint(p, n, 6);
    decoder->written_icnt = decoder->ctx.next_absidx;
  }
  nghttp3_buf_reset(&decoder->dbuf);
}
int nghttp3_qpack_decoder_cancel_stream(nghttp3_qpack_decoder *decoder,
                                        int64_t stream_id)
{
  uint8_t *p;
  int rv;
  if (qpack_decoder_dbuf_overflow(decoder))
  {
    return NGHTTP3_ERR_QPACK_FATAL;
  }
  rv = reserve_buf(&decoder->dbuf,
                   nghttp3_qpack_put_varint_len((uint64_t)stream_id, 6),
                   decoder->ctx.mem);
  if (rv != 0)
  {
    return rv;
  }
  p = decoder->dbuf.last;
  *p = 0x40;
  decoder->dbuf.last = nghttp3_qpack_put_varint(p, (uint64_t)stream_id, 6);
  return 0;
}
int nghttp3_qpack_decoder_reconstruct_ricnt(nghttp3_qpack_decoder *decoder,
                                            uint64_t *dest, uint64_t encricnt)
{
  uint64_t max_ents, full, max, max_wrapped, ricnt;
  if (encricnt == 0)
  {
    *dest = 0;
    return 0;
  }
  max_ents = decoder->ctx.hard_max_dtable_size / 32;
  full = 2 * max_ents;
  if (encricnt > full)
  {
    return NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED;
  }
  max = decoder->ctx.next_absidx + max_ents;
  max_wrapped = max / full * full;
  ricnt = max_wrapped + encricnt - 1;
  if (ricnt > max)
  {
    if (ricnt <= full)
    {
      return NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED;
    }
    ricnt -= full;
  }
  if (ricnt == 0)
  {
    return NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED;
  }
  *dest = ricnt;
  return 0;
}
int nghttp3_qpack_decoder_rel2abs(nghttp3_qpack_decoder *decoder,
                                  nghttp3_qpack_read_state *rstate)
{
  do
  {
  } while (0);
  if (rstate->dynamic)
  {
    if (decoder->ctx.next_absidx < rstate->left + 1)
    {
      return NGHTTP3_ERR_QPACK_ENCODER_STREAM_ERROR;
    }
    rstate->absidx = decoder->ctx.next_absidx - rstate->left - 1;
  }
  else
  {
    rstate->absidx = rstate->left;
  }
  if (qpack_decoder_validate_index(decoder, rstate) != 0)
  {
    return NGHTTP3_ERR_QPACK_ENCODER_STREAM_ERROR;
  }
  return 0;
}
int nghttp3_qpack_decoder_brel2abs(nghttp3_qpack_decoder *decoder,
                                   nghttp3_qpack_stream_context *sctx)
{
  nghttp3_qpack_read_state *rstate = &sctx->rstate;
  do
  {
  } while (0);
  if (rstate->dynamic)
  {
    if (sctx->base < rstate->left + 1)
    {
      return NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED;
    }
    rstate->absidx = sctx->base - rstate->left - 1;
    if (rstate->absidx >= sctx->ricnt)
    {
      return NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED;
    }
  }
  else
  {
    rstate->absidx = rstate->left;
  }
  if (qpack_decoder_validate_index(decoder, rstate) != 0)
  {
    return NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED;
  }
  return 0;
}
int nghttp3_qpack_decoder_pbrel2abs(nghttp3_qpack_decoder *decoder,
                                    nghttp3_qpack_stream_context *sctx)
{
  nghttp3_qpack_read_state *rstate = &sctx->rstate;
  do
  {
  } while (0);
  assert(rstate->dynamic);
  rstate->absidx = rstate->left + sctx->base;
  if (rstate->absidx >= sctx->ricnt)
  {
    return NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED;
  }
  if (qpack_decoder_validate_index(decoder, rstate) != 0)
  {
    return NGHTTP3_ERR_QPACK_DECOMPRESSION_FAILED;
  }
  return 0;
}
static void
qpack_decoder_emit_static_indexed(nghttp3_qpack_decoder *decoder,
                                  nghttp3_qpack_stream_context *sctx,
                                  nghttp3_qpack_nv *nv)
{
  const nghttp3_qpack_static_header *shd = &stable[sctx->rstate.absidx];
  (void)decoder;
  nv->name = (nghttp3_rcbuf *)&shd->name;
  nv->value = (nghttp3_rcbuf *)&shd->value;
  nv->token = shd->token;
  nv->flags = NGHTTP3_NV_FLAG_NONE;
}
static void
qpack_decoder_emit_dynamic_indexed(nghttp3_qpack_decoder *decoder,
                                   nghttp3_qpack_stream_context *sctx,
                                   nghttp3_qpack_nv *nv)
{
  nghttp3_qpack_entry *ent =
      nghttp3_qpack_context_dtable_get(&decoder->ctx, sctx->rstate.absidx);
  *nv = ent->nv;
  nghttp3_rcbuf_incref(nv->name);
  nghttp3_rcbuf_incref(nv->value);
}
void nghttp3_qpack_decoder_emit_indexed(nghttp3_qpack_decoder *decoder,
                                        nghttp3_qpack_stream_context *sctx,
                                        nghttp3_qpack_nv *nv)
{
  do
  {
  } while (0);
  if (sctx->rstate.dynamic)
  {
    qpack_decoder_emit_dynamic_indexed(decoder, sctx, nv);
  }
  else
  {
    qpack_decoder_emit_static_indexed(decoder, sctx, nv);
  }
}
static void
qpack_decoder_emit_static_indexed_name(nghttp3_qpack_decoder *decoder,
                                       nghttp3_qpack_stream_context *sctx,
                                       nghttp3_qpack_nv *nv)
{
  const nghttp3_qpack_static_header *shd = &stable[sctx->rstate.absidx];
  (void)decoder;
  nv->name = (nghttp3_rcbuf *)&shd->name;
  nv->value = sctx->rstate.value;
  nv->token = shd->token;
  nv->flags =
      sctx->rstate.never ? NGHTTP3_NV_FLAG_NEVER_INDEX : NGHTTP3_NV_FLAG_NONE;
  sctx->rstate.value =
      __null;
}
static void
qpack_decoder_emit_dynamic_indexed_name(nghttp3_qpack_decoder *decoder,
                                        nghttp3_qpack_stream_context *sctx,
                                        nghttp3_qpack_nv *nv)
{
  nghttp3_qpack_entry *ent =
      nghttp3_qpack_context_dtable_get(&decoder->ctx, sctx->rstate.absidx);
  (void)decoder;
  nv->name = ent->nv.name;
  nv->value = sctx->rstate.value;
  nv->token = ent->nv.token;
  nv->flags =
      sctx->rstate.never ? NGHTTP3_NV_FLAG_NEVER_INDEX : NGHTTP3_NV_FLAG_NONE;
  nghttp3_rcbuf_incref(nv->name);
  sctx->rstate.value =
      __null;
}
void nghttp3_qpack_decoder_emit_indexed_name(nghttp3_qpack_decoder *decoder,
                                             nghttp3_qpack_stream_context *sctx,
                                             nghttp3_qpack_nv *nv)
{
  (void)decoder;
  do
  {
  } while (0);
  if (sctx->rstate.dynamic)
  {
    qpack_decoder_emit_dynamic_indexed_name(decoder, sctx, nv);
  }
  else
  {
    qpack_decoder_emit_static_indexed_name(decoder, sctx, nv);
  }
}
void nghttp3_qpack_decoder_emit_literal(nghttp3_qpack_decoder *decoder,
                                        nghttp3_qpack_stream_context *sctx,
                                        nghttp3_qpack_nv *nv)
{
  (void)decoder;
  do
  {
  } while (0);
  nv->name = sctx->rstate.name;
  nv->value = sctx->rstate.value;
  nv->token = qpack_lookup_token(nv->name->base, nv->name->len);
  nv->flags =
      sctx->rstate.never ? NGHTTP3_NV_FLAG_NEVER_INDEX : NGHTTP3_NV_FLAG_NONE;
  sctx->rstate.name =
      __null;
  sctx->rstate.value =
      __null;
}
int nghttp3_qpack_encoder_new(nghttp3_qpack_encoder **pencoder,
                              size_t max_dtable_size, size_t max_blocked,
                              const nghttp3_mem *mem)
{
  int rv;
  nghttp3_qpack_encoder *p;
  p = nghttp3_mem_malloc(mem, sizeof(nghttp3_qpack_encoder));
  if (p ==
      __null)
  {
    return NGHTTP3_ERR_NOMEM;
  }
  rv = nghttp3_qpack_encoder_init(p, max_dtable_size, max_blocked, mem);
  if (rv != 0)
  {
    return rv;
  }
  *pencoder = p;
  return 0;
}
void nghttp3_qpack_encoder_del(nghttp3_qpack_encoder *encoder)
{
  const nghttp3_mem *mem;
  if (encoder ==
      __null)
  {
    return;
  }
  mem = encoder->ctx.mem;
  nghttp3_qpack_encoder_free(encoder);
  nghttp3_mem_free(mem, encoder);
}
int nghttp3_qpack_stream_context_new(nghttp3_qpack_stream_context **psctx,
                                     int64_t stream_id,
                                     const nghttp3_mem *mem)
{
  nghttp3_qpack_stream_context *p;
  p = nghttp3_mem_malloc(mem, sizeof(nghttp3_qpack_stream_context));
  if (p ==
      __null)
  {
    return NGHTTP3_ERR_NOMEM;
  }
  nghttp3_qpack_stream_context_init(p, stream_id, mem);
  *psctx = p;
  return 0;
}
void nghttp3_qpack_stream_context_del(nghttp3_qpack_stream_context *sctx)
{
  const nghttp3_mem *mem;
  if (sctx ==
      __null)
  {
    return;
  }
  mem = sctx->mem;
  nghttp3_qpack_stream_context_free(sctx);
  nghttp3_mem_free(mem, sctx);
}
int nghttp3_qpack_decoder_new(nghttp3_qpack_decoder **pdecoder,
                              size_t max_dtable_size, size_t max_blocked,
                              const nghttp3_mem *mem)
{
  int rv;
  nghttp3_qpack_decoder *p;
  p = nghttp3_mem_malloc(mem, sizeof(nghttp3_qpack_decoder));
  if (p ==
      __null)
  {
    return NGHTTP3_ERR_NOMEM;
  }
  rv = nghttp3_qpack_decoder_init(p, max_dtable_size, max_blocked, mem);
  if (rv != 0)
  {
    return rv;
  }
  *pdecoder = p;
  return 0;
}
void nghttp3_qpack_decoder_del(nghttp3_qpack_decoder *decoder)
{
  const nghttp3_mem *mem;
  if (decoder ==
      __null)
  {
    return;
  }
  mem = decoder->ctx.mem;
  nghttp3_qpack_decoder_free(decoder);
  nghttp3_mem_free(mem, decoder);
}
uint64_t nghttp3_qpack_decoder_get_icnt(const nghttp3_qpack_decoder *decoder)
{
  return decoder->ctx.next_absidx;
}
size_t nghttp3_qpack_huffman_encode_count(const uint8_t *src, size_t len)
{
  size_t i;
  size_t nbits = 0;
  for (i = 0; i < len; ++i)
  {
    nbits += huffman_sym_table[src[i]].nbits;
  }
  return (nbits + 7) / 8;
}
uint8_t *nghttp3_qpack_huffman_encode(uint8_t *dest, const uint8_t *src,
                                      size_t srclen)
{
  const nghttp3_qpack_huffman_sym *sym;
  const uint8_t *end = src + srclen;
  uint64_t code = 0;
  size_t nbits = 0;
  uint32_t x;
  for (; src != end;)
  {
    sym = &huffman_sym_table[*src++];
    code |= (uint64_t)sym->code << (32 - nbits);
    nbits += sym->nbits;
    if (nbits < 32)
    {
      continue;
    }
    x = htonl((uint32_t)(code >> 32));
    memcpy(dest, &x, 4);
    dest += 4;
    code <<= 32;
    nbits -= 32;
  }
  for (; nbits >= 8;)
  {
    *dest++ = (uint8_t)(code >> 56);
    code <<= 8;
    nbits -= 8;
  }
  if (nbits)
  {
    *dest++ = (uint8_t)((uint8_t)(code >> 56) | ((1 << (8 - nbits)) - 1));
  }
  return dest;
}
void nghttp3_qpack_huffman_decode_context_init(
    nghttp3_qpack_huffman_decode_context *ctx)
{
  ctx->fstate = NGHTTP3_QPACK_HUFFMAN_ACCEPTED;
}
nghttp3_ssize
nghttp3_qpack_huffman_decode(nghttp3_qpack_huffman_decode_context *ctx,
                             uint8_t *dest, const uint8_t *src, size_t srclen,
                             int fin)
{
  uint8_t *p = dest;
  const uint8_t *end = src + srclen;
  nghttp3_qpack_huffman_decode_node node = {ctx->fstate, 0};
  const nghttp3_qpack_huffman_decode_node *t = &node;
  uint8_t c;
  for (; src != end;)
  {
    c = *src++;
    t = &qpack_huffman_decode_table[t->fstate & 0x1ff][c >> 4];
    if (t->fstate & NGHTTP3_QPACK_HUFFMAN_SYM)
    {
      *p++ = t->sym;
    }
    t = &qpack_huffman_decode_table[t->fstate & 0x1ff][c & 0xf];
    if (t->fstate & NGHTTP3_QPACK_HUFFMAN_SYM)
    {
      *p++ = t->sym;
    }
  }
  ctx->fstate = t->fstate;
  if (fin && !(ctx->fstate & NGHTTP3_QPACK_HUFFMAN_ACCEPTED))
  {
    return NGHTTP3_ERR_QPACK_FATAL;
  }
  return p - dest;
}
int nghttp3_qpack_huffman_decode_failure_state(
    nghttp3_qpack_huffman_decode_context *ctx)
{
  return ctx->fstate == 0x100;
}
const nghttp3_qpack_huffman_sym huffman_sym_table[] = {
    {13, 0xffc00000u}, {23, 0xffffb000u}, {28, 0xfffffe20u}, {28, 0xfffffe30u}, {28, 0xfffffe40u}, {28, 0xfffffe50u}, {28, 0xfffffe60u}, {28, 0xfffffe70u}, {28, 0xfffffe80u}, {24, 0xffffea00u}, {30, 0xfffffff0u}, {28, 0xfffffe90u}, {28, 0xfffffea0u}, {30, 0xfffffff4u}, {28, 0xfffffeb0u}, {28, 0xfffffec0u}, {28, 0xfffffed0u}, {28, 0xfffffee0u}, {28, 0xfffffef0u}, {28, 0xffffff00u}, {28, 0xffffff10u}, {28, 0xffffff20u}, {30, 0xfffffff8u}, {28, 0xffffff30u}, {28, 0xffffff40u}, {28, 0xffffff50u}, {28, 0xffffff60u}, {28, 0xffffff70u}, {28, 0xffffff80u}, {28, 0xffffff90u}, {28, 0xffffffa0u}, {28, 0xffffffb0u}, {6, 0x50000000u}, {10, 0xfe000000u}, {10, 0xfe400000u}, {12, 0xffa00000u}, {13, 0xffc80000u}, {6, 0x54000000u}, {8, 0xf8000000u}, {11, 0xff400000u}, {10, 0xfe800000u}, {10, 0xfec00000u}, {8, 0xf9000000u}, {11, 0xff600000u}, {8, 0xfa000000u}, {6, 0x58000000u}, {6, 0x5c000000u}, {6, 0x60000000u}, {5, 0x0u}, {5, 0x8000000u}, {5, 0x10000000u}, {6, 0x64000000u}, {6, 0x68000000u}, {6, 0x6c000000u}, {6, 0x70000000u}, {6, 0x74000000u}, {6, 0x78000000u}, {6, 0x7c000000u}, {7, 0xb8000000u}, {8, 0xfb000000u}, {15, 0xfff80000u}, {6, 0x80000000u}, {12, 0xffb00000u}, {10, 0xff000000u}, {13, 0xffd00000u}, {6, 0x84000000u}, {7, 0xba000000u}, {7, 0xbc000000u}, {7, 0xbe000000u}, {7, 0xc0000000u}, {7, 0xc2000000u}, {7, 0xc4000000u}, {7, 0xc6000000u}, {7, 0xc8000000u}, {7, 0xca000000u}, {7, 0xcc000000u}, {7, 0xce000000u}, {7, 0xd0000000u}, {7, 0xd2000000u}, {7, 0xd4000000u}, {7, 0xd6000000u}, {7, 0xd8000000u}, {7, 0xda000000u}, {7, 0xdc000000u}, {7, 0xde000000u}, {7, 0xe0000000u}, {7, 0xe2000000u}, {7, 0xe4000000u}, {8, 0xfc000000u}, {7, 0xe6000000u}, {8, 0xfd000000u}, {13, 0xffd80000u}, {19, 0xfffe0000u}, {13, 0xffe00000u}, {14, 0xfff00000u}, {6, 0x88000000u}, {15, 0xfffa0000u}, {5, 0x18000000u}, {6, 0x8c000000u}, {5, 0x20000000u}, {6, 0x90000000u}, {5, 0x28000000u}, {6, 0x94000000u}, {6, 0x98000000u}, {6, 0x9c000000u}, {5, 0x30000000u}, {7, 0xe8000000u}, {7, 0xea000000u}, {6, 0xa0000000u}, {6, 0xa4000000u}, {6, 0xa8000000u}, {5, 0x38000000u}, {6, 0xac000000u}, {7, 0xec000000u}, {6, 0xb0000000u}, {5, 0x40000000u}, {5, 0x48000000u}, {6, 0xb4000000u}, {7, 0xee000000u}, {7, 0xf0000000u}, {7, 0xf2000000u}, {7, 0xf4000000u}, {7, 0xf6000000u}, {15, 0xfffc0000u}, {11, 0xff800000u}, {14, 0xfff40000u}, {13, 0xffe80000u}, {28, 0xffffffc0u}, {20, 0xfffe6000u}, {22, 0xffff4800u}, {20, 0xfffe7000u}, {20, 0xfffe8000u}, {22, 0xffff4c00u}, {22, 0xffff5000u}, {22, 0xffff5400u}, {23, 0xffffb200u}, {22, 0xffff5800u}, {23, 0xffffb400u}, {23, 0xffffb600u}, {23, 0xffffb800u}, {23, 0xffffba00u}, {23, 0xffffbc00u}, {24, 0xffffeb00u}, {23, 0xffffbe00u}, {24, 0xffffec00u}, {24, 0xffffed00u}, {22, 0xffff5c00u}, {23, 0xffffc000u}, {24, 0xffffee00u}, {23, 0xffffc200u}, {23, 0xffffc400u}, {23, 0xffffc600u}, {23, 0xffffc800u}, {21, 0xfffee000u}, {22, 0xffff6000u}, {23, 0xffffca00u}, {22, 0xffff6400u}, {23, 0xffffcc00u}, {23, 0xffffce00u}, {24, 0xffffef00u}, {22, 0xffff6800u}, {21, 0xfffee800u}, {20, 0xfffe9000u}, {22, 0xffff6c00u}, {22, 0xffff7000u}, {23, 0xffffd000u}, {23, 0xffffd200u}, {21, 0xfffef000u}, {23, 0xffffd400u}, {22, 0xffff7400u}, {22, 0xffff7800u}, {24, 0xfffff000u}, {21, 0xfffef800u}, {22, 0xffff7c00u}, {23, 0xffffd600u}, {23, 0xffffd800u}, {21, 0xffff0000u}, {21, 0xffff0800u}, {22, 0xffff8000u}, {21, 0xffff1000u}, {23, 0xffffda00u}, {22, 0xffff8400u}, {23, 0xffffdc00u}, {23, 0xffffde00u}, {20, 0xfffea000u}, {22, 0xffff8800u}, {22, 0xffff8c00u}, {22, 0xffff9000u}, {23, 0xffffe000u}, {22, 0xffff9400u}, {22, 0xffff9800u}, {23, 0xffffe200u}, {26, 0xfffff800u}, {26, 0xfffff840u}, {20, 0xfffeb000u}, {19, 0xfffe2000u}, {22, 0xffff9c00u}, {23, 0xffffe400u}, {22, 0xffffa000u}, {25, 0xfffff600u}, {26, 0xfffff880u}, {26, 0xfffff8c0u}, {26, 0xfffff900u}, {27, 0xfffffbc0u}, {27, 0xfffffbe0u}, {26, 0xfffff940u}, {24, 0xfffff100u}, {25, 0xfffff680u}, {19, 0xfffe4000u}, {21, 0xffff1800u}, {26, 0xfffff980u}, {27, 0xfffffc00u}, {27, 0xfffffc20u}, {26, 0xfffff9c0u}, {27, 0xfffffc40u}, {24, 0xfffff200u}, {21, 0xffff2000u}, {21, 0xffff2800u}, {26, 0xfffffa00u}, {26, 0xfffffa40u}, {28, 0xffffffd0u}, {27, 0xfffffc60u}, {27, 0xfffffc80u}, {27, 0xfffffca0u}, {20, 0xfffec000u}, {24, 0xfffff300u}, {20, 0xfffed000u}, {21, 0xffff3000u}, {22, 0xffffa400u}, {21, 0xffff3800u}, {21, 0xffff4000u}, {23, 0xffffe600u}, {22, 0xffffa800u}, {22, 0xffffac00u}, {25, 0xfffff700u}, {25, 0xfffff780u}, {24, 0xfffff400u}, {24, 0xfffff500u}, {26, 0xfffffa80u}, {23, 0xffffe800u}, {26, 0xfffffac0u}, {27, 0xfffffcc0u}, {26, 0xfffffb00u}, {26, 0xfffffb40u}, {27, 0xfffffce0u}, {27, 0xfffffd00u}, {27, 0xfffffd20u}, {27, 0xfffffd40u}, {27, 0xfffffd60u}, {28, 0xffffffe0u}, {27, 0xfffffd80u}, {27, 0xfffffda0u}, {27, 0xfffffdc0u}, {27, 0xfffffde0u}, {27, 0xfffffe00u}, {26, 0xfffffb80u}, {30, 0xfffffffcu}};
const nghttp3_qpack_huffman_decode_node qpack_huffman_decode_table[][16] = {
    {
        {0x04, 0},
        {0x05, 0},
        {0x07, 0},
        {0x08, 0},
        {0x0b, 0},
        {0x0c, 0},
        {0x10, 0},
        {0x13, 0},
        {0x19, 0},
        {0x1c, 0},
        {0x20, 0},
        {0x23, 0},
        {0x2a, 0},
        {0x31, 0},
        {0x39, 0},
        {0x4040, 0},
    },
    {
        {0xc000, 48},
        {0xc000, 49},
        {0xc000, 50},
        {0xc000, 97},
        {0xc000, 99},
        {0xc000, 101},
        {0xc000, 105},
        {0xc000, 111},
        {0xc000, 115},
        {0xc000, 116},
        {0x0d, 0},
        {0x0e, 0},
        {0x11, 0},
        {0x12, 0},
        {0x14, 0},
        {0x15, 0},
    },
    {
        {0x8001, 48},
        {0xc016, 48},
        {0x8001, 49},
        {0xc016, 49},
        {0x8001, 50},
        {0xc016, 50},
        {0x8001, 97},
        {0xc016, 97},
        {0x8001, 99},
        {0xc016, 99},
        {0x8001, 101},
        {0xc016, 101},
        {0x8001, 105},
        {0xc016, 105},
        {0x8001, 111},
        {0xc016, 111},
    },
    {
        {0x8002, 48},
        {0x8009, 48},
        {0x8017, 48},
        {0xc028, 48},
        {0x8002, 49},
        {0x8009, 49},
        {0x8017, 49},
        {0xc028, 49},
        {0x8002, 50},
        {0x8009, 50},
        {0x8017, 50},
        {0xc028, 50},
        {0x8002, 97},
        {0x8009, 97},
        {0x8017, 97},
        {0xc028, 97},
    },
    {
        {0x8003, 48},
        {0x8006, 48},
        {0x800a, 48},
        {0x800f, 48},
        {0x8018, 48},
        {0x801f, 48},
        {0x8029, 48},
        {0xc038, 48},
        {0x8003, 49},
        {0x8006, 49},
        {0x800a, 49},
        {0x800f, 49},
        {0x8018, 49},
        {0x801f, 49},
        {0x8029, 49},
        {0xc038, 49},
    },
    {
        {0x8003, 50},
        {0x8006, 50},
        {0x800a, 50},
        {0x800f, 50},
        {0x8018, 50},
        {0x801f, 50},
        {0x8029, 50},
        {0xc038, 50},
        {0x8003, 97},
        {0x8006, 97},
        {0x800a, 97},
        {0x800f, 97},
        {0x8018, 97},
        {0x801f, 97},
        {0x8029, 97},
        {0xc038, 97},
    },
    {
        {0x8002, 99},
        {0x8009, 99},
        {0x8017, 99},
        {0xc028, 99},
        {0x8002, 101},
        {0x8009, 101},
        {0x8017, 101},
        {0xc028, 101},
        {0x8002, 105},
        {0x8009, 105},
        {0x8017, 105},
        {0xc028, 105},
        {0x8002, 111},
        {0x8009, 111},
        {0x8017, 111},
        {0xc028, 111},
    },
    {
        {0x8003, 99},
        {0x8006, 99},
        {0x800a, 99},
        {0x800f, 99},
        {0x8018, 99},
        {0x801f, 99},
        {0x8029, 99},
        {0xc038, 99},
        {0x8003, 101},
        {0x8006, 101},
        {0x800a, 101},
        {0x800f, 101},
        {0x8018, 101},
        {0x801f, 101},
        {0x8029, 101},
        {0xc038, 101},
    },
    {
        {0x8003, 105},
        {0x8006, 105},
        {0x800a, 105},
        {0x800f, 105},
        {0x8018, 105},
        {0x801f, 105},
        {0x8029, 105},
        {0xc038, 105},
        {0x8003, 111},
        {0x8006, 111},
        {0x800a, 111},
        {0x800f, 111},
        {0x8018, 111},
        {0x801f, 111},
        {0x8029, 111},
        {0xc038, 111},
    },
    {
        {0x8001, 115},
        {0xc016, 115},
        {0x8001, 116},
        {0xc016, 116},
        {0xc000, 32},
        {0xc000, 37},
        {0xc000, 45},
        {0xc000, 46},
        {0xc000, 47},
        {0xc000, 51},
        {0xc000, 52},
        {0xc000, 53},
        {0xc000, 54},
        {0xc000, 55},
        {0xc000, 56},
        {0xc000, 57},
    },
    {
        {0x8002, 115},
        {0x8009, 115},
        {0x8017, 115},
        {0xc028, 115},
        {0x8002, 116},
        {0x8009, 116},
        {0x8017, 116},
        {0xc028, 116},
        {0x8001, 32},
        {0xc016, 32},
        {0x8001, 37},
        {0xc016, 37},
        {0x8001, 45},
        {0xc016, 45},
        {0x8001, 46},
        {0xc016, 46},
    },
    {
        {0x8003, 115},
        {0x8006, 115},
        {0x800a, 115},
        {0x800f, 115},
        {0x8018, 115},
        {0x801f, 115},
        {0x8029, 115},
        {0xc038, 115},
        {0x8003, 116},
        {0x8006, 116},
        {0x800a, 116},
        {0x800f, 116},
        {0x8018, 116},
        {0x801f, 116},
        {0x8029, 116},
        {0xc038, 116},
    },
    {
        {0x8002, 32},
        {0x8009, 32},
        {0x8017, 32},
        {0xc028, 32},
        {0x8002, 37},
        {0x8009, 37},
        {0x8017, 37},
        {0xc028, 37},
        {0x8002, 45},
        {0x8009, 45},
        {0x8017, 45},
        {0xc028, 45},
        {0x8002, 46},
        {0x8009, 46},
        {0x8017, 46},
        {0xc028, 46},
    },
    {
        {0x8003, 32},
        {0x8006, 32},
        {0x800a, 32},
        {0x800f, 32},
        {0x8018, 32},
        {0x801f, 32},
        {0x8029, 32},
        {0xc038, 32},
        {0x8003, 37},
        {0x8006, 37},
        {0x800a, 37},
        {0x800f, 37},
        {0x8018, 37},
        {0x801f, 37},
        {0x8029, 37},
        {0xc038, 37},
    },
    {
        {0x8003, 45},
        {0x8006, 45},
        {0x800a, 45},
        {0x800f, 45},
        {0x8018, 45},
        {0x801f, 45},
        {0x8029, 45},
        {0xc038, 45},
        {0x8003, 46},
        {0x8006, 46},
        {0x800a, 46},
        {0x800f, 46},
        {0x8018, 46},
        {0x801f, 46},
        {0x8029, 46},
        {0xc038, 46},
    },
    {
        {0x8001, 47},
        {0xc016, 47},
        {0x8001, 51},
        {0xc016, 51},
        {0x8001, 52},
        {0xc016, 52},
        {0x8001, 53},
        {0xc016, 53},
        {0x8001, 54},
        {0xc016, 54},
        {0x8001, 55},
        {0xc016, 55},
        {0x8001, 56},
        {0xc016, 56},
        {0x8001, 57},
        {0xc016, 57},
    },
    {
        {0x8002, 47},
        {0x8009, 47},
        {0x8017, 47},
        {0xc028, 47},
        {0x8002, 51},
        {0x8009, 51},
        {0x8017, 51},
        {0xc028, 51},
        {0x8002, 52},
        {0x8009, 52},
        {0x8017, 52},
        {0xc028, 52},
        {0x8002, 53},
        {0x8009, 53},
        {0x8017, 53},
        {0xc028, 53},
    },
    {
        {0x8003, 47},
        {0x8006, 47},
        {0x800a, 47},
        {0x800f, 47},
        {0x8018, 47},
        {0x801f, 47},
        {0x8029, 47},
        {0xc038, 47},
        {0x8003, 51},
        {0x8006, 51},
        {0x800a, 51},
        {0x800f, 51},
        {0x8018, 51},
        {0x801f, 51},
        {0x8029, 51},
        {0xc038, 51},
    },
    {
        {0x8003, 52},
        {0x8006, 52},
        {0x800a, 52},
        {0x800f, 52},
        {0x8018, 52},
        {0x801f, 52},
        {0x8029, 52},
        {0xc038, 52},
        {0x8003, 53},
        {0x8006, 53},
        {0x800a, 53},
        {0x800f, 53},
        {0x8018, 53},
        {0x801f, 53},
        {0x8029, 53},
        {0xc038, 53},
    },
    {
        {0x8002, 54},
        {0x8009, 54},
        {0x8017, 54},
        {0xc028, 54},
        {0x8002, 55},
        {0x8009, 55},
        {0x8017, 55},
        {0xc028, 55},
        {0x8002, 56},
        {0x8009, 56},
        {0x8017, 56},
        {0xc028, 56},
        {0x8002, 57},
        {0x8009, 57},
        {0x8017, 57},
        {0xc028, 57},
    },
    {
        {0x8003, 54},
        {0x8006, 54},
        {0x800a, 54},
        {0x800f, 54},
        {0x8018, 54},
        {0x801f, 54},
        {0x8029, 54},
        {0xc038, 54},
        {0x8003, 55},
        {0x8006, 55},
        {0x800a, 55},
        {0x800f, 55},
        {0x8018, 55},
        {0x801f, 55},
        {0x8029, 55},
        {0xc038, 55},
    },
    {
        {0x8003, 56},
        {0x8006, 56},
        {0x800a, 56},
        {0x800f, 56},
        {0x8018, 56},
        {0x801f, 56},
        {0x8029, 56},
        {0xc038, 56},
        {0x8003, 57},
        {0x8006, 57},
        {0x800a, 57},
        {0x800f, 57},
        {0x8018, 57},
        {0x801f, 57},
        {0x8029, 57},
        {0xc038, 57},
    },
    {
        {0x1a, 0},
        {0x1b, 0},
        {0x1d, 0},
        {0x1e, 0},
        {0x21, 0},
        {0x22, 0},
        {0x24, 0},
        {0x25, 0},
        {0x2b, 0},
        {0x2e, 0},
        {0x32, 0},
        {0x35, 0},
        {0x3a, 0},
        {0x3d, 0},
        {0x41, 0},
        {0x4044, 0},
    },
    {
        {0xc000, 61},
        {0xc000, 65},
        {0xc000, 95},
        {0xc000, 98},
        {0xc000, 100},
        {0xc000, 102},
        {0xc000, 103},
        {0xc000, 104},
        {0xc000, 108},
        {0xc000, 109},
        {0xc000, 110},
        {0xc000, 112},
        {0xc000, 114},
        {0xc000, 117},
        {0x26, 0},
        {0x27, 0},
    },
    {
        {0x8001, 61},
        {0xc016, 61},
        {0x8001, 65},
        {0xc016, 65},
        {0x8001, 95},
        {0xc016, 95},
        {0x8001, 98},
        {0xc016, 98},
        {0x8001, 100},
        {0xc016, 100},
        {0x8001, 102},
        {0xc016, 102},
        {0x8001, 103},
        {0xc016, 103},
        {0x8001, 104},
        {0xc016, 104},
    },
    {
        {0x8002, 61},
        {0x8009, 61},
        {0x8017, 61},
        {0xc028, 61},
        {0x8002, 65},
        {0x8009, 65},
        {0x8017, 65},
        {0xc028, 65},
        {0x8002, 95},
        {0x8009, 95},
        {0x8017, 95},
        {0xc028, 95},
        {0x8002, 98},
        {0x8009, 98},
        {0x8017, 98},
        {0xc028, 98},
    },
    {
        {0x8003, 61},
        {0x8006, 61},
        {0x800a, 61},
        {0x800f, 61},
        {0x8018, 61},
        {0x801f, 61},
        {0x8029, 61},
        {0xc038, 61},
        {0x8003, 65},
        {0x8006, 65},
        {0x800a, 65},
        {0x800f, 65},
        {0x8018, 65},
        {0x801f, 65},
        {0x8029, 65},
        {0xc038, 65},
    },
    {
        {0x8003, 95},
        {0x8006, 95},
        {0x800a, 95},
        {0x800f, 95},
        {0x8018, 95},
        {0x801f, 95},
        {0x8029, 95},
        {0xc038, 95},
        {0x8003, 98},
        {0x8006, 98},
        {0x800a, 98},
        {0x800f, 98},
        {0x8018, 98},
        {0x801f, 98},
        {0x8029, 98},
        {0xc038, 98},
    },
    {
        {0x8002, 100},
        {0x8009, 100},
        {0x8017, 100},
        {0xc028, 100},
        {0x8002, 102},
        {0x8009, 102},
        {0x8017, 102},
        {0xc028, 102},
        {0x8002, 103},
        {0x8009, 103},
        {0x8017, 103},
        {0xc028, 103},
        {0x8002, 104},
        {0x8009, 104},
        {0x8017, 104},
        {0xc028, 104},
    },
    {
        {0x8003, 100},
        {0x8006, 100},
        {0x800a, 100},
        {0x800f, 100},
        {0x8018, 100},
        {0x801f, 100},
        {0x8029, 100},
        {0xc038, 100},
        {0x8003, 102},
        {0x8006, 102},
        {0x800a, 102},
        {0x800f, 102},
        {0x8018, 102},
        {0x801f, 102},
        {0x8029, 102},
        {0xc038, 102},
    },
    {
        {0x8003, 103},
        {0x8006, 103},
        {0x800a, 103},
        {0x800f, 103},
        {0x8018, 103},
        {0x801f, 103},
        {0x8029, 103},
        {0xc038, 103},
        {0x8003, 104},
        {0x8006, 104},
        {0x800a, 104},
        {0x800f, 104},
        {0x8018, 104},
        {0x801f, 104},
        {0x8029, 104},
        {0xc038, 104},
    },
    {
        {0x8001, 108},
        {0xc016, 108},
        {0x8001, 109},
        {0xc016, 109},
        {0x8001, 110},
        {0xc016, 110},
        {0x8001, 112},
        {0xc016, 112},
        {0x8001, 114},
        {0xc016, 114},
        {0x8001, 117},
        {0xc016, 117},
        {0xc000, 58},
        {0xc000, 66},
        {0xc000, 67},
        {0xc000, 68},
    },
    {
        {0x8002, 108},
        {0x8009, 108},
        {0x8017, 108},
        {0xc028, 108},
        {0x8002, 109},
        {0x8009, 109},
        {0x8017, 109},
        {0xc028, 109},
        {0x8002, 110},
        {0x8009, 110},
        {0x8017, 110},
        {0xc028, 110},
        {0x8002, 112},
        {0x8009, 112},
        {0x8017, 112},
        {0xc028, 112},
    },
    {
        {0x8003, 108},
        {0x8006, 108},
        {0x800a, 108},
        {0x800f, 108},
        {0x8018, 108},
        {0x801f, 108},
        {0x8029, 108},
        {0xc038, 108},
        {0x8003, 109},
        {0x8006, 109},
        {0x800a, 109},
        {0x800f, 109},
        {0x8018, 109},
        {0x801f, 109},
        {0x8029, 109},
        {0xc038, 109},
    },
    {
        {0x8003, 110},
        {0x8006, 110},
        {0x800a, 110},
        {0x800f, 110},
        {0x8018, 110},
        {0x801f, 110},
        {0x8029, 110},
        {0xc038, 110},
        {0x8003, 112},
        {0x8006, 112},
        {0x800a, 112},
        {0x800f, 112},
        {0x8018, 112},
        {0x801f, 112},
        {0x8029, 112},
        {0xc038, 112},
    },
    {
        {0x8002, 114},
        {0x8009, 114},
        {0x8017, 114},
        {0xc028, 114},
        {0x8002, 117},
        {0x8009, 117},
        {0x8017, 117},
        {0xc028, 117},
        {0x8001, 58},
        {0xc016, 58},
        {0x8001, 66},
        {0xc016, 66},
        {0x8001, 67},
        {0xc016, 67},
        {0x8001, 68},
        {0xc016, 68},
    },
    {
        {0x8003, 114},
        {0x8006, 114},
        {0x800a, 114},
        {0x800f, 114},
        {0x8018, 114},
        {0x801f, 114},
        {0x8029, 114},
        {0xc038, 114},
        {0x8003, 117},
        {0x8006, 117},
        {0x800a, 117},
        {0x800f, 117},
        {0x8018, 117},
        {0x801f, 117},
        {0x8029, 117},
        {0xc038, 117},
    },
    {
        {0x8002, 58},
        {0x8009, 58},
        {0x8017, 58},
        {0xc028, 58},
        {0x8002, 66},
        {0x8009, 66},
        {0x8017, 66},
        {0xc028, 66},
        {0x8002, 67},
        {0x8009, 67},
        {0x8017, 67},
        {0xc028, 67},
        {0x8002, 68},
        {0x8009, 68},
        {0x8017, 68},
        {0xc028, 68},
    },
    {
        {0x8003, 58},
        {0x8006, 58},
        {0x800a, 58},
        {0x800f, 58},
        {0x8018, 58},
        {0x801f, 58},
        {0x8029, 58},
        {0xc038, 58},
        {0x8003, 66},
        {0x8006, 66},
        {0x800a, 66},
        {0x800f, 66},
        {0x8018, 66},
        {0x801f, 66},
        {0x8029, 66},
        {0xc038, 66},
    },
    {
        {0x8003, 67},
        {0x8006, 67},
        {0x800a, 67},
        {0x800f, 67},
        {0x8018, 67},
        {0x801f, 67},
        {0x8029, 67},
        {0xc038, 67},
        {0x8003, 68},
        {0x8006, 68},
        {0x800a, 68},
        {0x800f, 68},
        {0x8018, 68},
        {0x801f, 68},
        {0x8029, 68},
        {0xc038, 68},
    },
    {
        {0x2c, 0},
        {0x2d, 0},
        {0x2f, 0},
        {0x30, 0},
        {0x33, 0},
        {0x34, 0},
        {0x36, 0},
        {0x37, 0},
        {0x3b, 0},
        {0x3c, 0},
        {0x3e, 0},
        {0x3f, 0},
        {0x42, 0},
        {0x43, 0},
        {0x45, 0},
        {0x4048, 0},
    },
    {
        {0xc000, 69},
        {0xc000, 70},
        {0xc000, 71},
        {0xc000, 72},
        {0xc000, 73},
        {0xc000, 74},
        {0xc000, 75},
        {0xc000, 76},
        {0xc000, 77},
        {0xc000, 78},
        {0xc000, 79},
        {0xc000, 80},
        {0xc000, 81},
        {0xc000, 82},
        {0xc000, 83},
        {0xc000, 84},
    },
    {
        {0x8001, 69},
        {0xc016, 69},
        {0x8001, 70},
        {0xc016, 70},
        {0x8001, 71},
        {0xc016, 71},
        {0x8001, 72},
        {0xc016, 72},
        {0x8001, 73},
        {0xc016, 73},
        {0x8001, 74},
        {0xc016, 74},
        {0x8001, 75},
        {0xc016, 75},
        {0x8001, 76},
        {0xc016, 76},
    },
    {
        {0x8002, 69},
        {0x8009, 69},
        {0x8017, 69},
        {0xc028, 69},
        {0x8002, 70},
        {0x8009, 70},
        {0x8017, 70},
        {0xc028, 70},
        {0x8002, 71},
        {0x8009, 71},
        {0x8017, 71},
        {0xc028, 71},
        {0x8002, 72},
        {0x8009, 72},
        {0x8017, 72},
        {0xc028, 72},
    },
    {
        {0x8003, 69},
        {0x8006, 69},
        {0x800a, 69},
        {0x800f, 69},
        {0x8018, 69},
        {0x801f, 69},
        {0x8029, 69},
        {0xc038, 69},
        {0x8003, 70},
        {0x8006, 70},
        {0x800a, 70},
        {0x800f, 70},
        {0x8018, 70},
        {0x801f, 70},
        {0x8029, 70},
        {0xc038, 70},
    },
    {
        {0x8003, 71},
        {0x8006, 71},
        {0x800a, 71},
        {0x800f, 71},
        {0x8018, 71},
        {0x801f, 71},
        {0x8029, 71},
        {0xc038, 71},
        {0x8003, 72},
        {0x8006, 72},
        {0x800a, 72},
        {0x800f, 72},
        {0x8018, 72},
        {0x801f, 72},
        {0x8029, 72},
        {0xc038, 72},
    },
    {
        {0x8002, 73},
        {0x8009, 73},
        {0x8017, 73},
        {0xc028, 73},
        {0x8002, 74},
        {0x8009, 74},
        {0x8017, 74},
        {0xc028, 74},
        {0x8002, 75},
        {0x8009, 75},
        {0x8017, 75},
        {0xc028, 75},
        {0x8002, 76},
        {0x8009, 76},
        {0x8017, 76},
        {0xc028, 76},
    },
    {
        {0x8003, 73},
        {0x8006, 73},
        {0x800a, 73},
        {0x800f, 73},
        {0x8018, 73},
        {0x801f, 73},
        {0x8029, 73},
        {0xc038, 73},
        {0x8003, 74},
        {0x8006, 74},
        {0x800a, 74},
        {0x800f, 74},
        {0x8018, 74},
        {0x801f, 74},
        {0x8029, 74},
        {0xc038, 74},
    },
    {
        {0x8003, 75},
        {0x8006, 75},
        {0x800a, 75},
        {0x800f, 75},
        {0x8018, 75},
        {0x801f, 75},
        {0x8029, 75},
        {0xc038, 75},
        {0x8003, 76},
        {0x8006, 76},
        {0x800a, 76},
        {0x800f, 76},
        {0x8018, 76},
        {0x801f, 76},
        {0x8029, 76},
        {0xc038, 76},
    },
    {
        {0x8001, 77},
        {0xc016, 77},
        {0x8001, 78},
        {0xc016, 78},
        {0x8001, 79},
        {0xc016, 79},
        {0x8001, 80},
        {0xc016, 80},
        {0x8001, 81},
        {0xc016, 81},
        {0x8001, 82},
        {0xc016, 82},
        {0x8001, 83},
        {0xc016, 83},
        {0x8001, 84},
        {0xc016, 84},
    },
    {
        {0x8002, 77},
        {0x8009, 77},
        {0x8017, 77},
        {0xc028, 77},
        {0x8002, 78},
        {0x8009, 78},
        {0x8017, 78},
        {0xc028, 78},
        {0x8002, 79},
        {0x8009, 79},
        {0x8017, 79},
        {0xc028, 79},
        {0x8002, 80},
        {0x8009, 80},
        {0x8017, 80},
        {0xc028, 80},
    },
    {
        {0x8003, 77},
        {0x8006, 77},
        {0x800a, 77},
        {0x800f, 77},
        {0x8018, 77},
        {0x801f, 77},
        {0x8029, 77},
        {0xc038, 77},
        {0x8003, 78},
        {0x8006, 78},
        {0x800a, 78},
        {0x800f, 78},
        {0x8018, 78},
        {0x801f, 78},
        {0x8029, 78},
        {0xc038, 78},
    },
    {
        {0x8003, 79},
        {0x8006, 79},
        {0x800a, 79},
        {0x800f, 79},
        {0x8018, 79},
        {0x801f, 79},
        {0x8029, 79},
        {0xc038, 79},
        {0x8003, 80},
        {0x8006, 80},
        {0x800a, 80},
        {0x800f, 80},
        {0x8018, 80},
        {0x801f, 80},
        {0x8029, 80},
        {0xc038, 80},
    },
    {
        {0x8002, 81},
        {0x8009, 81},
        {0x8017, 81},
        {0xc028, 81},
        {0x8002, 82},
        {0x8009, 82},
        {0x8017, 82},
        {0xc028, 82},
        {0x8002, 83},
        {0x8009, 83},
        {0x8017, 83},
        {0xc028, 83},
        {0x8002, 84},
        {0x8009, 84},
        {0x8017, 84},
        {0xc028, 84},
    },
    {
        {0x8003, 81},
        {0x8006, 81},
        {0x800a, 81},
        {0x800f, 81},
        {0x8018, 81},
        {0x801f, 81},
        {0x8029, 81},
        {0xc038, 81},
        {0x8003, 82},
        {0x8006, 82},
        {0x800a, 82},
        {0x800f, 82},
        {0x8018, 82},
        {0x801f, 82},
        {0x8029, 82},
        {0xc038, 82},
    },
    {
        {0x8003, 83},
        {0x8006, 83},
        {0x800a, 83},
        {0x800f, 83},
        {0x8018, 83},
        {0x801f, 83},
        {0x8029, 83},
        {0xc038, 83},
        {0x8003, 84},
        {0x8006, 84},
        {0x800a, 84},
        {0x800f, 84},
        {0x8018, 84},
        {0x801f, 84},
        {0x8029, 84},
        {0xc038, 84},
    },
    {
        {0xc000, 85},
        {0xc000, 86},
        {0xc000, 87},
        {0xc000, 89},
        {0xc000, 106},
        {0xc000, 107},
        {0xc000, 113},
        {0xc000, 118},
        {0xc000, 119},
        {0xc000, 120},
        {0xc000, 121},
        {0xc000, 122},
        {0x46, 0},
        {0x47, 0},
        {0x49, 0},
        {0x404a, 0},
    },
    {
        {0x8001, 85},
        {0xc016, 85},
        {0x8001, 86},
        {0xc016, 86},
        {0x8001, 87},
        {0xc016, 87},
        {0x8001, 89},
        {0xc016, 89},
        {0x8001, 106},
        {0xc016, 106},
        {0x8001, 107},
        {0xc016, 107},
        {0x8001, 113},
        {0xc016, 113},
        {0x8001, 118},
        {0xc016, 118},
    },
    {
        {0x8002, 85},
        {0x8009, 85},
        {0x8017, 85},
        {0xc028, 85},
        {0x8002, 86},
        {0x8009, 86},
        {0x8017, 86},
        {0xc028, 86},
        {0x8002, 87},
        {0x8009, 87},
        {0x8017, 87},
        {0xc028, 87},
        {0x8002, 89},
        {0x8009, 89},
        {0x8017, 89},
        {0xc028, 89},
    },
    {
        {0x8003, 85},
        {0x8006, 85},
        {0x800a, 85},
        {0x800f, 85},
        {0x8018, 85},
        {0x801f, 85},
        {0x8029, 85},
        {0xc038, 85},
        {0x8003, 86},
        {0x8006, 86},
        {0x800a, 86},
        {0x800f, 86},
        {0x8018, 86},
        {0x801f, 86},
        {0x8029, 86},
        {0xc038, 86},
    },
    {
        {0x8003, 87},
        {0x8006, 87},
        {0x800a, 87},
        {0x800f, 87},
        {0x8018, 87},
        {0x801f, 87},
        {0x8029, 87},
        {0xc038, 87},
        {0x8003, 89},
        {0x8006, 89},
        {0x800a, 89},
        {0x800f, 89},
        {0x8018, 89},
        {0x801f, 89},
        {0x8029, 89},
        {0xc038, 89},
    },
    {
        {0x8002, 106},
        {0x8009, 106},
        {0x8017, 106},
        {0xc028, 106},
        {0x8002, 107},
        {0x8009, 107},
        {0x8017, 107},
        {0xc028, 107},
        {0x8002, 113},
        {0x8009, 113},
        {0x8017, 113},
        {0xc028, 113},
        {0x8002, 118},
        {0x8009, 118},
        {0x8017, 118},
        {0xc028, 118},
    },
    {
        {0x8003, 106},
        {0x8006, 106},
        {0x800a, 106},
        {0x800f, 106},
        {0x8018, 106},
        {0x801f, 106},
        {0x8029, 106},
        {0xc038, 106},
        {0x8003, 107},
        {0x8006, 107},
        {0x800a, 107},
        {0x800f, 107},
        {0x8018, 107},
        {0x801f, 107},
        {0x8029, 107},
        {0xc038, 107},
    },
    {
        {0x8003, 113},
        {0x8006, 113},
        {0x800a, 113},
        {0x800f, 113},
        {0x8018, 113},
        {0x801f, 113},
        {0x8029, 113},
        {0xc038, 113},
        {0x8003, 118},
        {0x8006, 118},
        {0x800a, 118},
        {0x800f, 118},
        {0x8018, 118},
        {0x801f, 118},
        {0x8029, 118},
        {0xc038, 118},
    },
    {
        {0x8001, 119},
        {0xc016, 119},
        {0x8001, 120},
        {0xc016, 120},
        {0x8001, 121},
        {0xc016, 121},
        {0x8001, 122},
        {0xc016, 122},
        {0xc000, 38},
        {0xc000, 42},
        {0xc000, 44},
        {0xc000, 59},
        {0xc000, 88},
        {0xc000, 90},
        {0x4b, 0},
        {0x4e, 0},
    },
    {
        {0x8002, 119},
        {0x8009, 119},
        {0x8017, 119},
        {0xc028, 119},
        {0x8002, 120},
        {0x8009, 120},
        {0x8017, 120},
        {0xc028, 120},
        {0x8002, 121},
        {0x8009, 121},
        {0x8017, 121},
        {0xc028, 121},
        {0x8002, 122},
        {0x8009, 122},
        {0x8017, 122},
        {0xc028, 122},
    },
    {
        {0x8003, 119},
        {0x8006, 119},
        {0x800a, 119},
        {0x800f, 119},
        {0x8018, 119},
        {0x801f, 119},
        {0x8029, 119},
        {0xc038, 119},
        {0x8003, 120},
        {0x8006, 120},
        {0x800a, 120},
        {0x800f, 120},
        {0x8018, 120},
        {0x801f, 120},
        {0x8029, 120},
        {0xc038, 120},
    },
    {
        {0x8003, 121},
        {0x8006, 121},
        {0x800a, 121},
        {0x800f, 121},
        {0x8018, 121},
        {0x801f, 121},
        {0x8029, 121},
        {0xc038, 121},
        {0x8003, 122},
        {0x8006, 122},
        {0x800a, 122},
        {0x800f, 122},
        {0x8018, 122},
        {0x801f, 122},
        {0x8029, 122},
        {0xc038, 122},
    },
    {
        {0x8001, 38},
        {0xc016, 38},
        {0x8001, 42},
        {0xc016, 42},
        {0x8001, 44},
        {0xc016, 44},
        {0x8001, 59},
        {0xc016, 59},
        {0x8001, 88},
        {0xc016, 88},
        {0x8001, 90},
        {0xc016, 90},
        {0x4c, 0},
        {0x4d, 0},
        {0x4f, 0},
        {0x51, 0},
    },
    {
        {0x8002, 38},
        {0x8009, 38},
        {0x8017, 38},
        {0xc028, 38},
        {0x8002, 42},
        {0x8009, 42},
        {0x8017, 42},
        {0xc028, 42},
        {0x8002, 44},
        {0x8009, 44},
        {0x8017, 44},
        {0xc028, 44},
        {0x8002, 59},
        {0x8009, 59},
        {0x8017, 59},
        {0xc028, 59},
    },
    {
        {0x8003, 38},
        {0x8006, 38},
        {0x800a, 38},
        {0x800f, 38},
        {0x8018, 38},
        {0x801f, 38},
        {0x8029, 38},
        {0xc038, 38},
        {0x8003, 42},
        {0x8006, 42},
        {0x800a, 42},
        {0x800f, 42},
        {0x8018, 42},
        {0x801f, 42},
        {0x8029, 42},
        {0xc038, 42},
    },
    {
        {0x8003, 44},
        {0x8006, 44},
        {0x800a, 44},
        {0x800f, 44},
        {0x8018, 44},
        {0x801f, 44},
        {0x8029, 44},
        {0xc038, 44},
        {0x8003, 59},
        {0x8006, 59},
        {0x800a, 59},
        {0x800f, 59},
        {0x8018, 59},
        {0x801f, 59},
        {0x8029, 59},
        {0xc038, 59},
    },
    {
        {0x8002, 88},
        {0x8009, 88},
        {0x8017, 88},
        {0xc028, 88},
        {0x8002, 90},
        {0x8009, 90},
        {0x8017, 90},
        {0xc028, 90},
        {0xc000, 33},
        {0xc000, 34},
        {0xc000, 40},
        {0xc000, 41},
        {0xc000, 63},
        {0x50, 0},
        {0x52, 0},
        {0x54, 0},
    },
    {
        {0x8003, 88},
        {0x8006, 88},
        {0x800a, 88},
        {0x800f, 88},
        {0x8018, 88},
        {0x801f, 88},
        {0x8029, 88},
        {0xc038, 88},
        {0x8003, 90},
        {0x8006, 90},
        {0x800a, 90},
        {0x800f, 90},
        {0x8018, 90},
        {0x801f, 90},
        {0x8029, 90},
        {0xc038, 90},
    },
    {
        {0x8001, 33},
        {0xc016, 33},
        {0x8001, 34},
        {0xc016, 34},
        {0x8001, 40},
        {0xc016, 40},
        {0x8001, 41},
        {0xc016, 41},
        {0x8001, 63},
        {0xc016, 63},
        {0xc000, 39},
        {0xc000, 43},
        {0xc000, 124},
        {0x53, 0},
        {0x55, 0},
        {0x58, 0},
    },
    {
        {0x8002, 33},
        {0x8009, 33},
        {0x8017, 33},
        {0xc028, 33},
        {0x8002, 34},
        {0x8009, 34},
        {0x8017, 34},
        {0xc028, 34},
        {0x8002, 40},
        {0x8009, 40},
        {0x8017, 40},
        {0xc028, 40},
        {0x8002, 41},
        {0x8009, 41},
        {0x8017, 41},
        {0xc028, 41},
    },
    {
        {0x8003, 33},
        {0x8006, 33},
        {0x800a, 33},
        {0x800f, 33},
        {0x8018, 33},
        {0x801f, 33},
        {0x8029, 33},
        {0xc038, 33},
        {0x8003, 34},
        {0x8006, 34},
        {0x800a, 34},
        {0x800f, 34},
        {0x8018, 34},
        {0x801f, 34},
        {0x8029, 34},
        {0xc038, 34},
    },
    {
        {0x8003, 40},
        {0x8006, 40},
        {0x800a, 40},
        {0x800f, 40},
        {0x8018, 40},
        {0x801f, 40},
        {0x8029, 40},
        {0xc038, 40},
        {0x8003, 41},
        {0x8006, 41},
        {0x800a, 41},
        {0x800f, 41},
        {0x8018, 41},
        {0x801f, 41},
        {0x8029, 41},
        {0xc038, 41},
    },
    {
        {0x8002, 63},
        {0x8009, 63},
        {0x8017, 63},
        {0xc028, 63},
        {0x8001, 39},
        {0xc016, 39},
        {0x8001, 43},
        {0xc016, 43},
        {0x8001, 124},
        {0xc016, 124},
        {0xc000, 35},
        {0xc000, 62},
        {0x56, 0},
        {0x57, 0},
        {0x59, 0},
        {0x5a, 0},
    },
    {
        {0x8003, 63},
        {0x8006, 63},
        {0x800a, 63},
        {0x800f, 63},
        {0x8018, 63},
        {0x801f, 63},
        {0x8029, 63},
        {0xc038, 63},
        {0x8002, 39},
        {0x8009, 39},
        {0x8017, 39},
        {0xc028, 39},
        {0x8002, 43},
        {0x8009, 43},
        {0x8017, 43},
        {0xc028, 43},
    },
    {
        {0x8003, 39},
        {0x8006, 39},
        {0x800a, 39},
        {0x800f, 39},
        {0x8018, 39},
        {0x801f, 39},
        {0x8029, 39},
        {0xc038, 39},
        {0x8003, 43},
        {0x8006, 43},
        {0x800a, 43},
        {0x800f, 43},
        {0x8018, 43},
        {0x801f, 43},
        {0x8029, 43},
        {0xc038, 43},
    },
    {
        {0x8002, 124},
        {0x8009, 124},
        {0x8017, 124},
        {0xc028, 124},
        {0x8001, 35},
        {0xc016, 35},
        {0x8001, 62},
        {0xc016, 62},
        {0xc000, 0},
        {0xc000, 36},
        {0xc000, 64},
        {0xc000, 91},
        {0xc000, 93},
        {0xc000, 126},
        {0x5b, 0},
        {0x5c, 0},
    },
    {
        {0x8003, 124},
        {0x8006, 124},
        {0x800a, 124},
        {0x800f, 124},
        {0x8018, 124},
        {0x801f, 124},
        {0x8029, 124},
        {0xc038, 124},
        {0x8002, 35},
        {0x8009, 35},
        {0x8017, 35},
        {0xc028, 35},
        {0x8002, 62},
        {0x8009, 62},
        {0x8017, 62},
        {0xc028, 62},
    },
    {
        {0x8003, 35},
        {0x8006, 35},
        {0x800a, 35},
        {0x800f, 35},
        {0x8018, 35},
        {0x801f, 35},
        {0x8029, 35},
        {0xc038, 35},
        {0x8003, 62},
        {0x8006, 62},
        {0x800a, 62},
        {0x800f, 62},
        {0x8018, 62},
        {0x801f, 62},
        {0x8029, 62},
        {0xc038, 62},
    },
    {
        {0x8001, 0},
        {0xc016, 0},
        {0x8001, 36},
        {0xc016, 36},
        {0x8001, 64},
        {0xc016, 64},
        {0x8001, 91},
        {0xc016, 91},
        {0x8001, 93},
        {0xc016, 93},
        {0x8001, 126},
        {0xc016, 126},
        {0xc000, 94},
        {0xc000, 125},
        {0x5d, 0},
        {0x5e, 0},
    },
    {
        {0x8002, 0},
        {0x8009, 0},
        {0x8017, 0},
        {0xc028, 0},
        {0x8002, 36},
        {0x8009, 36},
        {0x8017, 36},
        {0xc028, 36},
        {0x8002, 64},
        {0x8009, 64},
        {0x8017, 64},
        {0xc028, 64},
        {0x8002, 91},
        {0x8009, 91},
        {0x8017, 91},
        {0xc028, 91},
    },
    {
        {0x8003, 0},
        {0x8006, 0},
        {0x800a, 0},
        {0x800f, 0},
        {0x8018, 0},
        {0x801f, 0},
        {0x8029, 0},
        {0xc038, 0},
        {0x8003, 36},
        {0x8006, 36},
        {0x800a, 36},
        {0x800f, 36},
        {0x8018, 36},
        {0x801f, 36},
        {0x8029, 36},
        {0xc038, 36},
    },
    {
        {0x8003, 64},
        {0x8006, 64},
        {0x800a, 64},
        {0x800f, 64},
        {0x8018, 64},
        {0x801f, 64},
        {0x8029, 64},
        {0xc038, 64},
        {0x8003, 91},
        {0x8006, 91},
        {0x800a, 91},
        {0x800f, 91},
        {0x8018, 91},
        {0x801f, 91},
        {0x8029, 91},
        {0xc038, 91},
    },
    {
        {0x8002, 93},
        {0x8009, 93},
        {0x8017, 93},
        {0xc028, 93},
        {0x8002, 126},
        {0x8009, 126},
        {0x8017, 126},
        {0xc028, 126},
        {0x8001, 94},
        {0xc016, 94},
        {0x8001, 125},
        {0xc016, 125},
        {0xc000, 60},
        {0xc000, 96},
        {0xc000, 123},
        {0x5f, 0},
    },
    {
        {0x8003, 93},
        {0x8006, 93},
        {0x800a, 93},
        {0x800f, 93},
        {0x8018, 93},
        {0x801f, 93},
        {0x8029, 93},
        {0xc038, 93},
        {0x8003, 126},
        {0x8006, 126},
        {0x800a, 126},
        {0x800f, 126},
        {0x8018, 126},
        {0x801f, 126},
        {0x8029, 126},
        {0xc038, 126},
    },
    {
        {0x8002, 94},
        {0x8009, 94},
        {0x8017, 94},
        {0xc028, 94},
        {0x8002, 125},
        {0x8009, 125},
        {0x8017, 125},
        {0xc028, 125},
        {0x8001, 60},
        {0xc016, 60},
        {0x8001, 96},
        {0xc016, 96},
        {0x8001, 123},
        {0xc016, 123},
        {0x60, 0},
        {0x6e, 0},
    },
    {
        {0x8003, 94},
        {0x8006, 94},
        {0x800a, 94},
        {0x800f, 94},
        {0x8018, 94},
        {0x801f, 94},
        {0x8029, 94},
        {0xc038, 94},
        {0x8003, 125},
        {0x8006, 125},
        {0x800a, 125},
        {0x800f, 125},
        {0x8018, 125},
        {0x801f, 125},
        {0x8029, 125},
        {0xc038, 125},
    },
    {
        {0x8002, 60},
        {0x8009, 60},
        {0x8017, 60},
        {0xc028, 60},
        {0x8002, 96},
        {0x8009, 96},
        {0x8017, 96},
        {0xc028, 96},
        {0x8002, 123},
        {0x8009, 123},
        {0x8017, 123},
        {0xc028, 123},
        {0x61, 0},
        {0x65, 0},
        {0x6f, 0},
        {0x85, 0},
    },
    {
        {0x8003, 60},
        {0x8006, 60},
        {0x800a, 60},
        {0x800f, 60},
        {0x8018, 60},
        {0x801f, 60},
        {0x8029, 60},
        {0xc038, 60},
        {0x8003, 96},
        {0x8006, 96},
        {0x800a, 96},
        {0x800f, 96},
        {0x8018, 96},
        {0x801f, 96},
        {0x8029, 96},
        {0xc038, 96},
    },
    {
        {0x8003, 123},
        {0x8006, 123},
        {0x800a, 123},
        {0x800f, 123},
        {0x8018, 123},
        {0x801f, 123},
        {0x8029, 123},
        {0xc038, 123},
        {0x62, 0},
        {0x63, 0},
        {0x66, 0},
        {0x69, 0},
        {0x70, 0},
        {0x77, 0},
        {0x86, 0},
        {0x99, 0},
    },
    {
        {0xc000, 92},
        {0xc000, 195},
        {0xc000, 208},
        {0x64, 0},
        {0x67, 0},
        {0x68, 0},
        {0x6a, 0},
        {0x6b, 0},
        {0x71, 0},
        {0x74, 0},
        {0x78, 0},
        {0x7e, 0},
        {0x87, 0},
        {0x8e, 0},
        {0x9a, 0},
        {0xa9, 0},
    },
    {
        {0x8001, 92},
        {0xc016, 92},
        {0x8001, 195},
        {0xc016, 195},
        {0x8001, 208},
        {0xc016, 208},
        {0xc000, 128},
        {0xc000, 130},
        {0xc000, 131},
        {0xc000, 162},
        {0xc000, 184},
        {0xc000, 194},
        {0xc000, 224},
        {0xc000, 226},
        {0x6c, 0},
        {0x6d, 0},
    },
    {
        {0x8002, 92},
        {0x8009, 92},
        {0x8017, 92},
        {0xc028, 92},
        {0x8002, 195},
        {0x8009, 195},
        {0x8017, 195},
        {0xc028, 195},
        {0x8002, 208},
        {0x8009, 208},
        {0x8017, 208},
        {0xc028, 208},
        {0x8001, 128},
        {0xc016, 128},
        {0x8001, 130},
        {0xc016, 130},
    },
    {
        {0x8003, 92},
        {0x8006, 92},
        {0x800a, 92},
        {0x800f, 92},
        {0x8018, 92},
        {0x801f, 92},
        {0x8029, 92},
        {0xc038, 92},
        {0x8003, 195},
        {0x8006, 195},
        {0x800a, 195},
        {0x800f, 195},
        {0x8018, 195},
        {0x801f, 195},
        {0x8029, 195},
        {0xc038, 195},
    },
    {
        {0x8003, 208},
        {0x8006, 208},
        {0x800a, 208},
        {0x800f, 208},
        {0x8018, 208},
        {0x801f, 208},
        {0x8029, 208},
        {0xc038, 208},
        {0x8002, 128},
        {0x8009, 128},
        {0x8017, 128},
        {0xc028, 128},
        {0x8002, 130},
        {0x8009, 130},
        {0x8017, 130},
        {0xc028, 130},
    },
    {
        {0x8003, 128},
        {0x8006, 128},
        {0x800a, 128},
        {0x800f, 128},
        {0x8018, 128},
        {0x801f, 128},
        {0x8029, 128},
        {0xc038, 128},
        {0x8003, 130},
        {0x8006, 130},
        {0x800a, 130},
        {0x800f, 130},
        {0x8018, 130},
        {0x801f, 130},
        {0x8029, 130},
        {0xc038, 130},
    },
    {
        {0x8001, 131},
        {0xc016, 131},
        {0x8001, 162},
        {0xc016, 162},
        {0x8001, 184},
        {0xc016, 184},
        {0x8001, 194},
        {0xc016, 194},
        {0x8001, 224},
        {0xc016, 224},
        {0x8001, 226},
        {0xc016, 226},
        {0xc000, 153},
        {0xc000, 161},
        {0xc000, 167},
        {0xc000, 172},
    },
    {
        {0x8002, 131},
        {0x8009, 131},
        {0x8017, 131},
        {0xc028, 131},
        {0x8002, 162},
        {0x8009, 162},
        {0x8017, 162},
        {0xc028, 162},
        {0x8002, 184},
        {0x8009, 184},
        {0x8017, 184},
        {0xc028, 184},
        {0x8002, 194},
        {0x8009, 194},
        {0x8017, 194},
        {0xc028, 194},
    },
    {
        {0x8003, 131},
        {0x8006, 131},
        {0x800a, 131},
        {0x800f, 131},
        {0x8018, 131},
        {0x801f, 131},
        {0x8029, 131},
        {0xc038, 131},
        {0x8003, 162},
        {0x8006, 162},
        {0x800a, 162},
        {0x800f, 162},
        {0x8018, 162},
        {0x801f, 162},
        {0x8029, 162},
        {0xc038, 162},
    },
    {
        {0x8003, 184},
        {0x8006, 184},
        {0x800a, 184},
        {0x800f, 184},
        {0x8018, 184},
        {0x801f, 184},
        {0x8029, 184},
        {0xc038, 184},
        {0x8003, 194},
        {0x8006, 194},
        {0x800a, 194},
        {0x800f, 194},
        {0x8018, 194},
        {0x801f, 194},
        {0x8029, 194},
        {0xc038, 194},
    },
    {
        {0x8002, 224},
        {0x8009, 224},
        {0x8017, 224},
        {0xc028, 224},
        {0x8002, 226},
        {0x8009, 226},
        {0x8017, 226},
        {0xc028, 226},
        {0x8001, 153},
        {0xc016, 153},
        {0x8001, 161},
        {0xc016, 161},
        {0x8001, 167},
        {0xc016, 167},
        {0x8001, 172},
        {0xc016, 172},
    },
    {
        {0x8003, 224},
        {0x8006, 224},
        {0x800a, 224},
        {0x800f, 224},
        {0x8018, 224},
        {0x801f, 224},
        {0x8029, 224},
        {0xc038, 224},
        {0x8003, 226},
        {0x8006, 226},
        {0x800a, 226},
        {0x800f, 226},
        {0x8018, 226},
        {0x801f, 226},
        {0x8029, 226},
        {0xc038, 226},
    },
    {
        {0x8002, 153},
        {0x8009, 153},
        {0x8017, 153},
        {0xc028, 153},
        {0x8002, 161},
        {0x8009, 161},
        {0x8017, 161},
        {0xc028, 161},
        {0x8002, 167},
        {0x8009, 167},
        {0x8017, 167},
        {0xc028, 167},
        {0x8002, 172},
        {0x8009, 172},
        {0x8017, 172},
        {0xc028, 172},
    },
    {
        {0x8003, 153},
        {0x8006, 153},
        {0x800a, 153},
        {0x800f, 153},
        {0x8018, 153},
        {0x801f, 153},
        {0x8029, 153},
        {0xc038, 153},
        {0x8003, 161},
        {0x8006, 161},
        {0x800a, 161},
        {0x800f, 161},
        {0x8018, 161},
        {0x801f, 161},
        {0x8029, 161},
        {0xc038, 161},
    },
    {
        {0x8003, 167},
        {0x8006, 167},
        {0x800a, 167},
        {0x800f, 167},
        {0x8018, 167},
        {0x801f, 167},
        {0x8029, 167},
        {0xc038, 167},
        {0x8003, 172},
        {0x8006, 172},
        {0x800a, 172},
        {0x800f, 172},
        {0x8018, 172},
        {0x801f, 172},
        {0x8029, 172},
        {0xc038, 172},
    },
    {
        {0x72, 0},
        {0x73, 0},
        {0x75, 0},
        {0x76, 0},
        {0x79, 0},
        {0x7b, 0},
        {0x7f, 0},
        {0x82, 0},
        {0x88, 0},
        {0x8b, 0},
        {0x8f, 0},
        {0x92, 0},
        {0x9b, 0},
        {0xa2, 0},
        {0xaa, 0},
        {0xb4, 0},
    },
    {
        {0xc000, 176},
        {0xc000, 177},
        {0xc000, 179},
        {0xc000, 209},
        {0xc000, 216},
        {0xc000, 217},
        {0xc000, 227},
        {0xc000, 229},
        {0xc000, 230},
        {0x7a, 0},
        {0x7c, 0},
        {0x7d, 0},
        {0x80, 0},
        {0x81, 0},
        {0x83, 0},
        {0x84, 0},
    },
    {
        {0x8001, 176},
        {0xc016, 176},
        {0x8001, 177},
        {0xc016, 177},
        {0x8001, 179},
        {0xc016, 179},
        {0x8001, 209},
        {0xc016, 209},
        {0x8001, 216},
        {0xc016, 216},
        {0x8001, 217},
        {0xc016, 217},
        {0x8001, 227},
        {0xc016, 227},
        {0x8001, 229},
        {0xc016, 229},
    },
    {
        {0x8002, 176},
        {0x8009, 176},
        {0x8017, 176},
        {0xc028, 176},
        {0x8002, 177},
        {0x8009, 177},
        {0x8017, 177},
        {0xc028, 177},
        {0x8002, 179},
        {0x8009, 179},
        {0x8017, 179},
        {0xc028, 179},
        {0x8002, 209},
        {0x8009, 209},
        {0x8017, 209},
        {0xc028, 209},
    },
    {
        {0x8003, 176},
        {0x8006, 176},
        {0x800a, 176},
        {0x800f, 176},
        {0x8018, 176},
        {0x801f, 176},
        {0x8029, 176},
        {0xc038, 176},
        {0x8003, 177},
        {0x8006, 177},
        {0x800a, 177},
        {0x800f, 177},
        {0x8018, 177},
        {0x801f, 177},
        {0x8029, 177},
        {0xc038, 177},
    },
    {
        {0x8003, 179},
        {0x8006, 179},
        {0x800a, 179},
        {0x800f, 179},
        {0x8018, 179},
        {0x801f, 179},
        {0x8029, 179},
        {0xc038, 179},
        {0x8003, 209},
        {0x8006, 209},
        {0x800a, 209},
        {0x800f, 209},
        {0x8018, 209},
        {0x801f, 209},
        {0x8029, 209},
        {0xc038, 209},
    },
    {
        {0x8002, 216},
        {0x8009, 216},
        {0x8017, 216},
        {0xc028, 216},
        {0x8002, 217},
        {0x8009, 217},
        {0x8017, 217},
        {0xc028, 217},
        {0x8002, 227},
        {0x8009, 227},
        {0x8017, 227},
        {0xc028, 227},
        {0x8002, 229},
        {0x8009, 229},
        {0x8017, 229},
        {0xc028, 229},
    },
    {
        {0x8003, 216},
        {0x8006, 216},
        {0x800a, 216},
        {0x800f, 216},
        {0x8018, 216},
        {0x801f, 216},
        {0x8029, 216},
        {0xc038, 216},
        {0x8003, 217},
        {0x8006, 217},
        {0x800a, 217},
        {0x800f, 217},
        {0x8018, 217},
        {0x801f, 217},
        {0x8029, 217},
        {0xc038, 217},
    },
    {
        {0x8003, 227},
        {0x8006, 227},
        {0x800a, 227},
        {0x800f, 227},
        {0x8018, 227},
        {0x801f, 227},
        {0x8029, 227},
        {0xc038, 227},
        {0x8003, 229},
        {0x8006, 229},
        {0x800a, 229},
        {0x800f, 229},
        {0x8018, 229},
        {0x801f, 229},
        {0x8029, 229},
        {0xc038, 229},
    },
    {
        {0x8001, 230},
        {0xc016, 230},
        {0xc000, 129},
        {0xc000, 132},
        {0xc000, 133},
        {0xc000, 134},
        {0xc000, 136},
        {0xc000, 146},
        {0xc000, 154},
        {0xc000, 156},
        {0xc000, 160},
        {0xc000, 163},
        {0xc000, 164},
        {0xc000, 169},
        {0xc000, 170},
        {0xc000, 173},
    },
    {
        {0x8002, 230},
        {0x8009, 230},
        {0x8017, 230},
        {0xc028, 230},
        {0x8001, 129},
        {0xc016, 129},
        {0x8001, 132},
        {0xc016, 132},
        {0x8001, 133},
        {0xc016, 133},
        {0x8001, 134},
        {0xc016, 134},
        {0x8001, 136},
        {0xc016, 136},
        {0x8001, 146},
        {0xc016, 146},
    },
    {
        {0x8003, 230},
        {0x8006, 230},
        {0x800a, 230},
        {0x800f, 230},
        {0x8018, 230},
        {0x801f, 230},
        {0x8029, 230},
        {0xc038, 230},
        {0x8002, 129},
        {0x8009, 129},
        {0x8017, 129},
        {0xc028, 129},
        {0x8002, 132},
        {0x8009, 132},
        {0x8017, 132},
        {0xc028, 132},
    },
    {
        {0x8003, 129},
        {0x8006, 129},
        {0x800a, 129},
        {0x800f, 129},
        {0x8018, 129},
        {0x801f, 129},
        {0x8029, 129},
        {0xc038, 129},
        {0x8003, 132},
        {0x8006, 132},
        {0x800a, 132},
        {0x800f, 132},
        {0x8018, 132},
        {0x801f, 132},
        {0x8029, 132},
        {0xc038, 132},
    },
    {
        {0x8002, 133},
        {0x8009, 133},
        {0x8017, 133},
        {0xc028, 133},
        {0x8002, 134},
        {0x8009, 134},
        {0x8017, 134},
        {0xc028, 134},
        {0x8002, 136},
        {0x8009, 136},
        {0x8017, 136},
        {0xc028, 136},
        {0x8002, 146},
        {0x8009, 146},
        {0x8017, 146},
        {0xc028, 146},
    },
    {
        {0x8003, 133},
        {0x8006, 133},
        {0x800a, 133},
        {0x800f, 133},
        {0x8018, 133},
        {0x801f, 133},
        {0x8029, 133},
        {0xc038, 133},
        {0x8003, 134},
        {0x8006, 134},
        {0x800a, 134},
        {0x800f, 134},
        {0x8018, 134},
        {0x801f, 134},
        {0x8029, 134},
        {0xc038, 134},
    },
    {
        {0x8003, 136},
        {0x8006, 136},
        {0x800a, 136},
        {0x800f, 136},
        {0x8018, 136},
        {0x801f, 136},
        {0x8029, 136},
        {0xc038, 136},
        {0x8003, 146},
        {0x8006, 146},
        {0x800a, 146},
        {0x800f, 146},
        {0x8018, 146},
        {0x801f, 146},
        {0x8029, 146},
        {0xc038, 146},
    },
    {
        {0x8001, 154},
        {0xc016, 154},
        {0x8001, 156},
        {0xc016, 156},
        {0x8001, 160},
        {0xc016, 160},
        {0x8001, 163},
        {0xc016, 163},
        {0x8001, 164},
        {0xc016, 164},
        {0x8001, 169},
        {0xc016, 169},
        {0x8001, 170},
        {0xc016, 170},
        {0x8001, 173},
        {0xc016, 173},
    },
    {
        {0x8002, 154},
        {0x8009, 154},
        {0x8017, 154},
        {0xc028, 154},
        {0x8002, 156},
        {0x8009, 156},
        {0x8017, 156},
        {0xc028, 156},
        {0x8002, 160},
        {0x8009, 160},
        {0x8017, 160},
        {0xc028, 160},
        {0x8002, 163},
        {0x8009, 163},
        {0x8017, 163},
        {0xc028, 163},
    },
    {
        {0x8003, 154},
        {0x8006, 154},
        {0x800a, 154},
        {0x800f, 154},
        {0x8018, 154},
        {0x801f, 154},
        {0x8029, 154},
        {0xc038, 154},
        {0x8003, 156},
        {0x8006, 156},
        {0x800a, 156},
        {0x800f, 156},
        {0x8018, 156},
        {0x801f, 156},
        {0x8029, 156},
        {0xc038, 156},
    },
    {
        {0x8003, 160},
        {0x8006, 160},
        {0x800a, 160},
        {0x800f, 160},
        {0x8018, 160},
        {0x801f, 160},
        {0x8029, 160},
        {0xc038, 160},
        {0x8003, 163},
        {0x8006, 163},
        {0x800a, 163},
        {0x800f, 163},
        {0x8018, 163},
        {0x801f, 163},
        {0x8029, 163},
        {0xc038, 163},
    },
    {
        {0x8002, 164},
        {0x8009, 164},
        {0x8017, 164},
        {0xc028, 164},
        {0x8002, 169},
        {0x8009, 169},
        {0x8017, 169},
        {0xc028, 169},
        {0x8002, 170},
        {0x8009, 170},
        {0x8017, 170},
        {0xc028, 170},
        {0x8002, 173},
        {0x8009, 173},
        {0x8017, 173},
        {0xc028, 173},
    },
    {
        {0x8003, 164},
        {0x8006, 164},
        {0x800a, 164},
        {0x800f, 164},
        {0x8018, 164},
        {0x801f, 164},
        {0x8029, 164},
        {0xc038, 164},
        {0x8003, 169},
        {0x8006, 169},
        {0x800a, 169},
        {0x800f, 169},
        {0x8018, 169},
        {0x801f, 169},
        {0x8029, 169},
        {0xc038, 169},
    },
    {
        {0x8003, 170},
        {0x8006, 170},
        {0x800a, 170},
        {0x800f, 170},
        {0x8018, 170},
        {0x801f, 170},
        {0x8029, 170},
        {0xc038, 170},
        {0x8003, 173},
        {0x8006, 173},
        {0x800a, 173},
        {0x800f, 173},
        {0x8018, 173},
        {0x801f, 173},
        {0x8029, 173},
        {0xc038, 173},
    },
    {
        {0x89, 0},
        {0x8a, 0},
        {0x8c, 0},
        {0x8d, 0},
        {0x90, 0},
        {0x91, 0},
        {0x93, 0},
        {0x96, 0},
        {0x9c, 0},
        {0x9f, 0},
        {0xa3, 0},
        {0xa6, 0},
        {0xab, 0},
        {0xae, 0},
        {0xb5, 0},
        {0xbe, 0},
    },
    {
        {0xc000, 178},
        {0xc000, 181},
        {0xc000, 185},
        {0xc000, 186},
        {0xc000, 187},
        {0xc000, 189},
        {0xc000, 190},
        {0xc000, 196},
        {0xc000, 198},
        {0xc000, 228},
        {0xc000, 232},
        {0xc000, 233},
        {0x94, 0},
        {0x95, 0},
        {0x97, 0},
        {0x98, 0},
    },
    {
        {0x8001, 178},
        {0xc016, 178},
        {0x8001, 181},
        {0xc016, 181},
        {0x8001, 185},
        {0xc016, 185},
        {0x8001, 186},
        {0xc016, 186},
        {0x8001, 187},
        {0xc016, 187},
        {0x8001, 189},
        {0xc016, 189},
        {0x8001, 190},
        {0xc016, 190},
        {0x8001, 196},
        {0xc016, 196},
    },
    {
        {0x8002, 178},
        {0x8009, 178},
        {0x8017, 178},
        {0xc028, 178},
        {0x8002, 181},
        {0x8009, 181},
        {0x8017, 181},
        {0xc028, 181},
        {0x8002, 185},
        {0x8009, 185},
        {0x8017, 185},
        {0xc028, 185},
        {0x8002, 186},
        {0x8009, 186},
        {0x8017, 186},
        {0xc028, 186},
    },
    {
        {0x8003, 178},
        {0x8006, 178},
        {0x800a, 178},
        {0x800f, 178},
        {0x8018, 178},
        {0x801f, 178},
        {0x8029, 178},
        {0xc038, 178},
        {0x8003, 181},
        {0x8006, 181},
        {0x800a, 181},
        {0x800f, 181},
        {0x8018, 181},
        {0x801f, 181},
        {0x8029, 181},
        {0xc038, 181},
    },
    {
        {0x8003, 185},
        {0x8006, 185},
        {0x800a, 185},
        {0x800f, 185},
        {0x8018, 185},
        {0x801f, 185},
        {0x8029, 185},
        {0xc038, 185},
        {0x8003, 186},
        {0x8006, 186},
        {0x800a, 186},
        {0x800f, 186},
        {0x8018, 186},
        {0x801f, 186},
        {0x8029, 186},
        {0xc038, 186},
    },
    {
        {0x8002, 187},
        {0x8009, 187},
        {0x8017, 187},
        {0xc028, 187},
        {0x8002, 189},
        {0x8009, 189},
        {0x8017, 189},
        {0xc028, 189},
        {0x8002, 190},
        {0x8009, 190},
        {0x8017, 190},
        {0xc028, 190},
        {0x8002, 196},
        {0x8009, 196},
        {0x8017, 196},
        {0xc028, 196},
    },
    {
        {0x8003, 187},
        {0x8006, 187},
        {0x800a, 187},
        {0x800f, 187},
        {0x8018, 187},
        {0x801f, 187},
        {0x8029, 187},
        {0xc038, 187},
        {0x8003, 189},
        {0x8006, 189},
        {0x800a, 189},
        {0x800f, 189},
        {0x8018, 189},
        {0x801f, 189},
        {0x8029, 189},
        {0xc038, 189},
    },
    {
        {0x8003, 190},
        {0x8006, 190},
        {0x800a, 190},
        {0x800f, 190},
        {0x8018, 190},
        {0x801f, 190},
        {0x8029, 190},
        {0xc038, 190},
        {0x8003, 196},
        {0x8006, 196},
        {0x800a, 196},
        {0x800f, 196},
        {0x8018, 196},
        {0x801f, 196},
        {0x8029, 196},
        {0xc038, 196},
    },
    {
        {0x8001, 198},
        {0xc016, 198},
        {0x8001, 228},
        {0xc016, 228},
        {0x8001, 232},
        {0xc016, 232},
        {0x8001, 233},
        {0xc016, 233},
        {0xc000, 1},
        {0xc000, 135},
        {0xc000, 137},
        {0xc000, 138},
        {0xc000, 139},
        {0xc000, 140},
        {0xc000, 141},
        {0xc000, 143},
    },
    {
        {0x8002, 198},
        {0x8009, 198},
        {0x8017, 198},
        {0xc028, 198},
        {0x8002, 228},
        {0x8009, 228},
        {0x8017, 228},
        {0xc028, 228},
        {0x8002, 232},
        {0x8009, 232},
        {0x8017, 232},
        {0xc028, 232},
        {0x8002, 233},
        {0x8009, 233},
        {0x8017, 233},
        {0xc028, 233},
    },
    {
        {0x8003, 198},
        {0x8006, 198},
        {0x800a, 198},
        {0x800f, 198},
        {0x8018, 198},
        {0x801f, 198},
        {0x8029, 198},
        {0xc038, 198},
        {0x8003, 228},
        {0x8006, 228},
        {0x800a, 228},
        {0x800f, 228},
        {0x8018, 228},
        {0x801f, 228},
        {0x8029, 228},
        {0xc038, 228},
    },
    {
        {0x8003, 232},
        {0x8006, 232},
        {0x800a, 232},
        {0x800f, 232},
        {0x8018, 232},
        {0x801f, 232},
        {0x8029, 232},
        {0xc038, 232},
        {0x8003, 233},
        {0x8006, 233},
        {0x800a, 233},
        {0x800f, 233},
        {0x8018, 233},
        {0x801f, 233},
        {0x8029, 233},
        {0xc038, 233},
    },
    {
        {0x8001, 1},
        {0xc016, 1},
        {0x8001, 135},
        {0xc016, 135},
        {0x8001, 137},
        {0xc016, 137},
        {0x8001, 138},
        {0xc016, 138},
        {0x8001, 139},
        {0xc016, 139},
        {0x8001, 140},
        {0xc016, 140},
        {0x8001, 141},
        {0xc016, 141},
        {0x8001, 143},
        {0xc016, 143},
    },
    {
        {0x8002, 1},
        {0x8009, 1},
        {0x8017, 1},
        {0xc028, 1},
        {0x8002, 135},
        {0x8009, 135},
        {0x8017, 135},
        {0xc028, 135},
        {0x8002, 137},
        {0x8009, 137},
        {0x8017, 137},
        {0xc028, 137},
        {0x8002, 138},
        {0x8009, 138},
        {0x8017, 138},
        {0xc028, 138},
    },
    {
        {0x8003, 1},
        {0x8006, 1},
        {0x800a, 1},
        {0x800f, 1},
        {0x8018, 1},
        {0x801f, 1},
        {0x8029, 1},
        {0xc038, 1},
        {0x8003, 135},
        {0x8006, 135},
        {0x800a, 135},
        {0x800f, 135},
        {0x8018, 135},
        {0x801f, 135},
        {0x8029, 135},
        {0xc038, 135},
    },
    {
        {0x8003, 137},
        {0x8006, 137},
        {0x800a, 137},
        {0x800f, 137},
        {0x8018, 137},
        {0x801f, 137},
        {0x8029, 137},
        {0xc038, 137},
        {0x8003, 138},
        {0x8006, 138},
        {0x800a, 138},
        {0x800f, 138},
        {0x8018, 138},
        {0x801f, 138},
        {0x8029, 138},
        {0xc038, 138},
    },
    {
        {0x8002, 139},
        {0x8009, 139},
        {0x8017, 139},
        {0xc028, 139},
        {0x8002, 140},
        {0x8009, 140},
        {0x8017, 140},
        {0xc028, 140},
        {0x8002, 141},
        {0x8009, 141},
        {0x8017, 141},
        {0xc028, 141},
        {0x8002, 143},
        {0x8009, 143},
        {0x8017, 143},
        {0xc028, 143},
    },
    {
        {0x8003, 139},
        {0x8006, 139},
        {0x800a, 139},
        {0x800f, 139},
        {0x8018, 139},
        {0x801f, 139},
        {0x8029, 139},
        {0xc038, 139},
        {0x8003, 140},
        {0x8006, 140},
        {0x800a, 140},
        {0x800f, 140},
        {0x8018, 140},
        {0x801f, 140},
        {0x8029, 140},
        {0xc038, 140},
    },
    {
        {0x8003, 141},
        {0x8006, 141},
        {0x800a, 141},
        {0x800f, 141},
        {0x8018, 141},
        {0x801f, 141},
        {0x8029, 141},
        {0xc038, 141},
        {0x8003, 143},
        {0x8006, 143},
        {0x800a, 143},
        {0x800f, 143},
        {0x8018, 143},
        {0x801f, 143},
        {0x8029, 143},
        {0xc038, 143},
    },
    {
        {0x9d, 0},
        {0x9e, 0},
        {0xa0, 0},
        {0xa1, 0},
        {0xa4, 0},
        {0xa5, 0},
        {0xa7, 0},
        {0xa8, 0},
        {0xac, 0},
        {0xad, 0},
        {0xaf, 0},
        {0xb1, 0},
        {0xb6, 0},
        {0xb9, 0},
        {0xbf, 0},
        {0xcf, 0},
    },
    {
        {0xc000, 147},
        {0xc000, 149},
        {0xc000, 150},
        {0xc000, 151},
        {0xc000, 152},
        {0xc000, 155},
        {0xc000, 157},
        {0xc000, 158},
        {0xc000, 165},
        {0xc000, 166},
        {0xc000, 168},
        {0xc000, 174},
        {0xc000, 175},
        {0xc000, 180},
        {0xc000, 182},
        {0xc000, 183},
    },
    {
        {0x8001, 147},
        {0xc016, 147},
        {0x8001, 149},
        {0xc016, 149},
        {0x8001, 150},
        {0xc016, 150},
        {0x8001, 151},
        {0xc016, 151},
        {0x8001, 152},
        {0xc016, 152},
        {0x8001, 155},
        {0xc016, 155},
        {0x8001, 157},
        {0xc016, 157},
        {0x8001, 158},
        {0xc016, 158},
    },
    {
        {0x8002, 147},
        {0x8009, 147},
        {0x8017, 147},
        {0xc028, 147},
        {0x8002, 149},
        {0x8009, 149},
        {0x8017, 149},
        {0xc028, 149},
        {0x8002, 150},
        {0x8009, 150},
        {0x8017, 150},
        {0xc028, 150},
        {0x8002, 151},
        {0x8009, 151},
        {0x8017, 151},
        {0xc028, 151},
    },
    {
        {0x8003, 147},
        {0x8006, 147},
        {0x800a, 147},
        {0x800f, 147},
        {0x8018, 147},
        {0x801f, 147},
        {0x8029, 147},
        {0xc038, 147},
        {0x8003, 149},
        {0x8006, 149},
        {0x800a, 149},
        {0x800f, 149},
        {0x8018, 149},
        {0x801f, 149},
        {0x8029, 149},
        {0xc038, 149},
    },
    {
        {0x8003, 150},
        {0x8006, 150},
        {0x800a, 150},
        {0x800f, 150},
        {0x8018, 150},
        {0x801f, 150},
        {0x8029, 150},
        {0xc038, 150},
        {0x8003, 151},
        {0x8006, 151},
        {0x800a, 151},
        {0x800f, 151},
        {0x8018, 151},
        {0x801f, 151},
        {0x8029, 151},
        {0xc038, 151},
    },
    {
        {0x8002, 152},
        {0x8009, 152},
        {0x8017, 152},
        {0xc028, 152},
        {0x8002, 155},
        {0x8009, 155},
        {0x8017, 155},
        {0xc028, 155},
        {0x8002, 157},
        {0x8009, 157},
        {0x8017, 157},
        {0xc028, 157},
        {0x8002, 158},
        {0x8009, 158},
        {0x8017, 158},
        {0xc028, 158},
    },
    {
        {0x8003, 152},
        {0x8006, 152},
        {0x800a, 152},
        {0x800f, 152},
        {0x8018, 152},
        {0x801f, 152},
        {0x8029, 152},
        {0xc038, 152},
        {0x8003, 155},
        {0x8006, 155},
        {0x800a, 155},
        {0x800f, 155},
        {0x8018, 155},
        {0x801f, 155},
        {0x8029, 155},
        {0xc038, 155},
    },
    {
        {0x8003, 157},
        {0x8006, 157},
        {0x800a, 157},
        {0x800f, 157},
        {0x8018, 157},
        {0x801f, 157},
        {0x8029, 157},
        {0xc038, 157},
        {0x8003, 158},
        {0x8006, 158},
        {0x800a, 158},
        {0x800f, 158},
        {0x8018, 158},
        {0x801f, 158},
        {0x8029, 158},
        {0xc038, 158},
    },
    {
        {0x8001, 165},
        {0xc016, 165},
        {0x8001, 166},
        {0xc016, 166},
        {0x8001, 168},
        {0xc016, 168},
        {0x8001, 174},
        {0xc016, 174},
        {0x8001, 175},
        {0xc016, 175},
        {0x8001, 180},
        {0xc016, 180},
        {0x8001, 182},
        {0xc016, 182},
        {0x8001, 183},
        {0xc016, 183},
    },
    {
        {0x8002, 165},
        {0x8009, 165},
        {0x8017, 165},
        {0xc028, 165},
        {0x8002, 166},
        {0x8009, 166},
        {0x8017, 166},
        {0xc028, 166},
        {0x8002, 168},
        {0x8009, 168},
        {0x8017, 168},
        {0xc028, 168},
        {0x8002, 174},
        {0x8009, 174},
        {0x8017, 174},
        {0xc028, 174},
    },
    {
        {0x8003, 165},
        {0x8006, 165},
        {0x800a, 165},
        {0x800f, 165},
        {0x8018, 165},
        {0x801f, 165},
        {0x8029, 165},
        {0xc038, 165},
        {0x8003, 166},
        {0x8006, 166},
        {0x800a, 166},
        {0x800f, 166},
        {0x8018, 166},
        {0x801f, 166},
        {0x8029, 166},
        {0xc038, 166},
    },
    {
        {0x8003, 168},
        {0x8006, 168},
        {0x800a, 168},
        {0x800f, 168},
        {0x8018, 168},
        {0x801f, 168},
        {0x8029, 168},
        {0xc038, 168},
        {0x8003, 174},
        {0x8006, 174},
        {0x800a, 174},
        {0x800f, 174},
        {0x8018, 174},
        {0x801f, 174},
        {0x8029, 174},
        {0xc038, 174},
    },
    {
        {0x8002, 175},
        {0x8009, 175},
        {0x8017, 175},
        {0xc028, 175},
        {0x8002, 180},
        {0x8009, 180},
        {0x8017, 180},
        {0xc028, 180},
        {0x8002, 182},
        {0x8009, 182},
        {0x8017, 182},
        {0xc028, 182},
        {0x8002, 183},
        {0x8009, 183},
        {0x8017, 183},
        {0xc028, 183},
    },
    {
        {0x8003, 175},
        {0x8006, 175},
        {0x800a, 175},
        {0x800f, 175},
        {0x8018, 175},
        {0x801f, 175},
        {0x8029, 175},
        {0xc038, 175},
        {0x8003, 180},
        {0x8006, 180},
        {0x800a, 180},
        {0x800f, 180},
        {0x8018, 180},
        {0x801f, 180},
        {0x8029, 180},
        {0xc038, 180},
    },
    {
        {0x8003, 182},
        {0x8006, 182},
        {0x800a, 182},
        {0x800f, 182},
        {0x8018, 182},
        {0x801f, 182},
        {0x8029, 182},
        {0xc038, 182},
        {0x8003, 183},
        {0x8006, 183},
        {0x800a, 183},
        {0x800f, 183},
        {0x8018, 183},
        {0x801f, 183},
        {0x8029, 183},
        {0xc038, 183},
    },
    {
        {0xc000, 188},
        {0xc000, 191},
        {0xc000, 197},
        {0xc000, 231},
        {0xc000, 239},
        {0xb0, 0},
        {0xb2, 0},
        {0xb3, 0},
        {0xb7, 0},
        {0xb8, 0},
        {0xba, 0},
        {0xbb, 0},
        {0xc0, 0},
        {0xc7, 0},
        {0xd0, 0},
        {0xdf, 0},
    },
    {
        {0x8001, 188},
        {0xc016, 188},
        {0x8001, 191},
        {0xc016, 191},
        {0x8001, 197},
        {0xc016, 197},
        {0x8001, 231},
        {0xc016, 231},
        {0x8001, 239},
        {0xc016, 239},
        {0xc000, 9},
        {0xc000, 142},
        {0xc000, 144},
        {0xc000, 145},
        {0xc000, 148},
        {0xc000, 159},
    },
    {
        {0x8002, 188},
        {0x8009, 188},
        {0x8017, 188},
        {0xc028, 188},
        {0x8002, 191},
        {0x8009, 191},
        {0x8017, 191},
        {0xc028, 191},
        {0x8002, 197},
        {0x8009, 197},
        {0x8017, 197},
        {0xc028, 197},
        {0x8002, 231},
        {0x8009, 231},
        {0x8017, 231},
        {0xc028, 231},
    },
    {
        {0x8003, 188},
        {0x8006, 188},
        {0x800a, 188},
        {0x800f, 188},
        {0x8018, 188},
        {0x801f, 188},
        {0x8029, 188},
        {0xc038, 188},
        {0x8003, 191},
        {0x8006, 191},
        {0x800a, 191},
        {0x800f, 191},
        {0x8018, 191},
        {0x801f, 191},
        {0x8029, 191},
        {0xc038, 191},
    },
    {
        {0x8003, 197},
        {0x8006, 197},
        {0x800a, 197},
        {0x800f, 197},
        {0x8018, 197},
        {0x801f, 197},
        {0x8029, 197},
        {0xc038, 197},
        {0x8003, 231},
        {0x8006, 231},
        {0x800a, 231},
        {0x800f, 231},
        {0x8018, 231},
        {0x801f, 231},
        {0x8029, 231},
        {0xc038, 231},
    },
    {
        {0x8002, 239},
        {0x8009, 239},
        {0x8017, 239},
        {0xc028, 239},
        {0x8001, 9},
        {0xc016, 9},
        {0x8001, 142},
        {0xc016, 142},
        {0x8001, 144},
        {0xc016, 144},
        {0x8001, 145},
        {0xc016, 145},
        {0x8001, 148},
        {0xc016, 148},
        {0x8001, 159},
        {0xc016, 159},
    },
    {
        {0x8003, 239},
        {0x8006, 239},
        {0x800a, 239},
        {0x800f, 239},
        {0x8018, 239},
        {0x801f, 239},
        {0x8029, 239},
        {0xc038, 239},
        {0x8002, 9},
        {0x8009, 9},
        {0x8017, 9},
        {0xc028, 9},
        {0x8002, 142},
        {0x8009, 142},
        {0x8017, 142},
        {0xc028, 142},
    },
    {
        {0x8003, 9},
        {0x8006, 9},
        {0x800a, 9},
        {0x800f, 9},
        {0x8018, 9},
        {0x801f, 9},
        {0x8029, 9},
        {0xc038, 9},
        {0x8003, 142},
        {0x8006, 142},
        {0x800a, 142},
        {0x800f, 142},
        {0x8018, 142},
        {0x801f, 142},
        {0x8029, 142},
        {0xc038, 142},
    },
    {
        {0x8002, 144},
        {0x8009, 144},
        {0x8017, 144},
        {0xc028, 144},
        {0x8002, 145},
        {0x8009, 145},
        {0x8017, 145},
        {0xc028, 145},
        {0x8002, 148},
        {0x8009, 148},
        {0x8017, 148},
        {0xc028, 148},
        {0x8002, 159},
        {0x8009, 159},
        {0x8017, 159},
        {0xc028, 159},
    },
    {
        {0x8003, 144},
        {0x8006, 144},
        {0x800a, 144},
        {0x800f, 144},
        {0x8018, 144},
        {0x801f, 144},
        {0x8029, 144},
        {0xc038, 144},
        {0x8003, 145},
        {0x8006, 145},
        {0x800a, 145},
        {0x800f, 145},
        {0x8018, 145},
        {0x801f, 145},
        {0x8029, 145},
        {0xc038, 145},
    },
    {
        {0x8003, 148},
        {0x8006, 148},
        {0x800a, 148},
        {0x800f, 148},
        {0x8018, 148},
        {0x801f, 148},
        {0x8029, 148},
        {0xc038, 148},
        {0x8003, 159},
        {0x8006, 159},
        {0x800a, 159},
        {0x800f, 159},
        {0x8018, 159},
        {0x801f, 159},
        {0x8029, 159},
        {0xc038, 159},
    },
    {
        {0xc000, 171},
        {0xc000, 206},
        {0xc000, 215},
        {0xc000, 225},
        {0xc000, 236},
        {0xc000, 237},
        {0xbc, 0},
        {0xbd, 0},
        {0xc1, 0},
        {0xc4, 0},
        {0xc8, 0},
        {0xcb, 0},
        {0xd1, 0},
        {0xd8, 0},
        {0xe0, 0},
        {0xee, 0},
    },
    {
        {0x8001, 171},
        {0xc016, 171},
        {0x8001, 206},
        {0xc016, 206},
        {0x8001, 215},
        {0xc016, 215},
        {0x8001, 225},
        {0xc016, 225},
        {0x8001, 236},
        {0xc016, 236},
        {0x8001, 237},
        {0xc016, 237},
        {0xc000, 199},
        {0xc000, 207},
        {0xc000, 234},
        {0xc000, 235},
    },
    {
        {0x8002, 171},
        {0x8009, 171},
        {0x8017, 171},
        {0xc028, 171},
        {0x8002, 206},
        {0x8009, 206},
        {0x8017, 206},
        {0xc028, 206},
        {0x8002, 215},
        {0x8009, 215},
        {0x8017, 215},
        {0xc028, 215},
        {0x8002, 225},
        {0x8009, 225},
        {0x8017, 225},
        {0xc028, 225},
    },
    {
        {0x8003, 171},
        {0x8006, 171},
        {0x800a, 171},
        {0x800f, 171},
        {0x8018, 171},
        {0x801f, 171},
        {0x8029, 171},
        {0xc038, 171},
        {0x8003, 206},
        {0x8006, 206},
        {0x800a, 206},
        {0x800f, 206},
        {0x8018, 206},
        {0x801f, 206},
        {0x8029, 206},
        {0xc038, 206},
    },
    {
        {0x8003, 215},
        {0x8006, 215},
        {0x800a, 215},
        {0x800f, 215},
        {0x8018, 215},
        {0x801f, 215},
        {0x8029, 215},
        {0xc038, 215},
        {0x8003, 225},
        {0x8006, 225},
        {0x800a, 225},
        {0x800f, 225},
        {0x8018, 225},
        {0x801f, 225},
        {0x8029, 225},
        {0xc038, 225},
    },
    {
        {0x8002, 236},
        {0x8009, 236},
        {0x8017, 236},
        {0xc028, 236},
        {0x8002, 237},
        {0x8009, 237},
        {0x8017, 237},
        {0xc028, 237},
        {0x8001, 199},
        {0xc016, 199},
        {0x8001, 207},
        {0xc016, 207},
        {0x8001, 234},
        {0xc016, 234},
        {0x8001, 235},
        {0xc016, 235},
    },
    {
        {0x8003, 236},
        {0x8006, 236},
        {0x800a, 236},
        {0x800f, 236},
        {0x8018, 236},
        {0x801f, 236},
        {0x8029, 236},
        {0xc038, 236},
        {0x8003, 237},
        {0x8006, 237},
        {0x800a, 237},
        {0x800f, 237},
        {0x8018, 237},
        {0x801f, 237},
        {0x8029, 237},
        {0xc038, 237},
    },
    {
        {0x8002, 199},
        {0x8009, 199},
        {0x8017, 199},
        {0xc028, 199},
        {0x8002, 207},
        {0x8009, 207},
        {0x8017, 207},
        {0xc028, 207},
        {0x8002, 234},
        {0x8009, 234},
        {0x8017, 234},
        {0xc028, 234},
        {0x8002, 235},
        {0x8009, 235},
        {0x8017, 235},
        {0xc028, 235},
    },
    {
        {0x8003, 199},
        {0x8006, 199},
        {0x800a, 199},
        {0x800f, 199},
        {0x8018, 199},
        {0x801f, 199},
        {0x8029, 199},
        {0xc038, 199},
        {0x8003, 207},
        {0x8006, 207},
        {0x800a, 207},
        {0x800f, 207},
        {0x8018, 207},
        {0x801f, 207},
        {0x8029, 207},
        {0xc038, 207},
    },
    {
        {0x8003, 234},
        {0x8006, 234},
        {0x800a, 234},
        {0x800f, 234},
        {0x8018, 234},
        {0x801f, 234},
        {0x8029, 234},
        {0xc038, 234},
        {0x8003, 235},
        {0x8006, 235},
        {0x800a, 235},
        {0x800f, 235},
        {0x8018, 235},
        {0x801f, 235},
        {0x8029, 235},
        {0xc038, 235},
    },
    {
        {0xc2, 0},
        {0xc3, 0},
        {0xc5, 0},
        {0xc6, 0},
        {0xc9, 0},
        {0xca, 0},
        {0xcc, 0},
        {0xcd, 0},
        {0xd2, 0},
        {0xd5, 0},
        {0xd9, 0},
        {0xdc, 0},
        {0xe1, 0},
        {0xe7, 0},
        {0xef, 0},
        {0xf6, 0},
    },
    {
        {0xc000, 192},
        {0xc000, 193},
        {0xc000, 200},
        {0xc000, 201},
        {0xc000, 202},
        {0xc000, 205},
        {0xc000, 210},
        {0xc000, 213},
        {0xc000, 218},
        {0xc000, 219},
        {0xc000, 238},
        {0xc000, 240},
        {0xc000, 242},
        {0xc000, 243},
        {0xc000, 255},
        {0xce, 0},
    },
    {
        {0x8001, 192},
        {0xc016, 192},
        {0x8001, 193},
        {0xc016, 193},
        {0x8001, 200},
        {0xc016, 200},
        {0x8001, 201},
        {0xc016, 201},
        {0x8001, 202},
        {0xc016, 202},
        {0x8001, 205},
        {0xc016, 205},
        {0x8001, 210},
        {0xc016, 210},
        {0x8001, 213},
        {0xc016, 213},
    },
    {
        {0x8002, 192},
        {0x8009, 192},
        {0x8017, 192},
        {0xc028, 192},
        {0x8002, 193},
        {0x8009, 193},
        {0x8017, 193},
        {0xc028, 193},
        {0x8002, 200},
        {0x8009, 200},
        {0x8017, 200},
        {0xc028, 200},
        {0x8002, 201},
        {0x8009, 201},
        {0x8017, 201},
        {0xc028, 201},
    },
    {
        {0x8003, 192},
        {0x8006, 192},
        {0x800a, 192},
        {0x800f, 192},
        {0x8018, 192},
        {0x801f, 192},
        {0x8029, 192},
        {0xc038, 192},
        {0x8003, 193},
        {0x8006, 193},
        {0x800a, 193},
        {0x800f, 193},
        {0x8018, 193},
        {0x801f, 193},
        {0x8029, 193},
        {0xc038, 193},
    },
    {
        {0x8003, 200},
        {0x8006, 200},
        {0x800a, 200},
        {0x800f, 200},
        {0x8018, 200},
        {0x801f, 200},
        {0x8029, 200},
        {0xc038, 200},
        {0x8003, 201},
        {0x8006, 201},
        {0x800a, 201},
        {0x800f, 201},
        {0x8018, 201},
        {0x801f, 201},
        {0x8029, 201},
        {0xc038, 201},
    },
    {
        {0x8002, 202},
        {0x8009, 202},
        {0x8017, 202},
        {0xc028, 202},
        {0x8002, 205},
        {0x8009, 205},
        {0x8017, 205},
        {0xc028, 205},
        {0x8002, 210},
        {0x8009, 210},
        {0x8017, 210},
        {0xc028, 210},
        {0x8002, 213},
        {0x8009, 213},
        {0x8017, 213},
        {0xc028, 213},
    },
    {
        {0x8003, 202},
        {0x8006, 202},
        {0x800a, 202},
        {0x800f, 202},
        {0x8018, 202},
        {0x801f, 202},
        {0x8029, 202},
        {0xc038, 202},
        {0x8003, 205},
        {0x8006, 205},
        {0x800a, 205},
        {0x800f, 205},
        {0x8018, 205},
        {0x801f, 205},
        {0x8029, 205},
        {0xc038, 205},
    },
    {
        {0x8003, 210},
        {0x8006, 210},
        {0x800a, 210},
        {0x800f, 210},
        {0x8018, 210},
        {0x801f, 210},
        {0x8029, 210},
        {0xc038, 210},
        {0x8003, 213},
        {0x8006, 213},
        {0x800a, 213},
        {0x800f, 213},
        {0x8018, 213},
        {0x801f, 213},
        {0x8029, 213},
        {0xc038, 213},
    },
    {
        {0x8001, 218},
        {0xc016, 218},
        {0x8001, 219},
        {0xc016, 219},
        {0x8001, 238},
        {0xc016, 238},
        {0x8001, 240},
        {0xc016, 240},
        {0x8001, 242},
        {0xc016, 242},
        {0x8001, 243},
        {0xc016, 243},
        {0x8001, 255},
        {0xc016, 255},
        {0xc000, 203},
        {0xc000, 204},
    },
    {
        {0x8002, 218},
        {0x8009, 218},
        {0x8017, 218},
        {0xc028, 218},
        {0x8002, 219},
        {0x8009, 219},
        {0x8017, 219},
        {0xc028, 219},
        {0x8002, 238},
        {0x8009, 238},
        {0x8017, 238},
        {0xc028, 238},
        {0x8002, 240},
        {0x8009, 240},
        {0x8017, 240},
        {0xc028, 240},
    },
    {
        {0x8003, 218},
        {0x8006, 218},
        {0x800a, 218},
        {0x800f, 218},
        {0x8018, 218},
        {0x801f, 218},
        {0x8029, 218},
        {0xc038, 218},
        {0x8003, 219},
        {0x8006, 219},
        {0x800a, 219},
        {0x800f, 219},
        {0x8018, 219},
        {0x801f, 219},
        {0x8029, 219},
        {0xc038, 219},
    },
    {
        {0x8003, 238},
        {0x8006, 238},
        {0x800a, 238},
        {0x800f, 238},
        {0x8018, 238},
        {0x801f, 238},
        {0x8029, 238},
        {0xc038, 238},
        {0x8003, 240},
        {0x8006, 240},
        {0x800a, 240},
        {0x800f, 240},
        {0x8018, 240},
        {0x801f, 240},
        {0x8029, 240},
        {0xc038, 240},
    },
    {
        {0x8002, 242},
        {0x8009, 242},
        {0x8017, 242},
        {0xc028, 242},
        {0x8002, 243},
        {0x8009, 243},
        {0x8017, 243},
        {0xc028, 243},
        {0x8002, 255},
        {0x8009, 255},
        {0x8017, 255},
        {0xc028, 255},
        {0x8001, 203},
        {0xc016, 203},
        {0x8001, 204},
        {0xc016, 204},
    },
    {
        {0x8003, 242},
        {0x8006, 242},
        {0x800a, 242},
        {0x800f, 242},
        {0x8018, 242},
        {0x801f, 242},
        {0x8029, 242},
        {0xc038, 242},
        {0x8003, 243},
        {0x8006, 243},
        {0x800a, 243},
        {0x800f, 243},
        {0x8018, 243},
        {0x801f, 243},
        {0x8029, 243},
        {0xc038, 243},
    },
    {
        {0x8003, 255},
        {0x8006, 255},
        {0x800a, 255},
        {0x800f, 255},
        {0x8018, 255},
        {0x801f, 255},
        {0x8029, 255},
        {0xc038, 255},
        {0x8002, 203},
        {0x8009, 203},
        {0x8017, 203},
        {0xc028, 203},
        {0x8002, 204},
        {0x8009, 204},
        {0x8017, 204},
        {0xc028, 204},
    },
    {
        {0x8003, 203},
        {0x8006, 203},
        {0x800a, 203},
        {0x800f, 203},
        {0x8018, 203},
        {0x801f, 203},
        {0x8029, 203},
        {0xc038, 203},
        {0x8003, 204},
        {0x8006, 204},
        {0x800a, 204},
        {0x800f, 204},
        {0x8018, 204},
        {0x801f, 204},
        {0x8029, 204},
        {0xc038, 204},
    },
    {
        {0xd3, 0},
        {0xd4, 0},
        {0xd6, 0},
        {0xd7, 0},
        {0xda, 0},
        {0xdb, 0},
        {0xdd, 0},
        {0xde, 0},
        {0xe2, 0},
        {0xe4, 0},
        {0xe8, 0},
        {0xeb, 0},
        {0xf0, 0},
        {0xf3, 0},
        {0xf7, 0},
        {0xfa, 0},
    },
    {
        {0xc000, 211},
        {0xc000, 212},
        {0xc000, 214},
        {0xc000, 221},
        {0xc000, 222},
        {0xc000, 223},
        {0xc000, 241},
        {0xc000, 244},
        {0xc000, 245},
        {0xc000, 246},
        {0xc000, 247},
        {0xc000, 248},
        {0xc000, 250},
        {0xc000, 251},
        {0xc000, 252},
        {0xc000, 253},
    },
    {
        {0x8001, 211},
        {0xc016, 211},
        {0x8001, 212},
        {0xc016, 212},
        {0x8001, 214},
        {0xc016, 214},
        {0x8001, 221},
        {0xc016, 221},
        {0x8001, 222},
        {0xc016, 222},
        {0x8001, 223},
        {0xc016, 223},
        {0x8001, 241},
        {0xc016, 241},
        {0x8001, 244},
        {0xc016, 244},
    },
    {
        {0x8002, 211},
        {0x8009, 211},
        {0x8017, 211},
        {0xc028, 211},
        {0x8002, 212},
        {0x8009, 212},
        {0x8017, 212},
        {0xc028, 212},
        {0x8002, 214},
        {0x8009, 214},
        {0x8017, 214},
        {0xc028, 214},
        {0x8002, 221},
        {0x8009, 221},
        {0x8017, 221},
        {0xc028, 221},
    },
    {
        {0x8003, 211},
        {0x8006, 211},
        {0x800a, 211},
        {0x800f, 211},
        {0x8018, 211},
        {0x801f, 211},
        {0x8029, 211},
        {0xc038, 211},
        {0x8003, 212},
        {0x8006, 212},
        {0x800a, 212},
        {0x800f, 212},
        {0x8018, 212},
        {0x801f, 212},
        {0x8029, 212},
        {0xc038, 212},
    },
    {
        {0x8003, 214},
        {0x8006, 214},
        {0x800a, 214},
        {0x800f, 214},
        {0x8018, 214},
        {0x801f, 214},
        {0x8029, 214},
        {0xc038, 214},
        {0x8003, 221},
        {0x8006, 221},
        {0x800a, 221},
        {0x800f, 221},
        {0x8018, 221},
        {0x801f, 221},
        {0x8029, 221},
        {0xc038, 221},
    },
    {
        {0x8002, 222},
        {0x8009, 222},
        {0x8017, 222},
        {0xc028, 222},
        {0x8002, 223},
        {0x8009, 223},
        {0x8017, 223},
        {0xc028, 223},
        {0x8002, 241},
        {0x8009, 241},
        {0x8017, 241},
        {0xc028, 241},
        {0x8002, 244},
        {0x8009, 244},
        {0x8017, 244},
        {0xc028, 244},
    },
    {
        {0x8003, 222},
        {0x8006, 222},
        {0x800a, 222},
        {0x800f, 222},
        {0x8018, 222},
        {0x801f, 222},
        {0x8029, 222},
        {0xc038, 222},
        {0x8003, 223},
        {0x8006, 223},
        {0x800a, 223},
        {0x800f, 223},
        {0x8018, 223},
        {0x801f, 223},
        {0x8029, 223},
        {0xc038, 223},
    },
    {
        {0x8003, 241},
        {0x8006, 241},
        {0x800a, 241},
        {0x800f, 241},
        {0x8018, 241},
        {0x801f, 241},
        {0x8029, 241},
        {0xc038, 241},
        {0x8003, 244},
        {0x8006, 244},
        {0x800a, 244},
        {0x800f, 244},
        {0x8018, 244},
        {0x801f, 244},
        {0x8029, 244},
        {0xc038, 244},
    },
    {
        {0x8001, 245},
        {0xc016, 245},
        {0x8001, 246},
        {0xc016, 246},
        {0x8001, 247},
        {0xc016, 247},
        {0x8001, 248},
        {0xc016, 248},
        {0x8001, 250},
        {0xc016, 250},
        {0x8001, 251},
        {0xc016, 251},
        {0x8001, 252},
        {0xc016, 252},
        {0x8001, 253},
        {0xc016, 253},
    },
    {
        {0x8002, 245},
        {0x8009, 245},
        {0x8017, 245},
        {0xc028, 245},
        {0x8002, 246},
        {0x8009, 246},
        {0x8017, 246},
        {0xc028, 246},
        {0x8002, 247},
        {0x8009, 247},
        {0x8017, 247},
        {0xc028, 247},
        {0x8002, 248},
        {0x8009, 248},
        {0x8017, 248},
        {0xc028, 248},
    },
    {
        {0x8003, 245},
        {0x8006, 245},
        {0x800a, 245},
        {0x800f, 245},
        {0x8018, 245},
        {0x801f, 245},
        {0x8029, 245},
        {0xc038, 245},
        {0x8003, 246},
        {0x8006, 246},
        {0x800a, 246},
        {0x800f, 246},
        {0x8018, 246},
        {0x801f, 246},
        {0x8029, 246},
        {0xc038, 246},
    },
    {
        {0x8003, 247},
        {0x8006, 247},
        {0x800a, 247},
        {0x800f, 247},
        {0x8018, 247},
        {0x801f, 247},
        {0x8029, 247},
        {0xc038, 247},
        {0x8003, 248},
        {0x8006, 248},
        {0x800a, 248},
        {0x800f, 248},
        {0x8018, 248},
        {0x801f, 248},
        {0x8029, 248},
        {0xc038, 248},
    },
    {
        {0x8002, 250},
        {0x8009, 250},
        {0x8017, 250},
        {0xc028, 250},
        {0x8002, 251},
        {0x8009, 251},
        {0x8017, 251},
        {0xc028, 251},
        {0x8002, 252},
        {0x8009, 252},
        {0x8017, 252},
        {0xc028, 252},
        {0x8002, 253},
        {0x8009, 253},
        {0x8017, 253},
        {0xc028, 253},
    },
    {
        {0x8003, 250},
        {0x8006, 250},
        {0x800a, 250},
        {0x800f, 250},
        {0x8018, 250},
        {0x801f, 250},
        {0x8029, 250},
        {0xc038, 250},
        {0x8003, 251},
        {0x8006, 251},
        {0x800a, 251},
        {0x800f, 251},
        {0x8018, 251},
        {0x801f, 251},
        {0x8029, 251},
        {0xc038, 251},
    },
    {
        {0x8003, 252},
        {0x8006, 252},
        {0x800a, 252},
        {0x800f, 252},
        {0x8018, 252},
        {0x801f, 252},
        {0x8029, 252},
        {0xc038, 252},
        {0x8003, 253},
        {0x8006, 253},
        {0x800a, 253},
        {0x800f, 253},
        {0x8018, 253},
        {0x801f, 253},
        {0x8029, 253},
        {0xc038, 253},
    },
    {
        {0xc000, 254},
        {0xe3, 0},
        {0xe5, 0},
        {0xe6, 0},
        {0xe9, 0},
        {0xea, 0},
        {0xec, 0},
        {0xed, 0},
        {0xf1, 0},
        {0xf2, 0},
        {0xf4, 0},
        {0xf5, 0},
        {0xf8, 0},
        {0xf9, 0},
        {0xfb, 0},
        {0xfc, 0},
    },
    {
        {0x8001, 254},
        {0xc016, 254},
        {0xc000, 2},
        {0xc000, 3},
        {0xc000, 4},
        {0xc000, 5},
        {0xc000, 6},
        {0xc000, 7},
        {0xc000, 8},
        {0xc000, 11},
        {0xc000, 12},
        {0xc000, 14},
        {0xc000, 15},
        {0xc000, 16},
        {0xc000, 17},
        {0xc000, 18},
    },
    {
        {0x8002, 254},
        {0x8009, 254},
        {0x8017, 254},
        {0xc028, 254},
        {0x8001, 2},
        {0xc016, 2},
        {0x8001, 3},
        {0xc016, 3},
        {0x8001, 4},
        {0xc016, 4},
        {0x8001, 5},
        {0xc016, 5},
        {0x8001, 6},
        {0xc016, 6},
        {0x8001, 7},
        {0xc016, 7},
    },
    {
        {0x8003, 254},
        {0x8006, 254},
        {0x800a, 254},
        {0x800f, 254},
        {0x8018, 254},
        {0x801f, 254},
        {0x8029, 254},
        {0xc038, 254},
        {0x8002, 2},
        {0x8009, 2},
        {0x8017, 2},
        {0xc028, 2},
        {0x8002, 3},
        {0x8009, 3},
        {0x8017, 3},
        {0xc028, 3},
    },
    {
        {0x8003, 2},
        {0x8006, 2},
        {0x800a, 2},
        {0x800f, 2},
        {0x8018, 2},
        {0x801f, 2},
        {0x8029, 2},
        {0xc038, 2},
        {0x8003, 3},
        {0x8006, 3},
        {0x800a, 3},
        {0x800f, 3},
        {0x8018, 3},
        {0x801f, 3},
        {0x8029, 3},
        {0xc038, 3},
    },
    {
        {0x8002, 4},
        {0x8009, 4},
        {0x8017, 4},
        {0xc028, 4},
        {0x8002, 5},
        {0x8009, 5},
        {0x8017, 5},
        {0xc028, 5},
        {0x8002, 6},
        {0x8009, 6},
        {0x8017, 6},
        {0xc028, 6},
        {0x8002, 7},
        {0x8009, 7},
        {0x8017, 7},
        {0xc028, 7},
    },
    {
        {0x8003, 4},
        {0x8006, 4},
        {0x800a, 4},
        {0x800f, 4},
        {0x8018, 4},
        {0x801f, 4},
        {0x8029, 4},
        {0xc038, 4},
        {0x8003, 5},
        {0x8006, 5},
        {0x800a, 5},
        {0x800f, 5},
        {0x8018, 5},
        {0x801f, 5},
        {0x8029, 5},
        {0xc038, 5},
    },
    {
        {0x8003, 6},
        {0x8006, 6},
        {0x800a, 6},
        {0x800f, 6},
        {0x8018, 6},
        {0x801f, 6},
        {0x8029, 6},
        {0xc038, 6},
        {0x8003, 7},
        {0x8006, 7},
        {0x800a, 7},
        {0x800f, 7},
        {0x8018, 7},
        {0x801f, 7},
        {0x8029, 7},
        {0xc038, 7},
    },
    {
        {0x8001, 8},
        {0xc016, 8},
        {0x8001, 11},
        {0xc016, 11},
        {0x8001, 12},
        {0xc016, 12},
        {0x8001, 14},
        {0xc016, 14},
        {0x8001, 15},
        {0xc016, 15},
        {0x8001, 16},
        {0xc016, 16},
        {0x8001, 17},
        {0xc016, 17},
        {0x8001, 18},
        {0xc016, 18},
    },
    {
        {0x8002, 8},
        {0x8009, 8},
        {0x8017, 8},
        {0xc028, 8},
        {0x8002, 11},
        {0x8009, 11},
        {0x8017, 11},
        {0xc028, 11},
        {0x8002, 12},
        {0x8009, 12},
        {0x8017, 12},
        {0xc028, 12},
        {0x8002, 14},
        {0x8009, 14},
        {0x8017, 14},
        {0xc028, 14},
    },
    {
        {0x8003, 8},
        {0x8006, 8},
        {0x800a, 8},
        {0x800f, 8},
        {0x8018, 8},
        {0x801f, 8},
        {0x8029, 8},
        {0xc038, 8},
        {0x8003, 11},
        {0x8006, 11},
        {0x800a, 11},
        {0x800f, 11},
        {0x8018, 11},
        {0x801f, 11},
        {0x8029, 11},
        {0xc038, 11},
    },
    {
        {0x8003, 12},
        {0x8006, 12},
        {0x800a, 12},
        {0x800f, 12},
        {0x8018, 12},
        {0x801f, 12},
        {0x8029, 12},
        {0xc038, 12},
        {0x8003, 14},
        {0x8006, 14},
        {0x800a, 14},
        {0x800f, 14},
        {0x8018, 14},
        {0x801f, 14},
        {0x8029, 14},
        {0xc038, 14},
    },
    {
        {0x8002, 15},
        {0x8009, 15},
        {0x8017, 15},
        {0xc028, 15},
        {0x8002, 16},
        {0x8009, 16},
        {0x8017, 16},
        {0xc028, 16},
        {0x8002, 17},
        {0x8009, 17},
        {0x8017, 17},
        {0xc028, 17},
        {0x8002, 18},
        {0x8009, 18},
        {0x8017, 18},
        {0xc028, 18},
    },
    {
        {0x8003, 15},
        {0x8006, 15},
        {0x800a, 15},
        {0x800f, 15},
        {0x8018, 15},
        {0x801f, 15},
        {0x8029, 15},
        {0xc038, 15},
        {0x8003, 16},
        {0x8006, 16},
        {0x800a, 16},
        {0x800f, 16},
        {0x8018, 16},
        {0x801f, 16},
        {0x8029, 16},
        {0xc038, 16},
    },
    {
        {0x8003, 17},
        {0x8006, 17},
        {0x800a, 17},
        {0x800f, 17},
        {0x8018, 17},
        {0x801f, 17},
        {0x8029, 17},
        {0xc038, 17},
        {0x8003, 18},
        {0x8006, 18},
        {0x800a, 18},
        {0x800f, 18},
        {0x8018, 18},
        {0x801f, 18},
        {0x8029, 18},
        {0xc038, 18},
    },
    {
        {0xc000, 19},
        {0xc000, 20},
        {0xc000, 21},
        {0xc000, 23},
        {0xc000, 24},
        {0xc000, 25},
        {0xc000, 26},
        {0xc000, 27},
        {0xc000, 28},
        {0xc000, 29},
        {0xc000, 30},
        {0xc000, 31},
        {0xc000, 127},
        {0xc000, 220},
        {0xc000, 249},
        {0xfd, 0},
    },
    {
        {0x8001, 19},
        {0xc016, 19},
        {0x8001, 20},
        {0xc016, 20},
        {0x8001, 21},
        {0xc016, 21},
        {0x8001, 23},
        {0xc016, 23},
        {0x8001, 24},
        {0xc016, 24},
        {0x8001, 25},
        {0xc016, 25},
        {0x8001, 26},
        {0xc016, 26},
        {0x8001, 27},
        {0xc016, 27},
    },
    {
        {0x8002, 19},
        {0x8009, 19},
        {0x8017, 19},
        {0xc028, 19},
        {0x8002, 20},
        {0x8009, 20},
        {0x8017, 20},
        {0xc028, 20},
        {0x8002, 21},
        {0x8009, 21},
        {0x8017, 21},
        {0xc028, 21},
        {0x8002, 23},
        {0x8009, 23},
        {0x8017, 23},
        {0xc028, 23},
    },
    {
        {0x8003, 19},
        {0x8006, 19},
        {0x800a, 19},
        {0x800f, 19},
        {0x8018, 19},
        {0x801f, 19},
        {0x8029, 19},
        {0xc038, 19},
        {0x8003, 20},
        {0x8006, 20},
        {0x800a, 20},
        {0x800f, 20},
        {0x8018, 20},
        {0x801f, 20},
        {0x8029, 20},
        {0xc038, 20},
    },
    {
        {0x8003, 21},
        {0x8006, 21},
        {0x800a, 21},
        {0x800f, 21},
        {0x8018, 21},
        {0x801f, 21},
        {0x8029, 21},
        {0xc038, 21},
        {0x8003, 23},
        {0x8006, 23},
        {0x800a, 23},
        {0x800f, 23},
        {0x8018, 23},
        {0x801f, 23},
        {0x8029, 23},
        {0xc038, 23},
    },
    {
        {0x8002, 24},
        {0x8009, 24},
        {0x8017, 24},
        {0xc028, 24},
        {0x8002, 25},
        {0x8009, 25},
        {0x8017, 25},
        {0xc028, 25},
        {0x8002, 26},
        {0x8009, 26},
        {0x8017, 26},
        {0xc028, 26},
        {0x8002, 27},
        {0x8009, 27},
        {0x8017, 27},
        {0xc028, 27},
    },
    {
        {0x8003, 24},
        {0x8006, 24},
        {0x800a, 24},
        {0x800f, 24},
        {0x8018, 24},
        {0x801f, 24},
        {0x8029, 24},
        {0xc038, 24},
        {0x8003, 25},
        {0x8006, 25},
        {0x800a, 25},
        {0x800f, 25},
        {0x8018, 25},
        {0x801f, 25},
        {0x8029, 25},
        {0xc038, 25},
    },
    {
        {0x8003, 26},
        {0x8006, 26},
        {0x800a, 26},
        {0x800f, 26},
        {0x8018, 26},
        {0x801f, 26},
        {0x8029, 26},
        {0xc038, 26},
        {0x8003, 27},
        {0x8006, 27},
        {0x800a, 27},
        {0x800f, 27},
        {0x8018, 27},
        {0x801f, 27},
        {0x8029, 27},
        {0xc038, 27},
    },
    {
        {0x8001, 28},
        {0xc016, 28},
        {0x8001, 29},
        {0xc016, 29},
        {0x8001, 30},
        {0xc016, 30},
        {0x8001, 31},
        {0xc016, 31},
        {0x8001, 127},
        {0xc016, 127},
        {0x8001, 220},
        {0xc016, 220},
        {0x8001, 249},
        {0xc016, 249},
        {0xfe, 0},
        {0xff, 0},
    },
    {
        {0x8002, 28},
        {0x8009, 28},
        {0x8017, 28},
        {0xc028, 28},
        {0x8002, 29},
        {0x8009, 29},
        {0x8017, 29},
        {0xc028, 29},
        {0x8002, 30},
        {0x8009, 30},
        {0x8017, 30},
        {0xc028, 30},
        {0x8002, 31},
        {0x8009, 31},
        {0x8017, 31},
        {0xc028, 31},
    },
    {
        {0x8003, 28},
        {0x8006, 28},
        {0x800a, 28},
        {0x800f, 28},
        {0x8018, 28},
        {0x801f, 28},
        {0x8029, 28},
        {0xc038, 28},
        {0x8003, 29},
        {0x8006, 29},
        {0x800a, 29},
        {0x800f, 29},
        {0x8018, 29},
        {0x801f, 29},
        {0x8029, 29},
        {0xc038, 29},
    },
    {
        {0x8003, 30},
        {0x8006, 30},
        {0x800a, 30},
        {0x800f, 30},
        {0x8018, 30},
        {0x801f, 30},
        {0x8029, 30},
        {0xc038, 30},
        {0x8003, 31},
        {0x8006, 31},
        {0x800a, 31},
        {0x800f, 31},
        {0x8018, 31},
        {0x801f, 31},
        {0x8029, 31},
        {0xc038, 31},
    },
    {
        {0x8002, 127},
        {0x8009, 127},
        {0x8017, 127},
        {0xc028, 127},
        {0x8002, 220},
        {0x8009, 220},
        {0x8017, 220},
        {0xc028, 220},
        {0x8002, 249},
        {0x8009, 249},
        {0x8017, 249},
        {0xc028, 249},
        {0xc000, 10},
        {0xc000, 13},
        {0xc000, 22},
        {0x100, 0},
    },
    {
        {0x8003, 127},
        {0x8006, 127},
        {0x800a, 127},
        {0x800f, 127},
        {0x8018, 127},
        {0x801f, 127},
        {0x8029, 127},
        {0xc038, 127},
        {0x8003, 220},
        {0x8006, 220},
        {0x800a, 220},
        {0x800f, 220},
        {0x8018, 220},
        {0x801f, 220},
        {0x8029, 220},
        {0xc038, 220},
    },
    {
        {0x8003, 249},
        {0x8006, 249},
        {0x800a, 249},
        {0x800f, 249},
        {0x8018, 249},
        {0x801f, 249},
        {0x8029, 249},
        {0xc038, 249},
        {0x8001, 10},
        {0xc016, 10},
        {0x8001, 13},
        {0xc016, 13},
        {0x8001, 22},
        {0xc016, 22},
        {0x100, 0},
        {0x100, 0},
    },
    {
        {0x8002, 10},
        {0x8009, 10},
        {0x8017, 10},
        {0xc028, 10},
        {0x8002, 13},
        {0x8009, 13},
        {0x8017, 13},
        {0xc028, 13},
        {0x8002, 22},
        {0x8009, 22},
        {0x8017, 22},
        {0xc028, 22},
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
    },
    {
        {0x8003, 10},
        {0x8006, 10},
        {0x800a, 10},
        {0x800f, 10},
        {0x8018, 10},
        {0x801f, 10},
        {0x8029, 10},
        {0xc038, 10},
        {0x8003, 13},
        {0x8006, 13},
        {0x800a, 13},
        {0x800f, 13},
        {0x8018, 13},
        {0x801f, 13},
        {0x8029, 13},
        {0xc038, 13},
    },
    {
        {0x8003, 22},
        {0x8006, 22},
        {0x800a, 22},
        {0x800f, 22},
        {0x8018, 22},
        {0x801f, 22},
        {0x8029, 22},
        {0xc038, 22},
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
    },
    {
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
        {0x100, 0},
    },
};
void nghttp3_range_init(nghttp3_range *r, uint64_t begin, uint64_t end)
{
  r->begin = begin;
  r->end = end;
}
nghttp3_range nghttp3_range_intersect(const nghttp3_range *a,
                                      const nghttp3_range *b)
{
  nghttp3_range r = {0, 0};
  uint64_t begin = ((a->begin) > (b->begin) ? (a->begin) : (b->begin));
  uint64_t end = ((a->end) < (b->end) ? (a->end) : (b->end));
  if (begin < end)
  {
    nghttp3_range_init(&r, begin, end);
  }
  return r;
}
uint64_t nghttp3_range_len(const nghttp3_range *r) { return r->end - r->begin; }
int nghttp3_range_eq(const nghttp3_range *a, const nghttp3_range *b)
{
  return a->begin == b->begin && a->end == b->end;
}
void nghttp3_range_cut(nghttp3_range *left, nghttp3_range *right,
                       const nghttp3_range *a, const nghttp3_range *b)
{
  left->begin = a->begin;
  left->end = b->begin;
  right->begin = b->end;
  right->end = a->end;
}
int nghttp3_range_not_after(const nghttp3_range *a, const nghttp3_range *b)
{
  return a->end <= b->end;
}
extern "C"
{
  extern void __assert_fail(const char *__assertion, const char *__file,
                            unsigned int __line, const char *__function) throw() __attribute__((__noreturn__));
  extern void __assert_perror_fail(int __errnum, const char *__file,
                                   unsigned int __line, const char *__function) throw() __attribute__((__noreturn__));
  extern void __assert(const char *__assertion, const char *__file, int __line) throw() __attribute__((__noreturn__));
}
int nghttp3_rcbuf_new(nghttp3_rcbuf **rcbuf_ptr, size_t size,
                      const nghttp3_mem *mem)
{
  uint8_t *p;
  p = nghttp3_mem_malloc(mem, sizeof(nghttp3_rcbuf) + size);
  if (p ==
      __null)
  {
    return NGHTTP3_ERR_NOMEM;
  }
  *rcbuf_ptr = (void *)p;
  (*rcbuf_ptr)->mem_user_data = mem->mem_user_data;
  (*rcbuf_ptr)->free = mem->free;
  (*rcbuf_ptr)->base = p + sizeof(nghttp3_rcbuf);
  (*rcbuf_ptr)->len = size;
  (*rcbuf_ptr)->ref = 1;
  return 0;
}
int nghttp3_rcbuf_new2(nghttp3_rcbuf **rcbuf_ptr, const uint8_t *src,
                       size_t srclen, const nghttp3_mem *mem)
{
  int rv;
  uint8_t *p;
  rv = nghttp3_rcbuf_new(rcbuf_ptr, srclen + 1, mem);
  if (rv != 0)
  {
    return rv;
  }
  (*rcbuf_ptr)->len = srclen;
  p = (*rcbuf_ptr)->base;
  if (srclen)
  {
    p = nghttp3_cpymem(p, src, srclen);
  }
  *p = '\0';
  return 0;
}
void nghttp3_rcbuf_del(nghttp3_rcbuf *rcbuf)
{
  nghttp3_mem_free2(rcbuf->free, rcbuf, rcbuf->mem_user_data);
}
void nghttp3_rcbuf_incref(nghttp3_rcbuf *rcbuf)
{
  if (rcbuf->ref == -1)
  {
    return;
  }
  ++rcbuf->ref;
}
void nghttp3_rcbuf_decref(nghttp3_rcbuf *rcbuf)
{
  if (rcbuf ==
          __null ||
      rcbuf->ref == -1)
  {
    return;
  }

  (static_cast<bool>(
       rcbuf->ref > 0)
       ? void(0)
       : __assert_fail(
             "rcbuf->ref > 0", "all.cpp", 15045, __extension__ __PRETTY_FUNCTION__));
  if (--rcbuf->ref == 0)
  {
    nghttp3_rcbuf_del(rcbuf);
  }
}
nghttp3_vec nghttp3_rcbuf_get_buf(const nghttp3_rcbuf *rcbuf)
{
  nghttp3_vec res = {rcbuf->base, rcbuf->len};
  return res;
}
int nghttp3_rcbuf_is_static(const nghttp3_rcbuf *rcbuf)
{
  return rcbuf->ref == -1;
}
int nghttp3_ringbuf_init(nghttp3_ringbuf *rb, size_t nmemb, size_t size,
                         const nghttp3_mem *mem)
{
  if (nmemb)
  {

    (static_cast<bool>(
         1 == __builtin_popcount((unsigned int)nmemb))
         ? void(0)
         : __assert_fail(
               "1 == __builtin_popcount((unsigned int)nmemb)", "all.cpp", 15082, __extension__ __PRETTY_FUNCTION__));
    rb->buf = nghttp3_mem_malloc(mem, nmemb * size);
    if (rb->buf ==
        __null)
    {
      return NGHTTP3_ERR_NOMEM;
    }
  }
  else
  {
    rb->buf =
        __null;
  }
  rb->mem = mem;
  rb->nmemb = nmemb;
  rb->size = size;
  rb->first = 0;
  rb->len = 0;
  return 0;
}
void nghttp3_ringbuf_free(nghttp3_ringbuf *rb)
{
  if (rb ==
      __null)
  {
    return;
  }
  nghttp3_mem_free(rb->mem, rb->buf);
}
void *nghttp3_ringbuf_push_front(nghttp3_ringbuf *rb)
{
  rb->first = (rb->first - 1) & (rb->nmemb - 1);
  rb->len = ((rb->nmemb) < (rb->len + 1) ? (rb->nmemb) : (rb->len + 1));
  return (void *)&rb->buf[rb->first * rb->size];
}
void *nghttp3_ringbuf_push_back(nghttp3_ringbuf *rb)
{
  size_t offset = (rb->first + rb->len) & (rb->nmemb - 1);
  if (rb->len == rb->nmemb)
  {
    rb->first = (rb->first + 1) & (rb->nmemb - 1);
  }
  else
  {
    ++rb->len;
  }
  return (void *)&rb->buf[offset * rb->size];
}
void nghttp3_ringbuf_pop_front(nghttp3_ringbuf *rb)
{
  rb->first = (rb->first + 1) & (rb->nmemb - 1);
  --rb->len;
}
void nghttp3_ringbuf_pop_back(nghttp3_ringbuf *rb)
{

  (static_cast<bool>(
       rb->len)
       ? void(0)
       : __assert_fail(
             "rb->len", "all.cpp", 15140, __extension__ __PRETTY_FUNCTION__));
  --rb->len;
}
void nghttp3_ringbuf_resize(nghttp3_ringbuf *rb, size_t len)
{

  (static_cast<bool>(
       len <= rb->nmemb)
       ? void(0)
       : __assert_fail(
             "len <= rb->nmemb", "all.cpp", 15146, __extension__ __PRETTY_FUNCTION__));
  rb->len = len;
}
void *nghttp3_ringbuf_get(nghttp3_ringbuf *rb, size_t offset)
{

  (static_cast<bool>(
       offset < rb->len)
       ? void(0)
       : __assert_fail(
             "offset < rb->len", "all.cpp", 15152, __extension__ __PRETTY_FUNCTION__));
  offset = (rb->first + offset) & (rb->nmemb - 1);
  return &rb->buf[offset * rb->size];
}
int nghttp3_ringbuf_full(nghttp3_ringbuf *rb) { return rb->len == rb->nmemb; }
int nghttp3_ringbuf_reserve(nghttp3_ringbuf *rb, size_t nmemb)
{
  uint8_t *buf;
  if (rb->nmemb >= nmemb)
  {
    return 0;
  }

  (static_cast<bool>(
       1 == __builtin_popcount((unsigned int)nmemb))
       ? void(0)
       : __assert_fail(
             "1 == __builtin_popcount((unsigned int)nmemb)", "all.cpp", 15169, __extension__ __PRETTY_FUNCTION__));
  buf = nghttp3_mem_malloc(rb->mem, nmemb * rb->size);
  if (buf ==
      __null)
  {
    return NGHTTP3_ERR_NOMEM;
  }
  if (rb->buf !=
      __null)
  {
    if (rb->first + rb->len <= rb->nmemb)
    {
      memcpy(buf, rb->buf + rb->first * rb->size, rb->len * rb->size);
      rb->first = 0;
    }
    else
    {
      memcpy(buf, rb->buf + rb->first * rb->size,
             (rb->nmemb - rb->first) * rb->size);
      memcpy(buf + (rb->nmemb - rb->first) * rb->size, rb->buf,
             (rb->len - (rb->nmemb - rb->first)) * rb->size);
      rb->first = 0;
    }
    nghttp3_mem_free(rb->mem, rb->buf);
  }
  rb->buf = buf;
  rb->nmemb = nmemb;
  return 0;
}
uint8_t *nghttp3_cpymem(uint8_t *dest, const uint8_t *src, size_t n)
{
  memcpy(dest, src, n);
  return dest + n;
}
static const uint8_t DOWNCASE_TBL[] = {
    0,
    1,
    2,
    3,
    4,
    5,
    6,
    7,
    8,
    9,
    10,
    11,
    12,
    13,
    14,
    15,
    16,
    17,
    18,
    19,
    20,
    21,
    22,
    23,
    24,
    25,
    26,
    27,
    28,
    29,
    30,
    31,
    32,
    33,
    34,
    35,
    36,
    37,
    38,
    39,
    40,
    41,
    42,
    43,
    44,
    45,
    46,
    47,
    48,
    49,
    50,
    51,
    52,
    53,
    54,
    55,
    56,
    57,
    58,
    59,
    60,
    61,
    62,
    63,
    64,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    91,
    92,
    93,
    94,
    95,
    96,
    97,
    98,
    99,
    100,
    101,
    102,
    103,
    104,
    105,
    106,
    107,
    108,
    109,
    110,
    111,
    112,
    113,
    114,
    115,
    116,
    117,
    118,
    119,
    120,
    121,
    122,
    123,
    124,
    125,
    126,
    127,
    128,
    129,
    130,
    131,
    132,
    133,
    134,
    135,
    136,
    137,
    138,
    139,
    140,
    141,
    142,
    143,
    144,
    145,
    146,
    147,
    148,
    149,
    150,
    151,
    152,
    153,
    154,
    155,
    156,
    157,
    158,
    159,
    160,
    161,
    162,
    163,
    164,
    165,
    166,
    167,
    168,
    169,
    170,
    171,
    172,
    173,
    174,
    175,
    176,
    177,
    178,
    179,
    180,
    181,
    182,
    183,
    184,
    185,
    186,
    187,
    188,
    189,
    190,
    191,
    192,
    193,
    194,
    195,
    196,
    197,
    198,
    199,
    200,
    201,
    202,
    203,
    204,
    205,
    206,
    207,
    208,
    209,
    210,
    211,
    212,
    213,
    214,
    215,
    216,
    217,
    218,
    219,
    220,
    221,
    222,
    223,
    224,
    225,
    226,
    227,
    228,
    229,
    230,
    231,
    232,
    233,
    234,
    235,
    236,
    237,
    238,
    239,
    240,
    241,
    242,
    243,
    244,
    245,
    246,
    247,
    248,
    249,
    250,
    251,
    252,
    253,
    254,
    255,
};
void nghttp3_downcase(uint8_t *s, size_t len)
{
  size_t i;
  for (i = 0; i < len; ++i)
  {
    s[i] = DOWNCASE_TBL[s[i]];
  }
}
int nghttp3_stream_new(nghttp3_stream **pstream, int64_t stream_id,
                       uint64_t seq, const nghttp3_stream_callbacks *callbacks,
                       const nghttp3_mem *mem)
{
  int rv;
  nghttp3_stream *stream = nghttp3_mem_calloc(mem, 1, sizeof(nghttp3_stream));
  nghttp3_node_id nid;
  if (stream ==
      __null)
  {
    return NGHTTP3_ERR_NOMEM;
  }
  nghttp3_tnode_init(
      &stream->node,
      nghttp3_node_id_init(&nid, NGHTTP3_NODE_ID_TYPE_STREAM, stream_id), seq,
      1);
  rv = nghttp3_ringbuf_init(&stream->frq, 0, sizeof(nghttp3_frame_entry), mem);
  if (rv != 0)
  {
    goto frq_init_fail;
  }
  rv = nghttp3_ringbuf_init(&stream->chunks, 0, sizeof(nghttp3_buf), mem);
  if (rv != 0)
  {
    goto chunks_init_fail;
  }
  rv = nghttp3_ringbuf_init(&stream->outq, 0, sizeof(nghttp3_typed_buf), mem);
  if (rv != 0)
  {
    goto outq_init_fail;
  }
  rv = nghttp3_ringbuf_init(&stream->inq, 0, sizeof(nghttp3_buf), mem);
  if (rv != 0)
  {
    goto inq_init_fail;
  }
  nghttp3_qpack_stream_context_init(&stream->qpack_sctx, stream_id, mem);
  stream->me.key = (key_type)stream_id;
  stream->qpack_blocked_pe.index =
      (18446744073709551615UL);
  stream->mem = mem;
  stream->rx.http.status_code = -1;
  stream->rx.http.content_length = -1;
  stream->rx.http.pri = 1;
  stream->error_code = 0x0100;
  if (callbacks)
  {
    stream->callbacks = *callbacks;
  }
  *pstream = stream;
  return 0;
inq_init_fail:
  nghttp3_ringbuf_free(&stream->outq);
outq_init_fail:
  nghttp3_ringbuf_free(&stream->chunks);
chunks_init_fail:
  nghttp3_ringbuf_free(&stream->frq);
frq_init_fail:
  nghttp3_mem_free(mem, stream);
  return rv;
}
static void delete_outq(nghttp3_ringbuf *outq, const nghttp3_mem *mem)
{
  nghttp3_typed_buf *tbuf;
  size_t i, len = ((outq)->len);
  for (i = 0; i < len; ++i)
  {
    tbuf = nghttp3_ringbuf_get(outq, i);
    if (tbuf->type == NGHTTP3_BUF_TYPE_PRIVATE)
    {
      nghttp3_buf_free(&tbuf->buf, mem);
    }
  }
  nghttp3_ringbuf_free(outq);
}
static void delete_chunks(nghttp3_ringbuf *chunks, const nghttp3_mem *mem)
{
  nghttp3_buf *buf;
  size_t i, len = ((chunks)->len);
  for (i = 0; i < len; ++i)
  {
    buf = nghttp3_ringbuf_get(chunks, i);
    nghttp3_buf_free(buf, mem);
  }
  nghttp3_ringbuf_free(chunks);
}
static void delete_frq(nghttp3_ringbuf *frq, const nghttp3_mem *mem)
{
  nghttp3_frame_entry *frent;
  size_t i, len = ((frq)->len);
  for (i = 0; i < len; ++i)
  {
    frent = nghttp3_ringbuf_get(frq, i);
    switch (frent->fr.hd.type)
    {
    case NGHTTP3_FRAME_HEADERS:
      nghttp3_frame_headers_free(&frent->fr.headers, mem);
      break;
    case NGHTTP3_FRAME_PUSH_PROMISE:
      nghttp3_frame_push_promise_free(&frent->fr.push_promise, mem);
      break;
    default:
      break;
    }
  }
  nghttp3_ringbuf_free(frq);
}
void nghttp3_stream_del(nghttp3_stream *stream)
{
  if (stream ==
      __null)
  {
    return;
  }
  nghttp3_qpack_stream_context_free(&stream->qpack_sctx);
  delete_chunks(&stream->inq, stream->mem);
  delete_outq(&stream->outq, stream->mem);
  delete_chunks(&stream->chunks, stream->mem);
  delete_frq(&stream->frq, stream->mem);
  nghttp3_tnode_free(&stream->node);
  nghttp3_mem_free(stream->mem, stream);
}
void nghttp3_varint_read_state_reset(nghttp3_varint_read_state *rvint)
{
  memset(rvint, 0, sizeof(*rvint));
}
void nghttp3_stream_read_state_reset(nghttp3_stream_read_state *rstate)
{
  memset(rstate, 0, sizeof(*rstate));
}
nghttp3_ssize nghttp3_read_varint(nghttp3_varint_read_state *rvint,
                                  const uint8_t *src, size_t srclen, int fin)
{
  size_t nread = 0;
  size_t n;
  size_t i;

  (static_cast<bool>(
       srclen > 0)
       ? void(0)
       : __assert_fail(
             "srclen > 0", "all.cpp", 15615, __extension__ __PRETTY_FUNCTION__));
  if (rvint->left == 0)
  {

    (static_cast<bool>(
         rvint->acc == 0)
         ? void(0)
         : __assert_fail(
               "rvint->acc == 0", "all.cpp", 15618, __extension__ __PRETTY_FUNCTION__));
    rvint->left = nghttp3_get_varint_len(src);
    if (rvint->left <= srclen)
    {
      rvint->acc = nghttp3_get_varint(&nread, src);
      rvint->left = 0;
      return (nghttp3_ssize)nread;
    }
    if (fin)
    {
      return NGHTTP3_ERR_INVALID_ARGUMENT;
    }
    rvint->acc = nghttp3_get_varint_fb(src);
    nread = 1;
    ++src;
    --srclen;
    --rvint->left;
  }
  n = ((rvint->left) < (srclen) ? (rvint->left) : (srclen));
  for (i = 0; i < n; ++i)
  {
    rvint->acc = (rvint->acc << 8) + src[i];
  }
  rvint->left -= n;
  nread += n;
  if (fin && rvint->left)
  {
    return NGHTTP3_ERR_INVALID_ARGUMENT;
  }
  return (nghttp3_ssize)nread;
}
int nghttp3_stream_frq_add(nghttp3_stream *stream,
                           const nghttp3_frame_entry *frent)
{
  nghttp3_ringbuf *frq = &stream->frq;
  nghttp3_frame_entry *dest;
  int rv;
  if (nghttp3_ringbuf_full(frq))
  {
    size_t nlen = ((4) > (((frq)->len) * 2) ? (4) : (((frq)->len) * 2));
    rv = nghttp3_ringbuf_reserve(frq, nlen);
    if (rv != 0)
    {
      return rv;
    }
  }
  dest = nghttp3_ringbuf_push_back(frq);
  *dest = *frent;
  return 0;
}
int nghttp3_stream_fill_outq(nghttp3_stream *stream)
{
  nghttp3_ringbuf *frq = &stream->frq;
  nghttp3_frame_entry *frent;
  int data_eof;
  int rv;
  for (; ((frq)->len) && !nghttp3_stream_outq_is_full(stream) &&
         stream->unsent_bytes < 4096;)
  {
    frent = nghttp3_ringbuf_get(frq, 0);
    switch (frent->fr.hd.type)
    {
    case NGHTTP3_FRAME_SETTINGS:
      rv = nghttp3_stream_write_settings(stream, frent);
      if (rv != 0)
      {
        return rv;
      }
      break;
    case NGHTTP3_FRAME_HEADERS:
      rv = nghttp3_stream_write_headers(stream, frent);
      if (rv != 0)
      {
        return rv;
      }
      nghttp3_frame_headers_free(&frent->fr.headers, stream->mem);
      break;
    case NGHTTP3_FRAME_PUSH_PROMISE:
      rv = nghttp3_stream_write_push_promise(stream, frent);
      if (rv != 0)
      {
        return rv;
      }
      nghttp3_frame_push_promise_free(&frent->fr.push_promise, stream->mem);
      break;
    case NGHTTP3_FRAME_CANCEL_PUSH:
      rv = nghttp3_stream_write_cancel_push(stream, frent);
      if (rv != 0)
      {
        return rv;
      }
      break;
    case NGHTTP3_FRAME_DATA:
      rv = nghttp3_stream_write_data(stream, &data_eof, frent);
      if (rv != 0)
      {
        return rv;
      }
      if (stream->flags & NGHTTP3_STREAM_FLAG_READ_DATA_BLOCKED)
      {
        return 0;
      }
      if (!data_eof)
      {
        return 0;
      }
      break;
    case NGHTTP3_FRAME_MAX_PUSH_ID:
      if (stream->conn->flags & NGHTTP3_CONN_FLAG_GOAWAY_QUEUED)
      {
        break;
      }
      rv = nghttp3_stream_write_max_push_id(stream, frent);
      if (rv != 0)
      {
        return rv;
      }
      break;
    default:
      break;
    }
    nghttp3_ringbuf_pop_front(frq);
  }
  return 0;
}
static void typed_buf_shared_init(nghttp3_typed_buf *tbuf,
                                  const nghttp3_buf *chunk)
{
  nghttp3_typed_buf_init(tbuf, chunk, NGHTTP3_BUF_TYPE_SHARED);
  tbuf->buf.pos = tbuf->buf.last;
}
int nghttp3_stream_write_stream_type(nghttp3_stream *stream)
{
  size_t len = nghttp3_put_varint_len((int64_t)stream->type);
  nghttp3_buf *chunk;
  nghttp3_typed_buf tbuf;
  int rv;
  rv = nghttp3_stream_ensure_chunk(stream, len);
  if (rv != 0)
  {
    return rv;
  }
  chunk = nghttp3_stream_get_chunk(stream);
  typed_buf_shared_init(&tbuf, chunk);
  chunk->last = nghttp3_put_varint(chunk->last, (int64_t)stream->type);
  tbuf.buf.last = chunk->last;
  return nghttp3_stream_outq_add(stream, &tbuf);
}
int nghttp3_stream_write_stream_type_push_id(nghttp3_stream *stream)
{
  size_t len;
  nghttp3_buf *chunk;
  nghttp3_typed_buf tbuf;
  int rv;
  nghttp3_push_promise *pp = stream->pp;

  (static_cast<bool>(
       stream->type == NGHTTP3_STREAM_TYPE_PUSH)
       ? void(0)
       : __assert_fail(
             "stream->type == NGHTTP3_STREAM_TYPE_PUSH", "all.cpp", 15778, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       pp)
       ? void(0)
       : __assert_fail(
             "pp", "all.cpp", 15779, __extension__ __PRETTY_FUNCTION__));
  len = nghttp3_put_varint_len((int64_t)stream->type) +
        nghttp3_put_varint_len(pp->node.nid.id);
  rv = nghttp3_stream_ensure_chunk(stream, len);
  if (rv != 0)
  {
    return rv;
  }
  chunk = nghttp3_stream_get_chunk(stream);
  typed_buf_shared_init(&tbuf, chunk);
  chunk->last = nghttp3_put_varint(chunk->last, (int64_t)stream->type);
  chunk->last = nghttp3_put_varint(chunk->last, pp->node.nid.id);
  tbuf.buf.last = chunk->last;
  return nghttp3_stream_outq_add(stream, &tbuf);
}
int nghttp3_stream_write_settings(nghttp3_stream *stream,
                                  nghttp3_frame_entry *frent)
{
  size_t len;
  int rv;
  nghttp3_buf *chunk;
  nghttp3_typed_buf tbuf;
  struct
  {
    nghttp3_frame_settings settings;
    nghttp3_settings_entry iv[15];
  } fr;
  nghttp3_settings_entry *iv;
  nghttp3_conn_settings *local_settings = frent->aux.settings.local_settings;
  fr.settings.hd.type = NGHTTP3_FRAME_SETTINGS;
  fr.settings.niv = 3;
  iv = &fr.settings.iv[0];
  iv[0].id = 0x06;
  iv[0].value = local_settings->max_field_section_size;
  iv[1].id = 0x01;
  iv[1].value = local_settings->qpack_max_table_capacity;
  iv[2].id = 0x07;
  iv[2].value = local_settings->qpack_blocked_streams;
  len = nghttp3_frame_write_settings_len(&fr.settings.hd.length, &fr.settings);
  rv = nghttp3_stream_ensure_chunk(stream, len);
  if (rv != 0)
  {
    return rv;
  }
  chunk = nghttp3_stream_get_chunk(stream);
  typed_buf_shared_init(&tbuf, chunk);
  chunk->last = nghttp3_frame_write_settings(chunk->last, &fr.settings);
  tbuf.buf.last = chunk->last;
  return nghttp3_stream_outq_add(stream, &tbuf);
}
int nghttp3_stream_write_cancel_push(nghttp3_stream *stream,
                                     nghttp3_frame_entry *frent)
{
  nghttp3_frame_cancel_push *fr = &frent->fr.cancel_push;
  size_t len;
  int rv;
  nghttp3_buf *chunk;
  nghttp3_typed_buf tbuf;
  len = nghttp3_frame_write_cancel_push_len(&fr->hd.length, fr);
  rv = nghttp3_stream_ensure_chunk(stream, len);
  if (rv != 0)
  {
    return rv;
  }
  chunk = nghttp3_stream_get_chunk(stream);
  typed_buf_shared_init(&tbuf, chunk);
  chunk->last = nghttp3_frame_write_cancel_push(chunk->last, fr);
  tbuf.buf.last = chunk->last;
  return nghttp3_stream_outq_add(stream, &tbuf);
}
int nghttp3_stream_write_max_push_id(nghttp3_stream *stream,
                                     nghttp3_frame_entry *frent)
{
  nghttp3_frame_max_push_id *fr = &frent->fr.max_push_id;
  nghttp3_conn *conn = stream->conn;
  size_t len;
  int rv;
  nghttp3_buf *chunk;
  nghttp3_typed_buf tbuf;

  (static_cast<bool>(
       conn)
       ? void(0)
       : __assert_fail(
             "conn", "all.cpp", 15861, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       conn->flags & NGHTTP3_CONN_FLAG_MAX_PUSH_ID_QUEUED)
       ? void(0)
       : __assert_fail(
             "conn->flags & NGHTTP3_CONN_FLAG_MAX_PUSH_ID_QUEUED", "all.cpp", 15862, __extension__ __PRETTY_FUNCTION__));
  fr->push_id = (int64_t)conn->remote.uni.unsent_max_pushes - 1;
  conn->remote.uni.max_pushes = conn->remote.uni.unsent_max_pushes;
  conn->flags &= (uint16_t)~NGHTTP3_CONN_FLAG_MAX_PUSH_ID_QUEUED;
  len = nghttp3_frame_write_max_push_id_len(&fr->hd.length, fr);
  rv = nghttp3_stream_ensure_chunk(stream, len);
  if (rv != 0)
  {
    return rv;
  }
  chunk = nghttp3_stream_get_chunk(stream);
  typed_buf_shared_init(&tbuf, chunk);
  chunk->last = nghttp3_frame_write_max_push_id(chunk->last, fr);
  tbuf.buf.last = chunk->last;
  return nghttp3_stream_outq_add(stream, &tbuf);
}
int nghttp3_stream_write_headers(nghttp3_stream *stream,
                                 nghttp3_frame_entry *frent)
{
  nghttp3_frame_headers *fr = &frent->fr.headers;
  nghttp3_conn *conn = stream->conn;

  (static_cast<bool>(
       conn)
       ? void(0)
       : __assert_fail(
             "conn", "all.cpp", 15884, __extension__ __PRETTY_FUNCTION__));
  return nghttp3_stream_write_header_block(
      stream, &conn->qenc, conn->tx.qenc, &conn->tx.qpack.rbuf,
      &conn->tx.qpack.ebuf, NGHTTP3_FRAME_HEADERS, 0, fr->nva, fr->nvlen);
}
int nghttp3_stream_write_push_promise(nghttp3_stream *stream,
                                      nghttp3_frame_entry *frent)
{
  nghttp3_frame_push_promise *fr = &frent->fr.push_promise;
  nghttp3_conn *conn = stream->conn;

  (static_cast<bool>(
       conn)
       ? void(0)
       : __assert_fail(
             "conn", "all.cpp", 15895, __extension__ __PRETTY_FUNCTION__));
  return nghttp3_stream_write_header_block(
      stream, &conn->qenc, conn->tx.qenc, &conn->tx.qpack.rbuf,
      &conn->tx.qpack.ebuf, NGHTTP3_FRAME_PUSH_PROMISE, fr->push_id, fr->nva,
      fr->nvlen);
}
int nghttp3_stream_write_header_block(nghttp3_stream *stream,
                                      nghttp3_qpack_encoder *qenc,
                                      nghttp3_stream *qenc_stream,
                                      nghttp3_buf *rbuf, nghttp3_buf *ebuf,
                                      int64_t frame_type, int64_t push_id,
                                      const nghttp3_nv *nva, size_t nvlen)
{
  nghttp3_buf pbuf;
  int rv;
  size_t len;
  nghttp3_buf *chunk;
  nghttp3_typed_buf tbuf;
  nghttp3_frame_hd hd;
  size_t push_idlen = 0;
  uint8_t raw_pbuf[16];
  size_t pbuflen, rbuflen, ebuflen;
  nghttp3_buf_wrap_init(&pbuf, raw_pbuf, sizeof(raw_pbuf));
  rv = nghttp3_qpack_encoder_encode(qenc, &pbuf, rbuf, ebuf,
                                    stream->node.nid.id, nva, nvlen);
  if (rv != 0)
  {
    goto fail;
  }
  pbuflen = nghttp3_buf_len(&pbuf);
  rbuflen = nghttp3_buf_len(rbuf);
  ebuflen = nghttp3_buf_len(ebuf);
  if (frame_type == NGHTTP3_FRAME_PUSH_PROMISE)
  {
    push_idlen = nghttp3_put_varint_len(push_id);
  }
  hd.type = frame_type;
  hd.length = (int64_t)(pbuflen + rbuflen + push_idlen);
  len = nghttp3_frame_write_hd_len(&hd) + push_idlen + pbuflen;
  if (rbuflen <= 128)
  {
    len += rbuflen;
  }
  rv = nghttp3_stream_ensure_chunk(stream, len);
  if (rv != 0)
  {
    goto fail;
  }
  chunk = nghttp3_stream_get_chunk(stream);
  typed_buf_shared_init(&tbuf, chunk);
  chunk->last = nghttp3_frame_write_hd(chunk->last, &hd);
  if (push_idlen)
  {
    chunk->last = nghttp3_put_varint(chunk->last, push_id);
  }
  chunk->last = nghttp3_cpymem(chunk->last, pbuf.pos, pbuflen);
  nghttp3_buf_init(&pbuf);
  if (rbuflen > 128)
  {
    tbuf.buf.last = chunk->last;
    rv = nghttp3_stream_outq_add(stream, &tbuf);
    if (rv != 0)
    {
      goto fail;
    }
    nghttp3_typed_buf_init(&tbuf, rbuf, NGHTTP3_BUF_TYPE_PRIVATE);
    rv = nghttp3_stream_outq_add(stream, &tbuf);
    if (rv != 0)
    {
      goto fail;
    }
    nghttp3_buf_init(rbuf);
  }
  else if (rbuflen)
  {
    chunk->last = nghttp3_cpymem(chunk->last, rbuf->pos, rbuflen);
    tbuf.buf.last = chunk->last;
    rv = nghttp3_stream_outq_add(stream, &tbuf);
    if (rv != 0)
    {
      goto fail;
    }
    nghttp3_buf_reset(rbuf);
  }
  if (ebuflen > 128)
  {

    (static_cast<bool>(
         qenc_stream)
         ? void(0)
         : __assert_fail(
               "qenc_stream", "all.cpp", 15982, __extension__ __PRETTY_FUNCTION__));
    nghttp3_typed_buf_init(&tbuf, ebuf, NGHTTP3_BUF_TYPE_PRIVATE);
    rv = nghttp3_stream_outq_add(qenc_stream, &tbuf);
    if (rv != 0)
    {
      return rv;
    }
    nghttp3_buf_init(ebuf);
  }
  else if (ebuflen)
  {

    (static_cast<bool>(
         qenc_stream)
         ? void(0)
         : __assert_fail(
               "qenc_stream", "all.cpp", 15993, __extension__ __PRETTY_FUNCTION__));
    rv = nghttp3_stream_ensure_chunk(qenc_stream, ebuflen);
    if (rv != 0)
    {
      goto fail;
    }
    chunk = nghttp3_stream_get_chunk(qenc_stream);
    typed_buf_shared_init(&tbuf, chunk);
    chunk->last = nghttp3_cpymem(chunk->last, ebuf->pos, ebuflen);
    tbuf.buf.last = chunk->last;
    rv = nghttp3_stream_outq_add(qenc_stream, &tbuf);
    if (rv != 0)
    {
      goto fail;
    }
    nghttp3_buf_reset(ebuf);
  }

  (static_cast<bool>(
       0 == nghttp3_buf_len(&pbuf))
       ? void(0)
       : __assert_fail(
             "0 == nghttp3_buf_len(&pbuf)", "all.cpp", 16010, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       0 == nghttp3_buf_len(rbuf))
       ? void(0)
       : __assert_fail(
             "0 == nghttp3_buf_len(rbuf)", "all.cpp", 16011, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       0 == nghttp3_buf_len(ebuf))
       ? void(0)
       : __assert_fail(
             "0 == nghttp3_buf_len(ebuf)", "all.cpp", 16012, __extension__ __PRETTY_FUNCTION__));
  return 0;
fail:
  return rv;
}
int nghttp3_stream_write_data(nghttp3_stream *stream, int *peof,
                              nghttp3_frame_entry *frent)
{
  int rv;
  size_t len;
  nghttp3_typed_buf tbuf;
  nghttp3_buf buf;
  nghttp3_buf *chunk;
  nghttp3_read_data_callback read_data = frent->aux.data.dr.read_data;
  nghttp3_conn *conn = stream->conn;
  size_t datalen;
  uint32_t flags = 0;
  nghttp3_frame_hd hd;
  nghttp3_vec vec[8];
  nghttp3_vec *v;
  nghttp3_ssize sveccnt;
  size_t i;

  (static_cast<bool>(
       !(stream->flags & NGHTTP3_STREAM_FLAG_READ_DATA_BLOCKED))
       ? void(0)
       : __assert_fail(
             "!(stream->flags & NGHTTP3_STREAM_FLAG_READ_DATA_BLOCKED)", "all.cpp", 16036, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       read_data)
       ? void(0)
       : __assert_fail(
             "read_data", "all.cpp", 16037, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       conn)
       ? void(0)
       : __assert_fail(
             "conn", "all.cpp", 16038, __extension__ __PRETTY_FUNCTION__));
  *peof = 0;
  sveccnt = read_data(conn, stream->node.nid.id, vec, (sizeof(vec) / sizeof(*(vec))),
                      &flags, conn->user_data, stream->user_data);
  if (sveccnt < 0)
  {
    if (sveccnt == NGHTTP3_ERR_WOULDBLOCK)
    {
      stream->flags |= NGHTTP3_STREAM_FLAG_READ_DATA_BLOCKED;
      return 0;
    }
    return NGHTTP3_ERR_CALLBACK_FAILURE;
  }
  datalen = nghttp3_vec_len(vec, (size_t)sveccnt);

  (static_cast<bool>(
       datalen || flags & NGHTTP3_DATA_FLAG_EOF)
       ? void(0)
       : __assert_fail(
             "datalen || flags & NGHTTP3_DATA_FLAG_EOF", "all.cpp", 16052, __extension__ __PRETTY_FUNCTION__));
  if (flags & NGHTTP3_DATA_FLAG_EOF)
  {
    *peof = 1;
    if (!(flags & NGHTTP3_DATA_FLAG_NO_END_STREAM))
    {
      stream->flags |= NGHTTP3_STREAM_FLAG_WRITE_END_STREAM;
      if (datalen == 0)
      {
        if (nghttp3_stream_outq_write_done(stream))
        {
          nghttp3_buf_init(&buf);
          nghttp3_typed_buf_init(&tbuf, &buf, NGHTTP3_BUF_TYPE_PRIVATE);
          return nghttp3_stream_outq_add(stream, &tbuf);
        }
        return 0;
      }
    }
    if (datalen == 0)
    {
      return 0;
    }
  }
  hd.type = NGHTTP3_FRAME_DATA;
  hd.length = (int64_t)datalen;
  len = nghttp3_frame_write_hd_len(&hd);
  rv = nghttp3_stream_ensure_chunk(stream, len);
  if (rv != 0)
  {
    return rv;
  }
  chunk = nghttp3_stream_get_chunk(stream);
  typed_buf_shared_init(&tbuf, chunk);
  chunk->last = nghttp3_frame_write_hd(chunk->last, &hd);
  tbuf.buf.last = chunk->last;
  rv = nghttp3_stream_outq_add(stream, &tbuf);
  if (rv != 0)
  {
    return rv;
  }
  if (datalen)
  {
    for (i = 0; i < (size_t)sveccnt; ++i)
    {
      v = &vec[i];
      if (v->len == 0)
      {
        continue;
      }
      nghttp3_buf_wrap_init(&buf, v->base, v->len);
      buf.last = buf.end;
      nghttp3_typed_buf_init(&tbuf, &buf, NGHTTP3_BUF_TYPE_ALIEN);
      rv = nghttp3_stream_outq_add(stream, &tbuf);
      if (rv != 0)
      {
        return rv;
      }
    }
  }
  return 0;
}
int nghttp3_stream_write_qpack_decoder_stream(nghttp3_stream *stream)
{
  nghttp3_qpack_decoder *qdec;
  nghttp3_buf *chunk;
  int rv;
  nghttp3_typed_buf tbuf;
  size_t len;

  (static_cast<bool>(
       stream->conn)
       ? void(0)
       : __assert_fail(
             "stream->conn", "all.cpp", 16121, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       stream->conn->tx.qdec == stream)
       ? void(0)
       : __assert_fail(
             "stream->conn->tx.qdec == stream", "all.cpp", 16122, __extension__ __PRETTY_FUNCTION__));
  qdec = &stream->conn->qdec;

  (static_cast<bool>(
       qdec)
       ? void(0)
       : __assert_fail(
             "qdec", "all.cpp", 16124, __extension__ __PRETTY_FUNCTION__));
  len = nghttp3_qpack_decoder_get_decoder_streamlen(qdec);
  if (len == 0)
  {
    return 0;
  }
  rv = nghttp3_stream_ensure_chunk(stream, len);
  if (rv != 0)
  {
    return rv;
  }
  chunk = nghttp3_stream_get_chunk(stream);
  typed_buf_shared_init(&tbuf, chunk);
  nghttp3_qpack_decoder_write_decoder(qdec, chunk);
  tbuf.buf.last = chunk->last;
  return nghttp3_stream_outq_add(stream, &tbuf);
}
int nghttp3_stream_outq_is_full(nghttp3_stream *stream)
{
  return ((&stream->outq)->len) >= 1024;
}
int nghttp3_stream_outq_add(nghttp3_stream *stream,
                            const nghttp3_typed_buf *tbuf)
{
  nghttp3_ringbuf *outq = &stream->outq;
  int rv;
  nghttp3_typed_buf *dest;
  size_t len = ((outq)->len);
  stream->unsent_bytes += nghttp3_buf_len(&tbuf->buf);
  if (len)
  {
    dest = nghttp3_ringbuf_get(outq, len - 1);
    if (dest->type == tbuf->type && dest->type == NGHTTP3_BUF_TYPE_SHARED &&
        dest->buf.begin == tbuf->buf.begin && dest->buf.last == tbuf->buf.pos)
    {
      if (len == stream->outq_idx)
      {
        --stream->outq_idx;
        stream->outq_offset = nghttp3_buf_len(&dest->buf);
      }
      dest->buf.last = tbuf->buf.last;
      dest->buf.end = tbuf->buf.end;
      return 0;
    }
  }
  if (nghttp3_ringbuf_full(outq))
  {
    size_t nlen = ((4) > (len * 2) ? (4) : (len * 2));
    rv = nghttp3_ringbuf_reserve(outq, nlen);
    if (rv != 0)
    {
      return rv;
    }
  }
  dest = nghttp3_ringbuf_push_back(outq);
  *dest = *tbuf;
  return 0;
}
int nghttp3_stream_ensure_chunk(nghttp3_stream *stream, size_t need)
{
  nghttp3_ringbuf *chunks = &stream->chunks;
  nghttp3_buf *chunk;
  size_t len = ((chunks)->len);
  uint8_t *p;
  int rv;
  size_t n = 256;
  if (len)
  {
    chunk = nghttp3_ringbuf_get(chunks, len - 1);
    if (nghttp3_buf_left(chunk) >= need)
    {
      return 0;
    }
  }
  for (; n < need; n *= 2)
    ;
  p = nghttp3_mem_malloc(stream->mem, n);
  if (p ==
      __null)
  {
    return NGHTTP3_ERR_NOMEM;
  }
  if (nghttp3_ringbuf_full(chunks))
  {
    size_t nlen = ((4) > (len * 2) ? (4) : (len * 2));
    rv = nghttp3_ringbuf_reserve(chunks, nlen);
    if (rv != 0)
    {
      return rv;
    }
  }
  chunk = nghttp3_ringbuf_push_back(chunks);
  nghttp3_buf_wrap_init(chunk, p, n);
  return 0;
}
nghttp3_buf *nghttp3_stream_get_chunk(nghttp3_stream *stream)
{
  nghttp3_ringbuf *chunks = &stream->chunks;
  size_t len = ((chunks)->len);

  (static_cast<bool>(
       len)
       ? void(0)
       : __assert_fail(
             "len", "all.cpp", 16226, __extension__ __PRETTY_FUNCTION__));
  return nghttp3_ringbuf_get(chunks, len - 1);
}
int nghttp3_stream_is_blocked(nghttp3_stream *stream)
{
  return (stream->flags & NGHTTP3_STREAM_FLAG_FC_BLOCKED) ||
         (stream->flags & NGHTTP3_STREAM_FLAG_READ_DATA_BLOCKED);
}
int nghttp3_stream_require_schedule(nghttp3_stream *stream)
{
  return (!nghttp3_stream_outq_write_done(stream) &&
          !(stream->flags & NGHTTP3_STREAM_FLAG_FC_BLOCKED)) ||
         (((&stream->frq)->len) &&
          !(stream->flags & NGHTTP3_STREAM_FLAG_READ_DATA_BLOCKED));
}
nghttp3_ssize nghttp3_stream_writev(nghttp3_stream *stream, int *pfin,
                                    nghttp3_vec *vec, size_t veccnt)
{
  nghttp3_ringbuf *outq = &stream->outq;
  size_t len = ((outq)->len);
  size_t i;
  size_t offset = stream->outq_offset;
  size_t buflen;
  nghttp3_vec *vbegin = vec, *vend = vec + veccnt;
  nghttp3_typed_buf *tbuf;

  (static_cast<bool>(
       veccnt > 0)
       ? void(0)
       : __assert_fail(
             "veccnt > 0", "all.cpp", 16254, __extension__ __PRETTY_FUNCTION__));
  for (i = stream->outq_idx; i < len; ++i)
  {
    tbuf = nghttp3_ringbuf_get(outq, i);
    buflen = nghttp3_buf_len(&tbuf->buf);
    if (offset >= buflen)
    {
      offset -= buflen;
      continue;
    }
    vec->base = tbuf->buf.pos + offset;
    vec->len = buflen - offset;
    ++vec;
    ++i;
    break;
  }
  for (; i < len && vec != vend; ++i, ++vec)
  {
    tbuf = nghttp3_ringbuf_get(outq, i);
    vec->base = tbuf->buf.pos;
    vec->len = nghttp3_buf_len(&tbuf->buf);
  }
  *pfin = ((&stream->frq)->len) == 0 && i == len &&
          (stream->flags & NGHTTP3_STREAM_FLAG_WRITE_END_STREAM);
  return vec - vbegin;
}
int nghttp3_stream_add_outq_offset(nghttp3_stream *stream, size_t n)
{
  nghttp3_ringbuf *outq = &stream->outq;
  size_t i;
  size_t len = ((outq)->len);
  size_t offset = stream->outq_offset + n;
  size_t buflen;
  nghttp3_typed_buf *tbuf;
  for (i = stream->outq_idx; i < len; ++i)
  {
    tbuf = nghttp3_ringbuf_get(outq, i);
    buflen = nghttp3_buf_len(&tbuf->buf);
    if (offset >= buflen)
    {
      offset -= buflen;
      continue;
    }
    break;
  }

  (static_cast<bool>(
       i < len || offset == 0)
       ? void(0)
       : __assert_fail(
             "i < len || offset == 0", "all.cpp", 16300, __extension__ __PRETTY_FUNCTION__));
  stream->unsent_bytes -= n;
  stream->outq_idx = i;
  stream->outq_offset = offset;
  return 0;
}
int nghttp3_stream_outq_write_done(nghttp3_stream *stream)
{
  nghttp3_ringbuf *outq = &stream->outq;
  size_t len = ((outq)->len);
  return len == 0 || stream->outq_idx >= len;
}
static int stream_pop_outq_entry(nghttp3_stream *stream,
                                 nghttp3_typed_buf *tbuf)
{
  nghttp3_ringbuf *chunks = &stream->chunks;
  nghttp3_buf *chunk;
  switch (tbuf->type)
  {
  case NGHTTP3_BUF_TYPE_PRIVATE:
    nghttp3_buf_free(&tbuf->buf, stream->mem);
    break;
  case NGHTTP3_BUF_TYPE_ALIEN:
    break;
  default:

    (static_cast<bool>(
         ((chunks)->len))
         ? void(0)
         : __assert_fail(
               "nghttp3_ringbuf_len(chunks)", "all.cpp", 16327, __extension__ __PRETTY_FUNCTION__));
    chunk = nghttp3_ringbuf_get(chunks, 0);

    (static_cast<bool>(
         chunk->begin == tbuf->buf.begin)
         ? void(0)
         : __assert_fail(
               "chunk->begin == tbuf->buf.begin", "all.cpp", 16329, __extension__ __PRETTY_FUNCTION__));

    (static_cast<bool>(
         chunk->end == tbuf->buf.end)
         ? void(0)
         : __assert_fail(
               "chunk->end == tbuf->buf.end", "all.cpp", 16330, __extension__ __PRETTY_FUNCTION__));
    if (chunk->last == tbuf->buf.last)
    {
      nghttp3_buf_free(chunk, stream->mem);
      nghttp3_ringbuf_pop_front(chunks);
    }
  };
  nghttp3_ringbuf_pop_front(&stream->outq);
  return 0;
}
int nghttp3_stream_add_ack_offset(nghttp3_stream *stream, uint64_t n)
{
  nghttp3_ringbuf *outq = &stream->outq;
  uint64_t offset = stream->ack_offset + n;
  size_t buflen;
  size_t npopped = 0;
  size_t nack;
  nghttp3_typed_buf *tbuf;
  int rv;
  for (; ((outq)->len);)
  {
    tbuf = nghttp3_ringbuf_get(outq, 0);
    buflen = nghttp3_buf_len(&tbuf->buf);
    if (tbuf->type == NGHTTP3_BUF_TYPE_ALIEN)
    {
      nack = (size_t)((offset) < ((uint64_t)buflen) ? (offset) : ((uint64_t)buflen)) - stream->ack_done;
      if (stream->callbacks.acked_data)
      {
        rv = stream->callbacks.acked_data(stream, stream->node.nid.id, nack,
                                          stream->user_data);
        if (rv != 0)
        {
          return NGHTTP3_ERR_CALLBACK_FAILURE;
        }
      }
      stream->ack_done += nack;
    }
    if (offset >= buflen)
    {
      rv = stream_pop_outq_entry(stream, tbuf);
      if (rv != 0)
      {
        return rv;
      }
      offset -= buflen;
      ++npopped;
      stream->ack_done = 0;
      if (stream->outq_idx + 1 == npopped)
      {
        stream->outq_offset = 0;
        break;
      }
      continue;
    }
    break;
  }

  (static_cast<bool>(
       stream->outq_idx + 1 >= npopped)
       ? void(0)
       : __assert_fail(
             "stream->outq_idx + 1 >= npopped", "all.cpp", 16387, __extension__ __PRETTY_FUNCTION__));
  if (stream->outq_idx >= npopped)
  {
    stream->outq_idx -= npopped;
  }
  else
  {
    stream->outq_idx = 0;
  }
  stream->ack_offset = offset;
  return 0;
}
int nghttp3_stream_buffer_data(nghttp3_stream *stream, const uint8_t *data,
                               size_t datalen)
{
  nghttp3_ringbuf *inq = &stream->inq;
  size_t len = ((inq)->len);
  nghttp3_buf *buf;
  size_t nwrite;
  uint8_t *rawbuf;
  size_t bufleft;
  int rv;
  if (len)
  {
    buf = nghttp3_ringbuf_get(inq, len - 1);
    bufleft = nghttp3_buf_left(buf);
    nwrite = ((datalen) < (bufleft) ? (datalen) : (bufleft));
    buf->last = nghttp3_cpymem(buf->last, data, nwrite);
    data += nwrite;
    datalen -= nwrite;
  }
  for (; datalen;)
  {
    if (nghttp3_ringbuf_full(inq))
    {
      size_t nlen =
          ((4) > (((inq)->len) * 2) ? (4) : (((inq)->len) * 2));
      rv = nghttp3_ringbuf_reserve(inq, nlen);
      if (rv != 0)
      {
        return rv;
      }
    }
    rawbuf = nghttp3_mem_malloc(stream->mem, 16384);
    if (rawbuf ==
        __null)
    {
      return NGHTTP3_ERR_NOMEM;
    }
    buf = nghttp3_ringbuf_push_back(inq);
    nghttp3_buf_wrap_init(buf, rawbuf, 16384);
    bufleft = nghttp3_buf_left(buf);
    nwrite = ((datalen) < (bufleft) ? (datalen) : (bufleft));
    buf->last = nghttp3_cpymem(buf->last, data, nwrite);
    data += nwrite;
    datalen -= nwrite;
  }
  return 0;
}
size_t nghttp3_stream_get_buffered_datalen(nghttp3_stream *stream)
{
  nghttp3_ringbuf *inq = &stream->inq;
  size_t len = ((inq)->len);
  size_t i, n = 0;
  nghttp3_buf *buf;
  for (i = 0; i < len; ++i)
  {
    buf = nghttp3_ringbuf_get(inq, i);
    n += nghttp3_buf_len(buf);
  }
  return n;
}
int nghttp3_stream_transit_rx_http_state(nghttp3_stream *stream,
                                         nghttp3_stream_http_event event)
{
  int rv;
  switch (stream->rx.hstate)
  {
  case NGHTTP3_HTTP_STATE_NONE:
    return NGHTTP3_ERR_H3_INTERNAL_ERROR;
  case NGHTTP3_HTTP_STATE_REQ_INITIAL:
    switch (event)
    {
    case NGHTTP3_HTTP_EVENT_HEADERS_BEGIN:
      stream->rx.hstate = NGHTTP3_HTTP_STATE_REQ_HEADERS_BEGIN;
      return 0;
    default:
      return NGHTTP3_ERR_H3_FRAME_UNEXPECTED;
    }
  case NGHTTP3_HTTP_STATE_REQ_HEADERS_BEGIN:
    if (event != NGHTTP3_HTTP_EVENT_HEADERS_END)
    {
      return NGHTTP3_ERR_H3_GENERAL_PROTOCOL_ERROR;
    }
    stream->rx.hstate = NGHTTP3_HTTP_STATE_REQ_HEADERS_END;
    return 0;
  case NGHTTP3_HTTP_STATE_REQ_HEADERS_END:
    switch (event)
    {
    case NGHTTP3_HTTP_EVENT_HEADERS_BEGIN:
      if (stream->rx.http.flags & NGHTTP3_HTTP_FLAG_METH_CONNECT)
      {
        return NGHTTP3_ERR_H3_FRAME_UNEXPECTED;
      }
      rv = nghttp3_http_on_remote_end_stream(stream);
      if (rv != 0)
      {
        return rv;
      }
      stream->rx.hstate = NGHTTP3_HTTP_STATE_REQ_TRAILERS_BEGIN;
      return 0;
    case NGHTTP3_HTTP_EVENT_DATA_BEGIN:
      stream->rx.hstate = NGHTTP3_HTTP_STATE_REQ_DATA_BEGIN;
      return 0;
    case NGHTTP3_HTTP_EVENT_MSG_END:
      stream->rx.hstate = NGHTTP3_HTTP_STATE_REQ_END;
      return 0;
    default:
      return NGHTTP3_ERR_H3_FRAME_UNEXPECTED;
    }
  case NGHTTP3_HTTP_STATE_REQ_DATA_BEGIN:
    if (event != NGHTTP3_HTTP_EVENT_DATA_END)
    {
      return NGHTTP3_ERR_H3_GENERAL_PROTOCOL_ERROR;
    }
    stream->rx.hstate = NGHTTP3_HTTP_STATE_REQ_DATA_END;
    return 0;
  case NGHTTP3_HTTP_STATE_REQ_DATA_END:
    switch (event)
    {
    case NGHTTP3_HTTP_EVENT_DATA_BEGIN:
      stream->rx.hstate = NGHTTP3_HTTP_STATE_REQ_DATA_BEGIN;
      return 0;
    case NGHTTP3_HTTP_EVENT_HEADERS_BEGIN:
      if (stream->rx.http.flags & NGHTTP3_HTTP_FLAG_METH_CONNECT)
      {
        return NGHTTP3_ERR_H3_FRAME_UNEXPECTED;
      }
      rv = nghttp3_http_on_remote_end_stream(stream);
      if (rv != 0)
      {
        return rv;
      }
      stream->rx.hstate = NGHTTP3_HTTP_STATE_REQ_TRAILERS_BEGIN;
      return 0;
    case NGHTTP3_HTTP_EVENT_MSG_END:
      stream->rx.hstate = NGHTTP3_HTTP_STATE_REQ_END;
      return 0;
    default:
      return NGHTTP3_ERR_H3_FRAME_UNEXPECTED;
    }
  case NGHTTP3_HTTP_STATE_REQ_TRAILERS_BEGIN:
    if (event != NGHTTP3_HTTP_EVENT_HEADERS_END)
    {
      return NGHTTP3_ERR_H3_GENERAL_PROTOCOL_ERROR;
    }
    stream->rx.hstate = NGHTTP3_HTTP_STATE_REQ_TRAILERS_END;
    return 0;
  case NGHTTP3_HTTP_STATE_REQ_TRAILERS_END:
    if (event != NGHTTP3_HTTP_EVENT_MSG_END)
    {
      return NGHTTP3_ERR_H3_FRAME_UNEXPECTED;
    }
    stream->rx.hstate = NGHTTP3_HTTP_STATE_REQ_END;
    return 0;
  case NGHTTP3_HTTP_STATE_REQ_END:
    return NGHTTP3_ERR_H3_GENERAL_PROTOCOL_ERROR;
  case NGHTTP3_HTTP_STATE_RESP_INITIAL:
    if (event != NGHTTP3_HTTP_EVENT_HEADERS_BEGIN)
    {
      return NGHTTP3_ERR_H3_FRAME_UNEXPECTED;
    }
    stream->rx.hstate = NGHTTP3_HTTP_STATE_RESP_HEADERS_BEGIN;
    return 0;
  case NGHTTP3_HTTP_STATE_RESP_HEADERS_BEGIN:
    if (event != NGHTTP3_HTTP_EVENT_HEADERS_END)
    {
      return NGHTTP3_ERR_H3_GENERAL_PROTOCOL_ERROR;
    }
    stream->rx.hstate = NGHTTP3_HTTP_STATE_RESP_HEADERS_END;
    return 0;
  case NGHTTP3_HTTP_STATE_RESP_HEADERS_END:
    switch (event)
    {
    case NGHTTP3_HTTP_EVENT_HEADERS_BEGIN:
      if (stream->rx.http.status_code == -1)
      {
        stream->rx.hstate = NGHTTP3_HTTP_STATE_RESP_HEADERS_BEGIN;
        return 0;
      }
      if ((stream->rx.http.flags & NGHTTP3_HTTP_FLAG_METH_CONNECT) &&
          stream->rx.http.status_code / 100 == 2)
      {
        return NGHTTP3_ERR_H3_FRAME_UNEXPECTED;
      }
      rv = nghttp3_http_on_remote_end_stream(stream);
      if (rv != 0)
      {
        return rv;
      }
      stream->rx.hstate = NGHTTP3_HTTP_STATE_RESP_TRAILERS_BEGIN;
      return 0;
    case NGHTTP3_HTTP_EVENT_DATA_BEGIN:
      if (stream->rx.http.flags & NGHTTP3_HTTP_FLAG_EXPECT_FINAL_RESPONSE)
      {
        return NGHTTP3_ERR_H3_FRAME_UNEXPECTED;
      }
      stream->rx.hstate = NGHTTP3_HTTP_STATE_RESP_DATA_BEGIN;
      return 0;
    case NGHTTP3_HTTP_EVENT_MSG_END:
      stream->rx.hstate = NGHTTP3_HTTP_STATE_RESP_END;
      return 0;
    default:
      return NGHTTP3_ERR_H3_FRAME_UNEXPECTED;
    }
  case NGHTTP3_HTTP_STATE_RESP_DATA_BEGIN:
    if (event != NGHTTP3_HTTP_EVENT_DATA_END)
    {
      return NGHTTP3_ERR_H3_GENERAL_PROTOCOL_ERROR;
    }
    stream->rx.hstate = NGHTTP3_HTTP_STATE_RESP_DATA_END;
    return 0;
  case NGHTTP3_HTTP_STATE_RESP_DATA_END:
    switch (event)
    {
    case NGHTTP3_HTTP_EVENT_DATA_BEGIN:
      stream->rx.hstate = NGHTTP3_HTTP_STATE_RESP_DATA_BEGIN;
      return 0;
    case NGHTTP3_HTTP_EVENT_HEADERS_BEGIN:
      if ((stream->rx.http.flags & NGHTTP3_HTTP_FLAG_METH_CONNECT) &&
          stream->rx.http.status_code / 100 == 2)
      {
        return NGHTTP3_ERR_H3_FRAME_UNEXPECTED;
      }
      rv = nghttp3_http_on_remote_end_stream(stream);
      if (rv != 0)
      {
        return rv;
      }
      stream->rx.hstate = NGHTTP3_HTTP_STATE_RESP_TRAILERS_BEGIN;
      return 0;
    case NGHTTP3_HTTP_EVENT_MSG_END:
      stream->rx.hstate = NGHTTP3_HTTP_STATE_RESP_END;
      return 0;
    default:
      return NGHTTP3_ERR_H3_FRAME_UNEXPECTED;
    }
  case NGHTTP3_HTTP_STATE_RESP_TRAILERS_BEGIN:
    if (event != NGHTTP3_HTTP_EVENT_HEADERS_END)
    {
      return NGHTTP3_ERR_H3_GENERAL_PROTOCOL_ERROR;
    }
    stream->rx.hstate = NGHTTP3_HTTP_STATE_RESP_TRAILERS_END;
    return 0;
  case NGHTTP3_HTTP_STATE_RESP_TRAILERS_END:
    if (event != NGHTTP3_HTTP_EVENT_MSG_END)
    {
      return NGHTTP3_ERR_H3_GENERAL_PROTOCOL_ERROR;
    }
    stream->rx.hstate = NGHTTP3_HTTP_STATE_RESP_END;
    return 0;
  case NGHTTP3_HTTP_STATE_RESP_END:
    return NGHTTP3_ERR_H3_GENERAL_PROTOCOL_ERROR;
  default:

    (static_cast<bool>(
         0)
         ? void(0)
         : __assert_fail(
               "0", "all.cpp", 16653, __extension__ __PRETTY_FUNCTION__));
  }
}
int nghttp3_stream_empty_headers_allowed(nghttp3_stream *stream)
{
  switch (stream->rx.hstate)
  {
  case NGHTTP3_HTTP_STATE_REQ_TRAILERS_BEGIN:
  case NGHTTP3_HTTP_STATE_RESP_TRAILERS_BEGIN:
    return 0;
  default:
    return NGHTTP3_ERR_H3_GENERAL_PROTOCOL_ERROR;
  }
}
int nghttp3_stream_bidi_or_push(nghttp3_stream *stream)
{
  return (!nghttp3_stream_uni(stream->node.nid.id) ||
          stream->type == NGHTTP3_STREAM_TYPE_PUSH);
}
int nghttp3_stream_uni(int64_t stream_id) { return (stream_id & 0x2) != 0; }
int nghttp3_client_stream_bidi(int64_t stream_id)
{
  return (stream_id & 0x3) == 0;
}
int nghttp3_client_stream_uni(int64_t stream_id)
{
  return (stream_id & 0x3) == 0x2;
}
int nghttp3_server_stream_uni(int64_t stream_id)
{
  return (stream_id & 0x3) == 0x3;
}
nghttp3_node_id *nghttp3_node_id_init(nghttp3_node_id *nid,
                                      nghttp3_node_id_type type, int64_t id)
{
  nid->type = type;
  nid->id = id;
  return nid;
}
int nghttp3_node_id_eq(const nghttp3_node_id *a, const nghttp3_node_id *b)
{
  return a->type == b->type && a->id == b->id;
}
void nghttp3_tnode_init(nghttp3_tnode *tnode, const nghttp3_node_id *nid,
                        uint64_t seq, uint8_t pri)
{

  (static_cast<bool>(
       ((uint32_t)((pri) & ~(1 << 7))) < (7 + 1))
       ? void(0)
       : __assert_fail(
             "nghttp3_pri_uint8_urgency(pri) < NGHTTP3_URGENCY_LEVELS", "all.cpp", 16708, __extension__ __PRETTY_FUNCTION__));
  tnode->pe.index =
      (18446744073709551615UL);
  tnode->nid = *nid;
  tnode->seq = seq;
  tnode->cycle = 0;
  tnode->pri = pri;
}
void nghttp3_tnode_free(nghttp3_tnode *tnode) { (void)tnode; }
static void tnode_unschedule(nghttp3_tnode *tnode, nghttp3_pq *pq)
{

  (static_cast<bool>(
       tnode->pe.index !=
       (18446744073709551615UL))
       ? void(0)
       : __assert_fail(
             "tnode->pe.index != NGHTTP3_PQ_BAD_INDEX", "all.cpp", 16720, __extension__ __PRETTY_FUNCTION__));
  nghttp3_pq_remove(pq, &tnode->pe);
  tnode->pe.index =
      (18446744073709551615UL);
}
void nghttp3_tnode_unschedule(nghttp3_tnode *tnode, nghttp3_pq *pq)
{
  if (tnode->pe.index ==
      (18446744073709551615UL))
  {
    return;
  }
  tnode_unschedule(tnode, pq);
}
static uint64_t pq_get_first_cycle(nghttp3_pq *pq)
{
  nghttp3_tnode *top;
  if (nghttp3_pq_empty(pq))
  {
    return 0;
  }
  top = ((nghttp3_tnode *)(void *)((char *)(nghttp3_pq_top(pq)) -
                                   __builtin_offsetof(
                                       nghttp3_tnode,
                                       pe)));
  return top->cycle;
}
int nghttp3_tnode_schedule(nghttp3_tnode *tnode, nghttp3_pq *pq,
                           size_t nwrite)
{
  uint64_t penalty = nwrite / 800;
  if (tnode->pe.index ==
      (18446744073709551615UL))
  {
    tnode->cycle = pq_get_first_cycle(pq) +
                   ((nwrite == 0 || !(((tnode->pri) & (1 << 7)) != 0))
                        ? 0
                        : ((1) > (penalty) ? (1) : (penalty)));
  }
  else if (nwrite > 0)
  {
    if (!(((tnode->pri) & (1 << 7)) != 0) || nghttp3_pq_size(pq) == 1)
    {
      return 0;
    }
    nghttp3_pq_remove(pq, &tnode->pe);
    tnode->pe.index =
        (18446744073709551615UL);
    tnode->cycle += ((1) > (penalty) ? (1) : (penalty));
  }
  else
  {
    return 0;
  }
  return nghttp3_pq_push(pq, &tnode->pe);
}
int nghttp3_tnode_is_scheduled(nghttp3_tnode *tnode)
{
  return tnode->pe.index !=
         (18446744073709551615UL);
}
size_t nghttp3_vec_len(const nghttp3_vec *vec, size_t n)
{
  size_t i;
  size_t res = 0;
  for (i = 0; i < n; ++i)
  {
    res += vec[i].len;
  }
  return res;
}
int nghttp3_vec_empty(const nghttp3_vec *vec, size_t cnt)
{
  size_t i;
  for (i = 0; i < cnt && vec[i].len == 0; ++i)
    ;
  return i == cnt;
}
void nghttp3_vec_consume(nghttp3_vec **pvec, size_t *pcnt, size_t len)
{
  nghttp3_vec *v = *pvec;
  size_t cnt = *pcnt;
  for (; cnt > 0; --cnt, ++v)
  {
    if (v->len > len)
    {
      v->len -= len;
      v->base += len;
      break;
    }
    len -= v->len;
  }
  *pvec = v;
  *pcnt = cnt;
}
static nghttp3_info version = {1, 0x000100,
                               "0.1.0-DEV"};
nghttp3_info *nghttp3_version(int least_version)
{
  if (least_version > 0x000100)
  {
    return __null;
  }
  return &version;
}
int ngtcp2_crypto_hkdf_expand(uint8_t *dest, size_t destlen,
                              const ngtcp2_crypto_md *md, const uint8_t *secret,
                              size_t secretlen, const uint8_t *info,
                              size_t infolen);
ngtcp2_crypto_ctx *ngtcp2_crypto_ctx_initial(ngtcp2_crypto_ctx *ctx);
int ngtcp2_crypto_hkdf_extract(uint8_t *dest, const ngtcp2_crypto_md *md,
                               const uint8_t *secret, size_t secretlen,
                               const uint8_t *salt, size_t saltlen);
size_t ngtcp2_crypto_aead_noncelen(const ngtcp2_crypto_aead *aead);
int ngtcp2_crypto_hkdf_expand_label(uint8_t *dest, size_t destlen,
                                    const ngtcp2_crypto_md *md,
                                    const uint8_t *secret, size_t secretlen,
                                    const uint8_t *label, size_t labellen)
{
  static const uint8_t LABEL[] = "tls13 ";
  uint8_t info[256];
  uint8_t *p = info;
  *p++ = (uint8_t)(destlen / 256);
  *p++ = (uint8_t)(destlen % 256);
  *p++ = (uint8_t)(sizeof(LABEL) - 1 + labellen);
  memcpy(p, LABEL, sizeof(LABEL) - 1);
  p += sizeof(LABEL) - 1;
  memcpy(p, label, labellen);
  p += labellen;
  *p++ = 0;
  return ngtcp2_crypto_hkdf_expand(dest, destlen, md, secret, secretlen, info,
                                   (size_t)(p - info));
}
int ngtcp2_crypto_derive_initial_secrets(uint8_t *rx_secret, uint8_t *tx_secret,
                                         uint8_t *initial_secret,
                                         const ngtcp2_cid *client_dcid,
                                         ngtcp2_crypto_side side)
{
  static const uint8_t CLABEL[] = "client in";
  static const uint8_t SLABEL[] = "server in";
  uint8_t initial_secret_buf[32];
  uint8_t *client_secret;
  uint8_t *server_secret;
  ngtcp2_crypto_ctx ctx;
  if (!initial_secret)
  {
    initial_secret = initial_secret_buf;
  }
  ngtcp2_crypto_ctx_initial(&ctx);
  if (ngtcp2_crypto_hkdf_extract(initial_secret, &ctx.md, client_dcid->data,
                                 client_dcid->datalen,
                                 (const uint8_t *)"\xaf\xbf\xec\x28\x99\x93\xd2\x4c\x9e\x97\x86\xf1\x9c\x61\x11\xe0\x43\x90"
                                                  "\xa8\x99",
                                 sizeof("\xaf\xbf\xec\x28\x99\x93\xd2\x4c\x9e\x97\x86\xf1\x9c\x61\x11\xe0\x43\x90"
                                        "\xa8\x99") -
                                     1) != 0)
  {
    return -1;
  }
  if (side == NGTCP2_CRYPTO_SIDE_SERVER)
  {
    client_secret = rx_secret;
    server_secret = tx_secret;
  }
  else
  {
    client_secret = tx_secret;
    server_secret = rx_secret;
  }
  if (ngtcp2_crypto_hkdf_expand_label(
          client_secret, 32, &ctx.md,
          initial_secret, 32, CLABEL,
          sizeof(CLABEL) - 1) != 0 ||
      ngtcp2_crypto_hkdf_expand_label(
          server_secret, 32, &ctx.md,
          initial_secret, 32, SLABEL,
          sizeof(SLABEL) - 1) != 0)
  {
    return -1;
  }
  return 0;
}
size_t ngtcp2_crypto_packet_protection_ivlen(const ngtcp2_crypto_aead *aead)
{
  size_t noncelen = ngtcp2_crypto_aead_noncelen(aead);
  return ((8) > (noncelen) ? (8) : (noncelen));
}
size_t ngtcp2_crypto_aead_keylen(const ngtcp2_crypto_aead *aead);
int ngtcp2_crypto_derive_packet_protection_key(
    uint8_t *key, uint8_t *iv, uint8_t *hp_key, const ngtcp2_crypto_aead *aead,
    const ngtcp2_crypto_md *md, const uint8_t *secret, size_t secretlen)
{
  static const uint8_t KEY_LABEL[] = "quic key";
  static const uint8_t IV_LABEL[] = "quic iv";
  static const uint8_t HP_KEY_LABEL[] = "quic hp";
  size_t keylen = ngtcp2_crypto_aead_keylen(aead);
  size_t ivlen = ngtcp2_crypto_packet_protection_ivlen(aead);
  if (ngtcp2_crypto_hkdf_expand_label(key, keylen, md, secret, secretlen,
                                      KEY_LABEL, sizeof(KEY_LABEL) - 1) != 0)
  {
    return -1;
  }
  if (ngtcp2_crypto_hkdf_expand_label(iv, ivlen, md, secret, secretlen,
                                      IV_LABEL, sizeof(IV_LABEL) - 1) != 0)
  {
    return -1;
  }
  if (hp_key !=
          __null &&
      ngtcp2_crypto_hkdf_expand_label(
          hp_key, keylen, md, secret, secretlen, HP_KEY_LABEL,
          sizeof(HP_KEY_LABEL) - 1) != 0)
  {
    return -1;
  }
  return 0;
}
int ngtcp2_crypto_update_traffic_secret(uint8_t *dest,
                                        const ngtcp2_crypto_md *md,
                                        const uint8_t *secret,
                                        size_t secretlen)
{
  static const uint8_t LABEL[] = "quic ku";
  if (ngtcp2_crypto_hkdf_expand_label(dest, secretlen, md, secret, secretlen,
                                      LABEL, sizeof(LABEL) - 1) != 0)
  {
    return -1;
  }
  return 0;
}
ngtcp2_crypto_ctx *ngtcp2_crypto_ctx_tls(ngtcp2_crypto_ctx *ctx,
                                         void *tls_native_handle);
size_t ngtcp2_crypto_aead_taglen(const ngtcp2_crypto_aead *aead);
int ngtcp2_crypto_aead_ctx_decrypt_init(ngtcp2_crypto_aead_ctx *aead_ctx,
                                        const ngtcp2_crypto_aead *aead,
                                        const uint8_t *key, size_t noncelen);
void ngtcp2_crypto_aead_ctx_free(ngtcp2_crypto_aead_ctx *aead_ctx);
int ngtcp2_crypto_derive_and_install_rx_key(ngtcp2_conn *conn, uint8_t *key,
                                            uint8_t *iv, uint8_t *hp_key,
                                            ngtcp2_crypto_level level,
                                            const uint8_t *secret,
                                            size_t secretlen)
{
  const ngtcp2_crypto_ctx *ctx;
  const ngtcp2_crypto_aead *aead;
  const ngtcp2_crypto_md *md;
  const ngtcp2_crypto_cipher *hp;
  ngtcp2_crypto_aead_ctx aead_ctx = {0};
  ngtcp2_crypto_cipher_ctx hp_ctx = {0};
  void *tls = ngtcp2_conn_get_tls_native_handle(conn);
  uint8_t keybuf[64], ivbuf[64], hp_keybuf[64];
  size_t ivlen;
  int rv;
  if (level == NGTCP2_CRYPTO_LEVEL_EARLY && !ngtcp2_conn_is_server(conn))
  {
    return 0;
  }
  if (!key)
  {
    key = keybuf;
  }
  if (!iv)
  {
    iv = ivbuf;
  }
  if (!hp_key)
  {
    hp_key = hp_keybuf;
  }
  ctx = ngtcp2_conn_get_crypto_ctx(conn);
  if (!ctx->aead.native_handle)
  {
    ngtcp2_crypto_ctx cctx;
    ngtcp2_crypto_ctx_tls(&cctx, tls);
    ngtcp2_conn_set_aead_overhead(conn, ngtcp2_crypto_aead_taglen(&cctx.aead));
    ngtcp2_conn_set_crypto_ctx(conn, &cctx);
    ctx = ngtcp2_conn_get_crypto_ctx(conn);
  }
  aead = &ctx->aead;
  md = &ctx->md;
  hp = &ctx->hp;
  ivlen = ngtcp2_crypto_packet_protection_ivlen(aead);
  if (ngtcp2_crypto_derive_packet_protection_key(key, iv, hp_key, aead, md,
                                                 secret, secretlen) != 0)
  {
    return -1;
  }
  if (ngtcp2_crypto_aead_ctx_decrypt_init(&aead_ctx, aead, key, ivlen) != 0)
  {
    goto fail;
  }
  if (ngtcp2_crypto_cipher_ctx_encrypt_init(&hp_ctx, hp, hp_key) != 0)
  {
    goto fail;
  }
  switch (level)
  {
  case NGTCP2_CRYPTO_LEVEL_EARLY:
    rv = ngtcp2_conn_install_early_key(conn, &aead_ctx, iv, ivlen, &hp_ctx);
    if (rv != 0)
    {
      goto fail;
    }
    break;
  case NGTCP2_CRYPTO_LEVEL_HANDSHAKE:
    rv = ngtcp2_conn_install_rx_handshake_key(conn, &aead_ctx, iv, ivlen,
                                              &hp_ctx);
    if (rv != 0)
    {
      goto fail;
    }
    break;
  case NGTCP2_CRYPTO_LEVEL_APP:
    if (!ngtcp2_conn_is_server(conn))
    {
      rv = ngtcp2_crypto_set_remote_transport_params(conn, tls);
      if (rv != 0)
      {
        goto fail;
      }
    }
    rv = ngtcp2_conn_install_rx_key(conn, secret, secretlen, &aead_ctx, iv,
                                    ivlen, &hp_ctx);
    if (rv != 0)
    {
      goto fail;
    }
    break;
  default:
    goto fail;
  }
  return 0;
fail:
  ngtcp2_crypto_cipher_ctx_free(&hp_ctx);
  ngtcp2_crypto_aead_ctx_free(&aead_ctx);
  return -1;
}
static int crypto_set_local_transport_params(ngtcp2_conn *conn, void *tls)
{
  ngtcp2_transport_params_type exttype =
      ngtcp2_conn_is_server(conn)
          ? NGTCP2_TRANSPORT_PARAMS_TYPE_ENCRYPTED_EXTENSIONS
          : NGTCP2_TRANSPORT_PARAMS_TYPE_CLIENT_HELLO;
  ngtcp2_transport_params params;
  ngtcp2_ssize nwrite;
  uint8_t buf[256];
  ngtcp2_conn_get_local_transport_params(conn, &params);
  nwrite = ngtcp2_encode_transport_params(buf, sizeof(buf), exttype, &params);
  if (nwrite < 0)
  {
    return -1;
  }
  if (ngtcp2_crypto_set_local_transport_params(tls, buf, (size_t)nwrite) != 0)
  {
    return -1;
  }
  return 0;
}
int ngtcp2_crypto_aead_ctx_encrypt_init(ngtcp2_crypto_aead_ctx *aead_ctx,
                                        const ngtcp2_crypto_aead *aead,
                                        const uint8_t *key, size_t noncelen);
int ngtcp2_crypto_derive_and_install_tx_key(ngtcp2_conn *conn, uint8_t *key,
                                            uint8_t *iv, uint8_t *hp_key,
                                            ngtcp2_crypto_level level,
                                            const uint8_t *secret,
                                            size_t secretlen)
{
  const ngtcp2_crypto_ctx *ctx;
  const ngtcp2_crypto_aead *aead;
  const ngtcp2_crypto_md *md;
  const ngtcp2_crypto_cipher *hp;
  ngtcp2_crypto_aead_ctx aead_ctx = {0};
  ngtcp2_crypto_cipher_ctx hp_ctx = {0};
  void *tls = ngtcp2_conn_get_tls_native_handle(conn);
  uint8_t keybuf[64], ivbuf[64], hp_keybuf[64];
  size_t ivlen;
  int rv;
  if (level == NGTCP2_CRYPTO_LEVEL_EARLY && ngtcp2_conn_is_server(conn))
  {
    return 0;
  }
  if (!key)
  {
    key = keybuf;
  }
  if (!iv)
  {
    iv = ivbuf;
  }
  if (!hp_key)
  {
    hp_key = hp_keybuf;
  }
  ctx = ngtcp2_conn_get_crypto_ctx(conn);
  if (!ctx->aead.native_handle)
  {
    ngtcp2_crypto_ctx cctx;
    ngtcp2_crypto_ctx_tls(&cctx, tls);
    ngtcp2_conn_set_aead_overhead(conn, ngtcp2_crypto_aead_taglen(&cctx.aead));
    ngtcp2_conn_set_crypto_ctx(conn, &cctx);
    ctx = ngtcp2_conn_get_crypto_ctx(conn);
  }
  aead = &ctx->aead;
  md = &ctx->md;
  hp = &ctx->hp;
  ivlen = ngtcp2_crypto_packet_protection_ivlen(aead);
  if (ngtcp2_crypto_derive_packet_protection_key(key, iv, hp_key, aead, md,
                                                 secret, secretlen) != 0)
  {
    return -1;
  }
  if (ngtcp2_crypto_aead_ctx_encrypt_init(&aead_ctx, aead, key, ivlen) != 0)
  {
    goto fail;
  }
  if (ngtcp2_crypto_cipher_ctx_encrypt_init(&hp_ctx, hp, hp_key) != 0)
  {
    goto fail;
  }
  switch (level)
  {
  case NGTCP2_CRYPTO_LEVEL_EARLY:
    rv = ngtcp2_conn_install_early_key(conn, &aead_ctx, iv, ivlen, &hp_ctx);
    if (rv != 0)
    {
      goto fail;
    }
    break;
  case NGTCP2_CRYPTO_LEVEL_HANDSHAKE:
    rv = ngtcp2_conn_install_tx_handshake_key(conn, &aead_ctx, iv, ivlen,
                                              &hp_ctx);
    if (rv != 0)
    {
      goto fail;
    }
    if (ngtcp2_conn_is_server(conn))
    {
      rv = ngtcp2_crypto_set_remote_transport_params(conn, tls);
      if (rv != 0)
      {
        return rv;
      }
      if (crypto_set_local_transport_params(conn, tls) != 0)
      {
        return rv;
      }
    }
    break;
  case NGTCP2_CRYPTO_LEVEL_APP:
    rv = ngtcp2_conn_install_tx_key(conn, secret, secretlen, &aead_ctx, iv,
                                    ivlen, &hp_ctx);
    if (rv != 0)
    {
      goto fail;
    }
    break;
  default:
    goto fail;
  }
  return 0;
fail:
  ngtcp2_crypto_cipher_ctx_free(&hp_ctx);
  ngtcp2_crypto_aead_ctx_free(&aead_ctx);
  return -1;
}
ngtcp2_crypto_aead *ngtcp2_crypto_aead_retry(ngtcp2_crypto_aead *aead);
int ngtcp2_crypto_derive_and_install_initial_key(
    ngtcp2_conn *conn, uint8_t *rx_secret, uint8_t *tx_secret,
    uint8_t *initial_secret, uint8_t *rx_key, uint8_t *rx_iv,
    uint8_t *rx_hp_key, uint8_t *tx_key, uint8_t *tx_iv, uint8_t *tx_hp_key,
    const ngtcp2_cid *client_dcid)
{
  uint8_t rx_secretbuf[32];
  uint8_t tx_secretbuf[32];
  uint8_t initial_secretbuf[32];
  uint8_t rx_keybuf[16];
  uint8_t rx_ivbuf[12];
  uint8_t rx_hp_keybuf[16];
  uint8_t tx_keybuf[16];
  uint8_t tx_ivbuf[12];
  uint8_t tx_hp_keybuf[16];
  ngtcp2_crypto_ctx ctx;
  ngtcp2_crypto_aead retry_aead;
  ngtcp2_crypto_aead_ctx rx_aead_ctx = {0};
  ngtcp2_crypto_cipher_ctx rx_hp_ctx = {0};
  ngtcp2_crypto_aead_ctx tx_aead_ctx = {0};
  ngtcp2_crypto_cipher_ctx tx_hp_ctx = {0};
  ngtcp2_crypto_aead_ctx retry_aead_ctx = {0};
  int rv;
  int server = ngtcp2_conn_is_server(conn);
  ngtcp2_crypto_ctx_initial(&ctx);
  if (!rx_secret)
  {
    rx_secret = rx_secretbuf;
  }
  if (!tx_secret)
  {
    tx_secret = tx_secretbuf;
  }
  if (!initial_secret)
  {
    initial_secret = initial_secretbuf;
  }
  if (!rx_key)
  {
    rx_key = rx_keybuf;
  }
  if (!rx_iv)
  {
    rx_iv = rx_ivbuf;
  }
  if (!rx_hp_key)
  {
    rx_hp_key = rx_hp_keybuf;
  }
  if (!tx_key)
  {
    tx_key = tx_keybuf;
  }
  if (!tx_iv)
  {
    tx_iv = tx_ivbuf;
  }
  if (!tx_hp_key)
  {
    tx_hp_key = tx_hp_keybuf;
  }
  ngtcp2_conn_set_initial_crypto_ctx(conn, &ctx);
  if (ngtcp2_crypto_derive_initial_secrets(
          rx_secret, tx_secret, initial_secret, client_dcid,
          server ? NGTCP2_CRYPTO_SIDE_SERVER : NGTCP2_CRYPTO_SIDE_CLIENT) !=
      0)
  {
    return -1;
  }
  if (ngtcp2_crypto_derive_packet_protection_key(
          rx_key, rx_iv, rx_hp_key, &ctx.aead, &ctx.md, rx_secret,
          32) != 0)
  {
    return -1;
  }
  if (ngtcp2_crypto_derive_packet_protection_key(
          tx_key, tx_iv, tx_hp_key, &ctx.aead, &ctx.md, tx_secret,
          32) != 0)
  {
    return -1;
  }
  if (ngtcp2_crypto_aead_ctx_decrypt_init(&rx_aead_ctx, &ctx.aead, rx_key,
                                          12) != 0)
  {
    goto fail;
  }
  if (ngtcp2_crypto_cipher_ctx_encrypt_init(&rx_hp_ctx, &ctx.hp, rx_hp_key) !=
      0)
  {
    goto fail;
  }
  if (ngtcp2_crypto_aead_ctx_encrypt_init(&tx_aead_ctx, &ctx.aead, tx_key,
                                          12) != 0)
  {
    goto fail;
  }
  if (ngtcp2_crypto_cipher_ctx_encrypt_init(&tx_hp_ctx, &ctx.hp, tx_hp_key) !=
      0)
  {
    goto fail;
  }
  if (!server && !ngtcp2_conn_after_retry(conn))
  {
    ngtcp2_crypto_aead_retry(&retry_aead);
    if (ngtcp2_crypto_aead_ctx_encrypt_init(
            &retry_aead_ctx, &retry_aead, (const uint8_t *)"\xcc\xce\x18\x7e\xd0\x9a\x09\xd0\x57\x28\x15\x5a\x6c\xb9\x6b\xe1",
            sizeof("\xe5\x49\x30\xf9\x7f\x21\x36\xf0\x53\x0a\x8c\x1c") - 1) != 0)
    {
      goto fail;
    }
  }
  rv = ngtcp2_conn_install_initial_key(conn, &rx_aead_ctx, rx_iv, &rx_hp_ctx,
                                       &tx_aead_ctx, tx_iv, &tx_hp_ctx,
                                       12);
  if (rv != 0)
  {
    goto fail;
  }
  if (retry_aead_ctx.native_handle)
  {
    ngtcp2_conn_set_retry_aead(conn, &retry_aead, &retry_aead_ctx);
  }
  return 0;
fail:
  ngtcp2_crypto_aead_ctx_free(&retry_aead_ctx);
  ngtcp2_crypto_cipher_ctx_free(&tx_hp_ctx);
  ngtcp2_crypto_aead_ctx_free(&tx_aead_ctx);
  ngtcp2_crypto_cipher_ctx_free(&rx_hp_ctx);
  ngtcp2_crypto_aead_ctx_free(&rx_aead_ctx);
  return -1;
}
int ngtcp2_crypto_update_key(
    ngtcp2_conn *conn, uint8_t *rx_secret, uint8_t *tx_secret,
    ngtcp2_crypto_aead_ctx *rx_aead_ctx, uint8_t *rx_key, uint8_t *rx_iv,
    ngtcp2_crypto_aead_ctx *tx_aead_ctx, uint8_t *tx_key, uint8_t *tx_iv,
    const uint8_t *current_rx_secret, const uint8_t *current_tx_secret,
    size_t secretlen)
{
  const ngtcp2_crypto_ctx *ctx = ngtcp2_conn_get_crypto_ctx(conn);
  const ngtcp2_crypto_aead *aead = &ctx->aead;
  const ngtcp2_crypto_md *md = &ctx->md;
  size_t ivlen = ngtcp2_crypto_packet_protection_ivlen(aead);
  if (ngtcp2_crypto_update_traffic_secret(rx_secret, md, current_rx_secret,
                                          secretlen) != 0)
  {
    return -1;
  }
  if (ngtcp2_crypto_derive_packet_protection_key(rx_key, rx_iv,
                                                 __null, aead, md,
                                                 rx_secret, secretlen) != 0)
  {
    return -1;
  }
  if (ngtcp2_crypto_update_traffic_secret(tx_secret, md, current_tx_secret,
                                          secretlen) != 0)
  {
    return -1;
  }
  if (ngtcp2_crypto_derive_packet_protection_key(tx_key, tx_iv,
                                                 __null, aead, md,
                                                 tx_secret, secretlen) != 0)
  {
    return -1;
  }
  if (ngtcp2_crypto_aead_ctx_decrypt_init(rx_aead_ctx, aead, rx_key, ivlen) !=
      0)
  {
    return -1;
  }
  if (ngtcp2_crypto_aead_ctx_encrypt_init(tx_aead_ctx, aead, tx_key, ivlen) !=
      0)
  {
    ngtcp2_crypto_aead_ctx_free(rx_aead_ctx);
    rx_aead_ctx->native_handle =
        __null;
    return -1;
  }
  return 0;
}
int ngtcp2_crypto_encrypt(uint8_t *dest, const ngtcp2_crypto_aead *aead,
                          const ngtcp2_crypto_aead_ctx *aead_ctx,
                          const uint8_t *plaintext, size_t plaintextlen,
                          const uint8_t *nonce, size_t noncelen,
                          const uint8_t *ad, size_t adlen);
int ngtcp2_crypto_encrypt_cb(uint8_t *dest, const ngtcp2_crypto_aead *aead,
                             const ngtcp2_crypto_aead_ctx *aead_ctx,
                             const uint8_t *plaintext, size_t plaintextlen,
                             const uint8_t *nonce, size_t noncelen,
                             const uint8_t *ad, size_t adlen)
{
  if (ngtcp2_crypto_encrypt(dest, aead, aead_ctx, plaintext, plaintextlen,
                            nonce, noncelen, ad, adlen) != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
int ngtcp2_crypto_decrypt(uint8_t *dest, const ngtcp2_crypto_aead *aead,
                          const ngtcp2_crypto_aead_ctx *aead_ctx,
                          const uint8_t *ciphertext, size_t ciphertextlen,
                          const uint8_t *nonce, size_t noncelen,
                          const uint8_t *ad, size_t adlen);
int ngtcp2_crypto_decrypt_cb(uint8_t *dest, const ngtcp2_crypto_aead *aead,
                             const ngtcp2_crypto_aead_ctx *aead_ctx,
                             const uint8_t *ciphertext, size_t ciphertextlen,
                             const uint8_t *nonce, size_t noncelen,
                             const uint8_t *ad, size_t adlen)
{
  if (ngtcp2_crypto_decrypt(dest, aead, aead_ctx, ciphertext, ciphertextlen,
                            nonce, noncelen, ad, adlen) != 0)
  {
    return NGTCP2_ERR_TLS_DECRYPT;
  }
  return 0;
}
int ngtcp2_crypto_hp_mask(uint8_t *dest, const ngtcp2_crypto_cipher *hp,
                          const ngtcp2_crypto_cipher_ctx *hp_ctx,
                          const uint8_t *sample);
int ngtcp2_crypto_hp_mask_cb(uint8_t *dest, const ngtcp2_crypto_cipher *hp,
                             const ngtcp2_crypto_cipher_ctx *hp_ctx,
                             const uint8_t *sample)
{
  if (ngtcp2_crypto_hp_mask(dest, hp, hp_ctx, sample) != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
int ngtcp2_crypto_update_key_cb(
    ngtcp2_conn *conn, uint8_t *rx_secret, uint8_t *tx_secret,
    ngtcp2_crypto_aead_ctx *rx_aead_ctx, uint8_t *rx_iv,
    ngtcp2_crypto_aead_ctx *tx_aead_ctx, uint8_t *tx_iv,
    const uint8_t *current_rx_secret, const uint8_t *current_tx_secret,
    size_t secretlen, void *user_data)
{
  uint8_t rx_key[64];
  uint8_t tx_key[64];
  (void)conn;
  (void)user_data;
  if (ngtcp2_crypto_update_key(conn, rx_secret, tx_secret, rx_aead_ctx, rx_key,
                               rx_iv, tx_aead_ctx, tx_key, tx_iv,
                               current_rx_secret, current_tx_secret,
                               secretlen) != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
size_t ngtcp2_crypto_md_hashlen(const ngtcp2_crypto_md *md);
int ngtcp2_crypto_generate_stateless_reset_token(uint8_t *token,
                                                 const ngtcp2_crypto_md *md,
                                                 const uint8_t *secret,
                                                 size_t secretlen,
                                                 const ngtcp2_cid *cid)
{
  uint8_t buf[64];
  int rv;

  (static_cast<bool>(
       ngtcp2_crypto_md_hashlen(md) <= sizeof(buf))
       ? void(0)
       : __assert_fail(
             "ngtcp2_crypto_md_hashlen(md) <= sizeof(buf)", "all.cpp", 17458, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       16 <= sizeof(buf))
       ? void(0)
       : __assert_fail(
             "NGTCP2_STATELESS_RESET_TOKENLEN <= sizeof(buf)", "all.cpp", 17459, __extension__ __PRETTY_FUNCTION__));
  rv = ngtcp2_crypto_hkdf_extract(buf, md, secret, secretlen, cid->data,
                                  cid->datalen);
  if (rv != 0)
  {
    return -1;
  }
  memcpy(token, buf, 16);
  return 0;
}
ngtcp2_ssize ngtcp2_crypto_write_connection_close(uint8_t *dest, size_t destlen,
                                                  uint32_t version,
                                                  const ngtcp2_cid *dcid,
                                                  const ngtcp2_cid *scid,
                                                  uint64_t error_code)
{
  uint8_t rx_secret[32];
  uint8_t tx_secret[32];
  uint8_t initial_secret[32];
  uint8_t tx_key[16];
  uint8_t tx_iv[12];
  uint8_t tx_hp_key[16];
  ngtcp2_crypto_ctx ctx;
  ngtcp2_ssize spktlen;
  ngtcp2_crypto_aead_ctx aead_ctx = {0};
  ngtcp2_crypto_cipher_ctx hp_ctx = {0};
  ngtcp2_crypto_ctx_initial(&ctx);
  if (ngtcp2_crypto_derive_initial_secrets(rx_secret, tx_secret, initial_secret,
                                           scid,
                                           NGTCP2_CRYPTO_SIDE_SERVER) != 0)
  {
    return -1;
  }
  if (ngtcp2_crypto_derive_packet_protection_key(
          tx_key, tx_iv, tx_hp_key, &ctx.aead, &ctx.md, tx_secret,
          32) != 0)
  {
    return -1;
  }
  if (ngtcp2_crypto_aead_ctx_encrypt_init(&aead_ctx, &ctx.aead, tx_key,
                                          12) != 0)
  {
    spktlen = -1;
    goto end;
  }
  if (ngtcp2_crypto_cipher_ctx_encrypt_init(&hp_ctx, &ctx.hp, tx_hp_key) != 0)
  {
    spktlen = -1;
    goto end;
  }
  spktlen = ngtcp2_pkt_write_connection_close(
      dest, destlen, version, dcid, scid, error_code, ngtcp2_crypto_encrypt_cb,
      &ctx.aead, &aead_ctx, tx_iv, ngtcp2_crypto_hp_mask_cb, &ctx.hp, &hp_ctx);
  if (spktlen < 0)
  {
    spktlen = -1;
  }
end:
  ngtcp2_crypto_cipher_ctx_free(&hp_ctx);
  ngtcp2_crypto_aead_ctx_free(&aead_ctx);
  return spktlen;
}
ngtcp2_ssize ngtcp2_crypto_write_retry(uint8_t *dest, size_t destlen,
                                       uint32_t version, const ngtcp2_cid *dcid,
                                       const ngtcp2_cid *scid,
                                       const ngtcp2_cid *odcid,
                                       const uint8_t *token, size_t tokenlen)
{
  ngtcp2_crypto_aead aead;
  ngtcp2_ssize spktlen;
  ngtcp2_crypto_aead_ctx aead_ctx = {0};
  ngtcp2_crypto_aead_retry(&aead);
  if (ngtcp2_crypto_aead_ctx_encrypt_init(&aead_ctx, &aead,
                                          (const uint8_t *)"\xcc\xce\x18\x7e\xd0\x9a\x09\xd0\x57\x28\x15\x5a\x6c\xb9\x6b\xe1",
                                          12) != 0)
  {
    return -1;
  }
  spktlen = ngtcp2_pkt_write_retry(dest, destlen, version, dcid, scid, odcid,
                                   token, tokenlen, ngtcp2_crypto_encrypt_cb,
                                   &aead, &aead_ctx);
  if (spktlen < 0)
  {
    spktlen = -1;
  }
  ngtcp2_crypto_aead_ctx_free(&aead_ctx);
  return spktlen;
}
static int crypto_setup_initial_crypto(ngtcp2_conn *conn,
                                       const ngtcp2_cid *dcid)
{
  return ngtcp2_crypto_derive_and_install_initial_key(
      conn,
      __null,
      __null,
      __null,
      __null,
      __null,
      __null,
      __null,
      __null,
      __null, dcid);
}
int ngtcp2_crypto_read_write_crypto_data(ngtcp2_conn *conn,
                                         ngtcp2_crypto_level crypto_level,
                                         const uint8_t *data, size_t datalen);
int ngtcp2_crypto_client_initial_cb(ngtcp2_conn *conn, void *user_data)
{
  const ngtcp2_cid *dcid = ngtcp2_conn_get_dcid(conn);
  void *tls = ngtcp2_conn_get_tls_native_handle(conn);
  (void)user_data;
  if (crypto_setup_initial_crypto(conn, dcid) != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  if (crypto_set_local_transport_params(conn, tls) != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  if (ngtcp2_crypto_read_write_crypto_data(conn, NGTCP2_CRYPTO_LEVEL_INITIAL,

                                           __null, 0) != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
int ngtcp2_crypto_recv_retry_cb(ngtcp2_conn *conn, const ngtcp2_pkt_hd *hd,
                                void *user_data)
{
  (void)user_data;
  if (ngtcp2_crypto_derive_and_install_initial_key(conn,
                                                   __null,
                                                   __null,
                                                   __null,
                                                   __null,

                                                   __null,
                                                   __null,
                                                   __null,
                                                   __null,
                                                   __null,
                                                   &hd->scid) != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
int ngtcp2_crypto_recv_client_initial_cb(ngtcp2_conn *conn,
                                         const ngtcp2_cid *dcid,
                                         void *user_data)
{
  (void)user_data;
  if (crypto_setup_initial_crypto(conn, dcid) != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
void ngtcp2_crypto_delete_crypto_aead_ctx_cb(ngtcp2_conn *conn,
                                             ngtcp2_crypto_aead_ctx *aead_ctx,
                                             void *user_data)
{
  (void)conn;
  (void)user_data;
  ngtcp2_crypto_aead_ctx_free(aead_ctx);
}
void ngtcp2_crypto_delete_crypto_cipher_ctx_cb(
    ngtcp2_conn *conn, ngtcp2_crypto_cipher_ctx *cipher_ctx, void *user_data)
{
  (void)conn;
  (void)user_data;
  ngtcp2_crypto_cipher_ctx_free(cipher_ctx);
}
ngtcp2_crypto_ctx *ngtcp2_crypto_ctx_initial(ngtcp2_crypto_ctx *ctx)
{
  ctx->aead.native_handle = (void *)EVP_aes_128_gcm();
  ctx->md.native_handle = (void *)EVP_sha256();
  ctx->hp.native_handle = (void *)EVP_aes_128_ctr();
  ctx->max_encryption = 0;
  ctx->max_decryption_failure = 0;
  return ctx;
}
ngtcp2_crypto_aead *ngtcp2_crypto_aead_retry(ngtcp2_crypto_aead *aead)
{
  aead->native_handle = (void *)EVP_aes_128_gcm();
  return aead;
}
static const EVP_CIPHER *crypto_ssl_get_aead(SSL *ssl)
{
  switch (SSL_CIPHER_get_id(SSL_get_current_cipher(ssl)))
  {
  case 0x03001301:
    return EVP_aes_128_gcm();
  case 0x03001302:
    return EVP_aes_256_gcm();
  case 0x03001303:
    return EVP_chacha20_poly1305();
  case 0x03001304:
    return EVP_aes_128_ccm();
  default:
    return __null;
  }
}
static uint64_t crypto_ssl_get_aead_max_encryption(SSL *ssl)
{
  switch (SSL_CIPHER_get_id(SSL_get_current_cipher(ssl)))
  {
  case 0x03001301:
  case 0x03001302:
    return (1ULL << 23);
  case 0x03001303:
    return (1ULL << 62);
  case 0x03001304:
    return (2965820ULL);
  default:
    return 0;
  }
}
static uint64_t crypto_ssl_get_aead_max_decryption_failure(SSL *ssl)
{
  switch (SSL_CIPHER_get_id(SSL_get_current_cipher(ssl)))
  {
  case 0x03001301:
  case 0x03001302:
    return (1ULL << 52);
  case 0x03001303:
    return (1ULL << 36);
  case 0x03001304:
    return (2965820ULL);
  default:
    return 0;
  }
}
static const EVP_CIPHER *crypto_ssl_get_hp(SSL *ssl)
{
  switch (SSL_CIPHER_get_id(SSL_get_current_cipher(ssl)))
  {
  case 0x03001301:
  case 0x03001304:
    return EVP_aes_128_ctr();
  case 0x03001302:
    return EVP_aes_256_ctr();
  case 0x03001303:
    return EVP_chacha20();
  default:
    return __null;
  }
}
static const EVP_MD *crypto_ssl_get_md(SSL *ssl)
{
  switch (SSL_CIPHER_get_id(SSL_get_current_cipher(ssl)))
  {
  case 0x03001301:
  case 0x03001303:
  case 0x03001304:
    return EVP_sha256();
  case 0x03001302:
    return EVP_sha384();
  default:
    return __null;
  }
}
ngtcp2_crypto_ctx *ngtcp2_crypto_ctx_tls(ngtcp2_crypto_ctx *ctx,
                                         void *tls_native_handle)
{
  SSL *ssl = tls_native_handle;
  ctx->aead.native_handle = (void *)crypto_ssl_get_aead(ssl);
  ctx->md.native_handle = (void *)crypto_ssl_get_md(ssl);
  ctx->hp.native_handle = (void *)crypto_ssl_get_hp(ssl);
  ctx->max_encryption = crypto_ssl_get_aead_max_encryption(ssl);
  ctx->max_decryption_failure = crypto_ssl_get_aead_max_decryption_failure(ssl);
  return ctx;
}
static size_t crypto_md_hashlen(const EVP_MD *md)
{
  return (size_t)EVP_MD_size(md);
}
size_t ngtcp2_crypto_md_hashlen(const ngtcp2_crypto_md *md)
{
  return crypto_md_hashlen(md->native_handle);
}
static size_t crypto_aead_keylen(const EVP_CIPHER *aead)
{
  return (size_t)EVP_CIPHER_key_length(aead);
}
size_t ngtcp2_crypto_aead_keylen(const ngtcp2_crypto_aead *aead)
{
  return crypto_aead_keylen(aead->native_handle);
}
static size_t crypto_aead_noncelen(const EVP_CIPHER *aead)
{
  return (size_t)EVP_CIPHER_iv_length(aead);
}
size_t ngtcp2_crypto_aead_noncelen(const ngtcp2_crypto_aead *aead)
{
  return crypto_aead_noncelen(aead->native_handle);
}
static size_t crypto_aead_taglen(const EVP_CIPHER *aead)
{
  if (aead == EVP_aes_128_gcm() || aead == EVP_aes_256_gcm())
  {
    return 16;
  }
  if (aead == EVP_chacha20_poly1305())
  {
    return 16;
  }
  if (aead == EVP_aes_128_ccm())
  {
    return 16;
  }
  return 0;
}
size_t ngtcp2_crypto_aead_taglen(const ngtcp2_crypto_aead *aead)
{
  return crypto_aead_taglen(aead->native_handle);
}
int ngtcp2_crypto_aead_ctx_encrypt_init(ngtcp2_crypto_aead_ctx *aead_ctx,
                                        const ngtcp2_crypto_aead *aead,
                                        const uint8_t *key, size_t noncelen)
{
  const EVP_CIPHER *cipher = aead->native_handle;
  EVP_CIPHER_CTX *actx;
  actx = EVP_CIPHER_CTX_new();
  if (actx ==
      __null)
  {
    return -1;
  }
  if (!EVP_EncryptInit_ex(actx, cipher,
                          __null,
                          __null,
                          __null) ||
      !EVP_CIPHER_CTX_ctrl(actx, 0x9, (int)noncelen,

                           __null) ||
      (cipher == EVP_aes_128_ccm() &&
       !EVP_CIPHER_CTX_ctrl(actx, 0x11,
                            (int)crypto_aead_taglen(cipher),
                            __null)) ||
      !EVP_EncryptInit_ex(actx,
                          __null,
                          __null, key,
                          __null))
  {
    EVP_CIPHER_CTX_free(actx);
    return -1;
  }
  aead_ctx->native_handle = actx;
  return 0;
}
int ngtcp2_crypto_aead_ctx_decrypt_init(ngtcp2_crypto_aead_ctx *aead_ctx,
                                        const ngtcp2_crypto_aead *aead,
                                        const uint8_t *key, size_t noncelen)
{
  const EVP_CIPHER *cipher = aead->native_handle;
  EVP_CIPHER_CTX *actx;
  actx = EVP_CIPHER_CTX_new();
  if (actx ==
      __null)
  {
    return -1;
  }
  if (!EVP_DecryptInit_ex(actx, cipher,
                          __null,
                          __null,
                          __null) ||
      !EVP_CIPHER_CTX_ctrl(actx, 0x9, (int)noncelen,

                           __null) ||
      (cipher == EVP_aes_128_ccm() &&
       !EVP_CIPHER_CTX_ctrl(actx, 0x11,
                            (int)crypto_aead_taglen(cipher),
                            __null)) ||
      !EVP_DecryptInit_ex(actx,
                          __null,
                          __null, key,
                          __null))
  {
    EVP_CIPHER_CTX_free(actx);
    return -1;
  }
  aead_ctx->native_handle = actx;
  return 0;
}
void ngtcp2_crypto_aead_ctx_free(ngtcp2_crypto_aead_ctx *aead_ctx)
{
  if (aead_ctx->native_handle)
  {
    EVP_CIPHER_CTX_free(aead_ctx->native_handle);
  }
}
int ngtcp2_crypto_cipher_ctx_encrypt_init(ngtcp2_crypto_cipher_ctx *cipher_ctx,
                                          const ngtcp2_crypto_cipher *cipher,
                                          const uint8_t *key)
{
  EVP_CIPHER_CTX *actx;
  actx = EVP_CIPHER_CTX_new();
  if (actx ==
      __null)
  {
    return -1;
  }
  if (!EVP_EncryptInit_ex(actx, cipher->native_handle,
                          __null, key,
                          __null))
  {
    EVP_CIPHER_CTX_free(actx);
    return -1;
  }
  cipher_ctx->native_handle = actx;
  return 0;
}
void ngtcp2_crypto_cipher_ctx_free(ngtcp2_crypto_cipher_ctx *cipher_ctx)
{
  if (cipher_ctx->native_handle)
  {
    EVP_CIPHER_CTX_free(cipher_ctx->native_handle);
  }
}
int ngtcp2_crypto_hkdf_extract(uint8_t *dest, const ngtcp2_crypto_md *md,
                               const uint8_t *secret, size_t secretlen,
                               const uint8_t *salt, size_t saltlen)
{
  const EVP_MD *prf = md->native_handle;
  int rv = 0;
  EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new_id(1036,
                                           __null);
  size_t destlen = (size_t)EVP_MD_size(prf);
  if (pctx ==
      __null)
  {
    return -1;
  }
  if (EVP_PKEY_derive_init(pctx) != 1 ||
      EVP_PKEY_CTX_ctrl(pctx, -1, (1 << 10), (0x1000 + 7), 1,
                        __null) != 1 ||
      EVP_PKEY_CTX_ctrl(pctx, -1, (1 << 10), (0x1000 + 3), 0, (void *)(prf)) != 1 ||
      EVP_PKEY_CTX_ctrl(pctx, -1, (1 << 10), (0x1000 + 4), (int)saltlen, (void *)(salt)) != 1 ||
      EVP_PKEY_CTX_ctrl(pctx, -1, (1 << 10), (0x1000 + 5), (int)secretlen, (void *)(secret)) != 1 ||
      EVP_PKEY_derive(pctx, dest, &destlen) != 1)
  {
    rv = -1;
  }
  EVP_PKEY_CTX_free(pctx);
  return rv;
}
int ngtcp2_crypto_hkdf_expand(uint8_t *dest, size_t destlen,
                              const ngtcp2_crypto_md *md, const uint8_t *secret,
                              size_t secretlen, const uint8_t *info,
                              size_t infolen)
{
  const EVP_MD *prf = md->native_handle;
  int rv = 0;
  EVP_PKEY_CTX *pctx = EVP_PKEY_CTX_new_id(1036,
                                           __null);
  if (pctx ==
      __null)
  {
    return -1;
  }
  if (EVP_PKEY_derive_init(pctx) != 1 ||
      EVP_PKEY_CTX_ctrl(pctx, -1, (1 << 10), (0x1000 + 7), 2,
                        __null) != 1 ||
      EVP_PKEY_CTX_ctrl(pctx, -1, (1 << 10), (0x1000 + 3), 0, (void *)(prf)) != 1 ||
      EVP_PKEY_CTX_ctrl(pctx, -1, (1 << 10), (0x1000 + 4), 0, (void *)("")) != 1 ||
      EVP_PKEY_CTX_ctrl(pctx, -1, (1 << 10), (0x1000 + 5), (int)secretlen, (void *)(secret)) != 1 ||
      EVP_PKEY_CTX_ctrl(pctx, -1, (1 << 10), (0x1000 + 6), (int)infolen, (void *)(info)) != 1 ||
      EVP_PKEY_derive(pctx, dest, &destlen) != 1)
  {
    rv = -1;
  }
  EVP_PKEY_CTX_free(pctx);
  return rv;
}
int ngtcp2_crypto_encrypt(uint8_t *dest, const ngtcp2_crypto_aead *aead,
                          const ngtcp2_crypto_aead_ctx *aead_ctx,
                          const uint8_t *plaintext, size_t plaintextlen,
                          const uint8_t *nonce, size_t noncelen,
                          const uint8_t *ad, size_t adlen)
{
  const EVP_CIPHER *cipher = aead->native_handle;
  size_t taglen = crypto_aead_taglen(cipher);
  EVP_CIPHER_CTX *actx = aead_ctx->native_handle;
  int len;
  (void)noncelen;
  if (!EVP_EncryptInit_ex(actx,
                          __null,
                          __null,
                          __null, nonce) ||
      (cipher == EVP_aes_128_ccm() &&
       !EVP_EncryptUpdate(actx,
                          __null, &len,
                          __null, (int)plaintextlen)) ||
      !EVP_EncryptUpdate(actx,
                         __null, &len, ad, (int)adlen) ||
      !EVP_EncryptUpdate(actx, dest, &len, plaintext, (int)plaintextlen) ||
      !EVP_EncryptFinal_ex(actx, dest + len, &len) ||
      !EVP_CIPHER_CTX_ctrl(actx, 0x10, (int)taglen,
                           dest + plaintextlen))
  {
    return -1;
  }
  return 0;
}
int ngtcp2_crypto_decrypt(uint8_t *dest, const ngtcp2_crypto_aead *aead,
                          const ngtcp2_crypto_aead_ctx *aead_ctx,
                          const uint8_t *ciphertext, size_t ciphertextlen,
                          const uint8_t *nonce, size_t noncelen,
                          const uint8_t *ad, size_t adlen)
{
  const EVP_CIPHER *cipher = aead->native_handle;
  size_t taglen = crypto_aead_taglen(cipher);
  EVP_CIPHER_CTX *actx = aead_ctx->native_handle;
  int len;
  const uint8_t *tag;
  (void)noncelen;
  if (taglen > ciphertextlen)
  {
    return -1;
  }
  ciphertextlen -= taglen;
  tag = ciphertext + ciphertextlen;
  if (!EVP_DecryptInit_ex(actx,
                          __null,
                          __null,
                          __null, nonce) ||
      !EVP_CIPHER_CTX_ctrl(actx, 0x11, (int)taglen,
                           (uint8_t *)tag) ||
      (cipher == EVP_aes_128_ccm() &&
       !EVP_DecryptUpdate(actx,
                          __null, &len,
                          __null, (int)ciphertextlen)) ||
      !EVP_DecryptUpdate(actx,
                         __null, &len, ad, (int)adlen) ||
      !EVP_DecryptUpdate(actx, dest, &len, ciphertext, (int)ciphertextlen) ||
      (cipher != EVP_aes_128_ccm() &&
       !EVP_DecryptFinal_ex(actx, dest + ciphertextlen, &len)))
  {
    return -1;
  }
  return 0;
}
int ngtcp2_crypto_hp_mask(uint8_t *dest, const ngtcp2_crypto_cipher *hp,
                          const ngtcp2_crypto_cipher_ctx *hp_ctx,
                          const uint8_t *sample)
{
  static const uint8_t PLAINTEXT[] = "\x00\x00\x00\x00\x00";
  EVP_CIPHER_CTX *actx = hp_ctx->native_handle;
  int len;
  (void)hp;
  if (!EVP_EncryptInit_ex(actx,
                          __null,
                          __null,
                          __null, sample) ||
      !EVP_EncryptUpdate(actx, dest, &len, PLAINTEXT, sizeof(PLAINTEXT) - 1) ||
      !EVP_EncryptFinal_ex(actx, dest + sizeof(PLAINTEXT) - 1, &len))
  {
    return -1;
  }
  return 0;
}
static OSSL_ENCRYPTION_LEVEL
from_ngtcp2_level(ngtcp2_crypto_level crypto_level)
{
  switch (crypto_level)
  {
  case NGTCP2_CRYPTO_LEVEL_INITIAL:
    return ssl_encryption_initial;
  case NGTCP2_CRYPTO_LEVEL_HANDSHAKE:
    return ssl_encryption_handshake;
  case NGTCP2_CRYPTO_LEVEL_APP:
    return ssl_encryption_application;
  case NGTCP2_CRYPTO_LEVEL_EARLY:
    return ssl_encryption_early_data;
  default:

    (static_cast<bool>(
         0)
         ? void(0)
         : __assert_fail(
               "0", "all.cpp", 18011, __extension__ __PRETTY_FUNCTION__));
  }
}
int ngtcp2_crypto_read_write_crypto_data(ngtcp2_conn *conn,
                                         ngtcp2_crypto_level crypto_level,
                                         const uint8_t *data, size_t datalen)
{
  SSL *ssl = ngtcp2_conn_get_tls_native_handle(conn);
  int rv;
  int err;
  if (SSL_provide_quic_data(ssl, from_ngtcp2_level(crypto_level), data,
                            datalen) != 1)
  {
    return -1;
  }
  if (!ngtcp2_conn_get_handshake_completed(conn))
  {
    rv = SSL_do_handshake(ssl);
    if (rv <= 0)
    {
      err = SSL_get_error(ssl, rv);
      switch (err)
      {
      case 2:
      case 3:
        return 0;
      case 11:
        return -10002;
      case 4:
        return -10001;
      case 1:
        return -1;
      default:
        return -1;
      }
    }
    ngtcp2_conn_handshake_completed(conn);
  }
  rv = SSL_process_quic_post_handshake(ssl);
  if (rv != 1)
  {
    err = SSL_get_error(ssl, rv);
    switch (err)
    {
    case 2:
    case 3:
      return 0;
    case 1:
    case 6:
      return -1;
    default:
      return -1;
    }
  }
  return 0;
}
int ngtcp2_crypto_set_remote_transport_params(ngtcp2_conn *conn, void *tls)
{
  SSL *ssl = tls;
  ngtcp2_transport_params_type exttype =
      ngtcp2_conn_is_server(conn)
          ? NGTCP2_TRANSPORT_PARAMS_TYPE_CLIENT_HELLO
          : NGTCP2_TRANSPORT_PARAMS_TYPE_ENCRYPTED_EXTENSIONS;
  const uint8_t *tp;
  size_t tplen;
  ngtcp2_transport_params params;
  int rv;
  SSL_get_peer_quic_transport_params(ssl, &tp, &tplen);
  rv = ngtcp2_decode_transport_params(&params, exttype, tp, tplen);
  if (rv != 0)
  {
    ngtcp2_conn_set_tls_error(conn, rv);
    return -1;
  }
  rv = ngtcp2_conn_set_remote_transport_params(conn, &params);
  if (rv != 0)
  {
    ngtcp2_conn_set_tls_error(conn, rv);
    return -1;
  }
  return 0;
}
int ngtcp2_crypto_set_local_transport_params(void *tls, const uint8_t *buf,
                                             size_t len)
{
  if (SSL_set_quic_transport_params(tls, buf, len) != 1)
  {
    return -1;
  }
  return 0;
}
int ngtcp2_acktr_entry_new(ngtcp2_acktr_entry **ent, int64_t pkt_num,
                           ngtcp2_tstamp tstamp, const ngtcp2_mem *mem)
{
  *ent = ngtcp2_mem_malloc(mem, sizeof(ngtcp2_acktr_entry));
  if (*ent ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  (*ent)->pkt_num = pkt_num;
  (*ent)->len = 1;
  (*ent)->tstamp = tstamp;
  return 0;
}
void ngtcp2_acktr_entry_del(ngtcp2_acktr_entry *ent, const ngtcp2_mem *mem)
{
  ngtcp2_mem_free(mem, ent);
}
static int greater(const ngtcp2_ksl_key *lhs, const ngtcp2_ksl_key *rhs)
{
  return *(int64_t *)lhs > *(int64_t *)rhs;
}
int ngtcp2_acktr_init(ngtcp2_acktr *acktr, ngtcp2_log *log,
                      const ngtcp2_mem *mem)
{
  int rv;
  rv = ngtcp2_ringbuf_init(&acktr->acks, 128, sizeof(ngtcp2_acktr_ack_entry),
                           mem);
  if (rv != 0)
  {
    return rv;
  }
  rv = ngtcp2_ksl_init(&acktr->ents, greater, sizeof(int64_t), mem);
  if (rv != 0)
  {
    ngtcp2_ringbuf_free(&acktr->acks);
    return rv;
  }
  acktr->log = log;
  acktr->mem = mem;
  acktr->flags = NGTCP2_ACKTR_FLAG_NONE;
  acktr->first_unacked_ts =
      (18446744073709551615UL);
  acktr->rx_npkt = 0;
  return 0;
}
void ngtcp2_acktr_free(ngtcp2_acktr *acktr)
{
  ngtcp2_ksl_it it;
  if (acktr ==
      __null)
  {
    return;
  }
  for (it = ngtcp2_ksl_begin(&acktr->ents); !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                                               __null);
       (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
  {
    ngtcp2_acktr_entry_del(ngtcp2_ksl_it_get(&it), acktr->mem);
  }
  ngtcp2_ksl_free(&acktr->ents);
  ngtcp2_ringbuf_free(&acktr->acks);
}
int ngtcp2_acktr_add(ngtcp2_acktr *acktr, int64_t pkt_num, int active_ack,
                     ngtcp2_tstamp ts)
{
  ngtcp2_ksl_it it;
  ngtcp2_acktr_entry *ent, *prev_ent, *delent;
  int rv;
  int added = 0;
  if (ngtcp2_ksl_len(&acktr->ents))
  {
    it = ngtcp2_ksl_lower_bound(&acktr->ents, &pkt_num);
    if (((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                          __null))
    {
      ngtcp2_ksl_it_prev(&it);
      ent = ngtcp2_ksl_it_get(&it);

      (static_cast<bool>(
           ent->pkt_num >= pkt_num + (int64_t)ent->len)
           ? void(0)
           : __assert_fail(
                 "ent->pkt_num >= pkt_num + (int64_t)ent->len", "all.cpp", 18184, __extension__ __PRETTY_FUNCTION__));
      if (ent->pkt_num == pkt_num + (int64_t)ent->len)
      {
        ++ent->len;
        added = 1;
      }
    }
    else
    {
      ent = ngtcp2_ksl_it_get(&it);

      (static_cast<bool>(
           ent->pkt_num != pkt_num)
           ? void(0)
           : __assert_fail(
                 "ent->pkt_num != pkt_num", "all.cpp", 18194, __extension__ __PRETTY_FUNCTION__));
      if (ngtcp2_ksl_it_begin(&it))
      {
        if (ent->pkt_num + 1 == pkt_num)
        {
          ngtcp2_ksl_update_key(&acktr->ents, &ent->pkt_num, &pkt_num);
          ent->pkt_num = pkt_num;
          ent->tstamp = ts;
          ++ent->len;
          added = 1;
        }
      }
      else
      {
        ngtcp2_ksl_it_prev(&it);
        prev_ent = ngtcp2_ksl_it_get(&it);

        (static_cast<bool>(
             prev_ent->pkt_num >= pkt_num + (int64_t)prev_ent->len)
             ? void(0)
             : __assert_fail(
                   "prev_ent->pkt_num >= pkt_num + (int64_t)prev_ent->len", "all.cpp", 18210, __extension__ __PRETTY_FUNCTION__));
        if (ent->pkt_num + 1 == pkt_num)
        {
          if (prev_ent->pkt_num == pkt_num + (int64_t)prev_ent->len)
          {
            prev_ent->len += ent->len + 1;
            ngtcp2_ksl_remove(&acktr->ents,
                              __null, &ent->pkt_num);
            ngtcp2_acktr_entry_del(ent, acktr->mem);
            added = 1;
          }
          else
          {
            ngtcp2_ksl_update_key(&acktr->ents, &ent->pkt_num, &pkt_num);
            ent->pkt_num = pkt_num;
            ent->tstamp = ts;
            ++ent->len;
            added = 1;
          }
        }
        else if (prev_ent->pkt_num == pkt_num + (int64_t)prev_ent->len)
        {
          ++prev_ent->len;
          added = 1;
        }
      }
    }
  }
  if (!added)
  {
    rv = ngtcp2_acktr_entry_new(&ent, pkt_num, ts, acktr->mem);
    if (rv != 0)
    {
      return rv;
    }
    rv = ngtcp2_ksl_insert(&acktr->ents,
                           __null, &ent->pkt_num, ent);
    if (rv != 0)
    {
      ngtcp2_acktr_entry_del(ent, acktr->mem);
      return rv;
    }
  }
  if (active_ack)
  {
    acktr->flags |= NGTCP2_ACKTR_FLAG_ACTIVE_ACK;
    if (acktr->first_unacked_ts ==
        (18446744073709551615UL))
    {
      acktr->first_unacked_ts = ts;
    }
  }
  if (ngtcp2_ksl_len(&acktr->ents) > 1024)
  {
    it = ngtcp2_ksl_end(&acktr->ents);
    ngtcp2_ksl_it_prev(&it);
    delent = ngtcp2_ksl_it_get(&it);
    ngtcp2_ksl_remove(&acktr->ents,
                      __null, &delent->pkt_num);
    ngtcp2_acktr_entry_del(delent, acktr->mem);
  }
  return 0;
}
void ngtcp2_acktr_forget(ngtcp2_acktr *acktr, ngtcp2_acktr_entry *ent)
{
  ngtcp2_ksl_it it;
  it = ngtcp2_ksl_lower_bound(&acktr->ents, &ent->pkt_num);

  (static_cast<bool>(
       *(int64_t *)((ngtcp2_ksl_key *)((ngtcp2_ksl_node *)(void *)(((&it)->blk)->nodes + ((&it)->ksl)->nodelen * ((&it)->i)))->key) == (int64_t)ent->pkt_num)
       ? void(0)
       : __assert_fail(
             "*(int64_t *)ngtcp2_ksl_it_key(&it) == (int64_t)ent->pkt_num", "all.cpp", 18274, __extension__ __PRETTY_FUNCTION__));
  for (; !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                            __null);)
  {
    ent = ngtcp2_ksl_it_get(&it);
    ngtcp2_ksl_remove(&acktr->ents, &it, &ent->pkt_num);
    ngtcp2_acktr_entry_del(ent, acktr->mem);
  }
}
ngtcp2_ksl_it ngtcp2_acktr_get(ngtcp2_acktr *acktr)
{
  return ngtcp2_ksl_begin(&acktr->ents);
}
int ngtcp2_acktr_empty(ngtcp2_acktr *acktr)
{
  ngtcp2_ksl_it it = ngtcp2_ksl_begin(&acktr->ents);
  return ((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                           __null);
}
ngtcp2_acktr_ack_entry *ngtcp2_acktr_add_ack(ngtcp2_acktr *acktr,
                                             int64_t pkt_num,
                                             int64_t largest_ack)
{
  ngtcp2_acktr_ack_entry *ent = ngtcp2_ringbuf_push_front(&acktr->acks);
  ent->largest_ack = largest_ack;
  ent->pkt_num = pkt_num;
  return ent;
}
static void acktr_remove(ngtcp2_acktr *acktr, ngtcp2_ksl_it *it,
                         ngtcp2_acktr_entry *ent)
{
  ngtcp2_ksl_remove(&acktr->ents, it, &ent->pkt_num);
  ngtcp2_acktr_entry_del(ent, acktr->mem);
}
static void acktr_on_ack(ngtcp2_acktr *acktr, ngtcp2_ringbuf *rb,
                         size_t ack_ent_offset)
{
  ngtcp2_acktr_ack_entry *ack_ent;
  ngtcp2_acktr_entry *ent;
  ngtcp2_ksl_it it;

  (static_cast<bool>(
       ((rb)->len))
       ? void(0)
       : __assert_fail(
             "ngtcp2_ringbuf_len(rb)", "all.cpp", 18317, __extension__ __PRETTY_FUNCTION__));
  ack_ent = ngtcp2_ringbuf_get(rb, ack_ent_offset);
  it = ngtcp2_ksl_lower_bound(&acktr->ents, &ack_ent->largest_ack);
  for (; !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                            __null);)
  {
    ent = ngtcp2_ksl_it_get(&it);
    acktr_remove(acktr, &it, ent);
  }
  if (ngtcp2_ksl_len(&acktr->ents))
  {

    (static_cast<bool>(
         ((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                           __null))
         ? void(0)
         : __assert_fail(
               "ngtcp2_ksl_it_end(&it)", "all.cpp", 18327, __extension__ __PRETTY_FUNCTION__));
    ngtcp2_ksl_it_prev(&it);
    ent = ngtcp2_ksl_it_get(&it);
    if (ent->pkt_num > ack_ent->largest_ack &&
        ack_ent->largest_ack >= ent->pkt_num - (int64_t)(ent->len - 1))
    {
      ent->len = (size_t)(ent->pkt_num - ack_ent->largest_ack);
    }
  }
  ngtcp2_ringbuf_resize(rb, ack_ent_offset);
}
void ngtcp2_acktr_recv_ack(ngtcp2_acktr *acktr, const ngtcp2_ack *fr)
{
  ngtcp2_acktr_ack_entry *ent;
  int64_t largest_ack = fr->largest_ack, min_ack;
  size_t i, j;
  ngtcp2_ringbuf *rb = &acktr->acks;
  size_t nacks = ((rb)->len);
  for (j = 0; j < nacks; ++j)
  {
    ent = ngtcp2_ringbuf_get(rb, j);
    if (largest_ack >= ent->pkt_num)
    {
      break;
    }
  }
  if (j == nacks)
  {
    return;
  }
  min_ack = largest_ack - (int64_t)fr->first_ack_blklen;
  if (min_ack <= ent->pkt_num && ent->pkt_num <= largest_ack)
  {
    acktr_on_ack(acktr, rb, j);
    return;
  }
  for (i = 0; i < fr->num_blks && j < nacks; ++i)
  {
    largest_ack = min_ack - (int64_t)fr->blks[i].gap - 2;
    min_ack = largest_ack - (int64_t)fr->blks[i].blklen;
    for (;;)
    {
      if (ent->pkt_num > largest_ack)
      {
        ++j;
        if (j == nacks)
        {
          return;
        }
        ent = ngtcp2_ringbuf_get(rb, j);
        continue;
      }
      if (ent->pkt_num < min_ack)
      {
        break;
      }
      acktr_on_ack(acktr, rb, j);
      return;
    }
  }
}
void ngtcp2_acktr_commit_ack(ngtcp2_acktr *acktr)
{
  acktr->flags &= (uint16_t) ~(NGTCP2_ACKTR_FLAG_ACTIVE_ACK |
                               NGTCP2_ACKTR_FLAG_IMMEDIATE_ACK |
                               NGTCP2_ACKTR_FLAG_CANCEL_TIMER);
  acktr->first_unacked_ts =
      (18446744073709551615UL);
  acktr->rx_npkt = 0;
}
int ngtcp2_acktr_require_active_ack(ngtcp2_acktr *acktr,
                                    ngtcp2_duration max_ack_delay,
                                    ngtcp2_tstamp ts)
{
  return acktr->first_unacked_ts <= ts - max_ack_delay;
}
void ngtcp2_acktr_immediate_ack(ngtcp2_acktr *acktr)
{
  acktr->flags |= NGTCP2_ACKTR_FLAG_IMMEDIATE_ACK;
}
ngtcp2_addr *ngtcp2_addr_init(ngtcp2_addr *dest, const struct sockaddr *addr,
                              size_t addrlen, void *user_data)
{
  dest->addrlen = addrlen;
  dest->addr = (struct sockaddr *)addr;
  dest->user_data = user_data;
  return dest;
}
void ngtcp2_addr_copy(ngtcp2_addr *dest, const ngtcp2_addr *src)
{
  dest->addrlen = src->addrlen;
  if (src->addrlen)
  {
    memcpy(dest->addr, src->addr, src->addrlen);
  }
  dest->user_data = src->user_data;
}
void ngtcp2_addr_copy_byte(ngtcp2_addr *dest, const struct sockaddr *addr,
                           size_t addrlen)
{
  dest->addrlen = addrlen;
  if (addrlen)
  {
    memcpy(dest->addr, addr, addrlen);
  }
}
static int sockaddr_eq(const struct sockaddr *a, const struct sockaddr *b)
{

  (static_cast<bool>(
       a->sa_family == b->sa_family)
       ? void(0)
       : __assert_fail(
             "a->sa_family == b->sa_family", "all.cpp", 18442, __extension__ __PRETTY_FUNCTION__));
  switch (a->sa_family)
  {
  case 2:
  {
    const struct sockaddr_in *ai = (const struct sockaddr_in *)(void *)a,
                             *bi = (const struct sockaddr_in *)(void *)b;
    return ai->sin_port == bi->sin_port &&
           memcmp(&ai->sin_addr, &bi->sin_addr, sizeof(ai->sin_addr)) == 0;
  }
  case 10:
  {
    const struct sockaddr_in6 *ai = (const struct sockaddr_in6 *)(void *)a,
                              *bi = (const struct sockaddr_in6 *)(void *)b;
    return ai->sin6_port == bi->sin6_port &&
           memcmp(&ai->sin6_addr, &bi->sin6_addr, sizeof(ai->sin6_addr)) == 0;
  }
  default:

    (static_cast<bool>(
         0)
         ? void(0)
         : __assert_fail(
               "0", "all.cpp", 18460, __extension__ __PRETTY_FUNCTION__));
  }
}
int ngtcp2_addr_eq(const ngtcp2_addr *a, const ngtcp2_addr *b)
{
  return a->addr->sa_family == b->addr->sa_family &&
         sockaddr_eq(a->addr, b->addr);
}
uint32_t ngtcp2_addr_compare(const ngtcp2_addr *aa, const ngtcp2_addr *bb)
{
  uint32_t flags = NGTCP2_ADDR_COMPARE_FLAG_NONE;
  const struct sockaddr *a = aa->addr;
  const struct sockaddr *b = bb->addr;
  if (a->sa_family != b->sa_family)
  {
    return NGTCP2_ADDR_COMPARE_FLAG_FAMILY;
  }
  switch (a->sa_family)
  {
  case 2:
  {
    const struct sockaddr_in *ai = (const struct sockaddr_in *)(void *)a,
                             *bi = (const struct sockaddr_in *)(void *)b;
    if (memcmp(&ai->sin_addr, &bi->sin_addr, sizeof(ai->sin_addr)))
    {
      flags |= NGTCP2_ADDR_COMPARE_FLAG_ADDR;
    }
    if (ai->sin_port != bi->sin_port)
    {
      flags |= NGTCP2_ADDR_COMPARE_FLAG_PORT;
    }
    return flags;
  }
  case 10:
  {
    const struct sockaddr_in6 *ai = (const struct sockaddr_in6 *)(void *)a,
                              *bi = (const struct sockaddr_in6 *)(void *)b;
    if (memcmp(&ai->sin6_addr, &bi->sin6_addr, sizeof(ai->sin6_addr)))
    {
      flags |= NGTCP2_ADDR_COMPARE_FLAG_ADDR;
    }
    if (ai->sin6_port != bi->sin6_port)
    {
      flags |= NGTCP2_ADDR_COMPARE_FLAG_PORT;
    }
    return flags;
  }
  default:

    (static_cast<bool>(
         0)
         ? void(0)
         : __assert_fail(
               "0", "all.cpp", 18510, __extension__ __PRETTY_FUNCTION__));
  }
}
int ngtcp2_addr_empty(const ngtcp2_addr *addr) { return addr->addrlen == 0; }
void ngtcp2_buf_init(ngtcp2_buf *buf, uint8_t *begin, size_t len)
{
  buf->begin = buf->pos = buf->last = begin;
  buf->end = begin + len;
}
void ngtcp2_buf_reset(ngtcp2_buf *buf) { buf->pos = buf->last = buf->begin; }
size_t ngtcp2_buf_left(const ngtcp2_buf *buf)
{
  return (size_t)(buf->end - buf->last);
}
size_t ngtcp2_buf_len(const ngtcp2_buf *buf)
{
  return (size_t)(buf->last - buf->pos);
}
size_t ngtcp2_buf_cap(const ngtcp2_buf *buf)
{
  return (size_t)(buf->end - buf->begin);
}
uint64_t ngtcp2_cc_compute_initcwnd(size_t max_udp_payload_size)
{
  uint64_t n = 2 * max_udp_payload_size;
  n = ((n) > (14720) ? (n) : (14720));
  return ((10 * max_udp_payload_size) < (n) ? (10 * max_udp_payload_size) : (n));
}
ngtcp2_cc_pkt *ngtcp2_cc_pkt_init(ngtcp2_cc_pkt *pkt, int64_t pkt_num,
                                  size_t pktlen, ngtcp2_pktns_id pktns_id,
                                  ngtcp2_tstamp ts_sent)
{
  pkt->pkt_num = pkt_num;
  pkt->pktlen = pktlen;
  pkt->pktns_id = pktns_id;
  pkt->ts_sent = ts_sent;
  return pkt;
}
static void reno_cc_reset(ngtcp2_reno_cc *cc)
{
  cc->max_delivery_rate_sec = 0;
  cc->target_cwnd = 0;
  cc->pending_add = 0;
}
void ngtcp2_reno_cc_init(ngtcp2_reno_cc *cc, ngtcp2_log *log)
{
  cc->ccb.log = log;
  reno_cc_reset(cc);
}
void ngtcp2_reno_cc_free(ngtcp2_reno_cc *cc) { (void)cc; }
int ngtcp2_cc_reno_cc_init(ngtcp2_cc *cc, ngtcp2_log *log,
                           const ngtcp2_mem *mem)
{
  ngtcp2_reno_cc *reno_cc;
  reno_cc = ngtcp2_mem_calloc(mem, 1, sizeof(ngtcp2_reno_cc));
  if (reno_cc ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  ngtcp2_reno_cc_init(reno_cc, log);
  cc->ccb = &reno_cc->ccb;
  cc->on_pkt_acked = ngtcp2_cc_reno_cc_on_pkt_acked;
  cc->congestion_event = ngtcp2_cc_reno_cc_congestion_event;
  cc->on_persistent_congestion = ngtcp2_cc_reno_cc_on_persistent_congestion;
  cc->on_ack_recv = ngtcp2_cc_reno_cc_on_ack_recv;
  cc->reset = ngtcp2_cc_reno_cc_reset;
  return 0;
}
void ngtcp2_cc_reno_cc_free(ngtcp2_cc *cc, const ngtcp2_mem *mem)
{
  ngtcp2_reno_cc *reno_cc = ((ngtcp2_reno_cc *)(void *)((char *)(cc->ccb) -
                                                        __builtin_offsetof(
                                                            ngtcp2_reno_cc,
                                                            ccb)));
  ngtcp2_reno_cc_free(reno_cc);
  ngtcp2_mem_free(mem, reno_cc);
}
static int in_congestion_recovery(const ngtcp2_conn_stat *cstat,
                                  ngtcp2_tstamp sent_time)
{
  return cstat->congestion_recovery_start_ts !=
             (18446744073709551615UL) &&
         sent_time <= cstat->congestion_recovery_start_ts;
}
void ngtcp2_cc_reno_cc_on_pkt_acked(ngtcp2_cc *ccx, ngtcp2_conn_stat *cstat,
                                    const ngtcp2_cc_pkt *pkt,
                                    ngtcp2_tstamp ts)
{
  ngtcp2_reno_cc *cc = ((ngtcp2_reno_cc *)(void *)((char *)(ccx->ccb) -
                                                   __builtin_offsetof(
                                                       ngtcp2_reno_cc,
                                                       ccb)));
  uint64_t m;
  (void)ts;
  if (in_congestion_recovery(cstat, pkt->ts_sent))
  {
    return;
  }
  if (cc->target_cwnd && cc->target_cwnd < cstat->cwnd)
  {
    return;
  }
  if (cstat->cwnd < cstat->ssthresh)
  {
    cstat->cwnd += pkt->pktlen;
    ngtcp2_log_info(cc->ccb.log, NGTCP2_LOG_EVENT_RCV,
                    "pkn=%"
                    "l"
                    "d"
                    " acked, slow start cwnd=%"
                    "l"
                    "u",
                    pkt->pkt_num, cstat->cwnd);
    return;
  }
  m = cstat->max_udp_payload_size * pkt->pktlen + cc->pending_add;
  cc->pending_add = m % cstat->cwnd;
  cstat->cwnd += m / cstat->cwnd;
}
void ngtcp2_cc_reno_cc_congestion_event(ngtcp2_cc *ccx, ngtcp2_conn_stat *cstat,
                                        ngtcp2_tstamp ts_sent,
                                        ngtcp2_tstamp ts)
{
  ngtcp2_reno_cc *cc = ((ngtcp2_reno_cc *)(void *)((char *)(ccx->ccb) -
                                                   __builtin_offsetof(
                                                       ngtcp2_reno_cc,
                                                       ccb)));
  uint64_t min_cwnd;
  if (in_congestion_recovery(cstat, ts_sent))
  {
    return;
  }
  cstat->congestion_recovery_start_ts = ts;
  cstat->cwnd >>= 1;
  min_cwnd = 2 * cstat->max_udp_payload_size;
  cstat->cwnd = ((cstat->cwnd) > (min_cwnd) ? (cstat->cwnd) : (min_cwnd));
  cstat->ssthresh = cstat->cwnd;
  cc->pending_add = 0;
  ngtcp2_log_info(cc->ccb.log, NGTCP2_LOG_EVENT_RCV,
                  "reduce cwnd because of packet loss cwnd=%"
                  "l"
                  "u",
                  cstat->cwnd);
}
void ngtcp2_cc_reno_cc_on_persistent_congestion(ngtcp2_cc *ccx,
                                                ngtcp2_conn_stat *cstat,
                                                ngtcp2_tstamp ts)
{
  (void)ccx;
  (void)ts;
  cstat->cwnd = 2 * cstat->max_udp_payload_size;
  cstat->congestion_recovery_start_ts =
      (18446744073709551615UL);
}
void ngtcp2_cc_reno_cc_on_ack_recv(ngtcp2_cc *ccx, ngtcp2_conn_stat *cstat,
                                   ngtcp2_tstamp ts)
{
  ngtcp2_reno_cc *cc = ((ngtcp2_reno_cc *)(void *)((char *)(ccx->ccb) -
                                                   __builtin_offsetof(
                                                       ngtcp2_reno_cc,
                                                       ccb)));
  uint64_t target_cwnd, initcwnd;
  (void)ts;
  cc->max_delivery_rate_sec =
      ((cc->max_delivery_rate_sec) > (cstat->delivery_rate_sec) ? (cc->max_delivery_rate_sec) : (cstat->delivery_rate_sec));
  if (cstat->min_rtt !=
          (18446744073709551615UL) &&
      cc->max_delivery_rate_sec)
  {
    target_cwnd = cc->max_delivery_rate_sec * cstat->min_rtt / ((uint64_t)1000000000ULL);
    initcwnd = ngtcp2_cc_compute_initcwnd(cstat->max_udp_payload_size);
    cc->target_cwnd = ((initcwnd) > (target_cwnd) ? (initcwnd) : (target_cwnd)) * 289 / 100;
    ngtcp2_log_info(cc->ccb.log, NGTCP2_LOG_EVENT_RCV,
                    "target_cwnd=%"
                    "l"
                    "u"
                    " max_delivery_rate_sec=%"
                    "l"
                    "u"

                    " min_rtt=%"
                    "l"
                    "u",
                    cc->target_cwnd, cc->max_delivery_rate_sec, cstat->min_rtt);
  }
}
void ngtcp2_cc_reno_cc_reset(ngtcp2_cc *ccx)
{
  ngtcp2_reno_cc *cc = ((ngtcp2_reno_cc *)(void *)((char *)(ccx->ccb) -
                                                   __builtin_offsetof(
                                                       ngtcp2_reno_cc,
                                                       ccb)));
  reno_cc_reset(cc);
}
static void cubic_cc_reset(ngtcp2_cubic_cc *cc)
{
  cc->max_delivery_rate_sec = 0;
  cc->target_cwnd = 0;
  cc->w_last_max = 0;
  cc->w_tcp = 0;
  cc->origin_point = 0;
  cc->epoch_start =
      (18446744073709551615UL);
  cc->k = 0;
  cc->rtt_sample_count = 0;
  cc->current_round_min_rtt =
      (18446744073709551615UL);
  cc->last_round_min_rtt =
      (18446744073709551615UL);
  cc->window_end = -1;
}
void ngtcp2_cubic_cc_init(ngtcp2_cubic_cc *cc, ngtcp2_log *log)
{
  cc->ccb.log = log;
  cubic_cc_reset(cc);
}
void ngtcp2_cubic_cc_free(ngtcp2_cubic_cc *cc) { (void)cc; }
int ngtcp2_cc_cubic_cc_init(ngtcp2_cc *cc, ngtcp2_log *log,
                            const ngtcp2_mem *mem)
{
  ngtcp2_cubic_cc *cubic_cc;
  cubic_cc = ngtcp2_mem_calloc(mem, 1, sizeof(ngtcp2_cubic_cc));
  if (cubic_cc ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  ngtcp2_cubic_cc_init(cubic_cc, log);
  cc->ccb = &cubic_cc->ccb;
  cc->on_pkt_acked = ngtcp2_cc_cubic_cc_on_pkt_acked;
  cc->congestion_event = ngtcp2_cc_cubic_cc_congestion_event;
  cc->on_persistent_congestion = ngtcp2_cc_cubic_cc_on_persistent_congestion;
  cc->on_ack_recv = ngtcp2_cc_cubic_cc_on_ack_recv;
  cc->on_pkt_sent = ngtcp2_cc_cubic_cc_on_pkt_sent;
  cc->new_rtt_sample = ngtcp2_cc_cubic_cc_new_rtt_sample;
  cc->reset = ngtcp2_cc_cubic_cc_reset;
  cc->event = ngtcp2_cc_cubic_cc_event;
  return 0;
}
void ngtcp2_cc_cubic_cc_free(ngtcp2_cc *cc, const ngtcp2_mem *mem)
{
  ngtcp2_cubic_cc *cubic_cc = ((ngtcp2_cubic_cc *)(void *)((char *)(cc->ccb) -
                                                           __builtin_offsetof(
                                                               ngtcp2_cubic_cc,
                                                               ccb)));
  ngtcp2_cubic_cc_free(cubic_cc);
  ngtcp2_mem_free(mem, cubic_cc);
}
static uint64_t ngtcp2_cbrt(uint64_t n)
{
  int d;
  uint64_t a;
  if (n == 0)
  {
    return 0;
  }
  d = __builtin_clzll(n);
  a = 1ULL << ((64 - d) / 3 + 1);
  for (; a * a * a > n;)
  {
    a = (2 * a + n / a / a) / 3;
  }
  return a;
}
void ngtcp2_cc_cubic_cc_on_pkt_acked(ngtcp2_cc *ccx, ngtcp2_conn_stat *cstat,
                                     const ngtcp2_cc_pkt *pkt,
                                     ngtcp2_tstamp ts)
{
  ngtcp2_cubic_cc *cc = ((ngtcp2_cubic_cc *)(void *)((char *)(ccx->ccb) -
                                                     __builtin_offsetof(
                                                         ngtcp2_cubic_cc,
                                                         ccb)));
  ngtcp2_duration t, min_rtt, eta;
  uint64_t target;
  uint64_t tx, kx, time_delta, delta;
  uint64_t add, tcp_add;
  uint64_t m;
  if (pkt->pktns_id == NGTCP2_PKTNS_ID_APP && cc->window_end != -1 &&
      cc->window_end <= pkt->pkt_num)
  {
    cc->window_end = -1;
  }
  if (in_congestion_recovery(cstat, pkt->ts_sent))
  {
    return;
  }
  if (cc->target_cwnd && cc->target_cwnd < cstat->cwnd)
  {
    return;
  }
  if (cstat->cwnd < cstat->ssthresh)
  {
    cstat->cwnd += pkt->pktlen;
    ngtcp2_log_info(cc->ccb.log, NGTCP2_LOG_EVENT_RCV,
                    "pkn=%"
                    "l"
                    "d"
                    " acked, slow start cwnd=%"
                    "l"
                    "u",
                    pkt->pkt_num, cstat->cwnd);
    if (cc->last_round_min_rtt !=
            (18446744073709551615UL) &&
        cc->current_round_min_rtt !=
            (18446744073709551615UL) &&
        cstat->cwnd >= 16 * cstat->max_udp_payload_size &&
        cc->rtt_sample_count >= 8)
    {
      eta = cc->last_round_min_rtt / 8;
      if (eta < (4 * ((uint64_t)1000000ULL)))
      {
        eta = (4 * ((uint64_t)1000000ULL));
      }
      else if (eta > (16 * ((uint64_t)1000000ULL)))
      {
        eta = (16 * ((uint64_t)1000000ULL));
      }
      if (cc->current_round_min_rtt >= cc->last_round_min_rtt + eta)
      {
        ngtcp2_log_info(cc->ccb.log, NGTCP2_LOG_EVENT_RCV,
                        "HyStart++ exit slow start");
        cc->w_last_max = cstat->cwnd;
        cstat->ssthresh = cstat->cwnd;
      }
    }
    return;
  }
  if (cc->epoch_start ==
      (18446744073709551615UL))
  {
    cc->epoch_start = ts;
    if (cstat->cwnd < cc->w_last_max)
    {
      cc->k = ngtcp2_cbrt((cc->w_last_max - cstat->cwnd) * 10 / 4 /
                          cstat->max_udp_payload_size);
      cc->origin_point = cc->w_last_max;
    }
    else
    {
      cc->k = 0;
      cc->origin_point = cstat->cwnd;
    }
    cc->w_tcp = cstat->cwnd;
    ngtcp2_log_info(cc->ccb.log, NGTCP2_LOG_EVENT_RCV,
                    "cubic-ca epoch_start=%"
                    "l"
                    "u"
                    " k=%"
                    "l"
                    "u"

                    " origin_point=%"
                    "l"
                    "u",
                    cc->epoch_start, cc->k, cc->origin_point);
    cc->pending_add = 0;
    cc->pending_w_add = 0;
  }
  min_rtt = cstat->min_rtt ==
                    (18446744073709551615UL)
                ? cstat->initial_rtt
                : cstat->min_rtt;
  t = ts + min_rtt - cc->epoch_start;
  tx = (t << 4) / ((uint64_t)1000000000ULL);
  kx = (cc->k << 4);
  if (tx > kx)
  {
    time_delta = tx - kx;
  }
  else
  {
    time_delta = kx - tx;
  }
  delta = cstat->max_udp_payload_size *
          ((((time_delta * time_delta) >> 4) * time_delta) >> 8) * 4 / 10;
  if (tx > kx)
  {
    target = cc->origin_point + delta;
  }
  else
  {
    target = cc->origin_point - delta;
  }
  if (target > cstat->cwnd)
  {
    m = cc->pending_add + cstat->max_udp_payload_size * (target - cstat->cwnd);
    add = m / cstat->cwnd;
    cc->pending_add = m % cstat->cwnd;
  }
  else
  {
    m = cc->pending_add + cstat->max_udp_payload_size;
    add = m / (100 * cstat->cwnd);
    cc->pending_add = m % (100 * cstat->cwnd);
  }
  m = cc->pending_w_add + cstat->max_udp_payload_size * pkt->pktlen;
  cc->w_tcp += m / cstat->cwnd;
  cc->pending_w_add = m % cstat->cwnd;
  if (cc->w_tcp > cstat->cwnd)
  {
    tcp_add =
        cstat->max_udp_payload_size * (cc->w_tcp - cstat->cwnd) / cstat->cwnd;
    if (tcp_add > add)
    {
      add = tcp_add;
    }
  }
  cstat->cwnd += add;
  ngtcp2_log_info(cc->ccb.log, NGTCP2_LOG_EVENT_RCV,
                  "pkn=%"
                  "l"
                  "d"
                  " acked, cubic-ca cwnd=%"
                  "l"
                  "u"
                  " t=%"
                  "l"
                  "u"

                  " k=%"
                  "l"
                  "i"
                  " time_delta=%"
                  "l"
                  "u"
                  " delta=%"
                  "l"
                  "u"

                  " target=%"
                  "l"
                  "u"
                  " w_tcp=%"
                  "l"
                  "u",
                  pkt->pkt_num, cstat->cwnd, t, cc->k, time_delta >> 4, delta,
                  target, cc->w_tcp);
}
void ngtcp2_cc_cubic_cc_congestion_event(ngtcp2_cc *ccx,
                                         ngtcp2_conn_stat *cstat,
                                         ngtcp2_tstamp ts_sent,
                                         ngtcp2_tstamp ts)
{
  ngtcp2_cubic_cc *cc = ((ngtcp2_cubic_cc *)(void *)((char *)(ccx->ccb) -
                                                     __builtin_offsetof(
                                                         ngtcp2_cubic_cc,
                                                         ccb)));
  uint64_t min_cwnd;
  if (in_congestion_recovery(cstat, ts_sent))
  {
    return;
  }
  cstat->congestion_recovery_start_ts = ts;
  cc->epoch_start =
      (18446744073709551615UL);
  if (cstat->cwnd < cc->w_last_max)
  {
    cc->w_last_max = cstat->cwnd * 17 / 10 / 2;
  }
  else
  {
    cc->w_last_max = cstat->cwnd;
  }
  min_cwnd = 2 * cstat->max_udp_payload_size;
  cstat->ssthresh = cstat->cwnd * 7 / 10;
  cstat->ssthresh = ((cstat->ssthresh) > (min_cwnd) ? (cstat->ssthresh) : (min_cwnd));
  cstat->cwnd = cstat->ssthresh;
  ngtcp2_log_info(cc->ccb.log, NGTCP2_LOG_EVENT_RCV,
                  "reduce cwnd because of packet loss cwnd=%"
                  "l"
                  "u",
                  cstat->cwnd);
}
void ngtcp2_cc_cubic_cc_on_persistent_congestion(ngtcp2_cc *ccx,
                                                 ngtcp2_conn_stat *cstat,
                                                 ngtcp2_tstamp ts)
{
  (void)ccx;
  (void)ts;
  cstat->cwnd = 2 * cstat->max_udp_payload_size;
  cstat->congestion_recovery_start_ts =
      (18446744073709551615UL);
}
void ngtcp2_cc_cubic_cc_on_ack_recv(ngtcp2_cc *ccx, ngtcp2_conn_stat *cstat,
                                    ngtcp2_tstamp ts)
{
  ngtcp2_cubic_cc *cc = ((ngtcp2_cubic_cc *)(void *)((char *)(ccx->ccb) -
                                                     __builtin_offsetof(
                                                         ngtcp2_cubic_cc,
                                                         ccb)));
  uint64_t target_cwnd, initcwnd;
  (void)ts;
  cc->max_delivery_rate_sec =
      ((cc->max_delivery_rate_sec) > (cstat->delivery_rate_sec) ? (cc->max_delivery_rate_sec) : (cstat->delivery_rate_sec));
  if (cstat->min_rtt !=
          (18446744073709551615UL) &&
      cc->max_delivery_rate_sec)
  {
    target_cwnd = cc->max_delivery_rate_sec * cstat->min_rtt / ((uint64_t)1000000000ULL);
    initcwnd = ngtcp2_cc_compute_initcwnd(cstat->max_udp_payload_size);
    cc->target_cwnd = ((initcwnd) > (target_cwnd) ? (initcwnd) : (target_cwnd)) * 289 / 100;
    ngtcp2_log_info(cc->ccb.log, NGTCP2_LOG_EVENT_RCV,
                    "target_cwnd=%"
                    "l"
                    "u"
                    " max_delivery_rate_sec=%"
                    "l"
                    "u"

                    " min_rtt=%"
                    "l"
                    "u",
                    cc->target_cwnd, cc->max_delivery_rate_sec, cstat->min_rtt);
  }
}
void ngtcp2_cc_cubic_cc_on_pkt_sent(ngtcp2_cc *ccx, ngtcp2_conn_stat *cstat,
                                    const ngtcp2_cc_pkt *pkt)
{
  ngtcp2_cubic_cc *cc = ((ngtcp2_cubic_cc *)(void *)((char *)(ccx->ccb) -
                                                     __builtin_offsetof(
                                                         ngtcp2_cubic_cc,
                                                         ccb)));
  (void)cstat;
  if (pkt->pktns_id != NGTCP2_PKTNS_ID_APP || cc->window_end != -1)
  {
    return;
  }
  cc->window_end = pkt->pkt_num;
  cc->last_round_min_rtt = cc->current_round_min_rtt;
  cc->current_round_min_rtt =
      (18446744073709551615UL);
  cc->rtt_sample_count = 0;
}
void ngtcp2_cc_cubic_cc_new_rtt_sample(ngtcp2_cc *ccx, ngtcp2_conn_stat *cstat,
                                       ngtcp2_tstamp ts)
{
  ngtcp2_cubic_cc *cc = ((ngtcp2_cubic_cc *)(void *)((char *)(ccx->ccb) -
                                                     __builtin_offsetof(
                                                         ngtcp2_cubic_cc,
                                                         ccb)));
  (void)ts;
  if (cc->window_end == -1)
  {
    return;
  }
  cc->current_round_min_rtt =
      ((cc->current_round_min_rtt) < (cstat->latest_rtt) ? (cc->current_round_min_rtt) : (cstat->latest_rtt));
  ++cc->rtt_sample_count;
}
void ngtcp2_cc_cubic_cc_reset(ngtcp2_cc *ccx)
{
  ngtcp2_cubic_cc *cc = ((ngtcp2_cubic_cc *)(void *)((char *)(ccx->ccb) -
                                                     __builtin_offsetof(
                                                         ngtcp2_cubic_cc,
                                                         ccb)));
  cubic_cc_reset(cc);
}
void ngtcp2_cc_cubic_cc_event(ngtcp2_cc *ccx, ngtcp2_conn_stat *cstat,
                              ngtcp2_cc_event_type event, ngtcp2_tstamp ts)
{
  ngtcp2_cubic_cc *cc = ((ngtcp2_cubic_cc *)(void *)((char *)(ccx->ccb) -
                                                     __builtin_offsetof(
                                                         ngtcp2_cubic_cc,
                                                         ccb)));
  ngtcp2_tstamp last_ts;
  if (event != NGTCP2_CC_EVENT_TYPE_TX_START || cc->epoch_start ==
                                                    (18446744073709551615UL))
  {
    return;
  }
  last_ts = cstat->last_tx_pkt_ts[NGTCP2_PKTNS_ID_APP];
  if (last_ts ==
          (18446744073709551615UL) ||
      last_ts <= cc->epoch_start)
  {
    return;
  }

  (static_cast<bool>(
       ts >= last_ts)
       ? void(0)
       : __assert_fail(
             "ts >= last_ts", "all.cpp", 19026, __extension__ __PRETTY_FUNCTION__));
  cc->epoch_start += ts - last_ts;
}
void ngtcp2_cid_zero(ngtcp2_cid *cid) { cid->datalen = 0; }
void ngtcp2_cid_init(ngtcp2_cid *cid, const uint8_t *data, size_t datalen)
{

  (static_cast<bool>(
       datalen <= 20)
       ? void(0)
       : __assert_fail(
             "datalen <= NGTCP2_MAX_CIDLEN", "all.cpp", 19034, __extension__ __PRETTY_FUNCTION__));
  cid->datalen = datalen;
  if (datalen)
  {
    ngtcp2_cpymem(cid->data, data, datalen);
  }
}
int ngtcp2_cid_eq(const ngtcp2_cid *cid, const ngtcp2_cid *other)
{
  return cid->datalen == other->datalen &&
         0 == memcmp(cid->data, other->data, cid->datalen);
}
int ngtcp2_cid_less(const ngtcp2_cid *lhs, const ngtcp2_cid *rhs)
{
  int s = lhs->datalen < rhs->datalen;
  size_t n = s ? lhs->datalen : rhs->datalen;
  int c = memcmp(lhs->data, rhs->data, n);
  return c < 0 || (c == 0 && s);
}
int ngtcp2_cid_empty(const ngtcp2_cid *cid) { return cid->datalen == 0; }
void ngtcp2_scid_init(ngtcp2_scid *scid, uint64_t seq, const ngtcp2_cid *cid,
                      const uint8_t *token)
{
  scid->pe.index =
      (18446744073709551615UL);
  scid->seq = seq;
  scid->cid = *cid;
  scid->ts_retired =
      (18446744073709551615UL);
  scid->flags = NGTCP2_SCID_FLAG_NONE;
  if (token)
  {
    memcpy(scid->token, token, 16);
  }
  else
  {
    memset(scid->token, 0, 16);
  }
}
void ngtcp2_scid_copy(ngtcp2_scid *dest, const ngtcp2_scid *src)
{
  ngtcp2_scid_init(dest, src->seq, &src->cid, src->token);
  dest->ts_retired = src->ts_retired;
  dest->flags = src->flags;
}
void ngtcp2_dcid_init(ngtcp2_dcid *dcid, uint64_t seq, const ngtcp2_cid *cid,
                      const uint8_t *token)
{
  dcid->seq = seq;
  dcid->cid = *cid;
  if (token)
  {
    memcpy(dcid->token, token, 16);
  }
  else
  {
    memset(dcid->token, 0, 16);
  }
  ngtcp2_path_storage_zero(&dcid->ps);
  dcid->ts_retired =
      (18446744073709551615UL);
}
void ngtcp2_dcid_copy(ngtcp2_dcid *dest, const ngtcp2_dcid *src)
{
  ngtcp2_dcid_init(dest, src->seq, &src->cid, src->token);
  ngtcp2_path_copy(&dest->ps.path, &src->ps.path);
  dest->ts_retired = src->ts_retired;
}
void ngtcp2_dcid_copy_no_path(ngtcp2_dcid *dest, const ngtcp2_dcid *src)
{
  dest->seq = src->seq;
  dest->cid = src->cid;
  memcpy(dest->token, src->token, 16);
  dest->ts_retired = src->ts_retired;
}
int ngtcp2_dcid_verify_uniqueness(ngtcp2_dcid *dcid, uint64_t seq,
                                  const ngtcp2_cid *cid, const uint8_t *token)
{
  if (dcid->seq == seq)
  {
    return ngtcp2_cid_eq(&dcid->cid, cid) &&
                   memcmp(dcid->token, token,
                          16) == 0
               ? 0
               : NGTCP2_ERR_PROTO;
  }
  return !ngtcp2_cid_eq(&dcid->cid, cid) ? 0 : NGTCP2_ERR_PROTO;
}
static int conn_local_stream(ngtcp2_conn *conn, int64_t stream_id)
{
  return (uint8_t)(stream_id & 1) == conn->server;
}
static int bidi_stream(int64_t stream_id) { return (stream_id & 0x2) == 0; }
static int conn_call_recv_client_initial(ngtcp2_conn *conn,
                                         const ngtcp2_cid *dcid)
{
  int rv;

  (static_cast<bool>(
       conn->callbacks.recv_client_initial)
       ? void(0)
       : __assert_fail(
             "conn->callbacks.recv_client_initial", "all.cpp", 19142, __extension__ __PRETTY_FUNCTION__));
  rv = conn->callbacks.recv_client_initial(conn, dcid, conn->user_data);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_handshake_completed(ngtcp2_conn *conn)
{
  int rv;
  if (!conn->callbacks.handshake_completed)
  {
    return 0;
  }
  rv = conn->callbacks.handshake_completed(conn, conn->user_data);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_recv_stream_data(ngtcp2_conn *conn, ngtcp2_strm *strm,
                                      uint32_t flags, uint64_t offset,
                                      const uint8_t *data, size_t datalen)
{
  int rv;
  if (!conn->callbacks.recv_stream_data)
  {
    return 0;
  }
  rv = conn->callbacks.recv_stream_data(conn, flags, strm->stream_id, offset,
                                        data, datalen, conn->user_data,
                                        strm->stream_user_data);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_recv_crypto_data(ngtcp2_conn *conn,
                                      ngtcp2_crypto_level crypto_level,
                                      uint64_t offset, const uint8_t *data,
                                      size_t datalen)
{
  int rv;

  (static_cast<bool>(
       conn->callbacks.recv_crypto_data)
       ? void(0)
       : __assert_fail(
             "conn->callbacks.recv_crypto_data", "all.cpp", 19191, __extension__ __PRETTY_FUNCTION__));
  rv = conn->callbacks.recv_crypto_data(conn, crypto_level, offset, data,
                                        datalen, conn->user_data);
  switch (rv)
  {
  case 0:
  case NGTCP2_ERR_CRYPTO:
  case NGTCP2_ERR_REQUIRED_TRANSPORT_PARAM:
  case NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM:
  case NGTCP2_ERR_TRANSPORT_PARAM:
  case NGTCP2_ERR_PROTO:
  case NGTCP2_ERR_CALLBACK_FAILURE:
    return rv;
  default:
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
}
static int conn_call_stream_open(ngtcp2_conn *conn, ngtcp2_strm *strm)
{
  int rv;
  if (!conn->callbacks.stream_open)
  {
    return 0;
  }
  rv = conn->callbacks.stream_open(conn, strm->stream_id, conn->user_data);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_stream_close(ngtcp2_conn *conn, ngtcp2_strm *strm,
                                  uint64_t app_error_code)
{
  int rv;
  if (!conn->callbacks.stream_close)
  {
    return 0;
  }
  rv = conn->callbacks.stream_close(conn, strm->stream_id, app_error_code,
                                    conn->user_data, strm->stream_user_data);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_stream_reset(ngtcp2_conn *conn, int64_t stream_id,
                                  uint64_t final_size, uint64_t app_error_code,
                                  void *stream_user_data)
{
  int rv;
  if (!conn->callbacks.stream_reset)
  {
    return 0;
  }
  rv = conn->callbacks.stream_reset(conn, stream_id, final_size, app_error_code,
                                    conn->user_data, stream_user_data);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_extend_max_local_streams_bidi(ngtcp2_conn *conn,
                                                   uint64_t max_streams)
{
  int rv;
  if (!conn->callbacks.extend_max_local_streams_bidi)
  {
    return 0;
  }
  rv = conn->callbacks.extend_max_local_streams_bidi(conn, max_streams,
                                                     conn->user_data);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_extend_max_local_streams_uni(ngtcp2_conn *conn,
                                                  uint64_t max_streams)
{
  int rv;
  if (!conn->callbacks.extend_max_local_streams_uni)
  {
    return 0;
  }
  rv = conn->callbacks.extend_max_local_streams_uni(conn, max_streams,
                                                    conn->user_data);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_get_new_connection_id(ngtcp2_conn *conn, ngtcp2_cid *cid,
                                           uint8_t *token, size_t cidlen)
{
  int rv;

  (static_cast<bool>(
       conn->callbacks.get_new_connection_id)
       ? void(0)
       : __assert_fail(
             "conn->callbacks.get_new_connection_id", "all.cpp", 19297, __extension__ __PRETTY_FUNCTION__));
  rv = conn->callbacks.get_new_connection_id(conn, cid, token, cidlen,
                                             conn->user_data);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_remove_connection_id(ngtcp2_conn *conn,
                                          const ngtcp2_cid *cid)
{
  int rv;
  if (!conn->callbacks.remove_connection_id)
  {
    return 0;
  }
  rv = conn->callbacks.remove_connection_id(conn, cid, conn->user_data);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_path_validation(ngtcp2_conn *conn, const ngtcp2_path *path,
                                     ngtcp2_path_validation_result res)
{
  int rv;
  if (!conn->callbacks.path_validation)
  {
    return 0;
  }
  rv = conn->callbacks.path_validation(conn, path, res, conn->user_data);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_select_preferred_addr(ngtcp2_conn *conn,
                                           ngtcp2_addr *dest)
{
  int rv;
  if (!conn->callbacks.select_preferred_addr)
  {
    return 0;
  }

  (static_cast<bool>(
       conn->remote.transport_params.preferred_address_present)
       ? void(0)
       : __assert_fail(
             "conn->remote.transport_params.preferred_address_present", "all.cpp", 19347, __extension__ __PRETTY_FUNCTION__));
  rv = conn->callbacks.select_preferred_addr(
      conn, dest, &conn->remote.transport_params.preferred_address,
      conn->user_data);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_extend_max_remote_streams_bidi(ngtcp2_conn *conn,
                                                    uint64_t max_streams)
{
  int rv;
  if (!conn->callbacks.extend_max_remote_streams_bidi)
  {
    return 0;
  }
  rv = conn->callbacks.extend_max_remote_streams_bidi(conn, max_streams,
                                                      conn->user_data);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_extend_max_remote_streams_uni(ngtcp2_conn *conn,
                                                   uint64_t max_streams)
{
  int rv;
  if (!conn->callbacks.extend_max_remote_streams_uni)
  {
    return 0;
  }
  rv = conn->callbacks.extend_max_remote_streams_uni(conn, max_streams,
                                                     conn->user_data);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_extend_max_stream_data(ngtcp2_conn *conn,
                                            ngtcp2_strm *strm,
                                            int64_t stream_id,
                                            uint64_t datalen)
{
  int rv;
  if (!conn->callbacks.extend_max_stream_data)
  {
    return 0;
  }
  rv = conn->callbacks.extend_max_stream_data(
      conn, stream_id, datalen, conn->user_data, strm->stream_user_data);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_dcid_status(ngtcp2_conn *conn,
                                 ngtcp2_connection_id_status_type type,
                                 const ngtcp2_dcid *dcid)
{
  int rv;
  if (!conn->callbacks.dcid_status)
  {
    return 0;
  }
  rv = conn->callbacks.dcid_status(
      conn, (int)type, dcid->seq, &dcid->cid,
      ngtcp2_check_invalid_stateless_reset_token(dcid->token) ? __null

                                                              : dcid->token,
      conn->user_data);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_call_activate_dcid(ngtcp2_conn *conn, const ngtcp2_dcid *dcid)
{
  return conn_call_dcid_status(conn, NGTCP2_CONNECTION_ID_STATUS_TYPE_ACTIVATE,
                               dcid);
}
static int conn_call_deactivate_dcid(ngtcp2_conn *conn,
                                     const ngtcp2_dcid *dcid)
{
  return conn_call_dcid_status(
      conn, NGTCP2_CONNECTION_ID_STATUS_TYPE_DEACTIVATE, dcid);
}
static void conn_call_delete_crypto_aead_ctx(ngtcp2_conn *conn,
                                             ngtcp2_crypto_aead_ctx *aead_ctx)
{
  if (!aead_ctx->native_handle)
  {
    return;
  }

  (static_cast<bool>(
       conn->callbacks.delete_crypto_aead_ctx)
       ? void(0)
       : __assert_fail(
             "conn->callbacks.delete_crypto_aead_ctx", "all.cpp", 19452, __extension__ __PRETTY_FUNCTION__));
  conn->callbacks.delete_crypto_aead_ctx(conn, aead_ctx, conn->user_data);
}
static void
conn_call_delete_crypto_cipher_ctx(ngtcp2_conn *conn,
                                   ngtcp2_crypto_cipher_ctx *cipher_ctx)
{
  if (!cipher_ctx->native_handle)
  {
    return;
  }

  (static_cast<bool>(
       conn->callbacks.delete_crypto_cipher_ctx)
       ? void(0)
       : __assert_fail(
             "conn->callbacks.delete_crypto_cipher_ctx", "all.cpp", 19464, __extension__ __PRETTY_FUNCTION__));
  conn->callbacks.delete_crypto_cipher_ctx(conn, cipher_ctx, conn->user_data);
}
static int crypto_offset_less(const ngtcp2_ksl_key *lhs,
                              const ngtcp2_ksl_key *rhs)
{
  return *(int64_t *)lhs < *(int64_t *)rhs;
}
static int pktns_init(ngtcp2_pktns *pktns, ngtcp2_pktns_id pktns_id,
                      ngtcp2_rst *rst, ngtcp2_cc *cc, ngtcp2_log *log,
                      ngtcp2_qlog *qlog, const ngtcp2_mem *mem)
{
  int rv;
  memset(pktns, 0, sizeof(*pktns));
  rv = ngtcp2_gaptr_init(&pktns->rx.pngap, mem);
  if (rv != 0)
  {
    return rv;
  }
  pktns->tx.last_pkt_num = -1;
  pktns->rx.max_pkt_num = -1;
  pktns->rx.max_ack_eliciting_pkt_num = -1;
  rv = ngtcp2_acktr_init(&pktns->acktr, log, mem);
  if (rv != 0)
  {
    goto fail_acktr_init;
  }
  rv = ngtcp2_strm_init(&pktns->crypto.strm, 0, NGTCP2_STRM_FLAG_NONE, 0, 0,

                        __null, mem);
  if (rv != 0)
  {
    goto fail_crypto_init;
  }
  rv = ngtcp2_ksl_init(&pktns->crypto.tx.frq, crypto_offset_less,
                       sizeof(uint64_t), mem);
  if (rv != 0)
  {
    goto fail_tx_frq_init;
  }
  ngtcp2_rtb_init(&pktns->rtb, pktns_id, &pktns->crypto.strm, rst, cc, log,
                  qlog, mem);
  return 0;
fail_tx_frq_init:
  ngtcp2_strm_free(&pktns->crypto.strm);
fail_crypto_init:
  ngtcp2_acktr_free(&pktns->acktr);
fail_acktr_init:
  ngtcp2_gaptr_free(&pktns->rx.pngap);
  return rv;
}
static int pktns_new(ngtcp2_pktns **ppktns, ngtcp2_pktns_id pktns_id,
                     ngtcp2_rst *rst, ngtcp2_cc *cc, ngtcp2_log *log,
                     ngtcp2_qlog *qlog, const ngtcp2_mem *mem)
{
  int rv;
  *ppktns = ngtcp2_mem_malloc(mem, sizeof(ngtcp2_pktns));
  if (*ppktns ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  rv = pktns_init(*ppktns, pktns_id, rst, cc, log, qlog, mem);
  if (rv != 0)
  {
    ngtcp2_mem_free(mem, *ppktns);
  }
  return rv;
}
static int cycle_less(const ngtcp2_pq_entry *lhs, const ngtcp2_pq_entry *rhs)
{
  ngtcp2_strm *ls = ((ngtcp2_strm *)(void *)((char *)(lhs) -
                                             __builtin_offsetof(
                                                 ngtcp2_strm,
                                                 pe)));
  ngtcp2_strm *rs = ((ngtcp2_strm *)(void *)((char *)(rhs) -
                                             __builtin_offsetof(
                                                 ngtcp2_strm,
                                                 pe)));
  if (ls->cycle == rs->cycle)
  {
    return ls->stream_id < rs->stream_id;
  }
  return rs->cycle - ls->cycle <= 1;
}
static void delete_buffed_pkts(ngtcp2_pkt_chain *pc, const ngtcp2_mem *mem)
{
  ngtcp2_pkt_chain *next;
  for (; pc;)
  {
    next = pc->next;
    ngtcp2_pkt_chain_del(pc, mem);
    pc = next;
  }
}
static void pktns_free(ngtcp2_pktns *pktns, const ngtcp2_mem *mem)
{
  ngtcp2_frame_chain *frc;
  ngtcp2_ksl_it it;
  delete_buffed_pkts(pktns->rx.buffed_pkts, mem);
  ngtcp2_frame_chain_list_del(pktns->tx.frq, mem);
  ngtcp2_crypto_km_del(pktns->crypto.rx.ckm, mem);
  ngtcp2_crypto_km_del(pktns->crypto.tx.ckm, mem);
  for (it = ngtcp2_ksl_begin(&pktns->crypto.tx.frq); !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                                                        __null);
       (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
  {
    frc = ngtcp2_ksl_it_get(&it);
    ngtcp2_frame_chain_del(frc, mem);
  }
  ngtcp2_ksl_free(&pktns->crypto.tx.frq);
  ngtcp2_rtb_free(&pktns->rtb);
  ngtcp2_strm_free(&pktns->crypto.strm);
  ngtcp2_acktr_free(&pktns->acktr);
  ngtcp2_gaptr_free(&pktns->rx.pngap);
}
static void pktns_del(ngtcp2_pktns *pktns, const ngtcp2_mem *mem)
{
  if (pktns ==
      __null)
  {
    return;
  }
  pktns_free(pktns, mem);
  ngtcp2_mem_free(mem, pktns);
}
static void cc_del(ngtcp2_cc *cc, ngtcp2_cc_algo cc_algo,
                   const ngtcp2_mem *mem)
{
  switch (cc_algo)
  {
  case NGTCP2_CC_ALGO_RENO:
    ngtcp2_cc_reno_cc_free(cc, mem);
    break;
  case NGTCP2_CC_ALGO_CUBIC:
    ngtcp2_cc_cubic_cc_free(cc, mem);
    break;
  default:
    break;
  }
}
static int cid_less(const ngtcp2_ksl_key *lhs, const ngtcp2_ksl_key *rhs)
{
  return ngtcp2_cid_less(lhs, rhs);
}
static int ts_retired_less(const ngtcp2_pq_entry *lhs,
                           const ngtcp2_pq_entry *rhs)
{
  const ngtcp2_scid *a = ((ngtcp2_scid *)(void *)((char *)(lhs) -
                                                  __builtin_offsetof(
                                                      ngtcp2_scid,
                                                      pe)));
  const ngtcp2_scid *b = ((ngtcp2_scid *)(void *)((char *)(rhs) -
                                                  __builtin_offsetof(
                                                      ngtcp2_scid,
                                                      pe)));
  return a->ts_retired < b->ts_retired;
}
static void conn_reset_conn_stat_cc(ngtcp2_conn *conn,
                                    ngtcp2_conn_stat *cstat)
{
  cstat->latest_rtt = 0;
  cstat->min_rtt =
      (18446744073709551615UL);
  cstat->smoothed_rtt = conn->local.settings.initial_rtt;
  cstat->rttvar = conn->local.settings.initial_rtt / 2;
  cstat->first_rtt_sample_ts =
      (18446744073709551615UL);
  cstat->pto_count = 0;
  cstat->loss_detection_timer = 0;
  cstat->cwnd =
      ngtcp2_cc_compute_initcwnd(conn->local.settings.max_udp_payload_size);
  cstat->ssthresh =
      (18446744073709551615UL);
  cstat->congestion_recovery_start_ts =
      (18446744073709551615UL);
  cstat->bytes_in_flight = 0;
  cstat->delivery_rate_sec = 0;
  cstat->recv_rate_sec = 0;
}
static void reset_conn_stat_recovery(ngtcp2_conn_stat *cstat)
{
  memset(cstat->loss_time, 0xff, sizeof(cstat->loss_time));
  memset(cstat->last_tx_pkt_ts, 0xff, sizeof(cstat->last_tx_pkt_ts));
}
static void conn_reset_conn_stat(ngtcp2_conn *conn, ngtcp2_conn_stat *cstat)
{
  conn_reset_conn_stat_cc(conn, cstat);
  reset_conn_stat_recovery(cstat);
}
static void conn_reset_rx_rate(ngtcp2_conn *conn)
{
  conn->rx.rate.start_ts =
      (18446744073709551615UL);
  conn->rx.rate.received = 0;
}
static void conn_update_recv_rate(ngtcp2_conn *conn, size_t datalen,
                                  ngtcp2_tstamp ts)
{
  uint64_t bps;
  ngtcp2_duration window;
  conn->rx.rate.received += datalen;
  if (conn->rx.rate.start_ts ==
      (18446744073709551615UL))
  {
    conn->rx.rate.start_ts = ts;
    return;
  }

  (static_cast<bool>(
       conn->cstat.min_rtt)
       ? void(0)
       : __assert_fail(
             "conn->cstat.min_rtt", "all.cpp", 19667, __extension__ __PRETTY_FUNCTION__));
  window = conn->cstat.min_rtt ==
                   (18446744073709551615UL)
               ? conn->cstat.initial_rtt
               : conn->cstat.min_rtt * 2;

  (static_cast<bool>(
       window)
       ? void(0)
       : __assert_fail(
             "window", "all.cpp", 19670, __extension__ __PRETTY_FUNCTION__));
  if (window > ts - conn->rx.rate.start_ts)
  {
    return;
  }
  bps = conn->rx.rate.received * ((uint64_t)1000000000ULL) / (ts - conn->rx.rate.start_ts);
  if (conn->cstat.recv_rate_sec == 0)
  {
    conn->cstat.recv_rate_sec = bps;
  }
  else
  {
    conn->cstat.recv_rate_sec = (conn->cstat.recv_rate_sec * 3 + bps) / 4;
  }
  conn_reset_rx_rate(conn);
  if (conn->cstat.min_rtt !=
      (18446744073709551615UL))
  {
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_CON,
                    "recv_rate_sec=%"
                    "l"
                    "u"
                    " bytes/min_rtt=%"
                    "l"
                    "u",
                    conn->cstat.recv_rate_sec,
                    conn->cstat.recv_rate_sec * conn->cstat.min_rtt /
                        ((uint64_t)1000000000ULL));
  }
}
static void delete_scid(ngtcp2_ksl *scids, const ngtcp2_mem *mem)
{
  ngtcp2_ksl_it it;
  for (it = ngtcp2_ksl_begin(scids); !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                                        __null);
       (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
  {
    ngtcp2_mem_free(mem, ngtcp2_ksl_it_get(&it));
  }
}
static ngtcp2_duration conn_compute_pto(ngtcp2_conn *conn,
                                        ngtcp2_pktns *pktns)
{
  ngtcp2_conn_stat *cstat = &conn->cstat;
  ngtcp2_duration var = ((4 * cstat->rttvar) > (((uint64_t)1000000ULL)) ? (4 * cstat->rttvar) : (((uint64_t)1000000ULL)));
  ngtcp2_duration max_ack_delay =
      pktns->rtb.pktns_id == NGTCP2_PKTNS_ID_APP
          ? conn->remote.transport_params.max_ack_delay
          : 0;
  return cstat->smoothed_rtt + var + max_ack_delay;
}
static void conn_handle_tx_ecn(ngtcp2_conn *conn, ngtcp2_pkt_info *pi,
                               uint8_t *prtb_entry_flags, ngtcp2_pktns *pktns,
                               const ngtcp2_pkt_hd *hd, ngtcp2_tstamp ts)
{

  (static_cast<bool>(
       pi)
       ? void(0)
       : __assert_fail(
             "pi", "all.cpp", 19721, __extension__ __PRETTY_FUNCTION__));
  if (pi->ecn != NGTCP2_ECN_NOT_ECT)
  {
    if (pktns->tx.ecn.start_pkt_num ==
        (9223372036854775807L))
    {
      pktns->tx.ecn.start_pkt_num = hd->pkt_num;
    }
    ++pktns->tx.ecn.validation_pkt_sent;
    if (prtb_entry_flags)
    {
      *prtb_entry_flags |= NGTCP2_RTB_FLAG_ECN;
    }
    ++pktns->tx.ecn.ect0;
    return;
  }
  switch (conn->tx.ecn.state)
  {
  case NGTCP2_ECN_STATE_TESTING:
    if (conn->tx.ecn.validation_start_ts ==
        (18446744073709551615UL))
    {

      (static_cast<bool>(
           0 == pktns->tx.ecn.validation_pkt_sent)
           ? void(0)
           : __assert_fail(
                 "0 == pktns->tx.ecn.validation_pkt_sent", "all.cpp", 19741, __extension__ __PRETTY_FUNCTION__));

      (static_cast<bool>(
           0 == pktns->tx.ecn.validation_pkt_lost)
           ? void(0)
           : __assert_fail(
                 "0 == pktns->tx.ecn.validation_pkt_lost", "all.cpp", 19742, __extension__ __PRETTY_FUNCTION__));
      conn->tx.ecn.validation_start_ts = ts;
    }
    else if (ts - conn->tx.ecn.validation_start_ts >=
             3 * conn_compute_pto(conn, pktns))
    {
      conn->tx.ecn.state = NGTCP2_ECN_STATE_UNKNOWN;
      break;
    }
    if (pktns->tx.ecn.start_pkt_num ==
        (9223372036854775807L))
    {
      pktns->tx.ecn.start_pkt_num = hd->pkt_num;
    }
    ++pktns->tx.ecn.validation_pkt_sent;
    if (++conn->tx.ecn.dgram_sent == 10)
    {
      conn->tx.ecn.state = NGTCP2_ECN_STATE_UNKNOWN;
    }
  case NGTCP2_ECN_STATE_CAPABLE:

    (static_cast<bool>(
         NGTCP2_ECN_NOT_ECT == pi->ecn)
         ? void(0)
         : __assert_fail(
               "NGTCP2_ECN_NOT_ECT == pi->ecn", "all.cpp", 19761, __extension__ __PRETTY_FUNCTION__));
    pi->ecn = NGTCP2_ECN_ECT_0;
    if (prtb_entry_flags)
    {
      *prtb_entry_flags |= NGTCP2_RTB_FLAG_ECN;
    }
    ++pktns->tx.ecn.ect0;
    break;
  case NGTCP2_ECN_STATE_UNKNOWN:
  case NGTCP2_ECN_STATE_FAILED:
    break;
  default:

    (static_cast<bool>(
         0)
         ? void(0)
         : __assert_fail(
               "0", "all.cpp", 19773, __extension__ __PRETTY_FUNCTION__));
  }
}
static void conn_reset_ecn_validation_state(ngtcp2_conn *conn)
{
  ngtcp2_pktns *in_pktns = conn->in_pktns;
  ngtcp2_pktns *hs_pktns = conn->hs_pktns;
  ngtcp2_pktns *pktns = &conn->pktns;
  conn->tx.ecn.state = NGTCP2_ECN_STATE_TESTING;
  conn->tx.ecn.validation_start_ts =
      (18446744073709551615UL);
  conn->tx.ecn.dgram_sent = 0;
  if (in_pktns)
  {
    in_pktns->tx.ecn.start_pkt_num =
        (9223372036854775807L);
    in_pktns->tx.ecn.validation_pkt_sent = 0;
    in_pktns->tx.ecn.validation_pkt_lost = 0;
  }
  if (hs_pktns)
  {
    hs_pktns->tx.ecn.start_pkt_num =
        (9223372036854775807L);
    hs_pktns->tx.ecn.validation_pkt_sent = 0;
    hs_pktns->tx.ecn.validation_pkt_lost = 0;
  }
  pktns->tx.ecn.start_pkt_num =
      (9223372036854775807L);
  pktns->tx.ecn.validation_pkt_sent = 0;
  pktns->tx.ecn.validation_pkt_lost = 0;
}
static int conn_new(ngtcp2_conn **pconn, const ngtcp2_cid *dcid,
                    const ngtcp2_cid *scid, const ngtcp2_path *path,
                    uint32_t version, const ngtcp2_conn_callbacks *callbacks,
                    const ngtcp2_settings *settings, const ngtcp2_mem *mem,
                    void *user_data, int server)
{
  int rv;
  ngtcp2_scid *scident;
  const ngtcp2_transport_params *params = &settings->transport_params;
  uint8_t *buf;

  (static_cast<bool>(
       settings->max_window <= ((1ULL << 62) - 1))
       ? void(0)
       : __assert_fail(
             "settings->max_window <= NGTCP2_MAX_VARINT", "all.cpp", 19812, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       settings->max_stream_window <= ((1ULL << 62) - 1))
       ? void(0)
       : __assert_fail(
             "settings->max_stream_window <= NGTCP2_MAX_VARINT", "all.cpp", 19813, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       params->active_connection_id_limit <= 8)
       ? void(0)
       : __assert_fail(
             "params->active_connection_id_limit <= NGTCP2_MAX_DCID_POOL_SIZE", "all.cpp", 19814, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       params->initial_max_data <= ((1ULL << 62) - 1))
       ? void(0)
       : __assert_fail(
             "params->initial_max_data <= NGTCP2_MAX_VARINT", "all.cpp", 19815, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       params->initial_max_stream_data_bidi_local <= ((1ULL << 62) - 1))
       ? void(0)
       : __assert_fail(
             "params->initial_max_stream_data_bidi_local <= NGTCP2_MAX_VARINT", "all.cpp", 19816, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       params->initial_max_stream_data_bidi_remote <= ((1ULL << 62) - 1))
       ? void(0)
       : __assert_fail(
             "params->initial_max_stream_data_bidi_remote <= NGTCP2_MAX_VARINT", "all.cpp", 19817, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       params->initial_max_stream_data_uni <= ((1ULL << 62) - 1))
       ? void(0)
       : __assert_fail(
             "params->initial_max_stream_data_uni <= NGTCP2_MAX_VARINT", "all.cpp", 19818, __extension__ __PRETTY_FUNCTION__));
  if (mem ==
      __null)
  {
    mem = ngtcp2_mem_default();
  }
  *pconn = ngtcp2_mem_calloc(mem, 1, sizeof(ngtcp2_conn));
  if (*pconn ==
      __null)
  {
    rv = NGTCP2_ERR_NOMEM;
    goto fail_conn;
  }
  rv = ngtcp2_ringbuf_init(&(*pconn)->dcid.bound,
                           4, sizeof(ngtcp2_dcid),
                           mem);
  if (rv != 0)
  {
    goto fail_dcid_bound_init;
  }
  rv = ngtcp2_ringbuf_init(&(*pconn)->dcid.unused, 8,
                           sizeof(ngtcp2_dcid), mem);
  if (rv != 0)
  {
    goto fail_dcid_unused_init;
  }
  rv =
      ngtcp2_ringbuf_init(&(*pconn)->dcid.retired, 2,
                          sizeof(ngtcp2_dcid), mem);
  if (rv != 0)
  {
    goto fail_dcid_retired_init;
  }
  rv = ngtcp2_gaptr_init(&(*pconn)->dcid.seqgap, mem);
  if (rv != 0)
  {
    goto fail_seqgap_init;
  }
  rv = ngtcp2_ksl_init(&(*pconn)->scid.set, cid_less, sizeof(ngtcp2_cid), mem);
  if (rv != 0)
  {
    goto fail_scid_set_init;
  }
  ngtcp2_pq_init(&(*pconn)->scid.used, ts_retired_less, mem);
  rv = ngtcp2_map_init(&(*pconn)->strms, mem);
  if (rv != 0)
  {
    goto fail_strms_init;
  }
  ngtcp2_pq_init(&(*pconn)->tx.strmq, cycle_less, mem);
  rv = ngtcp2_idtr_init(&(*pconn)->remote.bidi.idtr, !server, mem);
  if (rv != 0)
  {
    goto fail_remote_bidi_idtr_init;
  }
  rv = ngtcp2_idtr_init(&(*pconn)->remote.uni.idtr, !server, mem);
  if (rv != 0)
  {
    goto fail_remote_uni_idtr_init;
  }
  rv = ngtcp2_ringbuf_init(&(*pconn)->rx.path_challenge, 4,
                           sizeof(ngtcp2_path_challenge_entry), mem);
  if (rv != 0)
  {
    goto fail_rx_path_challenge_init;
  }
  ngtcp2_log_init(&(*pconn)->log, scid, settings->log_printf,
                  settings->initial_ts, user_data);
  ngtcp2_qlog_init(&(*pconn)->qlog, settings->qlog.write, settings->initial_ts,
                   user_data);
  if ((*pconn)->qlog.write)
  {
    buf = ngtcp2_mem_malloc(mem, 4096);
    if (buf ==
        __null)
    {
      goto fail_qlog_buf;
    }
    ngtcp2_buf_init(&(*pconn)->qlog.buf, buf, 4096);
  }
  (*pconn)->local.settings = *settings;
  if (settings->token.len)
  {
    buf = ngtcp2_mem_malloc(mem, settings->token.len);
    if (buf ==
        __null)
    {
      goto fail_token;
    }
    memcpy(buf, settings->token.base, settings->token.len);
    (*pconn)->local.settings.token.base = buf;
  }
  else
  {
    (*pconn)->local.settings.token.base =
        __null;
    (*pconn)->local.settings.token.len = 0;
  }
  if (settings->max_udp_payload_size == 0)
  {
    (*pconn)->local.settings.max_udp_payload_size = 1200;
  }
  conn_reset_conn_stat(*pconn, &(*pconn)->cstat);
  (*pconn)->cstat.initial_rtt = settings->initial_rtt;
  (*pconn)->cstat.max_udp_payload_size =
      (*pconn)->local.settings.max_udp_payload_size;
  ngtcp2_rst_init(&(*pconn)->rst);
  (*pconn)->cc_algo = settings->cc_algo;
  switch (settings->cc_algo)
  {
  case NGTCP2_CC_ALGO_RENO:
    rv = ngtcp2_cc_reno_cc_init(&(*pconn)->cc, &(*pconn)->log, mem);
    if (rv != 0)
    {
      goto fail_cc_init;
    }
    break;
  case NGTCP2_CC_ALGO_CUBIC:
    rv = ngtcp2_cc_cubic_cc_init(&(*pconn)->cc, &(*pconn)->log, mem);
    if (rv != 0)
    {
      goto fail_cc_init;
    }
    break;
  case NGTCP2_CC_ALGO_CUSTOM:

    (static_cast<bool>(
         settings->cc)
         ? void(0)
         : __assert_fail(
               "settings->cc", "all.cpp", 19938, __extension__ __PRETTY_FUNCTION__));
    (*pconn)->cc = *settings->cc;
    (*pconn)->cc.ccb->log = &(*pconn)->log;
    break;
  default:

    (static_cast<bool>(
         0)
         ? void(0)
         : __assert_fail(
               "0", "all.cpp", 19943, __extension__ __PRETTY_FUNCTION__));
  }
  conn_reset_rx_rate(*pconn);
  rv = pktns_new(&(*pconn)->in_pktns, NGTCP2_PKTNS_ID_INITIAL, &(*pconn)->rst,
                 &(*pconn)->cc, &(*pconn)->log, &(*pconn)->qlog, mem);
  if (rv != 0)
  {
    goto fail_in_pktns_init;
  }
  rv = pktns_new(&(*pconn)->hs_pktns, NGTCP2_PKTNS_ID_HANDSHAKE, &(*pconn)->rst,
                 &(*pconn)->cc, &(*pconn)->log, &(*pconn)->qlog, mem);
  if (rv != 0)
  {
    goto fail_hs_pktns_init;
  }
  rv = pktns_init(&(*pconn)->pktns, NGTCP2_PKTNS_ID_APP, &(*pconn)->rst,
                  &(*pconn)->cc, &(*pconn)->log, &(*pconn)->qlog, mem);
  if (rv != 0)
  {
    goto fail_pktns_init;
  }
  scident = ngtcp2_mem_malloc(mem, sizeof(*scident));
  if (scident ==
      __null)
  {
    rv = NGTCP2_ERR_NOMEM;
    goto fail_scident;
  }
  ngtcp2_scid_init(scident, 0, scid,
                   __null);
  rv = ngtcp2_ksl_insert(&(*pconn)->scid.set,
                         __null, &scident->cid, scident);
  if (rv != 0)
  {
    goto fail_scid_set_insert;
  }
  scident =
      __null;
  ngtcp2_dcid_init(&(*pconn)->dcid.current, 0, dcid,
                   __null);
  ngtcp2_path_copy(&(*pconn)->dcid.current.ps.path, path);
  rv = ngtcp2_gaptr_push(&(*pconn)->dcid.seqgap, 0, 1);
  if (rv != 0)
  {
    goto fail_seqgap_push;
  }
  (*pconn)->server = server;
  (*pconn)->oscid = *scid;
  (*pconn)->callbacks = *callbacks;
  (*pconn)->version = version;
  (*pconn)->mem = mem;
  (*pconn)->user_data = user_data;
  (*pconn)->idle_ts = settings->initial_ts;
  (*pconn)->crypto.key_update.confirmed_ts =
      (18446744073709551615UL);
  (*pconn)->tx.last_max_data_ts =
      (18446744073709551615UL);
  conn_reset_ecn_validation_state(*pconn);
  ngtcp2_qlog_start(&(*pconn)->qlog, server ? &settings->qlog.odcid : dcid,
                    server);
  return 0;
fail_seqgap_push:
fail_scid_set_insert:
  ngtcp2_mem_free(mem, scident);
fail_scident:
  ngtcp2_mem_free(mem, (*pconn)->local.settings.token.base);
fail_token:
  pktns_free(&(*pconn)->pktns, mem);
fail_pktns_init:
  pktns_del((*pconn)->hs_pktns, mem);
fail_hs_pktns_init:
  pktns_del((*pconn)->in_pktns, mem);
fail_in_pktns_init:
  cc_del(&(*pconn)->cc, settings->cc_algo, mem);
fail_cc_init:
  ngtcp2_mem_free(mem, (*pconn)->qlog.buf.begin);
fail_qlog_buf:
  ngtcp2_ringbuf_free(&(*pconn)->rx.path_challenge);
fail_rx_path_challenge_init:
  ngtcp2_idtr_free(&(*pconn)->remote.uni.idtr);
fail_remote_uni_idtr_init:
  ngtcp2_idtr_free(&(*pconn)->remote.bidi.idtr);
fail_remote_bidi_idtr_init:
  ngtcp2_map_free(&(*pconn)->strms);
fail_strms_init:
  delete_scid(&(*pconn)->scid.set, mem);
  ngtcp2_ksl_free(&(*pconn)->scid.set);
fail_scid_set_init:
  ngtcp2_gaptr_free(&(*pconn)->dcid.seqgap);
fail_seqgap_init:
  ngtcp2_ringbuf_free(&(*pconn)->dcid.retired);
fail_dcid_retired_init:
  ngtcp2_ringbuf_free(&(*pconn)->dcid.unused);
fail_dcid_unused_init:
  ngtcp2_ringbuf_free(&(*pconn)->dcid.bound);
fail_dcid_bound_init:
  ngtcp2_mem_free(mem, *pconn);
fail_conn:
  return rv;
}
int ngtcp2_conn_client_new(ngtcp2_conn **pconn, const ngtcp2_cid *dcid,
                           const ngtcp2_cid *scid, const ngtcp2_path *path,
                           uint32_t version,
                           const ngtcp2_conn_callbacks *callbacks,
                           const ngtcp2_settings *settings,
                           const ngtcp2_mem *mem, void *user_data)
{
  int rv;
  rv = conn_new(pconn, dcid, scid, path, version, callbacks, settings, mem,
                user_data, 0);
  if (rv != 0)
  {
    return rv;
  }
  (*pconn)->rcid = *dcid;
  (*pconn)->state = NGTCP2_CS_CLIENT_INITIAL;
  (*pconn)->local.bidi.next_stream_id = 0;
  (*pconn)->local.uni.next_stream_id = 2;
  rv = ngtcp2_conn_commit_local_transport_params(*pconn);
  if (rv != 0)
  {
    ngtcp2_conn_del(*pconn);
    return rv;
  }
  ngtcp2_qlog_parameters_set_transport_params(
      &(*pconn)->qlog, &(*pconn)->local.settings.transport_params,
      (*pconn)->server, NGTCP2_QLOG_SIDE_LOCAL);
  return 0;
}
int ngtcp2_conn_server_new(ngtcp2_conn **pconn, const ngtcp2_cid *dcid,
                           const ngtcp2_cid *scid, const ngtcp2_path *path,
                           uint32_t version,
                           const ngtcp2_conn_callbacks *callbacks,
                           const ngtcp2_settings *settings,
                           const ngtcp2_mem *mem, void *user_data)
{
  int rv;
  rv = conn_new(pconn, dcid, scid, path, version, callbacks, settings, mem,
                user_data, 1);
  if (rv != 0)
  {
    return rv;
  }
  (*pconn)->state = NGTCP2_CS_SERVER_INITIAL;
  (*pconn)->local.bidi.next_stream_id = 1;
  (*pconn)->local.uni.next_stream_id = 3;
  if ((*pconn)->local.settings.token.len)
  {
    (*pconn)->flags |= NGTCP2_CONN_FLAG_SADDR_VERIFIED;
  }
  return 0;
}
static uint64_t conn_fc_credits(ngtcp2_conn *conn, ngtcp2_strm *strm)
{
  return ((strm->tx.max_offset - strm->tx.offset) < (conn->tx.max_offset - conn->tx.offset) ? (strm->tx.max_offset - strm->tx.offset) : (conn->tx.max_offset - conn->tx.offset));
}
static size_t conn_enforce_flow_control(ngtcp2_conn *conn, ngtcp2_strm *strm,
                                        size_t len)
{
  uint64_t fc_credits = conn_fc_credits(conn, strm);
  return (size_t)(((uint64_t)len) < (fc_credits) ? ((uint64_t)len) : (fc_credits));
}
static int delete_strms_each(ngtcp2_map_entry *ent, void *ptr)
{
  const ngtcp2_mem *mem = ptr;
  ngtcp2_strm *s = ((ngtcp2_strm *)(void *)((char *)(ent) -
                                            __builtin_offsetof(
                                                ngtcp2_strm,
                                                me)));
  ngtcp2_strm_free(s);
  ngtcp2_mem_free(mem, s);
  return 0;
}
void ngtcp2_conn_del(ngtcp2_conn *conn)
{
  if (conn ==
      __null)
  {
    return;
  }
  ngtcp2_qlog_end(&conn->qlog);
  if (conn->early.ckm)
  {
    conn_call_delete_crypto_aead_ctx(conn, &conn->early.ckm->aead_ctx);
  }
  conn_call_delete_crypto_cipher_ctx(conn, &conn->early.hp_ctx);
  if (conn->crypto.key_update.old_rx_ckm)
  {
    conn_call_delete_crypto_aead_ctx(
        conn, &conn->crypto.key_update.old_rx_ckm->aead_ctx);
  }
  if (conn->crypto.key_update.new_rx_ckm)
  {
    conn_call_delete_crypto_aead_ctx(
        conn, &conn->crypto.key_update.new_rx_ckm->aead_ctx);
  }
  if (conn->crypto.key_update.new_tx_ckm)
  {
    conn_call_delete_crypto_aead_ctx(
        conn, &conn->crypto.key_update.new_tx_ckm->aead_ctx);
  }
  if (conn->pktns.crypto.rx.ckm)
  {
    conn_call_delete_crypto_aead_ctx(conn,
                                     &conn->pktns.crypto.rx.ckm->aead_ctx);
  }
  conn_call_delete_crypto_cipher_ctx(conn, &conn->pktns.crypto.rx.hp_ctx);
  if (conn->pktns.crypto.tx.ckm)
  {
    conn_call_delete_crypto_aead_ctx(conn,
                                     &conn->pktns.crypto.tx.ckm->aead_ctx);
  }
  conn_call_delete_crypto_cipher_ctx(conn, &conn->pktns.crypto.tx.hp_ctx);
  if (conn->hs_pktns)
  {
    if (conn->hs_pktns->crypto.rx.ckm)
    {
      conn_call_delete_crypto_aead_ctx(
          conn, &conn->hs_pktns->crypto.rx.ckm->aead_ctx);
    }
    conn_call_delete_crypto_cipher_ctx(conn, &conn->hs_pktns->crypto.rx.hp_ctx);
    if (conn->hs_pktns->crypto.tx.ckm)
    {
      conn_call_delete_crypto_aead_ctx(
          conn, &conn->hs_pktns->crypto.tx.ckm->aead_ctx);
    }
    conn_call_delete_crypto_cipher_ctx(conn, &conn->hs_pktns->crypto.tx.hp_ctx);
  }
  if (conn->in_pktns)
  {
    if (conn->in_pktns->crypto.rx.ckm)
    {
      conn_call_delete_crypto_aead_ctx(
          conn, &conn->in_pktns->crypto.rx.ckm->aead_ctx);
    }
    conn_call_delete_crypto_cipher_ctx(conn, &conn->in_pktns->crypto.rx.hp_ctx);
    if (conn->in_pktns->crypto.tx.ckm)
    {
      conn_call_delete_crypto_aead_ctx(
          conn, &conn->in_pktns->crypto.tx.ckm->aead_ctx);
    }
    conn_call_delete_crypto_cipher_ctx(conn, &conn->in_pktns->crypto.tx.hp_ctx);
  }
  conn_call_delete_crypto_aead_ctx(conn, &conn->crypto.retry_aead_ctx);
  ngtcp2_mem_free(conn->mem, conn->crypto.decrypt_buf.base);
  ngtcp2_mem_free(conn->mem, conn->crypto.decrypt_hp_buf.base);
  ngtcp2_mem_free(conn->mem, conn->local.settings.token.base);
  ngtcp2_crypto_km_del(conn->crypto.key_update.old_rx_ckm, conn->mem);
  ngtcp2_crypto_km_del(conn->crypto.key_update.new_rx_ckm, conn->mem);
  ngtcp2_crypto_km_del(conn->crypto.key_update.new_tx_ckm, conn->mem);
  ngtcp2_crypto_km_del(conn->early.ckm, conn->mem);
  pktns_free(&conn->pktns, conn->mem);
  pktns_del(conn->hs_pktns, conn->mem);
  pktns_del(conn->in_pktns, conn->mem);
  cc_del(&conn->cc, conn->cc_algo, conn->mem);
  ngtcp2_mem_free(conn->mem, conn->qlog.buf.begin);
  ngtcp2_ringbuf_free(&conn->rx.path_challenge);
  ngtcp2_pv_del(conn->pv);
  ngtcp2_idtr_free(&conn->remote.uni.idtr);
  ngtcp2_idtr_free(&conn->remote.bidi.idtr);
  ngtcp2_mem_free(conn->mem, conn->tx.ack);
  ngtcp2_pq_free(&conn->tx.strmq);
  ngtcp2_map_each_free(&conn->strms, delete_strms_each, (void *)conn->mem);
  ngtcp2_map_free(&conn->strms);
  ngtcp2_pq_free(&conn->scid.used);
  delete_scid(&conn->scid.set, conn->mem);
  ngtcp2_ksl_free(&conn->scid.set);
  ngtcp2_gaptr_free(&conn->dcid.seqgap);
  ngtcp2_ringbuf_free(&conn->dcid.retired);
  ngtcp2_ringbuf_free(&conn->dcid.unused);
  ngtcp2_ringbuf_free(&conn->dcid.bound);
  ngtcp2_mem_free(conn->mem, conn);
}
static int conn_ensure_ack_blks(ngtcp2_conn *conn, size_t n)
{
  ngtcp2_frame *fr;
  size_t max = conn->tx.max_ack_blks;
  if (n <= max)
  {
    return 0;
  }
  max *= 2;

  (static_cast<bool>(
       max >= n)
       ? void(0)
       : __assert_fail(
             "max >= n", "all.cpp", 20223, __extension__ __PRETTY_FUNCTION__));
  fr = ngtcp2_mem_realloc(conn->mem, conn->tx.ack,
                          sizeof(ngtcp2_ack) + sizeof(ngtcp2_ack_blk) * max);
  if (fr ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  conn->tx.ack = fr;
  conn->tx.max_ack_blks = max;
  return 0;
}
static ngtcp2_duration conn_compute_ack_delay(ngtcp2_conn *conn)
{
  return ((conn->local.settings.transport_params.max_ack_delay) < (conn->cstat.smoothed_rtt / 8) ? (conn->local.settings.transport_params.max_ack_delay) : (conn->cstat.smoothed_rtt / 8));
}
static int conn_create_ack_frame(ngtcp2_conn *conn, ngtcp2_frame **pfr,
                                 ngtcp2_pktns *pktns, uint8_t type,
                                 ngtcp2_tstamp ts, ngtcp2_duration ack_delay,
                                 uint64_t ack_delay_exponent)
{
  const size_t initial_max_ack_blks = 8;
  int64_t last_pkt_num;
  ngtcp2_acktr *acktr = &pktns->acktr;
  ngtcp2_ack_blk *blk;
  ngtcp2_ksl_it it;
  ngtcp2_acktr_entry *rpkt;
  ngtcp2_ack *ack;
  size_t blk_idx;
  ngtcp2_tstamp largest_ack_ts;
  int rv;
  if (acktr->flags & NGTCP2_ACKTR_FLAG_IMMEDIATE_ACK)
  {
    ack_delay = 0;
  }
  if (!ngtcp2_acktr_require_active_ack(acktr, ack_delay, ts))
  {
    return 0;
  }
  it = ngtcp2_acktr_get(acktr);
  if (((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                        __null))
  {
    ngtcp2_acktr_commit_ack(acktr);
    return 0;
  }
  if (conn->tx.ack ==
      __null)
  {
    conn->tx.ack = ngtcp2_mem_malloc(
        conn->mem,
        sizeof(ngtcp2_ack) + sizeof(ngtcp2_ack_blk) * initial_max_ack_blks);
    if (conn->tx.ack ==
        __null)
    {
      return NGTCP2_ERR_NOMEM;
    }
    conn->tx.max_ack_blks = initial_max_ack_blks;
  }
  ack = &conn->tx.ack->ack;
  if (pktns->rx.ecn.ect0 || pktns->rx.ecn.ect1 || pktns->rx.ecn.ce)
  {
    ack->type = NGTCP2_FRAME_ACK_ECN;
    ack->ecn.ect0 = pktns->rx.ecn.ect0;
    ack->ecn.ect1 = pktns->rx.ecn.ect1;
    ack->ecn.ce = pktns->rx.ecn.ce;
  }
  else
  {
    ack->type = NGTCP2_FRAME_ACK;
  }
  ack->num_blks = 0;
  rpkt = ngtcp2_ksl_it_get(&it);
  if (rpkt->pkt_num == pktns->rx.max_pkt_num)
  {
    last_pkt_num = rpkt->pkt_num - (int64_t)(rpkt->len - 1);
    largest_ack_ts = rpkt->tstamp;
    ack->largest_ack = rpkt->pkt_num;
    ack->first_ack_blklen = rpkt->len - 1;
    (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0);
  }
  else
  {

    (static_cast<bool>(
         rpkt->pkt_num < pktns->rx.max_pkt_num)
         ? void(0)
         : __assert_fail(
               "rpkt->pkt_num < pktns->rx.max_pkt_num", "all.cpp", 20305, __extension__ __PRETTY_FUNCTION__));
    last_pkt_num = pktns->rx.max_pkt_num;
    largest_ack_ts = pktns->rx.max_pkt_ts;
    ack->largest_ack = pktns->rx.max_pkt_num;
    ack->first_ack_blklen = 0;
  }
  if (type == NGTCP2_PKT_SHORT)
  {
    ack->ack_delay_unscaled = ts - largest_ack_ts;
    ack->ack_delay = ack->ack_delay_unscaled / ((uint64_t)1000ULL) /
                     (1UL << ack_delay_exponent);
  }
  else
  {
    ack->ack_delay_unscaled = 0;
    ack->ack_delay = 0;
  }
  for (; !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                            __null);
       (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
  {
    if (ack->num_blks == 32)
    {
      break;
    }
    rpkt = ngtcp2_ksl_it_get(&it);
    blk_idx = ack->num_blks++;
    rv = conn_ensure_ack_blks(conn, ack->num_blks);
    if (rv != 0)
    {
      return rv;
    }
    ack = &conn->tx.ack->ack;
    blk = &ack->blks[blk_idx];
    blk->gap = (uint64_t)(last_pkt_num - rpkt->pkt_num - 2);
    blk->blklen = rpkt->len - 1;
    last_pkt_num = rpkt->pkt_num - (int64_t)(rpkt->len - 1);
  }
  if (!((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                         __null))
  {
    ngtcp2_acktr_forget(acktr, ngtcp2_ksl_it_get(&it));
  }
  *pfr = conn->tx.ack;
  return 0;
}
static int conn_ppe_write_frame_hd_log(ngtcp2_conn *conn, ngtcp2_ppe *ppe,
                                       int *hd_logged, const ngtcp2_pkt_hd *hd,
                                       ngtcp2_frame *fr)
{
  int rv;
  rv = ngtcp2_ppe_encode_frame(ppe, fr);
  if (rv != 0)
  {

    (static_cast<bool>(
         NGTCP2_ERR_NOBUF == rv)
         ? void(0)
         : __assert_fail(
               "NGTCP2_ERR_NOBUF == rv", "all.cpp", 20357, __extension__ __PRETTY_FUNCTION__));
    return rv;
  }
  if (hd_logged && !*hd_logged)
  {
    *hd_logged = 1;
    ngtcp2_log_tx_pkt_hd(&conn->log, hd);
    ngtcp2_qlog_pkt_sent_start(&conn->qlog, hd);
  }
  ngtcp2_log_tx_fr(&conn->log, hd, fr);
  ngtcp2_qlog_write_frame(&conn->qlog, fr);
  return 0;
}
static int conn_ppe_write_frame(ngtcp2_conn *conn, ngtcp2_ppe *ppe,
                                const ngtcp2_pkt_hd *hd, ngtcp2_frame *fr)
{
  return conn_ppe_write_frame_hd_log(conn, ppe,
                                     __null, hd, fr);
}
static int conn_on_pkt_sent(ngtcp2_conn *conn, ngtcp2_rtb *rtb,
                            ngtcp2_rtb_entry *ent)
{
  int rv;
  rv = ngtcp2_rtb_add(rtb, ent, &conn->cstat);
  if (rv != 0)
  {
    return rv;
  }
  if (ent->flags & NGTCP2_RTB_FLAG_ACK_ELICITING)
  {
    conn->cstat.last_tx_pkt_ts[rtb->pktns_id] = ent->ts;
  }
  ngtcp2_conn_set_loss_detection_timer(conn, ent->ts);
  return 0;
}
static size_t pktns_select_pkt_numlen(ngtcp2_pktns *pktns)
{
  int64_t pkt_num = pktns->tx.last_pkt_num + 1;
  ngtcp2_rtb *rtb = &pktns->rtb;
  int64_t n = pkt_num - rtb->largest_acked_tx_pkt_num;
  if (((int64_t)((1ll << 62) - 1)) / 2 <= pkt_num)
  {
    return 4;
  }
  n = n * 2 + 1;
  if (n > 0xffffff)
  {
    return 4;
  }
  if (n > 0xffff)
  {
    return 3;
  }
  if (n > 0xff)
  {
    return 2;
  }
  return 1;
}
static uint64_t conn_cwnd_is_zero(ngtcp2_conn *conn)
{
  uint64_t bytes_in_flight = conn->cstat.bytes_in_flight;
  uint64_t cwnd =
      conn->pv && (conn->pv->flags & NGTCP2_PV_FLAG_FALLBACK_ON_FAILURE)
          ? ngtcp2_cc_compute_initcwnd(conn->cstat.max_udp_payload_size)
          : conn->cstat.cwnd;
  return bytes_in_flight >= cwnd;
}
static size_t conn_retry_early_payloadlen(ngtcp2_conn *conn)
{
  ngtcp2_frame_chain *frc;
  ngtcp2_strm *strm;
  for (; !ngtcp2_pq_empty(&conn->tx.strmq);)
  {
    strm = ngtcp2_conn_tx_strmq_top(conn);
    if (ngtcp2_strm_streamfrq_empty(strm))
    {
      ngtcp2_conn_tx_strmq_pop(conn);
      continue;
    }
    frc = ngtcp2_strm_streamfrq_top(strm);
    return ngtcp2_vec_len(frc->fr.stream.data, frc->fr.stream.datacnt) +
           (1 + 8 + 8 + 8);
  }
  return 0;
}
static void conn_cryptofrq_clear(ngtcp2_conn *conn, ngtcp2_pktns *pktns)
{
  ngtcp2_frame_chain *frc;
  ngtcp2_ksl_it it;
  for (it = ngtcp2_ksl_begin(&pktns->crypto.tx.frq); !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                                                        __null);
       (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
  {
    frc = ngtcp2_ksl_it_get(&it);
    ngtcp2_frame_chain_del(frc, conn->mem);
  }
  ngtcp2_ksl_clear(&pktns->crypto.tx.frq);
}
static uint64_t conn_cryptofrq_unacked_offset(ngtcp2_conn *conn,
                                              ngtcp2_pktns *pktns)
{
  ngtcp2_frame_chain *frc;
  ngtcp2_crypto *fr;
  ngtcp2_range gap;
  ngtcp2_rtb *rtb = &pktns->rtb;
  ngtcp2_ksl_it it;
  size_t datalen;
  (void)conn;
  for (it = ngtcp2_ksl_begin(&pktns->crypto.tx.frq); !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                                                        __null);
       (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
  {
    frc = ngtcp2_ksl_it_get(&it);
    fr = &frc->fr.crypto;
    gap = ngtcp2_strm_get_unacked_range_after(rtb->crypto, fr->offset);
    datalen = ngtcp2_vec_len(fr->data, fr->datacnt);
    if (gap.begin <= fr->offset)
    {
      return fr->offset;
    }
    if (gap.begin < fr->offset + datalen)
    {
      return gap.begin;
    }
  }
  return (uint64_t)-1;
}
static int conn_cryptofrq_unacked_pop(ngtcp2_conn *conn, ngtcp2_pktns *pktns,
                                      ngtcp2_frame_chain **pfrc)
{
  ngtcp2_frame_chain *frc, *nfrc;
  ngtcp2_crypto *fr, *nfr;
  uint64_t offset, end_offset;
  size_t idx, end_idx;
  uint64_t base_offset, end_base_offset;
  ngtcp2_range gap;
  ngtcp2_rtb *rtb = &pktns->rtb;
  ngtcp2_vec *v;
  int rv;
  ngtcp2_ksl_it it;
  *pfrc =
      __null;
  for (it = ngtcp2_ksl_begin(&pktns->crypto.tx.frq); !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                                                        __null);)
  {
    frc = ngtcp2_ksl_it_get(&it);
    fr = &frc->fr.crypto;
    ngtcp2_ksl_remove(&pktns->crypto.tx.frq, &it, &fr->offset);
    idx = 0;
    offset = fr->offset;
    base_offset = 0;
    gap = ngtcp2_strm_get_unacked_range_after(rtb->crypto, offset);
    if (gap.begin < offset)
    {
      gap.begin = offset;
    }
    for (; idx < fr->datacnt && offset < gap.begin; ++idx)
    {
      v = &fr->data[idx];
      if (offset + v->len > gap.begin)
      {
        base_offset = gap.begin - offset;
        break;
      }
      offset += v->len;
    }
    if (idx == fr->datacnt)
    {
      ngtcp2_frame_chain_del(frc, conn->mem);
      continue;
    }

    (static_cast<bool>(
         gap.begin == offset + base_offset)
         ? void(0)
         : __assert_fail(
               "gap.begin == offset + base_offset", "all.cpp", 20532, __extension__ __PRETTY_FUNCTION__));
    end_idx = idx;
    end_offset = offset;
    end_base_offset = 0;
    for (; end_idx < fr->datacnt; ++end_idx)
    {
      v = &fr->data[end_idx];
      if (end_offset + v->len > gap.end)
      {
        end_base_offset = gap.end - end_offset;
        break;
      }
      end_offset += v->len;
    }
    if (fr->offset == offset && base_offset == 0 && fr->datacnt == end_idx)
    {
      *pfrc = frc;
      return 0;
    }
    if (fr->datacnt == end_idx)
    {
      memmove(fr->data, fr->data + idx, sizeof(fr->data[0]) * (end_idx - idx));

      (static_cast<bool>(
           fr->data[0].len > base_offset)
           ? void(0)
           : __assert_fail(
                 "fr->data[0].len > base_offset", "all.cpp", 20554, __extension__ __PRETTY_FUNCTION__));
      fr->offset = offset + base_offset;
      fr->datacnt = end_idx - idx;
      fr->data[0].base += base_offset;
      fr->data[0].len -= (size_t)base_offset;
      *pfrc = frc;
      return 0;
    }
    rv = ngtcp2_frame_chain_crypto_datacnt_new(&nfrc, fr->datacnt - end_idx,
                                               conn->mem);
    if (rv != 0)
    {
      ngtcp2_frame_chain_del(frc, conn->mem);
      return rv;
    }
    nfr = &nfrc->fr.crypto;
    nfr->type = NGTCP2_FRAME_CRYPTO;
    memcpy(nfr->data, fr->data + end_idx,
           sizeof(nfr->data[0]) * (fr->datacnt - end_idx));

    (static_cast<bool>(
         nfr->data[0].len > end_base_offset)
         ? void(0)
         : __assert_fail(
               "nfr->data[0].len > end_base_offset", "all.cpp", 20573, __extension__ __PRETTY_FUNCTION__));
    nfr->offset = end_offset + end_base_offset;
    nfr->datacnt = fr->datacnt - end_idx;
    nfr->data[0].base += end_base_offset;
    nfr->data[0].len -= (size_t)end_base_offset;
    rv = ngtcp2_ksl_insert(&pktns->crypto.tx.frq,
                           __null, &nfr->offset, nfrc);
    if (rv != 0)
    {

      (static_cast<bool>(
           ngtcp2_err_is_fatal(rv))
           ? void(0)
           : __assert_fail(
                 "ngtcp2_err_is_fatal(rv)", "all.cpp", 20581, __extension__ __PRETTY_FUNCTION__));
      ngtcp2_frame_chain_del(nfrc, conn->mem);
      ngtcp2_frame_chain_del(frc, conn->mem);
      return rv;
    }
    if (end_base_offset)
    {
      ++end_idx;
    }
    memmove(fr->data, fr->data + idx, sizeof(fr->data[0]) * (end_idx - idx));

    (static_cast<bool>(
         fr->data[0].len > base_offset)
         ? void(0)
         : __assert_fail(
               "fr->data[0].len > base_offset", "all.cpp", 20591, __extension__ __PRETTY_FUNCTION__));
    fr->offset = offset + base_offset;
    fr->datacnt = end_idx - idx;
    if (end_base_offset)
    {

      (static_cast<bool>(
           fr->data[fr->datacnt - 1].len > end_base_offset)
           ? void(0)
           : __assert_fail(
                 "fr->data[fr->datacnt - 1].len > end_base_offset", "all.cpp", 20596, __extension__ __PRETTY_FUNCTION__));
      fr->data[fr->datacnt - 1].len = (size_t)end_base_offset;
    }
    fr->data[0].base += base_offset;
    fr->data[0].len -= (size_t)base_offset;
    *pfrc = frc;
    return 0;
  }
  return 0;
}
static int conn_cryptofrq_pop(ngtcp2_conn *conn, ngtcp2_frame_chain **pfrc,
                              ngtcp2_pktns *pktns, size_t left)
{
  ngtcp2_crypto *fr, *nfr;
  ngtcp2_frame_chain *frc, *nfrc;
  int rv;
  size_t nmerged;
  size_t datalen;
  ngtcp2_vec a[8];
  ngtcp2_vec b[8];
  size_t acnt, bcnt;
  ngtcp2_ksl_it it;
  rv = conn_cryptofrq_unacked_pop(conn, pktns, &frc);
  if (rv != 0)
  {
    return rv;
  }
  if (frc ==
      __null)
  {
    *pfrc =
        __null;
    return 0;
  }
  fr = &frc->fr.crypto;
  datalen = ngtcp2_vec_len(fr->data, fr->datacnt);
  if (datalen > left)
  {
    ngtcp2_vec_copy(a, fr->data, fr->datacnt);
    acnt = fr->datacnt;
    bcnt = 0;
    ngtcp2_vec_split(a, &acnt, b, &bcnt, left, 8);

    (static_cast<bool>(
         acnt > 0)
         ? void(0)
         : __assert_fail(
               "acnt > 0", "all.cpp", 20636, __extension__ __PRETTY_FUNCTION__));

    (static_cast<bool>(
         bcnt > 0)
         ? void(0)
         : __assert_fail(
               "bcnt > 0", "all.cpp", 20637, __extension__ __PRETTY_FUNCTION__));
    rv = ngtcp2_frame_chain_crypto_datacnt_new(&nfrc, bcnt, conn->mem);
    if (rv != 0)
    {

      (static_cast<bool>(
           ngtcp2_err_is_fatal(rv))
           ? void(0)
           : __assert_fail(
                 "ngtcp2_err_is_fatal(rv)", "all.cpp", 20641, __extension__ __PRETTY_FUNCTION__));
      ngtcp2_frame_chain_del(frc, conn->mem);
      return rv;
    }
    nfr = &nfrc->fr.crypto;
    nfr->type = NGTCP2_FRAME_CRYPTO;
    nfr->offset = fr->offset + left;
    nfr->datacnt = bcnt;
    ngtcp2_vec_copy(nfr->data, b, bcnt);
    rv = ngtcp2_ksl_insert(&pktns->crypto.tx.frq,
                           __null, &nfr->offset, nfrc);
    if (rv != 0)
    {

      (static_cast<bool>(
           ngtcp2_err_is_fatal(rv))
           ? void(0)
           : __assert_fail(
                 "ngtcp2_err_is_fatal(rv)", "all.cpp", 20653, __extension__ __PRETTY_FUNCTION__));
      ngtcp2_frame_chain_del(nfrc, conn->mem);
      ngtcp2_frame_chain_del(frc, conn->mem);
      return rv;
    }
    rv = ngtcp2_frame_chain_crypto_datacnt_new(&nfrc, acnt, conn->mem);
    if (rv != 0)
    {

      (static_cast<bool>(
           ngtcp2_err_is_fatal(rv))
           ? void(0)
           : __assert_fail(
                 "ngtcp2_err_is_fatal(rv)", "all.cpp", 20661, __extension__ __PRETTY_FUNCTION__));
      ngtcp2_frame_chain_del(frc, conn->mem);
      return rv;
    }
    nfr = &nfrc->fr.crypto;
    *nfr = *fr;
    nfr->datacnt = acnt;
    ngtcp2_vec_copy(nfr->data, a, acnt);
    ngtcp2_frame_chain_del(frc, conn->mem);
    *pfrc = nfrc;
    return 0;
  }
  left -= datalen;
  ngtcp2_vec_copy(a, fr->data, fr->datacnt);
  acnt = fr->datacnt;
  for (; left && ngtcp2_ksl_len(&pktns->crypto.tx.frq);)
  {
    it = ngtcp2_ksl_begin(&pktns->crypto.tx.frq);
    nfrc = ngtcp2_ksl_it_get(&it);
    nfr = &nfrc->fr.crypto;
    if (nfr->offset != fr->offset + datalen)
    {

      (static_cast<bool>(
           fr->offset + datalen < nfr->offset)
           ? void(0)
           : __assert_fail(
                 "fr->offset + datalen < nfr->offset", "all.cpp", 20683, __extension__ __PRETTY_FUNCTION__));
      break;
    }
    rv = conn_cryptofrq_unacked_pop(conn, pktns, &nfrc);
    if (rv != 0)
    {

      (static_cast<bool>(
           ngtcp2_err_is_fatal(rv))
           ? void(0)
           : __assert_fail(
                 "ngtcp2_err_is_fatal(rv)", "all.cpp", 20689, __extension__ __PRETTY_FUNCTION__));
      ngtcp2_frame_chain_del(frc, conn->mem);
      return rv;
    }
    if (nfrc ==
        __null)
    {
      break;
    }
    nfr = &nfrc->fr.crypto;
    nmerged = ngtcp2_vec_merge(a, &acnt, nfr->data, &nfr->datacnt, left,
                               8);
    if (nmerged == 0)
    {
      rv = ngtcp2_ksl_insert(&pktns->crypto.tx.frq,
                             __null, &nfr->offset, nfrc);
      if (rv != 0)
      {

        (static_cast<bool>(
             ngtcp2_err_is_fatal(rv))
             ? void(0)
             : __assert_fail(
                   "ngtcp2_err_is_fatal(rv)", "all.cpp", 20705, __extension__ __PRETTY_FUNCTION__));
        ngtcp2_frame_chain_del(nfrc, conn->mem);
        ngtcp2_frame_chain_del(frc, conn->mem);
        return rv;
      }
      break;
    }
    datalen += nmerged;
    left -= nmerged;
    if (nfr->datacnt == 0)
    {
      ngtcp2_frame_chain_del(nfrc, conn->mem);
      continue;
    }
    nfr->offset += nmerged;
    rv = ngtcp2_ksl_insert(&pktns->crypto.tx.frq,
                           __null, &nfr->offset, nfrc);
    if (rv != 0)
    {
      ngtcp2_frame_chain_del(nfrc, conn->mem);
      ngtcp2_frame_chain_del(frc, conn->mem);
      return rv;
    }
    break;
  }
  if (acnt == fr->datacnt)
  {

    (static_cast<bool>(
         acnt > 0)
         ? void(0)
         : __assert_fail(
               "acnt > 0", "all.cpp", 20731, __extension__ __PRETTY_FUNCTION__));
    fr->data[acnt - 1] = a[acnt - 1];
    *pfrc = frc;
    return 0;
  }

  (static_cast<bool>(
       acnt > fr->datacnt)
       ? void(0)
       : __assert_fail(
             "acnt > fr->datacnt", "all.cpp", 20736, __extension__ __PRETTY_FUNCTION__));
  rv = ngtcp2_frame_chain_crypto_datacnt_new(&nfrc, acnt, conn->mem);
  if (rv != 0)
  {
    ngtcp2_frame_chain_del(frc, conn->mem);
    return rv;
  }
  nfr = &nfrc->fr.crypto;
  *nfr = *fr;
  nfr->datacnt = acnt;
  ngtcp2_vec_copy(nfr->data, a, acnt);
  ngtcp2_frame_chain_del(frc, conn->mem);
  *pfrc = nfrc;
  return 0;
}
static int conn_verify_dcid(ngtcp2_conn *conn, int *pnew_cid_used,
                            const ngtcp2_pkt_hd *hd)
{
  ngtcp2_ksl_it it;
  ngtcp2_scid *scid;
  int rv;
  it = ngtcp2_ksl_lower_bound(&conn->scid.set, &hd->dcid);
  if (((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                        __null))
  {
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  scid = ngtcp2_ksl_it_get(&it);
  if (!ngtcp2_cid_eq(&scid->cid, &hd->dcid))
  {
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  if (!(scid->flags & NGTCP2_SCID_FLAG_USED))
  {
    scid->flags |= NGTCP2_SCID_FLAG_USED;
    if (scid->pe.index ==
        (18446744073709551615UL))
    {
      rv = ngtcp2_pq_push(&conn->scid.used, &scid->pe);
      if (rv != 0)
      {
        return rv;
      }
    }
    if (pnew_cid_used)
    {
      *pnew_cid_used = 1;
    }
  }
  else if (pnew_cid_used)
  {
    *pnew_cid_used = 0;
  }
  return 0;
}
static int conn_should_pad_pkt(ngtcp2_conn *conn, uint8_t type, size_t left,
                               size_t early_datalen, int ack_eliciting)
{
  size_t min_payloadlen;
  if (conn->server)
  {
    if (type != NGTCP2_PKT_INITIAL || !ack_eliciting)
    {
      return 0;
    }
    if (conn->hs_pktns->crypto.tx.ckm &&
        (conn->hs_pktns->rtb.probe_pkt_left ||
         ngtcp2_ksl_len(&conn->hs_pktns->crypto.tx.frq) ||
         !ngtcp2_acktr_empty(&conn->hs_pktns->acktr)))
    {
      min_payloadlen = 128;
    }
    else
    {
      return 1;
    }
  }
  else
  {
    if (type == NGTCP2_PKT_HANDSHAKE)
    {
      return conn->in_pktns !=
             __null;
    }
    if (conn->hs_pktns->crypto.tx.ckm &&
        (conn->hs_pktns->rtb.probe_pkt_left ||
         ngtcp2_ksl_len(&conn->hs_pktns->crypto.tx.frq) ||
         !ngtcp2_acktr_empty(&conn->hs_pktns->acktr)))
    {
      min_payloadlen = 128;
    }
    else if (!conn->early.ckm || early_datalen == 0)
    {
      return 1;
    }
    else
    {
      min_payloadlen = ((early_datalen) < (128) ? (early_datalen) : (128));
    }
  }
  return left <
         (1 + 4 + 1 + 1 + 1 + 1) + conn->dcid.current.cid.datalen +
             conn->oscid.datalen + 1 +
             min_payloadlen + 16;
}
static void conn_restart_timer_on_write(ngtcp2_conn *conn, ngtcp2_tstamp ts)
{
  conn->idle_ts = ts;
  conn->flags &= (uint16_t)~NGTCP2_CONN_FLAG_RESTART_IDLE_TIMER_ON_WRITE;
}
static void conn_restart_timer_on_read(ngtcp2_conn *conn, ngtcp2_tstamp ts)
{
  conn->idle_ts = ts;
  conn->flags |= NGTCP2_CONN_FLAG_RESTART_IDLE_TIMER_ON_WRITE;
}
typedef enum
{
  NGTCP2_WRITE_PKT_FLAG_NONE = 0x00,
  NGTCP2_WRITE_PKT_FLAG_REQUIRE_PADDING = 0x01,
  NGTCP2_WRITE_PKT_FLAG_MORE = 0x02,
} ngtcp2_write_pkt_flag;
static ngtcp2_ssize
conn_write_handshake_pkt(ngtcp2_conn *conn, ngtcp2_pkt_info *pi, uint8_t *dest,
                         size_t destlen, uint8_t type, uint8_t flags,
                         size_t early_datalen, ngtcp2_tstamp ts)
{
  int rv;
  ngtcp2_ppe ppe;
  ngtcp2_pkt_hd hd;
  ngtcp2_frame_chain *frq =
                         __null,
                     **pfrc = &frq;
  ngtcp2_frame_chain *nfrc;
  ngtcp2_frame *ackfr =
                   __null,
               lfr;
  ngtcp2_ssize spktlen;
  ngtcp2_crypto_cc cc;
  ngtcp2_rtb_entry *rtbent;
  ngtcp2_pktns *pktns;
  size_t left;
  uint8_t rtb_entry_flags = NGTCP2_RTB_FLAG_NONE;
  int require_padding = (flags & NGTCP2_WRITE_PKT_FLAG_REQUIRE_PADDING) != 0;
  int pkt_empty = 1;
  int padded = 0;
  int hd_logged = 0;
  uint64_t crypto_offset;
  ngtcp2_ssize num_reclaimed;
  switch (type)
  {
  case NGTCP2_PKT_INITIAL:
    if (!conn->in_pktns)
    {
      return 0;
    }

    (static_cast<bool>(
         conn->in_pktns->crypto.tx.ckm)
         ? void(0)
         : __assert_fail(
               "conn->in_pktns->crypto.tx.ckm", "all.cpp", 20890, __extension__ __PRETTY_FUNCTION__));
    pktns = conn->in_pktns;
    cc.aead_overhead = 16;
    break;
  case NGTCP2_PKT_HANDSHAKE:
    if (!conn->hs_pktns || !conn->hs_pktns->crypto.tx.ckm)
    {
      return 0;
    }
    pktns = conn->hs_pktns;
    cc.aead_overhead = conn->crypto.aead_overhead;
    break;
  default:

    (static_cast<bool>(
         0)
         ? void(0)
         : __assert_fail(
               "0", "all.cpp", 20903, __extension__ __PRETTY_FUNCTION__));
  }
  cc.aead = pktns->crypto.ctx.aead;
  cc.hp = pktns->crypto.ctx.hp;
  cc.ckm = pktns->crypto.tx.ckm;
  cc.hp_ctx = pktns->crypto.tx.hp_ctx;
  cc.encrypt = conn->callbacks.encrypt;
  cc.hp_mask = conn->callbacks.hp_mask;
  ngtcp2_pkt_hd_init(&hd, NGTCP2_PKT_FLAG_LONG_FORM, type,
                     &conn->dcid.current.cid, &conn->oscid,
                     pktns->tx.last_pkt_num + 1, pktns_select_pkt_numlen(pktns),
                     conn->version, 0);
  if (!conn->server && type == NGTCP2_PKT_INITIAL &&
      conn->local.settings.token.len)
  {
    hd.token = conn->local.settings.token;
  }
  ngtcp2_ppe_init(&ppe, dest, destlen, &cc);
  rv = ngtcp2_ppe_encode_hd(&ppe, &hd);
  if (rv != 0)
  {

    (static_cast<bool>(
         NGTCP2_ERR_NOBUF == rv)
         ? void(0)
         : __assert_fail(
               "NGTCP2_ERR_NOBUF == rv", "all.cpp", 20924, __extension__ __PRETTY_FUNCTION__));
    return 0;
  }
  if (!ngtcp2_ppe_ensure_hp_sample(&ppe))
  {
    return 0;
  }
  rv = conn_create_ack_frame(conn, &ackfr, pktns, type, ts,
                             0,
                             3);
  if (rv != 0)
  {
    ngtcp2_frame_chain_list_del(frq, conn->mem);
    return rv;
  }
  if (ackfr)
  {
    rv = conn_ppe_write_frame_hd_log(conn, &ppe, &hd_logged, &hd, ackfr);
    if (rv != 0)
    {

      (static_cast<bool>(
           NGTCP2_ERR_NOBUF == rv)
           ? void(0)
           : __assert_fail(
                 "NGTCP2_ERR_NOBUF == rv", "all.cpp", 20944, __extension__ __PRETTY_FUNCTION__));
    }
    else
    {
      ngtcp2_acktr_commit_ack(&pktns->acktr);
      ngtcp2_acktr_add_ack(&pktns->acktr, hd.pkt_num, ackfr->ack.largest_ack);
      pkt_empty = 0;
    }
  }
  if (!conn->server || type != NGTCP2_PKT_INITIAL ||
      destlen >= 1200)
  {
  build_pkt:
    for (; ngtcp2_ksl_len(&pktns->crypto.tx.frq);)
    {
      left = ngtcp2_ppe_left(&ppe);
      crypto_offset = conn_cryptofrq_unacked_offset(conn, pktns);
      if (crypto_offset == (size_t)-1)
      {
        conn_cryptofrq_clear(conn, pktns);
        break;
      }
      left = ngtcp2_pkt_crypto_max_datalen(crypto_offset, left, left);
      if (left == (size_t)-1)
      {
        break;
      }
      rv = conn_cryptofrq_pop(conn, &nfrc, pktns, left);
      if (rv != 0)
      {

        (static_cast<bool>(
             ngtcp2_err_is_fatal(rv))
             ? void(0)
             : __assert_fail(
                   "ngtcp2_err_is_fatal(rv)", "all.cpp", 20974, __extension__ __PRETTY_FUNCTION__));
        ngtcp2_frame_chain_list_del(frq, conn->mem);
        return rv;
      }
      if (nfrc ==
          __null)
      {
        break;
      }
      rv = conn_ppe_write_frame_hd_log(conn, &ppe, &hd_logged, &hd, &nfrc->fr);
      if (rv != 0)
      {

        (static_cast<bool>(
             0)
             ? void(0)
             : __assert_fail(
                   "0", "all.cpp", 20985, __extension__ __PRETTY_FUNCTION__));
      }
      *pfrc = nfrc;
      pfrc = &(*pfrc)->next;
      pkt_empty = 0;
      rtb_entry_flags |=
          NGTCP2_RTB_FLAG_ACK_ELICITING | NGTCP2_RTB_FLAG_RETRANSMITTABLE;
    }
    if (!(rtb_entry_flags & NGTCP2_RTB_FLAG_ACK_ELICITING) &&
        pktns->rtb.num_retransmittable && pktns->rtb.probe_pkt_left)
    {
      num_reclaimed = ngtcp2_rtb_reclaim_on_pto(&pktns->rtb, conn, pktns,
                                                pktns->rtb.probe_pkt_left + 1);
      if (num_reclaimed < 0)
      {
        ngtcp2_frame_chain_list_del(frq, conn->mem);
        return rv;
      }
      if (num_reclaimed)
      {
        goto build_pkt;
      }
      if (pktns->rtb.num_retransmittable == 0 &&
          (conn->server ||
           (conn->flags & (NGTCP2_CONN_FLAG_SERVER_ADDR_VERIFIED |
                           NGTCP2_CONN_FLAG_HANDSHAKE_CONFIRMED))))
      {
        pktns->rtb.probe_pkt_left = 0;
        ngtcp2_conn_set_loss_detection_timer(conn, ts);
      }
    }
    if (!(rtb_entry_flags & NGTCP2_RTB_FLAG_ACK_ELICITING) &&
        pktns->rtb.probe_pkt_left &&
        (type != NGTCP2_PKT_INITIAL ||
         ngtcp2_strm_is_all_tx_data_acked(&pktns->crypto.strm)))
    {
      lfr.type = NGTCP2_FRAME_PING;
      rv = conn_ppe_write_frame_hd_log(conn, &ppe, &hd_logged, &hd, &lfr);
      if (rv != 0)
      {

        (static_cast<bool>(
             rv == NGTCP2_ERR_NOBUF)
             ? void(0)
             : __assert_fail(
                   "rv == NGTCP2_ERR_NOBUF", "all.cpp", 21025, __extension__ __PRETTY_FUNCTION__));
      }
      else
      {
        rtb_entry_flags |=
            NGTCP2_RTB_FLAG_ACK_ELICITING | NGTCP2_RTB_FLAG_PROBE;
        pkt_empty = 0;
      }
    }
    if (!pkt_empty)
    {
      if (!(rtb_entry_flags & NGTCP2_RTB_FLAG_ACK_ELICITING))
      {
        if (pktns->rtb.probe_pkt_left || pktns->tx.num_non_ack_pkt >= 1)
        {
          lfr.type = NGTCP2_FRAME_PING;
          rv = conn_ppe_write_frame_hd_log(conn, &ppe, &hd_logged, &hd, &lfr);
          if (rv != 0)
          {

            (static_cast<bool>(
                 rv == NGTCP2_ERR_NOBUF)
                 ? void(0)
                 : __assert_fail(
                       "rv == NGTCP2_ERR_NOBUF", "all.cpp", 21044, __extension__ __PRETTY_FUNCTION__));
          }
          else
          {
            rtb_entry_flags |= NGTCP2_RTB_FLAG_ACK_ELICITING;
            pktns->tx.num_non_ack_pkt = 0;
          }
        }
        else
        {
          ++pktns->tx.num_non_ack_pkt;
        }
      }
      else
      {
        pktns->tx.num_non_ack_pkt = 0;
      }
    }
  }
  if (pkt_empty)
  {
    return 0;
  }
  if (require_padding ||
      conn_should_pad_pkt(conn, type, ngtcp2_ppe_left(&ppe), early_datalen,
                          (rtb_entry_flags & NGTCP2_RTB_FLAG_ACK_ELICITING) !=
                              0))
  {
    lfr.type = NGTCP2_FRAME_PADDING;
    lfr.padding.len = ngtcp2_ppe_padding(&ppe);
  }
  else
  {
    lfr.type = NGTCP2_FRAME_PADDING;
    lfr.padding.len = ngtcp2_ppe_padding_hp_sample(&ppe);
  }
  if (lfr.padding.len)
  {
    padded = 1;
    ngtcp2_log_tx_fr(&conn->log, &hd, &lfr);
    ngtcp2_qlog_write_frame(&conn->qlog, &lfr);
  }
  spktlen = ngtcp2_ppe_final(&ppe,
                             __null);
  if (spktlen < 0)
  {

    (static_cast<bool>(
         ngtcp2_err_is_fatal((int)spktlen))
         ? void(0)
         : __assert_fail(
               "ngtcp2_err_is_fatal((int)spktlen)", "all.cpp", 21089, __extension__ __PRETTY_FUNCTION__));
    ngtcp2_frame_chain_list_del(frq, conn->mem);
    return spktlen;
  }
  ngtcp2_qlog_pkt_sent_end(&conn->qlog, &hd, (size_t)spktlen);
  if ((rtb_entry_flags & NGTCP2_RTB_FLAG_ACK_ELICITING) || padded)
  {
    if (pi)
    {
      conn_handle_tx_ecn(conn, pi, &rtb_entry_flags, pktns, &hd, ts);
    }
    rv = ngtcp2_rtb_entry_new(&rtbent, &hd, frq, ts, (size_t)spktlen,
                              rtb_entry_flags, conn->mem);
    if (rv != 0)
    {

      (static_cast<bool>(
           ngtcp2_err_is_fatal(rv))
           ? void(0)
           : __assert_fail(
                 "ngtcp2_err_is_fatal(rv)", "all.cpp", 21104, __extension__ __PRETTY_FUNCTION__));
      ngtcp2_frame_chain_list_del(frq, conn->mem);
      return rv;
    }
    rv = conn_on_pkt_sent(conn, &pktns->rtb, rtbent);
    if (rv != 0)
    {
      ngtcp2_rtb_entry_del(rtbent, conn->mem);
      return rv;
    }
    if ((rtb_entry_flags & NGTCP2_RTB_FLAG_ACK_ELICITING) &&
        (conn->flags & NGTCP2_CONN_FLAG_RESTART_IDLE_TIMER_ON_WRITE))
    {
      conn_restart_timer_on_write(conn, ts);
    }
  }
  else if (pi && conn->tx.ecn.state == NGTCP2_ECN_STATE_CAPABLE)
  {
    conn_handle_tx_ecn(conn, pi,
                       __null, pktns, &hd, ts);
  }
  if (pktns->rtb.probe_pkt_left &&
      (rtb_entry_flags & NGTCP2_RTB_FLAG_ACK_ELICITING))
  {
    --pktns->rtb.probe_pkt_left;
  }
  ngtcp2_qlog_metrics_updated(&conn->qlog, &conn->cstat);
  ++pktns->tx.last_pkt_num;
  return spktlen;
}
static ngtcp2_ssize conn_write_ack_pkt(ngtcp2_conn *conn, ngtcp2_pkt_info *pi,
                                       uint8_t *dest, size_t destlen,
                                       uint8_t type, ngtcp2_tstamp ts)
{
  int rv;
  ngtcp2_frame *ackfr;
  ngtcp2_pktns *pktns;
  ngtcp2_duration ack_delay;
  uint64_t ack_delay_exponent;

  (static_cast<bool>(
       !(conn->flags & NGTCP2_CONN_FLAG_PPE_PENDING))
       ? void(0)
       : __assert_fail(
             "!(conn->flags & NGTCP2_CONN_FLAG_PPE_PENDING)", "all.cpp", 21143, __extension__ __PRETTY_FUNCTION__));
  switch (type)
  {
  case NGTCP2_PKT_INITIAL:

    (static_cast<bool>(
         conn->server)
         ? void(0)
         : __assert_fail(
               "conn->server", "all.cpp", 21147, __extension__ __PRETTY_FUNCTION__));
    pktns = conn->in_pktns;
    ack_delay = 0;
    ack_delay_exponent = 3;
    break;
  case NGTCP2_PKT_HANDSHAKE:
    pktns = conn->hs_pktns;
    ack_delay = 0;
    ack_delay_exponent = 3;
    break;
  case NGTCP2_PKT_SHORT:
    pktns = &conn->pktns;
    ack_delay = conn_compute_ack_delay(conn);
    ack_delay_exponent =
        conn->local.settings.transport_params.ack_delay_exponent;
    break;
  default:

    (static_cast<bool>(
         0)
         ? void(0)
         : __assert_fail(
               "0", "all.cpp", 21164, __extension__ __PRETTY_FUNCTION__));
  }
  if (!pktns->crypto.tx.ckm)
  {
    return 0;
  }
  ackfr =
      __null;
  rv = conn_create_ack_frame(conn, &ackfr, pktns, type, ts, ack_delay,
                             ack_delay_exponent);
  if (rv != 0)
  {
    return rv;
  }
  if (!ackfr)
  {
    return 0;
  }
  return ngtcp2_conn_write_single_frame_pkt(conn, pi, dest, destlen, type,
                                            &conn->dcid.current.cid, ackfr,
                                            NGTCP2_RTB_FLAG_NONE,
                                            __null, ts);
}
static void conn_discard_pktns(ngtcp2_conn *conn, ngtcp2_pktns **ppktns,
                               ngtcp2_tstamp ts)
{
  ngtcp2_pktns *pktns = *ppktns;
  uint64_t bytes_in_flight;
  bytes_in_flight = pktns->rtb.cc_bytes_in_flight;

  (static_cast<bool>(
       conn->cstat.bytes_in_flight >= bytes_in_flight)
       ? void(0)
       : __assert_fail(
             "conn->cstat.bytes_in_flight >= bytes_in_flight", "all.cpp", 21192, __extension__ __PRETTY_FUNCTION__));
  conn->cstat.bytes_in_flight -= bytes_in_flight;
  conn->cstat.pto_count = 0;
  conn->cstat.last_tx_pkt_ts[pktns->rtb.pktns_id] =
      (18446744073709551615UL);
  conn->cstat.loss_time[pktns->rtb.pktns_id] =
      (18446744073709551615UL);
  conn_call_delete_crypto_aead_ctx(conn, &pktns->crypto.rx.ckm->aead_ctx);
  conn_call_delete_crypto_cipher_ctx(conn, &pktns->crypto.rx.hp_ctx);
  conn_call_delete_crypto_aead_ctx(conn, &pktns->crypto.tx.ckm->aead_ctx);
  conn_call_delete_crypto_cipher_ctx(conn, &pktns->crypto.tx.hp_ctx);
  pktns_del(pktns, conn->mem);
  *ppktns =
      __null;
  ngtcp2_conn_set_loss_detection_timer(conn, ts);
}
static void conn_discard_initial_state(ngtcp2_conn *conn, ngtcp2_tstamp ts)
{
  if (!conn->in_pktns)
  {
    return;
  }
  conn_discard_pktns(conn, &conn->in_pktns, ts);
}
static void conn_discard_handshake_state(ngtcp2_conn *conn, ngtcp2_tstamp ts)
{
  if (!conn->hs_pktns)
  {
    return;
  }
  conn_discard_pktns(conn, &conn->hs_pktns, ts);
}
static ngtcp2_ssize conn_write_handshake_ack_pkts(ngtcp2_conn *conn,
                                                  ngtcp2_pkt_info *pi,
                                                  uint8_t *dest, size_t destlen,
                                                  ngtcp2_tstamp ts)
{
  ngtcp2_ssize res = 0, nwrite = 0;
  if (conn->server && conn->in_pktns)
  {
    nwrite =
        conn_write_ack_pkt(conn, pi, dest, destlen, NGTCP2_PKT_INITIAL, ts);
    if (nwrite < 0)
    {

      (static_cast<bool>(
           nwrite != NGTCP2_ERR_NOBUF)
           ? void(0)
           : __assert_fail(
                 "nwrite != NGTCP2_ERR_NOBUF", "all.cpp", 21236, __extension__ __PRETTY_FUNCTION__));
      return nwrite;
    }
    res += nwrite;
    dest += nwrite;
    destlen -= (size_t)nwrite;
  }
  if (conn->hs_pktns->crypto.tx.ckm)
  {
    nwrite =
        conn_write_ack_pkt(conn, pi, dest, destlen, NGTCP2_PKT_HANDSHAKE, ts);
    if (nwrite < 0)
    {

      (static_cast<bool>(
           nwrite != NGTCP2_ERR_NOBUF)
           ? void(0)
           : __assert_fail(
                 "nwrite != NGTCP2_ERR_NOBUF", "all.cpp", 21249, __extension__ __PRETTY_FUNCTION__));
      return nwrite;
    }
    res += nwrite;
    if (!conn->server && nwrite)
    {
      conn_discard_initial_state(conn, ts);
    }
  }
  return res;
}
static ngtcp2_ssize conn_write_client_initial(ngtcp2_conn *conn,
                                              ngtcp2_pkt_info *pi,
                                              uint8_t *dest, size_t destlen,
                                              size_t early_datalen,
                                              ngtcp2_tstamp ts)
{
  int rv;

  (static_cast<bool>(
       conn->callbacks.client_initial)
       ? void(0)
       : __assert_fail(
             "conn->callbacks.client_initial", "all.cpp", 21268, __extension__ __PRETTY_FUNCTION__));
  rv = conn->callbacks.client_initial(conn, conn->user_data);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return conn_write_handshake_pkt(conn, pi, dest, destlen, NGTCP2_PKT_INITIAL,
                                  NGTCP2_WRITE_PKT_FLAG_NONE, early_datalen,
                                  ts);
}
static ngtcp2_ssize conn_write_handshake_pkts(ngtcp2_conn *conn,
                                              ngtcp2_pkt_info *pi,
                                              uint8_t *dest, size_t destlen,
                                              size_t early_datalen,
                                              ngtcp2_tstamp ts)
{
  ngtcp2_ssize nwrite;
  ngtcp2_ssize res = 0;
  int64_t prev_pkt_num = -1;
  ngtcp2_rtb_entry *rtbent;
  uint8_t wflags = NGTCP2_WRITE_PKT_FLAG_NONE;
  ngtcp2_ksl_it it;
  if (!conn->server && conn->hs_pktns->crypto.tx.ckm &&
      !ngtcp2_acktr_empty(&conn->hs_pktns->acktr))
  {
    conn_discard_initial_state(conn, ts);
  }
  else if (conn->in_pktns)
  {
    if (conn->server)
    {
      it = ngtcp2_rtb_head(&conn->in_pktns->rtb);
      if (!((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                             __null))
      {
        rtbent = ngtcp2_ksl_it_get(&it);
        prev_pkt_num = rtbent->hd.pkt_num;
      }
    }
    nwrite =
        conn_write_handshake_pkt(conn, pi, dest, destlen, NGTCP2_PKT_INITIAL,
                                 NGTCP2_WRITE_PKT_FLAG_NONE, early_datalen, ts);
    if (nwrite < 0)
    {

      (static_cast<bool>(
           nwrite != NGTCP2_ERR_NOBUF)
           ? void(0)
           : __assert_fail(
                 "nwrite != NGTCP2_ERR_NOBUF", "all.cpp", 21312, __extension__ __PRETTY_FUNCTION__));
      return nwrite;
    }
    if (nwrite == 0)
    {
      if (conn->server && (conn->in_pktns->rtb.probe_pkt_left ||
                           ngtcp2_ksl_len(&conn->in_pktns->crypto.tx.frq)))
      {
        return 0;
      }
    }
    else
    {
      res += nwrite;
      dest += nwrite;
      destlen -= (size_t)nwrite;
      if (conn->server && destlen)
      {
        it = ngtcp2_rtb_head(&conn->in_pktns->rtb);
        if (!((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                               __null))
        {
          rtbent = ngtcp2_ksl_it_get(&it);
          if (rtbent->hd.pkt_num != prev_pkt_num &&
              (rtbent->flags & NGTCP2_RTB_FLAG_ACK_ELICITING))
          {
            wflags |= NGTCP2_WRITE_PKT_FLAG_REQUIRE_PADDING;
          }
        }
      }
    }
  }
  nwrite = conn_write_handshake_pkt(conn, pi, dest, destlen,
                                    NGTCP2_PKT_HANDSHAKE, wflags, 0, ts);
  if (nwrite < 0)
  {

    (static_cast<bool>(
         nwrite != NGTCP2_ERR_NOBUF)
         ? void(0)
         : __assert_fail(
               "nwrite != NGTCP2_ERR_NOBUF", "all.cpp", 21347, __extension__ __PRETTY_FUNCTION__));
    return nwrite;
  }
  res += nwrite;
  if (!conn->server && conn->hs_pktns->crypto.tx.ckm && nwrite)
  {
    conn_discard_initial_state(conn, ts);
  }
  return res;
}
static uint64_t conn_initial_stream_rx_offset(ngtcp2_conn *conn,
                                              int64_t stream_id)
{
  int local_stream = conn_local_stream(conn, stream_id);
  if (bidi_stream(stream_id))
  {
    if (local_stream)
    {
      return conn->local.settings.transport_params
          .initial_max_stream_data_bidi_local;
    }
    return conn->local.settings.transport_params
        .initial_max_stream_data_bidi_remote;
  }
  if (local_stream)
  {
    return 0;
  }
  return conn->local.settings.transport_params.initial_max_stream_data_uni;
}
static int conn_should_send_max_stream_data(ngtcp2_conn *conn,
                                            ngtcp2_strm *strm)
{
  uint64_t inc = strm->rx.unsent_max_offset - strm->rx.max_offset;
  (void)conn;
  return strm->rx.window < 2 * inc;
}
static int conn_should_send_max_data(ngtcp2_conn *conn)
{
  uint64_t inc = conn->rx.unsent_max_offset - conn->rx.max_offset;
  return conn->rx.window < 2 * inc;
}
static size_t conn_required_num_new_connection_id(ngtcp2_conn *conn)
{
  uint64_t n;
  size_t len = ngtcp2_ksl_len(&conn->scid.set);
  if (len >= 8)
  {
    return 0;
  }
  n = conn->remote.transport_params.active_connection_id_limit +
      conn->scid.num_retired;
  return (size_t)((8) < (n) ? (8) : (n)) - len;
}
static int conn_enqueue_new_connection_id(ngtcp2_conn *conn)
{
  size_t i, need = conn_required_num_new_connection_id(conn);
  size_t cidlen = conn->oscid.datalen;
  ngtcp2_cid cid;
  uint64_t seq;
  int rv;
  uint8_t token[16];
  ngtcp2_frame_chain *nfrc;
  ngtcp2_pktns *pktns = &conn->pktns;
  ngtcp2_scid *scid;
  ngtcp2_ksl_it it;
  for (i = 0; i < need; ++i)
  {
    rv = conn_call_get_new_connection_id(conn, &cid, token, cidlen);
    if (rv != 0)
    {
      return rv;
    }
    if (cid.datalen != cidlen)
    {
      return NGTCP2_ERR_CALLBACK_FAILURE;
    }
    it = ngtcp2_ksl_lower_bound(&conn->scid.set, &cid);
    if (!((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                           __null) &&
        ngtcp2_cid_eq(((ngtcp2_ksl_key *)((ngtcp2_ksl_node *)(void *)(((&it)->blk)->nodes + ((&it)->ksl)->nodelen * ((&it)->i)))->key), &cid))
    {
      return NGTCP2_ERR_CALLBACK_FAILURE;
    }
    seq = ++conn->scid.last_seq;
    scid = ngtcp2_mem_malloc(conn->mem, sizeof(*scid));
    if (scid ==
        __null)
    {
      return NGTCP2_ERR_NOMEM;
    }
    ngtcp2_scid_init(scid, seq, &cid, token);
    rv = ngtcp2_ksl_insert(&conn->scid.set,
                           __null, &scid->cid, scid);
    if (rv != 0)
    {
      ngtcp2_mem_free(conn->mem, scid);
      return rv;
    }
    rv = ngtcp2_frame_chain_new(&nfrc, conn->mem);
    if (rv != 0)
    {
      return rv;
    }
    nfrc->fr.type = NGTCP2_FRAME_NEW_CONNECTION_ID;
    nfrc->fr.new_connection_id.seq = seq;
    nfrc->fr.new_connection_id.retire_prior_to = 0;
    nfrc->fr.new_connection_id.cid = cid;
    memcpy(nfrc->fr.new_connection_id.stateless_reset_token, token,
           sizeof(token));
    nfrc->next = pktns->tx.frq;
    pktns->tx.frq = nfrc;
  }
  return 0;
}
static int conn_remove_retired_connection_id(ngtcp2_conn *conn,
                                             ngtcp2_tstamp ts)
{
  ngtcp2_duration timeout = conn_compute_pto(conn, &conn->pktns);
  ngtcp2_scid *scid;
  ngtcp2_dcid *dcid;
  int rv;
  for (; !ngtcp2_pq_empty(&conn->scid.used);)
  {
    scid = ((ngtcp2_scid *)(void *)((char *)(ngtcp2_pq_top(&conn->scid.used)) -
                                    __builtin_offsetof(
                                        ngtcp2_scid,
                                        pe)));
    if (scid->ts_retired ==
            (18446744073709551615UL) ||
        scid->ts_retired + timeout >= ts)
    {
      break;
    }

    (static_cast<bool>(
         scid->flags & NGTCP2_SCID_FLAG_RETIRED)
         ? void(0)
         : __assert_fail(
               "scid->flags & NGTCP2_SCID_FLAG_RETIRED", "all.cpp", 21479, __extension__ __PRETTY_FUNCTION__));
    rv = conn_call_remove_connection_id(conn, &scid->cid);
    if (rv != 0)
    {
      return rv;
    }
    ngtcp2_ksl_remove(&conn->scid.set,
                      __null, &scid->cid);
    ngtcp2_pq_pop(&conn->scid.used);
    ngtcp2_mem_free(conn->mem, scid);

    (static_cast<bool>(
         conn->scid.num_retired)
         ? void(0)
         : __assert_fail(
               "conn->scid.num_retired", "all.cpp", 21488, __extension__ __PRETTY_FUNCTION__));
    --conn->scid.num_retired;
  }
  for (; ((&conn->dcid.retired)->len);)
  {
    dcid = ngtcp2_ringbuf_get(&conn->dcid.retired, 0);
    if (dcid->ts_retired + timeout >= ts)
    {
      break;
    }
    rv = conn_call_deactivate_dcid(conn, dcid);
    if (rv != 0)
    {
      return rv;
    }
    ngtcp2_ringbuf_pop_front(&conn->dcid.retired);
  }
  return 0;
}
static size_t conn_min_short_pktlen(ngtcp2_conn *conn)
{
  return conn->dcid.current.cid.datalen + 22;
}
static ngtcp2_ssize conn_write_pkt(ngtcp2_conn *conn, ngtcp2_pkt_info *pi,
                                   uint8_t *dest, size_t destlen,
                                   ngtcp2_vmsg *vmsg, uint8_t type,
                                   uint8_t flags, ngtcp2_tstamp ts)
{
  int rv = 0;
  ngtcp2_crypto_cc *cc = &conn->pkt.cc;
  ngtcp2_ppe *ppe = &conn->pkt.ppe;
  ngtcp2_pkt_hd *hd = &conn->pkt.hd;
  ngtcp2_frame *ackfr =
                   __null,
               lfr;
  ngtcp2_ssize nwrite;
  ngtcp2_frame_chain **pfrc, *nfrc, *frc;
  ngtcp2_rtb_entry *ent;
  ngtcp2_strm *strm;
  int pkt_empty = 1;
  size_t ndatalen = 0;
  int send_stream = 0;
  int stream_blocked = 0;
  ngtcp2_pktns *pktns = &conn->pktns;
  size_t left;
  size_t datalen = 0;
  ngtcp2_vec data[256];
  size_t datacnt;
  uint8_t rtb_entry_flags = NGTCP2_RTB_FLAG_NONE;
  int hd_logged = 0;
  ngtcp2_path_challenge_entry *pcent;
  uint8_t hd_flags;
  int require_padding = (flags & NGTCP2_WRITE_PKT_FLAG_REQUIRE_PADDING) != 0;
  int write_more = (flags & NGTCP2_WRITE_PKT_FLAG_MORE) != 0;
  int ppe_pending = (conn->flags & NGTCP2_CONN_FLAG_PPE_PENDING) != 0;
  size_t min_pktlen = conn_min_short_pktlen(conn);
  int padded = 0;
  int credit_expanded = 0;
  ngtcp2_cc_pkt cc_pkt;
  uint64_t crypto_offset;
  uint64_t stream_offset;
  ngtcp2_ssize num_reclaimed;
  int fin;
  uint64_t target_max_data;
  ngtcp2_conn_stat *cstat = &conn->cstat;
  uint64_t delta;
  if (destlen < min_pktlen)
  {
    return 0;
  }
  if (vmsg)
  {
    switch (vmsg->type)
    {
    case NGTCP2_VMSG_TYPE_STREAM:
      datalen = ngtcp2_vec_len(vmsg->stream.data, vmsg->stream.datacnt);
      ndatalen = conn_enforce_flow_control(conn, vmsg->stream.strm, datalen);
      if (ndatalen || datalen == 0)
      {
        send_stream = 1;
      }
      else
      {
        stream_blocked = 1;
      }
      break;
    default:
      break;
    }
  }
  if (!ppe_pending)
  {
    switch (type)
    {
    case NGTCP2_PKT_SHORT:
      hd_flags =
          (pktns->crypto.tx.ckm->flags & NGTCP2_CRYPTO_KM_FLAG_KEY_PHASE_ONE)
              ? NGTCP2_PKT_FLAG_KEY_PHASE
              : NGTCP2_PKT_FLAG_NONE;
      cc->ckm = pktns->crypto.tx.ckm;
      cc->hp_ctx = pktns->crypto.tx.hp_ctx;
      if (conn->oscid.datalen &&
          (conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED))
      {
        rv = conn_enqueue_new_connection_id(conn);
        if (rv != 0)
        {
          return rv;
        }
      }
      break;
    case NGTCP2_PKT_0RTT:

      (static_cast<bool>(
           !conn->server)
           ? void(0)
           : __assert_fail(
                 "!conn->server", "all.cpp", 21600, __extension__ __PRETTY_FUNCTION__));
      if (!conn->early.ckm)
      {
        return 0;
      }
      hd_flags = NGTCP2_PKT_FLAG_LONG_FORM;
      cc->ckm = conn->early.ckm;
      cc->hp_ctx = conn->early.hp_ctx;
      break;
    default:

      (static_cast<bool>(
           0)
           ? void(0)
           : __assert_fail(
                 "0", "all.cpp", 21610, __extension__ __PRETTY_FUNCTION__));
    }
    cc->aead = pktns->crypto.ctx.aead;
    cc->hp = pktns->crypto.ctx.hp;
    cc->aead_overhead = conn->crypto.aead_overhead;
    cc->encrypt = conn->callbacks.encrypt;
    cc->hp_mask = conn->callbacks.hp_mask;
    if (conn_should_send_max_data(conn))
    {
      rv = ngtcp2_frame_chain_new(&nfrc, conn->mem);
      if (rv != 0)
      {
        return rv;
      }
      if (conn->local.settings.max_window &&
          conn->tx.last_max_data_ts !=
              (18446744073709551615UL) &&
          ts - conn->tx.last_max_data_ts <
              2 * cstat->smoothed_rtt &&
          conn->local.settings.max_window > conn->rx.window)
      {
        target_max_data = 2 * conn->rx.window;
        if (target_max_data > conn->local.settings.max_window)
        {
          target_max_data = conn->local.settings.max_window;
        }
        delta = target_max_data - conn->rx.window;
        if (conn->rx.unsent_max_offset + delta > ((1ULL << 62) - 1))
        {
          delta = ((1ULL << 62) - 1) - conn->rx.unsent_max_offset;
        }
        conn->rx.window = target_max_data;
      }
      else
      {
        delta = 0;
      }
      conn->tx.last_max_data_ts = ts;
      nfrc->fr.type = NGTCP2_FRAME_MAX_DATA;
      nfrc->fr.max_data.max_data = conn->rx.unsent_max_offset + delta;
      nfrc->next = pktns->tx.frq;
      pktns->tx.frq = nfrc;
      conn->rx.max_offset = conn->rx.unsent_max_offset =
          nfrc->fr.max_data.max_data;
      credit_expanded = 1;
    }
    ngtcp2_pkt_hd_init(hd, hd_flags, type, &conn->dcid.current.cid,
                       &conn->oscid, pktns->tx.last_pkt_num + 1,
                       pktns_select_pkt_numlen(pktns), conn->version, 0);
    ngtcp2_ppe_init(ppe, dest, destlen, cc);
    rv = ngtcp2_ppe_encode_hd(ppe, hd);
    if (rv != 0)
    {

      (static_cast<bool>(
           NGTCP2_ERR_NOBUF == rv)
           ? void(0)
           : __assert_fail(
                 "NGTCP2_ERR_NOBUF == rv", "all.cpp", 21662, __extension__ __PRETTY_FUNCTION__));
      return 0;
    }
    if (!ngtcp2_ppe_ensure_hp_sample(ppe))
    {
      return 0;
    }
    if (((&conn->rx.path_challenge)->len))
    {
      pcent = ngtcp2_ringbuf_get(&conn->rx.path_challenge, 0);
      if (ngtcp2_path_eq(&conn->dcid.current.ps.path, &pcent->ps.path))
      {
        lfr.type = NGTCP2_FRAME_PATH_RESPONSE;
        memcpy(lfr.path_response.data, pcent->data,
               sizeof(lfr.path_response.data));
        rv = conn_ppe_write_frame_hd_log(conn, ppe, &hd_logged, hd, &lfr);
        if (rv != 0)
        {

          (static_cast<bool>(
               NGTCP2_ERR_NOBUF == rv)
               ? void(0)
               : __assert_fail(
                     "NGTCP2_ERR_NOBUF == rv", "all.cpp", 21680, __extension__ __PRETTY_FUNCTION__));
        }
        else
        {
          ngtcp2_ringbuf_pop_front(&conn->rx.path_challenge);
          pkt_empty = 0;
          rtb_entry_flags |= NGTCP2_RTB_FLAG_ACK_ELICITING;
          require_padding = 1;
        }
      }
    }
    rv = conn_create_ack_frame(
        conn, &ackfr, pktns, type, ts, conn_compute_ack_delay(conn),
        conn->local.settings.transport_params.ack_delay_exponent);
    if (rv != 0)
    {

      (static_cast<bool>(
           ngtcp2_err_is_fatal(rv))
           ? void(0)
           : __assert_fail(
                 "ngtcp2_err_is_fatal(rv)", "all.cpp", 21696, __extension__ __PRETTY_FUNCTION__));
      return rv;
    }
    if (ackfr)
    {
      rv = conn_ppe_write_frame_hd_log(conn, ppe, &hd_logged, hd, ackfr);
      if (rv != 0)
      {

        (static_cast<bool>(
             NGTCP2_ERR_NOBUF == rv)
             ? void(0)
             : __assert_fail(
                   "NGTCP2_ERR_NOBUF == rv", "all.cpp", 21704, __extension__ __PRETTY_FUNCTION__));
      }
      else
      {
        ngtcp2_acktr_commit_ack(&pktns->acktr);
        ngtcp2_acktr_add_ack(&pktns->acktr, hd->pkt_num,
                             ackfr->ack.largest_ack);
        pkt_empty = 0;
      }
    }
  build_pkt:
    for (pfrc = &pktns->tx.frq; *pfrc;)
    {
      if ((*pfrc)->binder &&
          ((*pfrc)->binder->flags & NGTCP2_FRAME_CHAIN_BINDER_FLAG_ACK))
      {
        frc = *pfrc;
        *pfrc = (*pfrc)->next;
        ngtcp2_frame_chain_del(frc, conn->mem);
        continue;
      }
      switch ((*pfrc)->fr.type)
      {
      case NGTCP2_FRAME_STOP_SENDING:
        strm =
            ngtcp2_conn_find_stream(conn, (*pfrc)->fr.stop_sending.stream_id);
        if (strm ==
                __null ||
            (strm->flags & NGTCP2_STRM_FLAG_SHUT_RD))
        {
          frc = *pfrc;
          *pfrc = (*pfrc)->next;
          ngtcp2_frame_chain_del(frc, conn->mem);
          continue;
        }
        break;
      case NGTCP2_FRAME_STREAM:

        (static_cast<bool>(
             0)
             ? void(0)
             : __assert_fail(
                   "0", "all.cpp", 21739, __extension__ __PRETTY_FUNCTION__));
        break;
      case NGTCP2_FRAME_MAX_STREAMS_BIDI:
        if ((*pfrc)->fr.max_streams.max_streams <
            conn->remote.bidi.max_streams)
        {
          frc = *pfrc;
          *pfrc = (*pfrc)->next;
          ngtcp2_frame_chain_del(frc, conn->mem);
          continue;
        }
        break;
      case NGTCP2_FRAME_MAX_STREAMS_UNI:
        if ((*pfrc)->fr.max_streams.max_streams <
            conn->remote.uni.max_streams)
        {
          frc = *pfrc;
          *pfrc = (*pfrc)->next;
          ngtcp2_frame_chain_del(frc, conn->mem);
          continue;
        }
        break;
      case NGTCP2_FRAME_MAX_STREAM_DATA:
        strm = ngtcp2_conn_find_stream(conn,
                                       (*pfrc)->fr.max_stream_data.stream_id);
        if (strm ==
                __null ||
            (strm->flags & NGTCP2_STRM_FLAG_SHUT_RD) ||
            (*pfrc)->fr.max_stream_data.max_stream_data < strm->rx.max_offset)
        {
          frc = *pfrc;
          *pfrc = (*pfrc)->next;
          ngtcp2_frame_chain_del(frc, conn->mem);
          continue;
        }
        break;
      case NGTCP2_FRAME_MAX_DATA:
        if ((*pfrc)->fr.max_data.max_data < conn->rx.max_offset)
        {
          frc = *pfrc;
          *pfrc = (*pfrc)->next;
          ngtcp2_frame_chain_del(frc, conn->mem);
          continue;
        }
        break;
      case NGTCP2_FRAME_RETIRE_CONNECTION_ID:
        ++conn->dcid.num_retire_queued;
        break;
      case NGTCP2_FRAME_CRYPTO:

        (static_cast<bool>(
             0)
             ? void(0)
             : __assert_fail(
                   "0", "all.cpp", 21786, __extension__ __PRETTY_FUNCTION__));
        break;
      }
      rv = conn_ppe_write_frame_hd_log(conn, ppe, &hd_logged, hd, &(*pfrc)->fr);
      if (rv != 0)
      {

        (static_cast<bool>(
             NGTCP2_ERR_NOBUF == rv)
             ? void(0)
             : __assert_fail(
                   "NGTCP2_ERR_NOBUF == rv", "all.cpp", 21792, __extension__ __PRETTY_FUNCTION__));
        break;
      }
      pkt_empty = 0;
      rtb_entry_flags |=
          NGTCP2_RTB_FLAG_ACK_ELICITING | NGTCP2_RTB_FLAG_RETRANSMITTABLE;
      pfrc = &(*pfrc)->next;
    }
    if (rv != NGTCP2_ERR_NOBUF)
    {
      for (; ngtcp2_ksl_len(&pktns->crypto.tx.frq);)
      {
        left = ngtcp2_ppe_left(ppe);
        crypto_offset = conn_cryptofrq_unacked_offset(conn, pktns);
        if (crypto_offset == (size_t)-1)
        {
          conn_cryptofrq_clear(conn, pktns);
          break;
        }
        left = ngtcp2_pkt_crypto_max_datalen(crypto_offset, left, left);
        if (left == (size_t)-1)
        {
          break;
        }
        rv = conn_cryptofrq_pop(conn, &nfrc, pktns, left);
        if (rv != 0)
        {

          (static_cast<bool>(
               ngtcp2_err_is_fatal(rv))
               ? void(0)
               : __assert_fail(
                     "ngtcp2_err_is_fatal(rv)", "all.cpp", 21819, __extension__ __PRETTY_FUNCTION__));
          return rv;
        }
        if (nfrc ==
            __null)
        {
          break;
        }
        rv = conn_ppe_write_frame_hd_log(conn, ppe, &hd_logged, hd, &nfrc->fr);
        if (rv != 0)
        {

          (static_cast<bool>(
               0)
               ? void(0)
               : __assert_fail(
                     "0", "all.cpp", 21829, __extension__ __PRETTY_FUNCTION__));
        }
        *pfrc = nfrc;
        pfrc = &(*pfrc)->next;
        pkt_empty = 0;
        rtb_entry_flags |=
            NGTCP2_RTB_FLAG_ACK_ELICITING | NGTCP2_RTB_FLAG_RETRANSMITTABLE;
      }
    }
    if (rv != NGTCP2_ERR_NOBUF && *pfrc == __null &&
        conn->remote.bidi.unsent_max_streams > conn->remote.bidi.max_streams)
    {
      rv = conn_call_extend_max_remote_streams_bidi(
          conn, conn->remote.bidi.unsent_max_streams);
      if (rv != 0)
      {

        (static_cast<bool>(
             ngtcp2_err_is_fatal(rv))
             ? void(0)
             : __assert_fail(
                   "ngtcp2_err_is_fatal(rv)", "all.cpp", 21845, __extension__ __PRETTY_FUNCTION__));
        return rv;
      }
      rv = ngtcp2_frame_chain_new(&nfrc, conn->mem);
      if (rv != 0)
      {

        (static_cast<bool>(
             ngtcp2_err_is_fatal(rv))
             ? void(0)
             : __assert_fail(
                   "ngtcp2_err_is_fatal(rv)", "all.cpp", 21851, __extension__ __PRETTY_FUNCTION__));
        return rv;
      }
      nfrc->fr.type = NGTCP2_FRAME_MAX_STREAMS_BIDI;
      nfrc->fr.max_streams.max_streams = conn->remote.bidi.unsent_max_streams;
      *pfrc = nfrc;
      conn->remote.bidi.max_streams = conn->remote.bidi.unsent_max_streams;
      rv = conn_ppe_write_frame_hd_log(conn, ppe, &hd_logged, hd, &(*pfrc)->fr);
      if (rv != 0)
      {

        (static_cast<bool>(
             NGTCP2_ERR_NOBUF == rv)
             ? void(0)
             : __assert_fail(
                   "NGTCP2_ERR_NOBUF == rv", "all.cpp", 21861, __extension__ __PRETTY_FUNCTION__));
      }
      else
      {
        pkt_empty = 0;
        rtb_entry_flags |=
            NGTCP2_RTB_FLAG_ACK_ELICITING | NGTCP2_RTB_FLAG_RETRANSMITTABLE;
        pfrc = &(*pfrc)->next;
      }
    }
    if (rv != NGTCP2_ERR_NOBUF && *pfrc ==
                                      __null)
    {
      if (conn->remote.uni.unsent_max_streams > conn->remote.uni.max_streams)
      {
        rv = conn_call_extend_max_remote_streams_uni(
            conn, conn->remote.uni.unsent_max_streams);
        if (rv != 0)
        {

          (static_cast<bool>(
               ngtcp2_err_is_fatal(rv))
               ? void(0)
               : __assert_fail(
                     "ngtcp2_err_is_fatal(rv)", "all.cpp", 21879, __extension__ __PRETTY_FUNCTION__));
          return rv;
        }
        rv = ngtcp2_frame_chain_new(&nfrc, conn->mem);
        if (rv != 0)
        {

          (static_cast<bool>(
               ngtcp2_err_is_fatal(rv))
               ? void(0)
               : __assert_fail(
                     "ngtcp2_err_is_fatal(rv)", "all.cpp", 21885, __extension__ __PRETTY_FUNCTION__));
          return rv;
        }
        nfrc->fr.type = NGTCP2_FRAME_MAX_STREAMS_UNI;
        nfrc->fr.max_streams.max_streams = conn->remote.uni.unsent_max_streams;
        *pfrc = nfrc;
        conn->remote.uni.max_streams = conn->remote.uni.unsent_max_streams;
        rv = conn_ppe_write_frame_hd_log(conn, ppe, &hd_logged, hd,
                                         &(*pfrc)->fr);
        if (rv != 0)
        {

          (static_cast<bool>(
               NGTCP2_ERR_NOBUF == rv)
               ? void(0)
               : __assert_fail(
                     "NGTCP2_ERR_NOBUF == rv", "all.cpp", 21896, __extension__ __PRETTY_FUNCTION__));
        }
        else
        {
          pkt_empty = 0;
          rtb_entry_flags |=
              NGTCP2_RTB_FLAG_ACK_ELICITING | NGTCP2_RTB_FLAG_RETRANSMITTABLE;
          pfrc = &(*pfrc)->next;
        }
      }
    }
    if (rv != NGTCP2_ERR_NOBUF)
    {
      for (; !ngtcp2_pq_empty(&conn->tx.strmq);)
      {
        strm = ngtcp2_conn_tx_strmq_top(conn);
        if (!(strm->flags & NGTCP2_STRM_FLAG_SHUT_RD) &&
            conn_should_send_max_stream_data(conn, strm))
        {
          rv = ngtcp2_frame_chain_new(&nfrc, conn->mem);
          if (rv != 0)
          {

            (static_cast<bool>(
                 ngtcp2_err_is_fatal(rv))
                 ? void(0)
                 : __assert_fail(
                       "ngtcp2_err_is_fatal(rv)", "all.cpp", 21918, __extension__ __PRETTY_FUNCTION__));
            return rv;
          }
          if (conn->local.settings.max_stream_window &&
              strm->tx.last_max_stream_data_ts !=
                  (18446744073709551615UL) &&
              ts - strm->tx.last_max_stream_data_ts <
                  2 * cstat->smoothed_rtt &&
              conn->local.settings.max_stream_window > strm->rx.window)
          {
            target_max_data =
                2 * strm->rx.window;
            if (target_max_data > conn->local.settings.max_stream_window)
            {
              target_max_data = conn->local.settings.max_stream_window;
            }
            delta = target_max_data - strm->rx.window;
            if (strm->rx.unsent_max_offset + delta > ((1ULL << 62) - 1))
            {
              delta = ((1ULL << 62) - 1) - strm->rx.unsent_max_offset;
            }
            strm->rx.window = target_max_data;
          }
          else
          {
            delta = 0;
          }
          strm->tx.last_max_stream_data_ts = ts;
          nfrc->fr.type = NGTCP2_FRAME_MAX_STREAM_DATA;
          nfrc->fr.max_stream_data.stream_id = strm->stream_id;
          nfrc->fr.max_stream_data.max_stream_data =
              strm->rx.unsent_max_offset + delta;
          do
          {
            (nfrc)->next = *(pfrc);
            *(pfrc) = (nfrc);
          } while (0);
          rv =
              conn_ppe_write_frame_hd_log(conn, ppe, &hd_logged, hd, &nfrc->fr);
          if (rv != 0)
          {

            (static_cast<bool>(
                 NGTCP2_ERR_NOBUF == rv)
                 ? void(0)
                 : __assert_fail(
                       "NGTCP2_ERR_NOBUF == rv", "all.cpp", 21954, __extension__ __PRETTY_FUNCTION__));
            break;
          }
          pkt_empty = 0;
          credit_expanded = 1;
          rtb_entry_flags |=
              NGTCP2_RTB_FLAG_ACK_ELICITING | NGTCP2_RTB_FLAG_RETRANSMITTABLE;
          pfrc = &(*pfrc)->next;
          strm->rx.max_offset = strm->rx.unsent_max_offset =
              nfrc->fr.max_stream_data.max_stream_data;
        }
        if (ngtcp2_strm_streamfrq_empty(strm))
        {
          ngtcp2_conn_tx_strmq_pop(conn);
          continue;
        }
        stream_offset = ngtcp2_strm_streamfrq_unacked_offset(strm);
        if (stream_offset == (uint64_t)-1)
        {
          ngtcp2_strm_streamfrq_clear(strm);
          ngtcp2_conn_tx_strmq_pop(conn);
          continue;
        }
        left = ngtcp2_ppe_left(ppe);
        left = ngtcp2_pkt_stream_max_datalen(strm->stream_id, stream_offset,
                                             left, left);
        if (left == (size_t)-1)
        {
          break;
        }
        rv = ngtcp2_strm_streamfrq_pop(strm, &nfrc, left);
        if (rv != 0)
        {

          (static_cast<bool>(
               ngtcp2_err_is_fatal(rv))
               ? void(0)
               : __assert_fail(
                     "ngtcp2_err_is_fatal(rv)", "all.cpp", 21987, __extension__ __PRETTY_FUNCTION__));
          return rv;
        }
        if (nfrc ==
            __null)
        {
          break;
        }
        rv = conn_ppe_write_frame_hd_log(conn, ppe, &hd_logged, hd, &nfrc->fr);
        if (rv != 0)
        {

          (static_cast<bool>(
               0)
               ? void(0)
               : __assert_fail(
                     "0", "all.cpp", 21997, __extension__ __PRETTY_FUNCTION__));
        }
        *pfrc = nfrc;
        pfrc = &(*pfrc)->next;
        pkt_empty = 0;
        rtb_entry_flags |=
            NGTCP2_RTB_FLAG_ACK_ELICITING | NGTCP2_RTB_FLAG_RETRANSMITTABLE;
        if (ngtcp2_strm_streamfrq_empty(strm))
        {
          ngtcp2_conn_tx_strmq_pop(conn);
          continue;
        }
        ngtcp2_conn_tx_strmq_pop(conn);
        ++strm->cycle;
        rv = ngtcp2_conn_tx_strmq_push(conn, strm);
        if (rv != 0)
        {

          (static_cast<bool>(
               ngtcp2_err_is_fatal(rv))
               ? void(0)
               : __assert_fail(
                     "ngtcp2_err_is_fatal(rv)", "all.cpp", 22014, __extension__ __PRETTY_FUNCTION__));
          return rv;
        }
      }
    }
    if (ackfr ==
            __null &&
        credit_expanded)
    {
      rv = conn_create_ack_frame(
          conn, &ackfr, pktns, type, ts, 0,
          conn->local.settings.transport_params.ack_delay_exponent);
      if (rv != 0)
      {

        (static_cast<bool>(
             ngtcp2_err_is_fatal(rv))
             ? void(0)
             : __assert_fail(
                   "ngtcp2_err_is_fatal(rv)", "all.cpp", 22026, __extension__ __PRETTY_FUNCTION__));
        return rv;
      }
      if (ackfr)
      {
        rv = conn_ppe_write_frame_hd_log(conn, ppe, &hd_logged, hd, ackfr);
        if (rv != 0)
        {

          (static_cast<bool>(
               NGTCP2_ERR_NOBUF == rv)
               ? void(0)
               : __assert_fail(
                     "NGTCP2_ERR_NOBUF == rv", "all.cpp", 22034, __extension__ __PRETTY_FUNCTION__));
        }
        else
        {
          ngtcp2_acktr_commit_ack(&pktns->acktr);
          ngtcp2_acktr_add_ack(&pktns->acktr, hd->pkt_num,
                               ackfr->ack.largest_ack);
        }
      }
    }
    if (rv != NGTCP2_ERR_NOBUF && !send_stream &&
        !(rtb_entry_flags & NGTCP2_RTB_FLAG_ACK_ELICITING) &&
        pktns->rtb.num_retransmittable && pktns->tx.frq == __null &&
        pktns->rtb.probe_pkt_left)
    {
      num_reclaimed = ngtcp2_rtb_reclaim_on_pto(&pktns->rtb, conn, pktns,
                                                pktns->rtb.probe_pkt_left + 1);
      if (num_reclaimed < 0)
      {
        return rv;
      }
      if (num_reclaimed)
      {
        goto build_pkt;
      }
      if (pktns->rtb.num_retransmittable == 0)
      {
        pktns->rtb.probe_pkt_left = 0;
        ngtcp2_conn_set_loss_detection_timer(conn, ts);
      }
    }
  }
  else
  {
    pfrc = conn->pkt.pfrc;
    rtb_entry_flags |= conn->pkt.rtb_entry_flags;
    pkt_empty = conn->pkt.pkt_empty;
    hd_logged = conn->pkt.hd_logged;
  }
  left = ngtcp2_ppe_left(ppe);
  if (rv != NGTCP2_ERR_NOBUF && send_stream && *pfrc == __null &&
      (ndatalen = ngtcp2_pkt_stream_max_datalen(
           vmsg->stream.strm->stream_id, vmsg->stream.strm->tx.offset, ndatalen,
           left)) != (size_t)-1 &&
      (ndatalen || datalen == 0))
  {
    datacnt = ngtcp2_vec_copy_at_most(
        data, &ndatalen, 256, vmsg->stream.data,
        vmsg->stream.datacnt, ndatalen);
    rv = ngtcp2_frame_chain_stream_datacnt_new(&nfrc, datacnt, conn->mem);
    if (rv != 0)
    {

      (static_cast<bool>(
           ngtcp2_err_is_fatal(rv))
           ? void(0)
           : __assert_fail(
                 "ngtcp2_err_is_fatal(rv)", "all.cpp", 22086, __extension__ __PRETTY_FUNCTION__));
      return rv;
    }
    nfrc->fr.stream.type = NGTCP2_FRAME_STREAM;
    nfrc->fr.stream.flags = 0;
    nfrc->fr.stream.stream_id = vmsg->stream.strm->stream_id;
    nfrc->fr.stream.offset = vmsg->stream.strm->tx.offset;
    nfrc->fr.stream.datacnt = datacnt;
    ngtcp2_vec_copy(nfrc->fr.stream.data, data, datacnt);
    fin = (vmsg->stream.flags & NGTCP2_WRITE_STREAM_FLAG_FIN) &&
          ndatalen == datalen;
    nfrc->fr.stream.fin = (uint8_t)fin;
    rv = conn_ppe_write_frame_hd_log(conn, ppe, &hd_logged, hd, &nfrc->fr);
    if (rv != 0)
    {

      (static_cast<bool>(
           0)
           ? void(0)
           : __assert_fail(
                 "0", "all.cpp", 22101, __extension__ __PRETTY_FUNCTION__));
    }
    *pfrc = nfrc;
    pfrc = &(*pfrc)->next;
    pkt_empty = 0;
    rtb_entry_flags |=
        NGTCP2_RTB_FLAG_ACK_ELICITING | NGTCP2_RTB_FLAG_RETRANSMITTABLE;
    vmsg->stream.strm->tx.offset += ndatalen;
    conn->tx.offset += ndatalen;
    if (fin)
    {
      ngtcp2_strm_shutdown(vmsg->stream.strm, NGTCP2_STRM_FLAG_SHUT_WR);
    }
    if (vmsg->stream.pdatalen)
    {
      *vmsg->stream.pdatalen = (ngtcp2_ssize)ndatalen;
    }
  }
  else
  {
    send_stream = 0;
  }
  if (pkt_empty)
  {

    (static_cast<bool>(
         rv == 0 || NGTCP2_ERR_NOBUF == rv)
         ? void(0)
         : __assert_fail(
               "rv == 0 || NGTCP2_ERR_NOBUF == rv", "all.cpp", 22125, __extension__ __PRETTY_FUNCTION__));
    if (rv == 0 && stream_blocked && ngtcp2_conn_get_max_data_left(conn))
    {
      return NGTCP2_ERR_STREAM_DATA_BLOCKED;
    }
    if (conn->pktns.rtb.probe_pkt_left == 0)
    {
      return 0;
    }
  }
  else if (write_more)
  {
    conn->pkt.pfrc = pfrc;
    conn->pkt.pkt_empty = pkt_empty;
    conn->pkt.rtb_entry_flags = rtb_entry_flags;
    conn->pkt.hd_logged = hd_logged;
    conn->flags |= NGTCP2_CONN_FLAG_PPE_PENDING;
    if (send_stream)
    {
      return NGTCP2_ERR_WRITE_MORE;
    }
    if (ngtcp2_conn_get_max_data_left(conn) && stream_blocked)
    {
      return NGTCP2_ERR_STREAM_DATA_BLOCKED;
    }
  }
  if (!(rtb_entry_flags & NGTCP2_RTB_FLAG_ACK_ELICITING))
  {
    if (pktns->tx.num_non_ack_pkt >= 3)
    {
      lfr.type = NGTCP2_FRAME_PING;
      rv = conn_ppe_write_frame_hd_log(conn, ppe, &hd_logged, hd, &lfr);
      if (rv != 0)
      {

        (static_cast<bool>(
             rv == NGTCP2_ERR_NOBUF)
             ? void(0)
             : __assert_fail(
                   "rv == NGTCP2_ERR_NOBUF", "all.cpp", 22159, __extension__ __PRETTY_FUNCTION__));
      }
      else
      {
        rtb_entry_flags |= NGTCP2_RTB_FLAG_ACK_ELICITING;
        pktns->tx.num_non_ack_pkt = 0;
      }
    }
    else
    {
      ++pktns->tx.num_non_ack_pkt;
    }
  }
  else
  {
    pktns->tx.num_non_ack_pkt = 0;
  }
  lfr.type = NGTCP2_FRAME_PADDING;
  if ((require_padding ||
       ngtcp2_ppe_left(ppe) < 10 ||
       (type == NGTCP2_PKT_0RTT && conn->state == NGTCP2_CS_CLIENT_INITIAL)) &&
      ngtcp2_ppe_left(ppe))
  {
    lfr.padding.len = ngtcp2_ppe_padding(ppe);
  }
  else
  {
    lfr.padding.len = ngtcp2_ppe_padding_size(ppe, min_pktlen);
  }
  if (lfr.padding.len)
  {
    padded = 1;
    ngtcp2_log_tx_fr(&conn->log, hd, &lfr);
    ngtcp2_qlog_write_frame(&conn->qlog, &lfr);
  }
  nwrite = ngtcp2_ppe_final(ppe,
                            __null);
  if (nwrite < 0)
  {

    (static_cast<bool>(
         ngtcp2_err_is_fatal((int)nwrite))
         ? void(0)
         : __assert_fail(
               "ngtcp2_err_is_fatal((int)nwrite)", "all.cpp", 22197, __extension__ __PRETTY_FUNCTION__));
    return nwrite;
  }
  ++cc->ckm->use_count;
  ngtcp2_qlog_pkt_sent_end(&conn->qlog, hd, (size_t)nwrite);
  if ((rtb_entry_flags & NGTCP2_RTB_FLAG_ACK_ELICITING) || padded)
  {
    if (pi)
    {
      conn_handle_tx_ecn(conn, pi, &rtb_entry_flags, pktns, hd, ts);
    }
    rv = ngtcp2_rtb_entry_new(&ent, hd,
                              __null, ts, (size_t)nwrite,
                              rtb_entry_flags, conn->mem);
    if (rv != 0)
    {

      (static_cast<bool>(
           ngtcp2_err_is_fatal((int)nwrite))
           ? void(0)
           : __assert_fail(
                 "ngtcp2_err_is_fatal((int)nwrite)", "all.cpp", 22212, __extension__ __PRETTY_FUNCTION__));
      return rv;
    }
    if (*pfrc != pktns->tx.frq)
    {
      ent->frc = pktns->tx.frq;
      pktns->tx.frq = *pfrc;
      *pfrc =
          __null;
    }
    if ((rtb_entry_flags & NGTCP2_RTB_FLAG_ACK_ELICITING) &&
        pktns->rtb.num_ack_eliciting == 0 && conn->cc.event)
    {
      conn->cc.event(&conn->cc, &conn->cstat, NGTCP2_CC_EVENT_TYPE_TX_START,
                     ts);
    }
    rv = conn_on_pkt_sent(conn, &pktns->rtb, ent);
    if (rv != 0)
    {

      (static_cast<bool>(
           ngtcp2_err_is_fatal(rv))
           ? void(0)
           : __assert_fail(
                 "ngtcp2_err_is_fatal(rv)", "all.cpp", 22230, __extension__ __PRETTY_FUNCTION__));
      ngtcp2_rtb_entry_del(ent, conn->mem);
      return rv;
    }
    if (rtb_entry_flags & NGTCP2_RTB_FLAG_ACK_ELICITING)
    {
      if (conn->cc.on_pkt_sent)
      {
        conn->cc.on_pkt_sent(&conn->cc, &conn->cstat,
                             ngtcp2_cc_pkt_init(&cc_pkt, hd->pkt_num,
                                                (size_t)nwrite,
                                                NGTCP2_PKTNS_ID_APP, ts));
      }
      if (conn->flags & NGTCP2_CONN_FLAG_RESTART_IDLE_TIMER_ON_WRITE)
      {
        conn_restart_timer_on_write(conn, ts);
      }
    }
  }
  else if (pi && conn->tx.ecn.state == NGTCP2_ECN_STATE_CAPABLE)
  {
    conn_handle_tx_ecn(conn, pi,
                       __null, pktns, hd, ts);
  }
  conn->flags &= (uint16_t)~NGTCP2_CONN_FLAG_PPE_PENDING;
  if (pktns->rtb.probe_pkt_left &&
      (rtb_entry_flags & NGTCP2_RTB_FLAG_ACK_ELICITING))
  {
    --pktns->rtb.probe_pkt_left;
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_CON, "probe pkt size=%td",
                    nwrite);
  }
  ngtcp2_qlog_metrics_updated(&conn->qlog, &conn->cstat);
  ++pktns->tx.last_pkt_num;
  return nwrite;
}
ngtcp2_ssize ngtcp2_conn_write_single_frame_pkt(
    ngtcp2_conn *conn, ngtcp2_pkt_info *pi, uint8_t *dest, size_t destlen,
    uint8_t type, const ngtcp2_cid *dcid, ngtcp2_frame *fr, uint8_t rtb_flags,
    const ngtcp2_path *path, ngtcp2_tstamp ts)
{
  int rv;
  ngtcp2_ppe ppe;
  ngtcp2_pkt_hd hd;
  ngtcp2_frame lfr;
  ngtcp2_ssize nwrite;
  ngtcp2_crypto_cc cc;
  ngtcp2_pktns *pktns;
  uint8_t flags;
  ngtcp2_rtb_entry *rtbent;
  int padded = 0;
  switch (type)
  {
  case NGTCP2_PKT_INITIAL:
    pktns = conn->in_pktns;
    cc.aead_overhead = 16;
    flags = NGTCP2_PKT_FLAG_LONG_FORM;
    break;
  case NGTCP2_PKT_HANDSHAKE:
    pktns = conn->hs_pktns;
    cc.aead_overhead = conn->crypto.aead_overhead;
    flags = NGTCP2_PKT_FLAG_LONG_FORM;
    break;
  case NGTCP2_PKT_SHORT:
    pktns = &conn->pktns;
    cc.aead_overhead = conn->crypto.aead_overhead;
    flags = (pktns->crypto.tx.ckm->flags & NGTCP2_CRYPTO_KM_FLAG_KEY_PHASE_ONE)
                ? NGTCP2_PKT_FLAG_KEY_PHASE
                : NGTCP2_PKT_FLAG_NONE;
    break;
  default:

    (static_cast<bool>(
         0)
         ? void(0)
         : __assert_fail(
               "0", "all.cpp", 22301, __extension__ __PRETTY_FUNCTION__));
  }
  cc.aead = pktns->crypto.ctx.aead;
  cc.hp = pktns->crypto.ctx.hp;
  cc.ckm = pktns->crypto.tx.ckm;
  cc.hp_ctx = pktns->crypto.tx.hp_ctx;
  cc.encrypt = conn->callbacks.encrypt;
  cc.hp_mask = conn->callbacks.hp_mask;
  ngtcp2_pkt_hd_init(&hd, flags, type, dcid, &conn->oscid,
                     pktns->tx.last_pkt_num + 1, pktns_select_pkt_numlen(pktns),
                     conn->version, 0);
  ngtcp2_ppe_init(&ppe, dest, destlen, &cc);
  rv = ngtcp2_ppe_encode_hd(&ppe, &hd);
  if (rv != 0)
  {

    (static_cast<bool>(
         NGTCP2_ERR_NOBUF == rv)
         ? void(0)
         : __assert_fail(
               "NGTCP2_ERR_NOBUF == rv", "all.cpp", 22316, __extension__ __PRETTY_FUNCTION__));
    return 0;
  }
  if (!ngtcp2_ppe_ensure_hp_sample(&ppe))
  {
    return 0;
  }
  ngtcp2_log_tx_pkt_hd(&conn->log, &hd);
  ngtcp2_qlog_pkt_sent_start(&conn->qlog, &hd);
  rv = conn_ppe_write_frame(conn, &ppe, &hd, fr);
  if (rv != 0)
  {

    (static_cast<bool>(
         NGTCP2_ERR_NOBUF == rv)
         ? void(0)
         : __assert_fail(
               "NGTCP2_ERR_NOBUF == rv", "all.cpp", 22328, __extension__ __PRETTY_FUNCTION__));
    return 0;
  }
  lfr.type = NGTCP2_FRAME_PADDING;
  switch (fr->type)
  {
  case NGTCP2_FRAME_PATH_CHALLENGE:
  case NGTCP2_FRAME_PATH_RESPONSE:
    lfr.padding.len = ngtcp2_ppe_padding(&ppe);
    break;
  default:
    if (type == NGTCP2_PKT_SHORT)
    {
      lfr.padding.len =
          ngtcp2_ppe_padding_size(&ppe, conn_min_short_pktlen(conn));
    }
    else
    {
      lfr.padding.len = ngtcp2_ppe_padding_hp_sample(&ppe);
    }
  }
  if (lfr.padding.len)
  {
    padded = 1;
    ngtcp2_log_tx_fr(&conn->log, &hd, &lfr);
    ngtcp2_qlog_write_frame(&conn->qlog, &lfr);
  }
  nwrite = ngtcp2_ppe_final(&ppe,
                            __null);
  if (nwrite < 0)
  {
    return nwrite;
  }
  if (type == NGTCP2_PKT_SHORT)
  {
    ++cc.ckm->use_count;
  }
  ngtcp2_qlog_pkt_sent_end(&conn->qlog, &hd, (size_t)nwrite);
  switch (fr->type)
  {
  case NGTCP2_FRAME_ACK:
  case NGTCP2_FRAME_ACK_ECN:
    ngtcp2_acktr_commit_ack(&pktns->acktr);
    ngtcp2_acktr_add_ack(&pktns->acktr, hd.pkt_num, fr->ack.largest_ack);
    break;
  }
  if (((rtb_flags & NGTCP2_RTB_FLAG_ACK_ELICITING) || padded) &&
      (!path || ngtcp2_path_eq(&conn->dcid.current.ps.path, path)))
  {
    if (pi)
    {
      conn_handle_tx_ecn(conn, pi, &rtb_flags, pktns, &hd, ts);
    }
    rv = ngtcp2_rtb_entry_new(&rtbent, &hd,
                              __null, ts, (size_t)nwrite, rtb_flags,
                              conn->mem);
    if (rv != 0)
    {
      return rv;
    }
    rv = conn_on_pkt_sent(conn, &pktns->rtb, rtbent);
    if (rv != 0)
    {
      ngtcp2_rtb_entry_del(rtbent, conn->mem);
      return rv;
    }
    if ((rtb_flags & NGTCP2_RTB_FLAG_ACK_ELICITING) &&
        (conn->flags & NGTCP2_CONN_FLAG_RESTART_IDLE_TIMER_ON_WRITE))
    {
      conn_restart_timer_on_write(conn, ts);
    }
  }
  else if (pi && conn->tx.ecn.state == NGTCP2_ECN_STATE_CAPABLE)
  {
    conn_handle_tx_ecn(conn, pi,
                       __null, pktns, &hd, ts);
  }
  ngtcp2_qlog_metrics_updated(&conn->qlog, &conn->cstat);
  ++pktns->tx.last_pkt_num;
  return nwrite;
}
static void conn_process_early_rtb(ngtcp2_conn *conn)
{
  ngtcp2_rtb_entry *ent;
  ngtcp2_rtb *rtb = &conn->pktns.rtb;
  ngtcp2_ksl_it it;
  for (it = ngtcp2_rtb_head(rtb); !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                                     __null);
       (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
  {
    ent = ngtcp2_ksl_it_get(&it);
    if ((ent->hd.flags & NGTCP2_PKT_FLAG_LONG_FORM) == 0 ||
        ent->hd.type != NGTCP2_PKT_0RTT)
    {
      continue;
    }
    ent->hd.flags &= (uint8_t)~NGTCP2_PKT_FLAG_LONG_FORM;
    ent->hd.type = NGTCP2_PKT_SHORT;
  }
}
static int conn_handshake_remnants_left(ngtcp2_conn *conn)
{
  ngtcp2_pktns *in_pktns = conn->in_pktns;
  ngtcp2_pktns *hs_pktns = conn->hs_pktns;
  return !(conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED) ||
         (in_pktns && (in_pktns->rtb.num_retransmittable ||
                       ngtcp2_ksl_len(&in_pktns->crypto.tx.frq))) ||
         (hs_pktns && (hs_pktns->rtb.num_retransmittable ||
                       ngtcp2_ksl_len(&hs_pktns->crypto.tx.frq)));
}
static int conn_retire_dcid_seq(ngtcp2_conn *conn, uint64_t seq)
{
  ngtcp2_pktns *pktns = &conn->pktns;
  ngtcp2_frame_chain *nfrc;
  int rv;
  rv = ngtcp2_frame_chain_new(&nfrc, conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  nfrc->fr.type = NGTCP2_FRAME_RETIRE_CONNECTION_ID;
  nfrc->fr.retire_connection_id.seq = seq;
  nfrc->next = pktns->tx.frq;
  pktns->tx.frq = nfrc;
  return 0;
}
static int conn_retire_dcid(ngtcp2_conn *conn, const ngtcp2_dcid *dcid,
                            ngtcp2_tstamp ts)
{
  ngtcp2_ringbuf *rb = &conn->dcid.retired;
  ngtcp2_dcid *dest, *stale_dcid;
  int rv;

  (static_cast<bool>(
       dcid->cid.datalen)
       ? void(0)
       : __assert_fail(
             "dcid->cid.datalen", "all.cpp", 22460, __extension__ __PRETTY_FUNCTION__));
  if (ngtcp2_ringbuf_full(rb))
  {
    stale_dcid = ngtcp2_ringbuf_get(rb, 0);
    rv = conn_call_deactivate_dcid(conn, stale_dcid);
    if (rv != 0)
    {
      return rv;
    }
    ngtcp2_ringbuf_pop_front(rb);
  }
  dest = ngtcp2_ringbuf_push_back(rb);
  ngtcp2_dcid_copy(dest, dcid);
  dest->ts_retired = ts;
  return conn_retire_dcid_seq(conn, dcid->seq);
}
static int conn_bind_dcid(ngtcp2_conn *conn, ngtcp2_dcid **pdcid,
                          const ngtcp2_path *path, ngtcp2_tstamp ts)
{
  ngtcp2_pv *pv = conn->pv;
  ngtcp2_dcid *dcid, *ndcid;
  size_t i, len;
  int rv;

  (static_cast<bool>(
       !ngtcp2_path_eq(&conn->dcid.current.ps.path, path))
       ? void(0)
       : __assert_fail(
             "!ngtcp2_path_eq(&conn->dcid.current.ps.path, path)", "all.cpp", 22484, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       !pv || !ngtcp2_path_eq(&pv->dcid.ps.path, path))
       ? void(0)
       : __assert_fail(
             "!pv || !ngtcp2_path_eq(&pv->dcid.ps.path, path)", "all.cpp", 22485, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       !pv || !(pv->flags & NGTCP2_PV_FLAG_FALLBACK_ON_FAILURE) || !ngtcp2_path_eq(&pv->fallback_dcid.ps.path, path))
       ? void(0)
       : __assert_fail(
             "!pv || !(pv->flags & NGTCP2_PV_FLAG_FALLBACK_ON_FAILURE) || !ngtcp2_path_eq(&pv->fallback_dcid.ps.path, path)",
             "all.cpp",
             22487, __extension__ __PRETTY_FUNCTION__))

      ;
  if (conn->dcid.current.cid.datalen == 0)
  {
    *pdcid = &conn->dcid.current;
    return 0;
  }
  len = ((&conn->dcid.bound)->len);
  for (i = 0; i < len; ++i)
  {
    dcid = ngtcp2_ringbuf_get(&conn->dcid.bound, i);
    if (ngtcp2_path_eq(&dcid->ps.path, path))
    {
      *pdcid = dcid;
      return 0;
    }
  }
  if (((&conn->dcid.unused)->len) == 0)
  {
    return NGTCP2_ERR_CONN_ID_BLOCKED;
  }
  if (ngtcp2_ringbuf_full(&conn->dcid.bound))
  {
    dcid = ngtcp2_ringbuf_get(&conn->dcid.bound, 0);
    rv = conn_retire_dcid(conn, dcid, ts);
    if (rv != 0)
    {
      return rv;
    }
  }
  dcid = ngtcp2_ringbuf_get(&conn->dcid.unused, 0);
  ndcid = ngtcp2_ringbuf_push_back(&conn->dcid.bound);
  ngtcp2_dcid_copy(ndcid, dcid);
  ngtcp2_path_copy(&ndcid->ps.path, path);
  ngtcp2_ringbuf_pop_front(&conn->dcid.unused);
  *pdcid = ndcid;
  return 0;
}
static int conn_stop_pv(ngtcp2_conn *conn, ngtcp2_tstamp ts)
{
  int rv = 0;
  ngtcp2_pv *pv = conn->pv;
  if (pv ==
      __null)
  {
    return 0;
  }
  if (pv->dcid.seq != conn->dcid.current.seq)
  {
    rv = conn_retire_dcid(conn, &pv->dcid, ts);
    if (rv != 0)
    {
      goto fin;
    }
  }
  if ((pv->flags & NGTCP2_PV_FLAG_FALLBACK_ON_FAILURE) &&
      pv->fallback_dcid.seq != conn->dcid.current.seq &&
      pv->fallback_dcid.seq != pv->dcid.seq)
  {
    rv = conn_retire_dcid(conn, &pv->fallback_dcid, ts);
    if (rv != 0)
    {
      goto fin;
    }
  }
fin:
  ngtcp2_pv_del(pv);
  conn->pv =
      __null;
  return rv;
}
static void conn_reset_congestion_state(ngtcp2_conn *conn);
static int conn_on_path_validation_failed(ngtcp2_conn *conn, ngtcp2_pv *pv,
                                          ngtcp2_tstamp ts)
{
  int rv;
  rv = conn_call_path_validation(conn, &pv->dcid.ps.path,
                                 NGTCP2_PATH_VALIDATION_RESULT_FAILURE);
  if (rv != 0)
  {
    return rv;
  }
  if (pv->flags & NGTCP2_PV_FLAG_FALLBACK_ON_FAILURE)
  {
    ngtcp2_dcid_copy(&conn->dcid.current, &pv->fallback_dcid);
    conn_reset_congestion_state(conn);
  }
  return conn_stop_pv(conn, ts);
}
static ngtcp2_ssize conn_write_path_challenge(ngtcp2_conn *conn,
                                              ngtcp2_path *path,
                                              ngtcp2_pkt_info *pi,
                                              uint8_t *dest, size_t destlen,
                                              ngtcp2_tstamp ts)
{
  int rv;
  ngtcp2_ssize nwrite;
  ngtcp2_tstamp expiry;
  ngtcp2_pv *pv = conn->pv;
  ngtcp2_frame lfr;
  ngtcp2_duration timeout;
  if (ngtcp2_pv_validation_timed_out(pv, ts))
  {
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PTV,
                    "path validation was timed out");
    return conn_on_path_validation_failed(conn, pv, ts);
  }
  ngtcp2_pv_handle_entry_expiry(pv, ts);
  if (!ngtcp2_pv_should_send_probe(pv))
  {
    return 0;
  }

  (static_cast<bool>(
       conn->callbacks.rand)
       ? void(0)
       : __assert_fail(
             "conn->callbacks.rand", "all.cpp", 22601, __extension__ __PRETTY_FUNCTION__));
  rv = conn->callbacks.rand(
      lfr.path_challenge.data, sizeof(lfr.path_challenge.data),
      &conn->local.settings.rand_ctx, NGTCP2_RAND_USAGE_PATH_CHALLENGE);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  lfr.type = NGTCP2_FRAME_PATH_CHALLENGE;
  timeout = conn_compute_pto(conn, &conn->pktns);
  timeout = ((timeout) > (3 * conn->cstat.initial_rtt) ? (timeout) : (3 * conn->cstat.initial_rtt));
  expiry = ts + timeout * (1ULL << pv->round);
  ngtcp2_pv_add_entry(pv, lfr.path_challenge.data, expiry, ts);
  nwrite = ngtcp2_conn_write_single_frame_pkt(
      conn, pi, dest, destlen, NGTCP2_PKT_SHORT, &pv->dcid.cid, &lfr,
      NGTCP2_RTB_FLAG_ACK_ELICITING, &pv->dcid.ps.path, ts);
  if (nwrite <= 0)
  {
    return nwrite;
  }
  if (path)
  {
    ngtcp2_path_copy(path, &pv->dcid.ps.path);
  }
  return nwrite;
}
static ngtcp2_ssize conn_write_path_response(ngtcp2_conn *conn,
                                             ngtcp2_path *path,
                                             ngtcp2_pkt_info *pi, uint8_t *dest,
                                             size_t destlen, ngtcp2_tstamp ts)
{
  ngtcp2_pv *pv = conn->pv;
  ngtcp2_path_challenge_entry *pcent =
      __null;
  ngtcp2_dcid *dcid =
      __null;
  ngtcp2_frame lfr;
  ngtcp2_ssize nwrite;
  int rv;
  for (; ((&conn->rx.path_challenge)->len);)
  {
    pcent = ngtcp2_ringbuf_get(&conn->rx.path_challenge, 0);
    if (ngtcp2_path_eq(&conn->dcid.current.ps.path, &pcent->ps.path))
    {
      return 0;
    }
    if (pv)
    {
      if (ngtcp2_path_eq(&pv->dcid.ps.path, &pcent->ps.path))
      {
        dcid = &pv->dcid;
        break;
      }
      if ((pv->flags & NGTCP2_PV_FLAG_FALLBACK_ON_FAILURE) &&
          ngtcp2_path_eq(&pv->fallback_dcid.ps.path, &pcent->ps.path))
      {
        dcid = &pv->fallback_dcid;
        break;
      }
    }
    if (conn->server)
    {
      break;
    }
    ngtcp2_ringbuf_pop_front(&conn->rx.path_challenge);
    pcent =
        __null;
  }
  if (pcent ==
      __null)
  {
    return 0;
  }
  if (dcid ==
      __null)
  {

    (static_cast<bool>(
         conn->server)
         ? void(0)
         : __assert_fail(
               "conn->server", "all.cpp", 22673, __extension__ __PRETTY_FUNCTION__));
    rv = conn_bind_dcid(conn, &dcid, &pcent->ps.path, ts);
    if (rv != 0)
    {
      if (ngtcp2_err_is_fatal(rv))
      {
        return rv;
      }
      return 0;
    }
  }
  lfr.type = NGTCP2_FRAME_PATH_RESPONSE;
  memcpy(lfr.path_response.data, pcent->data, sizeof(lfr.path_response.data));
  nwrite = ngtcp2_conn_write_single_frame_pkt(
      conn, pi, dest, destlen, NGTCP2_PKT_SHORT, &dcid->cid, &lfr,
      NGTCP2_RTB_FLAG_ACK_ELICITING, &pcent->ps.path, ts);
  if (nwrite <= 0)
  {
    return nwrite;
  }
  if (path)
  {
    ngtcp2_path_copy(path, &pcent->ps.path);
  }
  ngtcp2_ringbuf_pop_front(&conn->rx.path_challenge);
  return nwrite;
}
ngtcp2_ssize ngtcp2_conn_write_pkt(ngtcp2_conn *conn, ngtcp2_path *path,
                                   ngtcp2_pkt_info *pi, uint8_t *dest,
                                   size_t destlen, ngtcp2_tstamp ts)
{
  return ngtcp2_conn_writev_stream(conn, path, pi, dest, destlen,

                                   __null,
                                   NGTCP2_WRITE_STREAM_FLAG_NONE,
                                   -1,

                                   __null, 0, ts);
}
static int conn_on_version_negotiation(ngtcp2_conn *conn,
                                       const ngtcp2_pkt_hd *hd,
                                       const uint8_t *payload,
                                       size_t payloadlen)
{
  uint32_t sv[16];
  uint32_t *p;
  int rv = 0;
  size_t nsv;
  size_t i;
  if (payloadlen % sizeof(uint32_t))
  {
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  if (payloadlen > sizeof(sv))
  {
    p = ngtcp2_mem_malloc(conn->mem, payloadlen);
    if (p ==
        __null)
    {
      return NGTCP2_ERR_NOMEM;
    }
  }
  else
  {
    p = sv;
  }
  nsv = ngtcp2_pkt_decode_version_negotiation(p, payload, payloadlen);
  ngtcp2_log_rx_vn(&conn->log, hd, p, nsv);
  for (i = 0; i < nsv; ++i)
  {
    if (p[i] == conn->version)
    {
      ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                      "ignore Version Negotiation because it contains version "
                      "selected by client");
      rv = NGTCP2_ERR_INVALID_ARGUMENT;
      goto fin;
    }
  }
  if (conn->callbacks.recv_version_negotiation)
  {
    rv = conn->callbacks.recv_version_negotiation(conn, hd, p, nsv,
                                                  conn->user_data);
    if (rv != 0)
    {
      rv = NGTCP2_ERR_CALLBACK_FAILURE;
    }
  }
  if (rv == 0)
  {
    conn->state = NGTCP2_CS_DRAINING;
  }
fin:
  if (p != sv)
  {
    ngtcp2_mem_free(conn->mem, p);
  }
  return rv;
}
static uint64_t conn_tx_strmq_first_cycle(ngtcp2_conn *conn)
{
  ngtcp2_strm *strm;
  if (ngtcp2_pq_empty(&conn->tx.strmq))
  {
    return 0;
  }
  strm = ((ngtcp2_strm *)(void *)((char *)(ngtcp2_pq_top(&conn->tx.strmq)) -
                                  __builtin_offsetof(
                                      ngtcp2_strm,
                                      pe)));
  return strm->cycle;
}
uint64_t ngtcp2_conn_tx_strmq_first_cycle(ngtcp2_conn *conn)
{
  ngtcp2_strm *strm;
  if (ngtcp2_pq_empty(&conn->tx.strmq))
  {
    return 0;
  }
  strm = ((ngtcp2_strm *)(void *)((char *)(ngtcp2_pq_top(&conn->tx.strmq)) -
                                  __builtin_offsetof(
                                      ngtcp2_strm,
                                      pe)));
  return strm->cycle;
}
int ngtcp2_conn_resched_frames(ngtcp2_conn *conn, ngtcp2_pktns *pktns,
                               ngtcp2_frame_chain **pfrc)
{
  ngtcp2_frame_chain **first = pfrc;
  ngtcp2_frame_chain *frc;
  ngtcp2_stream *sfr;
  ngtcp2_strm *strm;
  int rv;
  if (*pfrc ==
      __null)
  {
    return 0;
  }
  for (; *pfrc;)
  {
    switch ((*pfrc)->fr.type)
    {
    case NGTCP2_FRAME_STREAM:
      frc = *pfrc;
      *pfrc = frc->next;
      frc->next =
          __null;
      sfr = &frc->fr.stream;
      strm = ngtcp2_conn_find_stream(conn, sfr->stream_id);
      if (!strm)
      {
        ngtcp2_frame_chain_del(frc, conn->mem);
        break;
      }
      rv = ngtcp2_strm_streamfrq_push(strm, frc);
      if (rv != 0)
      {
        ngtcp2_frame_chain_del(frc, conn->mem);
        return rv;
      }
      if (!ngtcp2_strm_is_tx_queued(strm))
      {
        strm->cycle = conn_tx_strmq_first_cycle(conn);
        rv = ngtcp2_conn_tx_strmq_push(conn, strm);
        if (rv != 0)
        {
          return rv;
        }
      }
      break;
    case NGTCP2_FRAME_CRYPTO:
      frc = *pfrc;
      *pfrc = frc->next;
      frc->next =
          __null;
      rv = ngtcp2_ksl_insert(&pktns->crypto.tx.frq,
                             __null,
                             &frc->fr.crypto.offset, frc);
      if (rv != 0)
      {

        (static_cast<bool>(
             ngtcp2_err_is_fatal(rv))
             ? void(0)
             : __assert_fail(
                   "ngtcp2_err_is_fatal(rv)", "all.cpp", 22846, __extension__ __PRETTY_FUNCTION__));
        ngtcp2_frame_chain_del(frc, conn->mem);
        return rv;
      }
      break;
    default:
      pfrc = &(*pfrc)->next;
    }
  }
  *pfrc = pktns->tx.frq;
  pktns->tx.frq = *first;
  return 0;
}
static int conn_on_retry(ngtcp2_conn *conn, const ngtcp2_pkt_hd *hd,
                         size_t hdpktlen, const uint8_t *pkt, size_t pktlen)
{
  int rv;
  ngtcp2_pkt_retry retry;
  ngtcp2_pktns *in_pktns = conn->in_pktns;
  ngtcp2_rtb *rtb = &conn->pktns.rtb;
  ngtcp2_rtb *in_rtb;
  uint8_t cidbuf[sizeof(retry.odcid.data) * 2 + 1];
  ngtcp2_vec *token;
  if (!in_pktns || conn->flags & NGTCP2_CONN_FLAG_RECV_RETRY)
  {
    return 0;
  }
  in_rtb = &in_pktns->rtb;
  rv = ngtcp2_pkt_decode_retry(&retry, pkt + hdpktlen, pktlen - hdpktlen);
  if (rv != 0)
  {
    return rv;
  }
  retry.odcid = conn->dcid.current.cid;
  rv = ngtcp2_pkt_verify_retry_tag(&retry, pkt, pktlen, conn->callbacks.encrypt,
                                   &conn->crypto.retry_aead,
                                   &conn->crypto.retry_aead_ctx);
  if (rv != 0)
  {
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                    "unable to verify Retry packet integrity");
    return rv;
  }
  ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT, "odcid=0x%s",
                  (const char *)ngtcp2_encode_hex(cidbuf, retry.odcid.data,
                                                  retry.odcid.datalen));
  if (retry.token.len == 0)
  {
    return NGTCP2_ERR_PROTO;
  }
  if (ngtcp2_cid_eq(&conn->dcid.current.cid, &hd->scid))
  {
    return 0;
  }
  conn->dcid.current.cid = hd->scid;
  conn->retry_scid = hd->scid;
  conn->flags |= NGTCP2_CONN_FLAG_RECV_RETRY;

  (static_cast<bool>(
       conn->callbacks.recv_retry)
       ? void(0)
       : __assert_fail(
             "conn->callbacks.recv_retry", "all.cpp", 22904, __extension__ __PRETTY_FUNCTION__));
  rv = conn->callbacks.recv_retry(conn, hd, conn->user_data);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  conn->state = NGTCP2_CS_CLIENT_INITIAL;
  rv = ngtcp2_rtb_remove_all(rtb, conn, &conn->pktns, &conn->cstat);
  if (rv != 0)
  {
    return rv;
  }
  rv = ngtcp2_rtb_remove_all(in_rtb, conn, in_pktns, &conn->cstat);
  if (rv != 0)
  {
    return rv;
  }
  token = &conn->local.settings.token;
  ngtcp2_mem_free(conn->mem, token->base);
  token->base =
      __null;
  token->len = 0;
  token->base = ngtcp2_mem_malloc(conn->mem, retry.token.len);
  if (token->base ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  token->len = retry.token.len;
  ngtcp2_cpymem(token->base, retry.token.base, retry.token.len);
  reset_conn_stat_recovery(&conn->cstat);
  conn_reset_congestion_state(conn);
  conn_reset_ecn_validation_state(conn);
  return 0;
}
int ngtcp2_conn_detect_lost_pkt(ngtcp2_conn *conn, ngtcp2_pktns *pktns,
                                ngtcp2_conn_stat *cstat, ngtcp2_tstamp ts)
{
  ngtcp2_duration pto = conn_compute_pto(conn, pktns);
  int rv = ngtcp2_rtb_detect_lost_pkt(&pktns->rtb, conn, pktns, cstat, pto, ts);
  if (rv != 0)
  {
    return rv;
  }
  return 0;
}
static int conn_recv_ack(ngtcp2_conn *conn, ngtcp2_pktns *pktns, ngtcp2_ack *fr,
                         ngtcp2_tstamp pkt_ts, ngtcp2_tstamp ts)
{
  int rv;
  ngtcp2_frame_chain *frc =
      __null;
  ngtcp2_ssize num_acked;
  ngtcp2_conn_stat *cstat = &conn->cstat;
  if (pktns->tx.last_pkt_num < fr->largest_ack)
  {
    return NGTCP2_ERR_PROTO;
  }
  rv = ngtcp2_pkt_validate_ack(fr);
  if (rv != 0)
  {
    return rv;
  }
  ngtcp2_acktr_recv_ack(&pktns->acktr, fr);
  num_acked = ngtcp2_rtb_recv_ack(&pktns->rtb, fr, &conn->cstat, conn, pktns,
                                  pkt_ts, ts);
  if (num_acked < 0)
  {

    (static_cast<bool>(
         ngtcp2_err_is_fatal((int)num_acked))
         ? void(0)
         : __assert_fail(
               "ngtcp2_err_is_fatal((int)num_acked)", "all.cpp", 22971, __extension__ __PRETTY_FUNCTION__));
    ngtcp2_frame_chain_list_del(frc, conn->mem);
    return (int)num_acked;
  }
  if (num_acked == 0)
  {
    return 0;
  }
  rv = ngtcp2_conn_detect_lost_pkt(conn, pktns, &conn->cstat, ts);
  if (rv != 0)
  {
    return rv;
  }
  pktns->rtb.probe_pkt_left = 0;
  if (cstat->pto_count &&
      (conn->server || (conn->flags & NGTCP2_CONN_FLAG_SERVER_ADDR_VERIFIED)))
  {
    cstat->pto_count = ((cstat->pto_count) < (2) ? (cstat->pto_count) : (2));
  }
  ngtcp2_conn_set_loss_detection_timer(conn, ts);
  return 0;
}
static void assign_recved_ack_delay_unscaled(ngtcp2_ack *fr,
                                             uint64_t ack_delay_exponent)
{
  fr->ack_delay_unscaled =
      fr->ack_delay * (1UL << ack_delay_exponent) * ((uint64_t)1000ULL);
}
static int conn_recv_max_stream_data(ngtcp2_conn *conn,
                                     const ngtcp2_max_stream_data *fr)
{
  ngtcp2_strm *strm;
  ngtcp2_idtr *idtr;
  int local_stream = conn_local_stream(conn, fr->stream_id);
  int bidi = bidi_stream(fr->stream_id);
  int rv;
  if (bidi)
  {
    if (local_stream)
    {
      if (conn->local.bidi.next_stream_id <= fr->stream_id)
      {
        return NGTCP2_ERR_STREAM_STATE;
      }
    }
    else if (conn->remote.bidi.max_streams <
             ngtcp2_ord_stream_id(fr->stream_id))
    {
      return NGTCP2_ERR_STREAM_LIMIT;
    }
    idtr = &conn->remote.bidi.idtr;
  }
  else
  {
    if (!local_stream || conn->local.uni.next_stream_id <= fr->stream_id)
    {
      return NGTCP2_ERR_STREAM_STATE;
    }
    idtr = &conn->remote.uni.idtr;
  }
  strm = ngtcp2_conn_find_stream(conn, fr->stream_id);
  if (strm ==
      __null)
  {
    if (local_stream)
    {
      return 0;
    }
    rv = ngtcp2_idtr_open(idtr, fr->stream_id);
    if (rv != 0)
    {
      if (ngtcp2_err_is_fatal(rv))
      {
        return rv;
      }

      (static_cast<bool>(
           rv == NGTCP2_ERR_STREAM_IN_USE)
           ? void(0)
           : __assert_fail(
                 "rv == NGTCP2_ERR_STREAM_IN_USE", "all.cpp", 23047, __extension__ __PRETTY_FUNCTION__));
      return 0;
    }
    strm = ngtcp2_mem_malloc(conn->mem, sizeof(ngtcp2_strm));
    if (strm ==
        __null)
    {
      return NGTCP2_ERR_NOMEM;
    }
    rv = ngtcp2_conn_init_stream(conn, strm, fr->stream_id,
                                 __null);
    if (rv != 0)
    {
      ngtcp2_mem_free(conn->mem, strm);
      return rv;
    }
  }
  if (strm->tx.max_offset < fr->max_stream_data)
  {
    strm->tx.max_offset = fr->max_stream_data;
    if (strm->flags & NGTCP2_STRM_FLAG_SHUT_WR)
    {
      return 0;
    }
    rv = conn_call_extend_max_stream_data(conn, strm, fr->stream_id,
                                          fr->max_stream_data);
    if (rv != 0)
    {
      return rv;
    }
  }
  return 0;
}
static void conn_recv_max_data(ngtcp2_conn *conn, const ngtcp2_max_data *fr)
{
  conn->tx.max_offset = ((conn->tx.max_offset) > (fr->max_data) ? (conn->tx.max_offset) : (fr->max_data));
}
static int conn_buffer_pkt(ngtcp2_conn *conn, ngtcp2_pktns *pktns,
                           const ngtcp2_path *path, const ngtcp2_pkt_info *pi,
                           const uint8_t *pkt, size_t pktlen,
                           ngtcp2_tstamp ts)
{
  int rv;
  ngtcp2_pkt_chain **ppc = &pktns->rx.buffed_pkts, *pc;
  size_t i;
  for (i = 0; *ppc && i < 4;
       ppc = &(*ppc)->next, ++i)
    ;
  if (i == 4)
  {
    return 0;
  }
  rv = ngtcp2_pkt_chain_new(&pc, path, pi, pkt, pktlen, ts, conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  *ppc = pc;
  return 0;
}
static int ensure_decrypt_buffer(ngtcp2_vec *vec, size_t n, size_t initial,
                                 const ngtcp2_mem *mem)
{
  uint8_t *nbuf;
  size_t len;
  if (vec->len >= n)
  {
    return 0;
  }
  len = vec->len == 0 ? initial : vec->len * 2;
  for (; len < n; len *= 2)
    ;
  nbuf = ngtcp2_mem_realloc(mem, vec->base, len);
  if (nbuf ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  vec->base = nbuf;
  vec->len = len;
  return 0;
}
static int conn_ensure_decrypt_hp_buffer(ngtcp2_conn *conn, size_t n)
{
  return ensure_decrypt_buffer(&conn->crypto.decrypt_hp_buf, n, 256, conn->mem);
}
static int conn_ensure_decrypt_buffer(ngtcp2_conn *conn, size_t n)
{
  return ensure_decrypt_buffer(&conn->crypto.decrypt_buf, n, 2048, conn->mem);
}
static ngtcp2_ssize decrypt_pkt(uint8_t *dest, const ngtcp2_crypto_aead *aead,
                                const uint8_t *payload, size_t payloadlen,
                                const uint8_t *ad, size_t adlen,
                                int64_t pkt_num, ngtcp2_crypto_km *ckm,
                                ngtcp2_decrypt decrypt, size_t aead_overhead)
{
  uint8_t nonce[64];
  int rv;

  (static_cast<bool>(
       sizeof(nonce) >= ckm->iv.len)
       ? void(0)
       : __assert_fail(
             "sizeof(nonce) >= ckm->iv.len", "all.cpp", 23148, __extension__ __PRETTY_FUNCTION__));
  ngtcp2_crypto_create_nonce(nonce, ckm->iv.base, ckm->iv.len, pkt_num);
  rv = decrypt(dest, aead, &ckm->aead_ctx, payload, payloadlen, nonce,
               ckm->iv.len, ad, adlen);
  if (rv != 0)
  {
    if (rv == NGTCP2_ERR_TLS_DECRYPT)
    {
      return rv;
    }
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }

  (static_cast<bool>(
       payloadlen >= aead_overhead)
       ? void(0)
       : __assert_fail(
             "payloadlen >= aead_overhead", "all.cpp", 23160, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)(payloadlen - aead_overhead);
}
static ngtcp2_ssize decrypt_hp(ngtcp2_pkt_hd *hd, uint8_t *dest,
                               const ngtcp2_crypto_cipher *hp,
                               const uint8_t *pkt, size_t pktlen,
                               size_t pkt_num_offset, ngtcp2_crypto_km *ckm,
                               const ngtcp2_crypto_cipher_ctx *hp_ctx,
                               ngtcp2_hp_mask hp_mask)
{
  size_t sample_offset;
  uint8_t *p = dest;
  uint8_t mask[5];
  size_t i;
  int rv;

  (static_cast<bool>(
       hp_mask)
       ? void(0)
       : __assert_fail(
             "hp_mask", "all.cpp", 23176, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       ckm)
       ? void(0)
       : __assert_fail(
             "ckm", "all.cpp", 23177, __extension__ __PRETTY_FUNCTION__));
  if (pkt_num_offset + 4 + 16 > pktlen)
  {
    return NGTCP2_ERR_PROTO;
  }
  p = ngtcp2_cpymem(p, pkt, pkt_num_offset);
  sample_offset = pkt_num_offset + 4;
  rv = hp_mask(mask, hp, hp_ctx, pkt + sample_offset);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  if (hd->flags & NGTCP2_PKT_FLAG_LONG_FORM)
  {
    dest[0] = (uint8_t)(dest[0] ^ (mask[0] & 0x0f));
  }
  else
  {
    dest[0] = (uint8_t)(dest[0] ^ (mask[0] & 0x1f));
    if (dest[0] & 0x04)
    {
      hd->flags |= NGTCP2_PKT_FLAG_KEY_PHASE;
    }
  }
  hd->pkt_numlen = (size_t)((dest[0] & 0x03) + 1);
  for (i = 0; i < hd->pkt_numlen; ++i)
  {
    *p++ = *(pkt + pkt_num_offset + i) ^ mask[i + 1];
  }
  hd->pkt_num = ngtcp2_get_pkt_num(p - hd->pkt_numlen, hd->pkt_numlen);
  return p - dest;
}
static int conn_emit_pending_crypto_data(ngtcp2_conn *conn,
                                         ngtcp2_crypto_level crypto_level,
                                         ngtcp2_strm *strm,
                                         uint64_t rx_offset)
{
  size_t datalen;
  const uint8_t *data;
  int rv;
  uint64_t offset;
  if (!strm->rx.rob)
  {
    return 0;
  }
  for (;;)
  {
    datalen = ngtcp2_rob_data_at(strm->rx.rob, &data, rx_offset);
    if (datalen == 0)
    {

      (static_cast<bool>(
           rx_offset == ngtcp2_strm_rx_offset(strm))
           ? void(0)
           : __assert_fail(
                 "rx_offset == ngtcp2_strm_rx_offset(strm)", "all.cpp", 23228, __extension__ __PRETTY_FUNCTION__));
      return 0;
    }
    offset = rx_offset;
    rx_offset += datalen;
    rv = conn_call_recv_crypto_data(conn, crypto_level, offset, data, datalen);
    if (rv != 0)
    {
      return rv;
    }
    ngtcp2_rob_pop(strm->rx.rob, rx_offset - datalen, datalen);
  }
}
static void conn_recv_connection_close(ngtcp2_conn *conn,
                                       ngtcp2_connection_close *fr)
{
  conn->state = NGTCP2_CS_DRAINING;
  if (fr->type == NGTCP2_FRAME_CONNECTION_CLOSE)
  {
    conn->rx.ccec.type = NGTCP2_CONNECTION_CLOSE_ERROR_CODE_TYPE_TRANSPORT;
  }
  else
  {
    conn->rx.ccec.type = NGTCP2_CONNECTION_CLOSE_ERROR_CODE_TYPE_APPLICATION;
  }
  conn->rx.ccec.error_code = fr->error_code;
}
static void conn_recv_path_challenge(ngtcp2_conn *conn, const ngtcp2_path *path,
                                     ngtcp2_path_challenge *fr)
{
  ngtcp2_path_challenge_entry *ent;
  ent = ngtcp2_ringbuf_push_front(&conn->rx.path_challenge);
  ngtcp2_path_challenge_entry_init(ent, path, fr->data);
}
static void conn_reset_congestion_state(ngtcp2_conn *conn)
{
  conn_reset_conn_stat_cc(conn, &conn->cstat);
  conn_reset_rx_rate(conn);
  conn->cc.reset(&conn->cc);
  if (conn->hs_pktns)
  {
    ngtcp2_rtb_reset_cc_state(&conn->hs_pktns->rtb,
                              conn->hs_pktns->tx.last_pkt_num + 1);
  }
  ngtcp2_rtb_reset_cc_state(&conn->pktns.rtb, conn->pktns.tx.last_pkt_num + 1);
  ngtcp2_rst_init(&conn->rst);
}
static int conn_recv_path_response(ngtcp2_conn *conn, ngtcp2_path_response *fr,
                                   ngtcp2_tstamp ts)
{
  int rv;
  ngtcp2_duration timeout;
  ngtcp2_pv *pv = conn->pv, *npv;
  if (!pv)
  {
    return 0;
  }
  rv = ngtcp2_pv_validate(pv, fr->data);
  if (rv != 0)
  {
    if (rv == NGTCP2_ERR_PATH_VALIDATION_FAILED)
    {
      return conn_on_path_validation_failed(conn, pv, ts);
    }
    return 0;
  }
  if (!(pv->flags & NGTCP2_PV_FLAG_FALLBACK_ON_FAILURE))
  {
    if (pv->dcid.seq != conn->dcid.current.seq)
    {

      (static_cast<bool>(
           conn->dcid.current.cid.datalen)
           ? void(0)
           : __assert_fail(
                 "conn->dcid.current.cid.datalen", "all.cpp", 23302, __extension__ __PRETTY_FUNCTION__));
      rv = conn_retire_dcid(conn, &conn->dcid.current, ts);
      if (rv != 0)
      {
        goto fail;
      }
      ngtcp2_dcid_copy(&conn->dcid.current, &pv->dcid);
    }
    conn_reset_congestion_state(conn);
    conn_reset_ecn_validation_state(conn);
  }
  if (!(pv->flags & NGTCP2_PV_FLAG_DONT_CARE))
  {
    rv = conn_call_path_validation(conn, &pv->dcid.ps.path,
                                   NGTCP2_PATH_VALIDATION_RESULT_SUCCESS);
    if (rv != 0)
    {
      goto fail;
    }
  }
  if (pv->flags & NGTCP2_PV_FLAG_FALLBACK_ON_FAILURE)
  {
    timeout = 3 * conn_compute_pto(conn, &conn->pktns);
    timeout = ((timeout) > (6 * conn->cstat.initial_rtt) ? (timeout) : (6 * conn->cstat.initial_rtt));
    rv = ngtcp2_pv_new(&npv, &pv->fallback_dcid, timeout,
                       NGTCP2_PV_FLAG_DONT_CARE, &conn->log, conn->mem);
    if (rv != 0)
    {
      goto fail;
    }
    pv->flags &= (uint8_t)~NGTCP2_PV_FLAG_FALLBACK_ON_FAILURE;
    rv = conn_stop_pv(conn, ts);
    if (rv != 0)
    {
      ngtcp2_pv_del(npv);
      return rv;
    }
    conn->pv = npv;
    return 0;
  }
fail:
  return conn_stop_pv(conn, ts);
}
static size_t pkt_num_bits(size_t pkt_numlen)
{
  switch (pkt_numlen)
  {
  case 1:
    return 8;
  case 2:
    return 16;
  case 3:
    return 24;
  case 4:
    return 32;
  default:

    (static_cast<bool>(
         0)
         ? void(0)
         : __assert_fail(
               "0", "all.cpp", 23360, __extension__ __PRETTY_FUNCTION__));
  }
}
static int pktns_pkt_num_is_duplicate(ngtcp2_pktns *pktns, int64_t pkt_num)
{
  return ngtcp2_gaptr_is_pushed(&pktns->rx.pngap, (uint64_t)pkt_num, 1);
}
static int pktns_commit_recv_pkt_num(ngtcp2_pktns *pktns, int64_t pkt_num,
                                     int ack_eliciting, ngtcp2_tstamp ts)
{
  int rv;
  if (ack_eliciting && pktns->rx.max_ack_eliciting_pkt_num + 1 != pkt_num)
  {
    ngtcp2_acktr_immediate_ack(&pktns->acktr);
  }
  if (pktns->rx.max_pkt_num < pkt_num)
  {
    pktns->rx.max_pkt_num = pkt_num;
    pktns->rx.max_pkt_ts = ts;
  }
  if (ack_eliciting && pktns->rx.max_ack_eliciting_pkt_num < pkt_num)
  {
    pktns->rx.max_ack_eliciting_pkt_num = pkt_num;
  }
  rv = ngtcp2_gaptr_push(&pktns->rx.pngap, (uint64_t)pkt_num, 1);
  if (rv != 0)
  {
    return rv;
  }
  if (ngtcp2_ksl_len(&pktns->rx.pngap.gap) > 256)
  {
    ngtcp2_gaptr_drop_first_gap(&pktns->rx.pngap);
  }
  return 0;
}
static int verify_token(const ngtcp2_vec *token, const ngtcp2_pkt_hd *hd)
{
  if (token->len == hd->token.len &&
      ngtcp2_cmemeq(token->base, hd->token.base, token->len))
  {
    return 0;
  }
  return NGTCP2_ERR_PROTO;
}
static void pktns_increase_ecn_counts(ngtcp2_pktns *pktns,
                                      const ngtcp2_pkt_info *pi)
{
  switch (pi->ecn & NGTCP2_ECN_MASK)
  {
  case NGTCP2_ECN_ECT_0:
    ++pktns->rx.ecn.ect0;
    break;
  case NGTCP2_ECN_ECT_1:
    ++pktns->rx.ecn.ect1;
    break;
  case NGTCP2_ECN_CE:
    ++pktns->rx.ecn.ce;
    break;
  }
}
static int conn_recv_crypto(ngtcp2_conn *conn, ngtcp2_crypto_level crypto_level,
                            ngtcp2_strm *strm, const ngtcp2_crypto *fr);
static ngtcp2_ssize conn_recv_pkt(ngtcp2_conn *conn, const ngtcp2_path *path,
                                  const ngtcp2_pkt_info *pi, const uint8_t *pkt,
                                  size_t pktlen, ngtcp2_tstamp pkt_ts,
                                  ngtcp2_tstamp ts);
static int conn_process_buffered_protected_pkt(ngtcp2_conn *conn,
                                               ngtcp2_pktns *pktns,
                                               ngtcp2_tstamp ts);
static ngtcp2_ssize
conn_recv_handshake_pkt(ngtcp2_conn *conn, const ngtcp2_path *path,
                        const ngtcp2_pkt_info *pi, const uint8_t *pkt,
                        size_t pktlen, ngtcp2_tstamp pkt_ts, ngtcp2_tstamp ts)
{
  ngtcp2_ssize nread;
  ngtcp2_pkt_hd hd;
  ngtcp2_max_frame mfr;
  ngtcp2_frame *fr = &mfr.fr;
  int rv;
  int require_ack = 0;
  size_t hdpktlen;
  const uint8_t *payload;
  size_t payloadlen;
  ngtcp2_ssize nwrite;
  ngtcp2_crypto_aead *aead;
  ngtcp2_crypto_cipher *hp;
  ngtcp2_crypto_km *ckm;
  ngtcp2_crypto_cipher_ctx *hp_ctx;
  ngtcp2_hp_mask hp_mask;
  ngtcp2_decrypt decrypt;
  size_t aead_overhead;
  ngtcp2_pktns *pktns;
  ngtcp2_strm *crypto;
  ngtcp2_crypto_level crypto_level;
  int invalid_reserved_bits = 0;
  if (pktlen == 0)
  {
    return 0;
  }
  if (!(pkt[0] & 0x80))
  {
    if (conn->state == NGTCP2_CS_SERVER_INITIAL)
    {
      return (ngtcp2_ssize)pktlen;
    }
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_CON,
                    "buffering Short packet len=%zu", pktlen);
    rv = conn_buffer_pkt(conn, &conn->pktns, path, pi, pkt, pktlen, ts);
    if (rv != 0)
    {

      (static_cast<bool>(
           ngtcp2_err_is_fatal(rv))
           ? void(0)
           : __assert_fail(
                 "ngtcp2_err_is_fatal(rv)", "all.cpp", 23478, __extension__ __PRETTY_FUNCTION__));
      return rv;
    }
    return (ngtcp2_ssize)pktlen;
  }
  nread = ngtcp2_pkt_decode_hd_long(&hd, pkt, pktlen);
  if (nread < 0)
  {
    return NGTCP2_ERR_DISCARD_PKT;
  }
  switch (hd.type)
  {
  case NGTCP2_PKT_VERSION_NEGOTIATION:
    hdpktlen = (size_t)nread;
    ngtcp2_log_rx_pkt_hd(&conn->log, &hd);
    if (conn->server)
    {
      return NGTCP2_ERR_DISCARD_PKT;
    }
    if (conn->flags & NGTCP2_CONN_FLAG_CONN_ID_NEGOTIATED)
    {
      return NGTCP2_ERR_DISCARD_PKT;
    }
    if (!ngtcp2_cid_eq(&conn->oscid, &hd.dcid))
    {
      ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                      "packet was ignored because of mismatched DCID");
      return NGTCP2_ERR_DISCARD_PKT;
    }
    if (!ngtcp2_cid_eq(&conn->dcid.current.cid, &hd.scid))
    {
      ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                      "packet was ignored because of mismatched SCID");
      return NGTCP2_ERR_DISCARD_PKT;
    }
    rv = conn_on_version_negotiation(conn, &hd, pkt + hdpktlen,
                                     pktlen - hdpktlen);
    if (rv != 0)
    {
      if (ngtcp2_err_is_fatal(rv))
      {
        return rv;
      }
      return NGTCP2_ERR_DISCARD_PKT;
    }
    return NGTCP2_ERR_RECV_VERSION_NEGOTIATION;
  case NGTCP2_PKT_RETRY:
    hdpktlen = (size_t)nread;
    ngtcp2_log_rx_pkt_hd(&conn->log, &hd);
    if (conn->server)
    {
      return NGTCP2_ERR_DISCARD_PKT;
    }
    if (conn->flags & NGTCP2_CONN_FLAG_CONN_ID_NEGOTIATED)
    {
      return NGTCP2_ERR_DISCARD_PKT;
    }
    rv = conn_on_retry(conn, &hd, hdpktlen, pkt, pktlen);
    if (rv != 0)
    {
      if (ngtcp2_err_is_fatal(rv))
      {
        return rv;
      }
      return NGTCP2_ERR_DISCARD_PKT;
    }
    return (ngtcp2_ssize)pktlen;
  }
  if (pktlen < (size_t)nread + hd.len)
  {
    return NGTCP2_ERR_DISCARD_PKT;
  }
  pktlen = (size_t)nread + hd.len;
  if (conn->version != hd.version)
  {
    return NGTCP2_ERR_DISCARD_PKT;
  }
  if ((conn->flags & NGTCP2_CONN_FLAG_CONN_ID_NEGOTIATED) &&
      !ngtcp2_cid_eq(&conn->dcid.current.cid, &hd.scid))
  {
    ngtcp2_log_rx_pkt_hd(&conn->log, &hd);
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                    "packet was ignored because of mismatched SCID");
    return NGTCP2_ERR_DISCARD_PKT;
  }
  switch (hd.type)
  {
  case NGTCP2_PKT_0RTT:
    if (!conn->server)
    {
      return NGTCP2_ERR_DISCARD_PKT;
    }
    if (conn->flags & NGTCP2_CONN_FLAG_CONN_ID_NEGOTIATED)
    {
      if (conn->early.ckm)
      {
        ngtcp2_ssize nread2;
        nread2 = conn_recv_pkt(conn, path, pi, pkt, pktlen, pkt_ts, ts);
        if (nread2 < 0)
        {
          return nread2;
        }
      }
      return (ngtcp2_ssize)pktlen;
    }
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_CON,
                    "buffering 0-RTT packet len=%zu", pktlen);
    rv = conn_buffer_pkt(conn, conn->in_pktns, path, pi, pkt, pktlen, ts);
    if (rv != 0)
    {

      (static_cast<bool>(
           ngtcp2_err_is_fatal(rv))
           ? void(0)
           : __assert_fail(
                 "ngtcp2_err_is_fatal(rv)", "all.cpp", 23588, __extension__ __PRETTY_FUNCTION__));
      return rv;
    }
    return (ngtcp2_ssize)pktlen;
  case NGTCP2_PKT_INITIAL:
    if (!conn->in_pktns)
    {
      ngtcp2_log_info(
          &conn->log, NGTCP2_LOG_EVENT_PKT,
          "Initial packet is discarded because keys have been discarded");
      return (ngtcp2_ssize)pktlen;
    }

    (static_cast<bool>(
         conn->in_pktns)
         ? void(0)
         : __assert_fail(
               "conn->in_pktns", "all.cpp", 23600, __extension__ __PRETTY_FUNCTION__));
    if (conn->server)
    {
      if (conn->local.settings.token.len)
      {
        rv = verify_token(&conn->local.settings.token, &hd);
        if (rv != 0)
        {
          ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                          "packet was ignored because token is invalid");
          return NGTCP2_ERR_DISCARD_PKT;
        }
      }
      if ((conn->flags & NGTCP2_CONN_FLAG_CONN_ID_NEGOTIATED) == 0)
      {
        conn->rcid = hd.dcid;
        rv = conn_call_recv_client_initial(conn, &hd.dcid);
        if (rv != 0)
        {
          return rv;
        }
      }
    }
    else if (hd.token.len != 0)
    {
      ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                      "packet was ignored because token is not empty");
      return NGTCP2_ERR_DISCARD_PKT;
    }
    pktns = conn->in_pktns;
    aead_overhead = 16;
    crypto = &pktns->crypto.strm;
    crypto_level = NGTCP2_CRYPTO_LEVEL_INITIAL;
    break;
  case NGTCP2_PKT_HANDSHAKE:
    if (!conn->hs_pktns->crypto.rx.ckm)
    {
      if (conn->server)
      {
        ngtcp2_log_info(
            &conn->log, NGTCP2_LOG_EVENT_PKT,
            "Handshake packet at this point is unexpected and discarded");
        return (ngtcp2_ssize)pktlen;
      }
      ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_CON,
                      "buffering Handshake packet len=%zu", pktlen);
      rv = conn_buffer_pkt(conn, conn->hs_pktns, path, pi, pkt, pktlen, ts);
      if (rv != 0)
      {

        (static_cast<bool>(
             ngtcp2_err_is_fatal(rv))
             ? void(0)
             : __assert_fail(
                   "ngtcp2_err_is_fatal(rv)", "all.cpp", 23649, __extension__ __PRETTY_FUNCTION__));
        return rv;
      }
      return (ngtcp2_ssize)pktlen;
    }
    pktns = conn->hs_pktns;
    aead_overhead = conn->crypto.aead_overhead;
    crypto = &pktns->crypto.strm;
    crypto_level = NGTCP2_CRYPTO_LEVEL_HANDSHAKE;
    break;
  default:
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                    "packet was ignored because of unknown packet type");
    return (ngtcp2_ssize)pktlen;
  }
  hp_mask = conn->callbacks.hp_mask;
  decrypt = conn->callbacks.decrypt;
  aead = &pktns->crypto.ctx.aead;
  hp = &pktns->crypto.ctx.hp;
  ckm = pktns->crypto.rx.ckm;
  hp_ctx = &pktns->crypto.rx.hp_ctx;

  (static_cast<bool>(
       ckm)
       ? void(0)
       : __assert_fail(
             "ckm", "all.cpp", 23670, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       hp_mask)
       ? void(0)
       : __assert_fail(
             "hp_mask", "all.cpp", 23671, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       decrypt)
       ? void(0)
       : __assert_fail(
             "decrypt", "all.cpp", 23672, __extension__ __PRETTY_FUNCTION__));
  rv = conn_ensure_decrypt_hp_buffer(conn, (size_t)nread + 4);
  if (rv != 0)
  {
    return rv;
  }
  nwrite = decrypt_hp(&hd, conn->crypto.decrypt_hp_buf.base, hp, pkt, pktlen,
                      (size_t)nread, ckm, hp_ctx, hp_mask);
  if (nwrite < 0)
  {
    if (ngtcp2_err_is_fatal((int)nwrite))
    {
      return nwrite;
    }
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                    "could not decrypt packet number");
    return NGTCP2_ERR_DISCARD_PKT;
  }
  hdpktlen = (size_t)nwrite;
  payload = pkt + hdpktlen;
  payloadlen = hd.len - hd.pkt_numlen;
  hd.pkt_num = ngtcp2_pkt_adjust_pkt_num(pktns->rx.max_pkt_num, hd.pkt_num,
                                         pkt_num_bits(hd.pkt_numlen));
  if (hd.pkt_num > ((int64_t)((1ll << 62) - 1)))
  {
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                    "pkn=%"
                    "l"
                    "d"
                    " is greater than maximum pkn",
                    hd.pkt_num);
    return NGTCP2_ERR_DISCARD_PKT;
  }
  ngtcp2_log_rx_pkt_hd(&conn->log, &hd);
  rv = ngtcp2_pkt_verify_reserved_bits(conn->crypto.decrypt_hp_buf.base[0]);
  if (rv != 0)
  {
    invalid_reserved_bits = 1;
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                    "packet has incorrect reserved bits");
  }
  if (pktns_pkt_num_is_duplicate(pktns, hd.pkt_num))
  {
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                    "packet was discarded because of duplicated packet number");
    return NGTCP2_ERR_DISCARD_PKT;
  }
  rv = conn_ensure_decrypt_buffer(conn, payloadlen);
  if (rv != 0)
  {
    return rv;
  }
  nwrite = decrypt_pkt(conn->crypto.decrypt_buf.base, aead, payload, payloadlen,
                       conn->crypto.decrypt_hp_buf.base, hdpktlen, hd.pkt_num,
                       ckm, decrypt, aead_overhead);
  if (nwrite < 0)
  {
    if (ngtcp2_err_is_fatal((int)nwrite))
    {
      return nwrite;
    }
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                    "could not decrypt packet payload");
    return NGTCP2_ERR_DISCARD_PKT;
  }
  if (invalid_reserved_bits)
  {
    return NGTCP2_ERR_PROTO;
  }
  payload = conn->crypto.decrypt_buf.base;
  payloadlen = (size_t)nwrite;
  switch (hd.type)
  {
  case NGTCP2_PKT_INITIAL:
    if (!conn->server || ((conn->flags & NGTCP2_CONN_FLAG_CONN_ID_NEGOTIATED) &&
                          !ngtcp2_cid_eq(&conn->rcid, &hd.dcid)))
    {
      rv = conn_verify_dcid(conn,
                            __null, &hd);
      if (rv != 0)
      {
        if (ngtcp2_err_is_fatal(rv))
        {
          return rv;
        }
        ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                        "packet was ignored because of mismatched DCID");
        return NGTCP2_ERR_DISCARD_PKT;
      }
    }
    break;
  case NGTCP2_PKT_HANDSHAKE:
    rv = conn_verify_dcid(conn,
                          __null, &hd);
    if (rv != 0)
    {
      if (ngtcp2_err_is_fatal(rv))
      {
        return rv;
      }
      ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                      "packet was ignored because of mismatched DCID");
      return NGTCP2_ERR_DISCARD_PKT;
    }
    break;
  default:

    (static_cast<bool>(
         0)
         ? void(0)
         : __assert_fail(
               "0", "all.cpp", 23772, __extension__ __PRETTY_FUNCTION__));
  }
  if (payloadlen == 0)
  {
    return NGTCP2_ERR_DISCARD_PKT;
  }
  if (hd.type == NGTCP2_PKT_INITIAL &&
      !(conn->flags & NGTCP2_CONN_FLAG_CONN_ID_NEGOTIATED))
  {
    conn->flags |= NGTCP2_CONN_FLAG_CONN_ID_NEGOTIATED;
    if (!conn->server)
    {
      conn->dcid.current.cid = hd.scid;
    }
  }
  ngtcp2_qlog_pkt_received_start(&conn->qlog, &hd);
  for (; payloadlen;)
  {
    nread = ngtcp2_pkt_decode_frame(fr, payload, payloadlen);
    if (nread < 0)
    {
      return nread;
    }
    payload += nread;
    payloadlen -= (size_t)nread;
    switch (fr->type)
    {
    case NGTCP2_FRAME_ACK:
    case NGTCP2_FRAME_ACK_ECN:
      fr->ack.ack_delay = 0;
      fr->ack.ack_delay_unscaled = 0;
      break;
    }
    ngtcp2_log_rx_fr(&conn->log, &hd, fr);
    switch (fr->type)
    {
    case NGTCP2_FRAME_ACK:
    case NGTCP2_FRAME_ACK_ECN:
      if (!conn->server && hd.type == NGTCP2_PKT_HANDSHAKE)
      {
        conn->flags |= NGTCP2_CONN_FLAG_SERVER_ADDR_VERIFIED;
      }
      rv = conn_recv_ack(conn, pktns, &fr->ack, pkt_ts, ts);
      if (rv != 0)
      {
        return rv;
      }
      break;
    case NGTCP2_FRAME_PADDING:
      break;
    case NGTCP2_FRAME_CRYPTO:
      rv = conn_recv_crypto(conn, crypto_level, crypto, &fr->crypto);
      if (rv != 0)
      {
        return rv;
      }
      require_ack = 1;
      break;
    case NGTCP2_FRAME_CONNECTION_CLOSE:
      conn_recv_connection_close(conn, &fr->connection_close);
      break;
    case NGTCP2_FRAME_PING:
      require_ack = 1;
      break;
    default:
      return NGTCP2_ERR_PROTO;
    }
    ngtcp2_qlog_write_frame(&conn->qlog, fr);
  }
  if (conn->server && hd.type == NGTCP2_PKT_HANDSHAKE)
  {
    conn->flags |= NGTCP2_CONN_FLAG_SADDR_VERIFIED;
  }
  ngtcp2_qlog_pkt_received_end(&conn->qlog, &hd, pktlen);
  rv = pktns_commit_recv_pkt_num(pktns, hd.pkt_num, require_ack, pkt_ts);
  if (rv != 0)
  {
    return rv;
  }
  pktns_increase_ecn_counts(pktns, pi);
  if (require_ack && (++pktns->acktr.rx_npkt >= 10 ||
                      (pi->ecn & NGTCP2_ECN_MASK) == NGTCP2_ECN_CE))
  {
    ngtcp2_acktr_immediate_ack(&pktns->acktr);
  }
  rv = ngtcp2_conn_sched_ack(conn, &pktns->acktr, hd.pkt_num, require_ack,
                             pkt_ts);
  if (rv != 0)
  {
    return rv;
  }
  conn_restart_timer_on_read(conn, ts);
  ngtcp2_qlog_metrics_updated(&conn->qlog, &conn->cstat);
  return conn->state == NGTCP2_CS_DRAINING ? NGTCP2_ERR_DRAINING
                                           : (ngtcp2_ssize)pktlen;
}
static int conn_recv_handshake_cpkt(ngtcp2_conn *conn, const ngtcp2_path *path,
                                    const ngtcp2_pkt_info *pi,
                                    const uint8_t *pkt, size_t pktlen,
                                    ngtcp2_tstamp ts)
{
  ngtcp2_ssize nread;
  conn->cstat.bytes_recv += pktlen;
  while (pktlen)
  {
    nread = conn_recv_handshake_pkt(conn, path, pi, pkt, pktlen, ts, ts);
    if (nread < 0)
    {
      if (ngtcp2_err_is_fatal((int)nread))
      {
        return (int)nread;
      }
      if (nread == NGTCP2_ERR_DRAINING)
      {
        return NGTCP2_ERR_DRAINING;
      }
      if ((pkt[0] & 0x80) &&
          pktlen > 4 && ngtcp2_get_uint32(&pkt[1]) > 0 &&
          ngtcp2_pkt_get_type_long(pkt[0]) == NGTCP2_PKT_INITIAL)
      {
        if (conn->server)
        {
          if (conn->in_pktns && conn->in_pktns->rx.max_pkt_num == -1)
          {
            if (nread == NGTCP2_ERR_CRYPTO)
            {
              return (int)nread;
            }
            return NGTCP2_ERR_DROP_CONN;
          }
        }
        else if (nread == NGTCP2_ERR_CRYPTO)
        {
          return (int)nread;
        }
        return 0;
      }
      if (nread == NGTCP2_ERR_DISCARD_PKT)
      {
        return 0;
      }
      return (int)nread;
    }

    (static_cast<bool>(
         pktlen >= (size_t)nread)
         ? void(0)
         : __assert_fail(
               "pktlen >= (size_t)nread", "all.cpp", 23916, __extension__ __PRETTY_FUNCTION__));
    pkt += nread;
    pktlen -= (size_t)nread;
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                    "read packet %td left %zu", nread, pktlen);
  }
  return 0;
}
int ngtcp2_conn_init_stream(ngtcp2_conn *conn, ngtcp2_strm *strm,
                            int64_t stream_id, void *stream_user_data)
{
  int rv;
  uint64_t max_rx_offset;
  uint64_t max_tx_offset;
  int local_stream = conn_local_stream(conn, stream_id);
  if (bidi_stream(stream_id))
  {
    if (local_stream)
    {
      max_rx_offset = conn->local.settings.transport_params
                          .initial_max_stream_data_bidi_local;
      max_tx_offset =
          conn->remote.transport_params.initial_max_stream_data_bidi_remote;
    }
    else
    {
      max_rx_offset = conn->local.settings.transport_params
                          .initial_max_stream_data_bidi_remote;
      max_tx_offset =
          conn->remote.transport_params.initial_max_stream_data_bidi_local;
    }
  }
  else if (local_stream)
  {
    max_rx_offset = 0;
    max_tx_offset = conn->remote.transport_params.initial_max_stream_data_uni;
  }
  else
  {
    max_rx_offset =
        conn->local.settings.transport_params.initial_max_stream_data_uni;
    max_tx_offset = 0;
  }
  rv = ngtcp2_strm_init(strm, stream_id, NGTCP2_STRM_FLAG_NONE, max_rx_offset,
                        max_tx_offset, stream_user_data, conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  rv = ngtcp2_map_insert(&conn->strms, &strm->me);
  if (rv != 0)
  {

    (static_cast<bool>(
         rv != NGTCP2_ERR_INVALID_ARGUMENT)
         ? void(0)
         : __assert_fail(
               "rv != NGTCP2_ERR_INVALID_ARGUMENT", "all.cpp", 23969, __extension__ __PRETTY_FUNCTION__));
    goto fail;
  }
  if (!conn_local_stream(conn, stream_id))
  {
    rv = conn_call_stream_open(conn, strm);
    if (rv != 0)
    {
      goto fail;
    }
  }
  return 0;
fail:
  ngtcp2_strm_free(strm);
  return rv;
}
static int conn_emit_pending_stream_data(ngtcp2_conn *conn, ngtcp2_strm *strm,
                                         uint64_t rx_offset)
{
  size_t datalen;
  const uint8_t *data;
  int rv;
  uint64_t offset;
  uint32_t sdflags;
  int handshake_completed = conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED;
  if (!strm->rx.rob)
  {
    return 0;
  }
  for (;;)
  {
    if (strm->flags & (NGTCP2_STRM_FLAG_STOP_SENDING))
    {
      return 0;
    }
    datalen = ngtcp2_rob_data_at(strm->rx.rob, &data, rx_offset);
    if (datalen == 0)
    {

      (static_cast<bool>(
           rx_offset == ngtcp2_strm_rx_offset(strm))
           ? void(0)
           : __assert_fail(
                 "rx_offset == ngtcp2_strm_rx_offset(strm)", "all.cpp", 24009, __extension__ __PRETTY_FUNCTION__));
      return 0;
    }
    offset = rx_offset;
    rx_offset += datalen;
    sdflags = NGTCP2_STREAM_DATA_FLAG_NONE;
    if ((strm->flags & NGTCP2_STRM_FLAG_SHUT_RD) &&
        rx_offset == strm->rx.last_offset)
    {
      sdflags |= NGTCP2_STREAM_DATA_FLAG_FIN;
    }
    if (!handshake_completed)
    {
      sdflags |= NGTCP2_STREAM_DATA_FLAG_0RTT;
    }
    rv = conn_call_recv_stream_data(conn, strm, sdflags, offset, data, datalen);
    if (rv != 0)
    {
      return rv;
    }
    ngtcp2_rob_pop(strm->rx.rob, rx_offset - datalen, datalen);
  }
}
static int conn_recv_crypto(ngtcp2_conn *conn, ngtcp2_crypto_level crypto_level,
                            ngtcp2_strm *crypto, const ngtcp2_crypto *fr)
{
  uint64_t fr_end_offset;
  uint64_t rx_offset;
  int rv;
  if (fr->datacnt == 0)
  {
    return 0;
  }
  fr_end_offset = fr->offset + fr->data[0].len;
  if (((1ULL << 62) - 1) < fr_end_offset)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  rx_offset = ngtcp2_strm_rx_offset(crypto);
  if (fr_end_offset <= rx_offset)
  {
    if (conn->server &&
        !(conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_EARLY_RETRANSMIT) &&
        crypto_level == NGTCP2_CRYPTO_LEVEL_INITIAL)
    {
      conn->flags |= NGTCP2_CONN_FLAG_HANDSHAKE_EARLY_RETRANSMIT;
      conn->in_pktns->rtb.probe_pkt_left = 1;
      conn->hs_pktns->rtb.probe_pkt_left = 1;
    }
    return 0;
  }
  crypto->rx.last_offset = ((crypto->rx.last_offset) > (fr_end_offset) ? (crypto->rx.last_offset) : (fr_end_offset));
  if (fr->offset <= rx_offset)
  {
    size_t ncut = (size_t)(rx_offset - fr->offset);
    const uint8_t *data = fr->data[0].base + ncut;
    size_t datalen = fr->data[0].len - ncut;
    uint64_t offset = rx_offset;
    rx_offset += datalen;
    rv = ngtcp2_strm_update_rx_offset(crypto, rx_offset);
    if (rv != 0)
    {
      return rv;
    }
    rv = conn_call_recv_crypto_data(conn, crypto_level, offset, data, datalen);
    if (rv != 0)
    {
      return rv;
    }
    rv = conn_emit_pending_crypto_data(conn, crypto_level, crypto, rx_offset);
    if (rv != 0)
    {
      return rv;
    }
  }
  else if (fr_end_offset - rx_offset > 65536)
  {
    return NGTCP2_ERR_CRYPTO_BUFFER_EXCEEDED;
  }
  else
  {
    rv = ngtcp2_strm_recv_reordering(crypto, fr->data[0].base, fr->data[0].len,
                                     fr->offset);
    if (rv != 0)
    {
      return rv;
    }
  }
  return 0;
}
static int conn_max_data_violated(ngtcp2_conn *conn, uint64_t datalen)
{
  return conn->rx.max_offset - conn->rx.offset < datalen;
}
static int conn_recv_stream(ngtcp2_conn *conn, const ngtcp2_stream *fr,
                            ngtcp2_tstamp ts)
{
  int rv;
  ngtcp2_strm *strm;
  ngtcp2_idtr *idtr;
  uint64_t rx_offset, fr_end_offset;
  int local_stream;
  int bidi;
  size_t datalen = ngtcp2_vec_len(fr->data, fr->datacnt);
  uint32_t sdflags = NGTCP2_STREAM_DATA_FLAG_NONE;
  local_stream = conn_local_stream(conn, fr->stream_id);
  bidi = bidi_stream(fr->stream_id);
  if (bidi)
  {
    if (local_stream)
    {
      if (conn->local.bidi.next_stream_id <= fr->stream_id)
      {
        return NGTCP2_ERR_STREAM_STATE;
      }
    }
    else if (conn->remote.bidi.max_streams <
             ngtcp2_ord_stream_id(fr->stream_id))
    {
      return NGTCP2_ERR_STREAM_LIMIT;
    }
    idtr = &conn->remote.bidi.idtr;
  }
  else
  {
    if (local_stream)
    {
      return NGTCP2_ERR_STREAM_STATE;
    }
    if (conn->remote.uni.max_streams < ngtcp2_ord_stream_id(fr->stream_id))
    {
      return NGTCP2_ERR_STREAM_LIMIT;
    }
    idtr = &conn->remote.uni.idtr;
  }
  if (((1ULL << 62) - 1) - datalen < fr->offset)
  {
    return NGTCP2_ERR_FLOW_CONTROL;
  }
  strm = ngtcp2_conn_find_stream(conn, fr->stream_id);
  if (strm ==
      __null)
  {
    if (local_stream)
    {
      return 0;
    }
    rv = ngtcp2_idtr_open(idtr, fr->stream_id);
    if (rv != 0)
    {
      if (ngtcp2_err_is_fatal(rv))
      {
        return rv;
      }

      (static_cast<bool>(
           rv == NGTCP2_ERR_STREAM_IN_USE)
           ? void(0)
           : __assert_fail(
                 "rv == NGTCP2_ERR_STREAM_IN_USE", "all.cpp", 24165, __extension__ __PRETTY_FUNCTION__));
      return 0;
    }
    strm = ngtcp2_mem_malloc(conn->mem, sizeof(ngtcp2_strm));
    if (strm ==
        __null)
    {
      return NGTCP2_ERR_NOMEM;
    }
    rv = ngtcp2_conn_init_stream(conn, strm, fr->stream_id,
                                 __null);
    if (rv != 0)
    {
      ngtcp2_mem_free(conn->mem, strm);
      return rv;
    }
    if (!bidi)
    {
      ngtcp2_strm_shutdown(strm, NGTCP2_STRM_FLAG_SHUT_WR);
    }
  }
  fr_end_offset = fr->offset + datalen;
  if (strm->rx.max_offset < fr_end_offset)
  {
    return NGTCP2_ERR_FLOW_CONTROL;
  }
  if (strm->rx.last_offset < fr_end_offset)
  {
    uint64_t len = fr_end_offset - strm->rx.last_offset;
    if (conn_max_data_violated(conn, len))
    {
      return NGTCP2_ERR_FLOW_CONTROL;
    }
    conn->rx.offset += len;
    if (strm->flags & NGTCP2_STRM_FLAG_STOP_SENDING)
    {
      ngtcp2_conn_extend_max_offset(conn, len);
    }
  }
  rx_offset = ngtcp2_strm_rx_offset(strm);
  if (fr->fin)
  {
    if (strm->flags & NGTCP2_STRM_FLAG_SHUT_RD)
    {
      if (strm->rx.last_offset != fr_end_offset)
      {
        return NGTCP2_ERR_FINAL_SIZE;
      }
      if (strm->flags &
          (NGTCP2_STRM_FLAG_STOP_SENDING | NGTCP2_STRM_FLAG_RECV_RST))
      {
        return 0;
      }
      if (rx_offset == fr_end_offset)
      {
        return 0;
      }
    }
    else if (strm->rx.last_offset > fr_end_offset)
    {
      return NGTCP2_ERR_FINAL_SIZE;
    }
    else
    {
      strm->rx.last_offset = fr_end_offset;
      ngtcp2_strm_shutdown(strm, NGTCP2_STRM_FLAG_SHUT_RD);
      if (strm->flags & NGTCP2_STRM_FLAG_STOP_SENDING)
      {
        return ngtcp2_conn_close_stream_if_shut_rdwr(conn, strm,
                                                     strm->app_error_code);
      }
    }
  }
  else
  {
    if ((strm->flags & NGTCP2_STRM_FLAG_SHUT_RD) &&
        strm->rx.last_offset < fr_end_offset)
    {
      return NGTCP2_ERR_FINAL_SIZE;
    }
    strm->rx.last_offset = ((strm->rx.last_offset) > (fr_end_offset) ? (strm->rx.last_offset) : (fr_end_offset));
    if (fr_end_offset <= rx_offset)
    {
      return 0;
    }
    if (strm->flags &
        (NGTCP2_STRM_FLAG_STOP_SENDING | NGTCP2_STRM_FLAG_RECV_RST))
    {
      return 0;
    }
  }
  conn_update_recv_rate(conn, fr_end_offset - fr->offset, ts);
  if (fr->offset <= rx_offset)
  {
    size_t ncut = (size_t)(rx_offset - fr->offset);
    uint64_t offset = rx_offset;
    const uint8_t *data;
    int fin;
    if (fr->datacnt)
    {
      data = fr->data[0].base + ncut;
      datalen -= ncut;
      rx_offset += datalen;
      rv = ngtcp2_strm_update_rx_offset(strm, rx_offset);
      if (rv != 0)
      {
        return rv;
      }
    }
    else
    {
      data =
          __null;
      datalen = 0;
    }
    fin = (strm->flags & NGTCP2_STRM_FLAG_SHUT_RD) &&
          rx_offset == strm->rx.last_offset;
    if (fin || datalen)
    {
      if (fin)
      {
        sdflags |= NGTCP2_STREAM_DATA_FLAG_FIN;
      }
      if (!(conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED))
      {
        sdflags |= NGTCP2_STREAM_DATA_FLAG_0RTT;
      }
      rv = conn_call_recv_stream_data(conn, strm, sdflags, offset, data,
                                      datalen);
      if (rv != 0)
      {
        return rv;
      }
      rv = conn_emit_pending_stream_data(conn, strm, rx_offset);
      if (rv != 0)
      {
        return rv;
      }
    }
  }
  else if (fr->datacnt)
  {
    rv = ngtcp2_strm_recv_reordering(strm, fr->data[0].base, fr->data[0].len,
                                     fr->offset);
    if (rv != 0)
    {
      return rv;
    }
  }
  return ngtcp2_conn_close_stream_if_shut_rdwr(conn, strm, 0x0u);
}
static int conn_reset_stream(ngtcp2_conn *conn, ngtcp2_strm *strm,
                             uint64_t app_error_code)
{
  int rv;
  ngtcp2_frame_chain *frc;
  ngtcp2_pktns *pktns = &conn->pktns;
  rv = ngtcp2_frame_chain_new(&frc, conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  frc->fr.type = NGTCP2_FRAME_RESET_STREAM;
  frc->fr.reset_stream.stream_id = strm->stream_id;
  frc->fr.reset_stream.app_error_code = app_error_code;
  frc->fr.reset_stream.final_size = strm->tx.offset;
  frc->next = pktns->tx.frq;
  pktns->tx.frq = frc;
  return 0;
}
static int conn_stop_sending(ngtcp2_conn *conn, ngtcp2_strm *strm,
                             uint64_t app_error_code)
{
  int rv;
  ngtcp2_frame_chain *frc;
  ngtcp2_pktns *pktns = &conn->pktns;
  rv = ngtcp2_frame_chain_new(&frc, conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  frc->fr.type = NGTCP2_FRAME_STOP_SENDING;
  frc->fr.stop_sending.stream_id = strm->stream_id;
  frc->fr.stop_sending.app_error_code = app_error_code;
  frc->next = pktns->tx.frq;
  pktns->tx.frq = frc;
  return 0;
}
static void
handle_max_remote_streams_extension(uint64_t *punsent_max_remote_streams,
                                    size_t n)
{
  if (
      (1LL << 60) < n ||
      *punsent_max_remote_streams > (uint64_t)((1LL << 60) - n))
  {
    *punsent_max_remote_streams = (1LL << 60);
  }
  else
  {
    *punsent_max_remote_streams += n;
  }
}
static int conn_recv_reset_stream(ngtcp2_conn *conn,
                                  const ngtcp2_reset_stream *fr)
{
  ngtcp2_strm *strm;
  int local_stream = conn_local_stream(conn, fr->stream_id);
  int bidi = bidi_stream(fr->stream_id);
  uint64_t datalen;
  ngtcp2_idtr *idtr;
  int rv;
  if (bidi)
  {
    if (local_stream)
    {
      if (conn->local.bidi.next_stream_id <= fr->stream_id)
      {
        return NGTCP2_ERR_STREAM_STATE;
      }
    }
    else if (conn->remote.bidi.max_streams <
             ngtcp2_ord_stream_id(fr->stream_id))
    {
      return NGTCP2_ERR_STREAM_LIMIT;
    }
    idtr = &conn->remote.bidi.idtr;
  }
  else
  {
    if (local_stream)
    {
      return NGTCP2_ERR_PROTO;
    }
    if (conn->remote.uni.max_streams < ngtcp2_ord_stream_id(fr->stream_id))
    {
      return NGTCP2_ERR_STREAM_LIMIT;
    }
    idtr = &conn->remote.uni.idtr;
  }
  if (((1ULL << 62) - 1) < fr->final_size)
  {
    return NGTCP2_ERR_FLOW_CONTROL;
  }
  strm = ngtcp2_conn_find_stream(conn, fr->stream_id);
  if (strm ==
      __null)
  {
    if (local_stream)
    {
      return 0;
    }
    if (conn_initial_stream_rx_offset(conn, fr->stream_id) < fr->final_size ||
        conn_max_data_violated(conn, fr->final_size))
    {
      return NGTCP2_ERR_FLOW_CONTROL;
    }
    rv = ngtcp2_idtr_open(idtr, fr->stream_id);
    if (rv != 0)
    {
      if (ngtcp2_err_is_fatal(rv))
      {
        return rv;
      }

      (static_cast<bool>(
           rv == NGTCP2_ERR_STREAM_IN_USE)
           ? void(0)
           : __assert_fail(
                 "rv == NGTCP2_ERR_STREAM_IN_USE", "all.cpp", 24431, __extension__ __PRETTY_FUNCTION__));
      return 0;
    }
    conn->rx.offset += fr->final_size;
    ngtcp2_conn_extend_max_offset(conn, fr->final_size);
    rv = conn_call_stream_reset(conn, fr->stream_id, fr->final_size,
                                fr->app_error_code,
                                __null);
    if (rv != 0)
    {
      return rv;
    }
    if (bidi)
    {
      handle_max_remote_streams_extension(&conn->remote.bidi.unsent_max_streams,
                                          1);
    }
    else
    {
      handle_max_remote_streams_extension(&conn->remote.uni.unsent_max_streams,
                                          1);
    }
    return 0;
  }
  if ((strm->flags & NGTCP2_STRM_FLAG_SHUT_RD))
  {
    if (strm->rx.last_offset != fr->final_size)
    {
      return NGTCP2_ERR_FINAL_SIZE;
    }
  }
  else if (strm->rx.last_offset > fr->final_size)
  {
    return NGTCP2_ERR_FINAL_SIZE;
  }
  datalen = fr->final_size - strm->rx.last_offset;
  if (strm->rx.max_offset < fr->final_size ||
      conn_max_data_violated(conn, datalen))
  {
    return NGTCP2_ERR_FLOW_CONTROL;
  }
  if (!(strm->flags & NGTCP2_STRM_FLAG_RECV_RST))
  {
    rv = conn_call_stream_reset(conn, fr->stream_id, fr->final_size,
                                fr->app_error_code, strm->stream_user_data);
    if (rv != 0)
    {
      return rv;
    }
    if (!(strm->flags & NGTCP2_STRM_FLAG_STOP_SENDING))
    {
      ngtcp2_conn_extend_max_offset(conn, strm->rx.last_offset -
                                              ngtcp2_strm_rx_offset(strm));
    }
  }
  conn->rx.offset += datalen;
  ngtcp2_conn_extend_max_offset(conn, datalen);
  strm->rx.last_offset = fr->final_size;
  strm->flags |= NGTCP2_STRM_FLAG_SHUT_RD | NGTCP2_STRM_FLAG_RECV_RST;
  return ngtcp2_conn_close_stream_if_shut_rdwr(conn, strm, fr->app_error_code);
}
static int conn_recv_stop_sending(ngtcp2_conn *conn,
                                  const ngtcp2_stop_sending *fr)
{
  int rv;
  ngtcp2_strm *strm;
  ngtcp2_idtr *idtr;
  int local_stream = conn_local_stream(conn, fr->stream_id);
  int bidi = bidi_stream(fr->stream_id);
  if (bidi)
  {
    if (local_stream)
    {
      if (conn->local.bidi.next_stream_id <= fr->stream_id)
      {
        return NGTCP2_ERR_STREAM_STATE;
      }
    }
    else if (conn->remote.bidi.max_streams <
             ngtcp2_ord_stream_id(fr->stream_id))
    {
      return NGTCP2_ERR_STREAM_LIMIT;
    }
    idtr = &conn->remote.bidi.idtr;
  }
  else
  {
    if (!local_stream || conn->local.uni.next_stream_id <= fr->stream_id)
    {
      return NGTCP2_ERR_STREAM_STATE;
    }
    idtr = &conn->remote.uni.idtr;
  }
  strm = ngtcp2_conn_find_stream(conn, fr->stream_id);
  if (strm ==
      __null)
  {
    if (local_stream)
    {
      return 0;
    }
    rv = ngtcp2_idtr_open(idtr, fr->stream_id);
    if (rv != 0)
    {
      if (ngtcp2_err_is_fatal(rv))
      {
        return rv;
      }

      (static_cast<bool>(
           rv == NGTCP2_ERR_STREAM_IN_USE)
           ? void(0)
           : __assert_fail(
                 "rv == NGTCP2_ERR_STREAM_IN_USE", "all.cpp", 24538, __extension__ __PRETTY_FUNCTION__));
      return 0;
    }
    strm = ngtcp2_mem_malloc(conn->mem, sizeof(ngtcp2_strm));
    if (strm ==
        __null)
    {
      return NGTCP2_ERR_NOMEM;
    }
    rv = ngtcp2_conn_init_stream(conn, strm, fr->stream_id,
                                 __null);
    if (rv != 0)
    {
      ngtcp2_mem_free(conn->mem, strm);
      return rv;
    }
  }
  if ((strm->flags & NGTCP2_STRM_FLAG_SHUT_WR) &&
      ngtcp2_strm_is_all_tx_data_acked(strm))
  {
    return 0;
  }
  rv = conn_reset_stream(conn, strm, fr->app_error_code);
  if (rv != 0)
  {
    return rv;
  }
  strm->flags |= NGTCP2_STRM_FLAG_SHUT_WR | NGTCP2_STRM_FLAG_SENT_RST;
  ngtcp2_strm_streamfrq_clear(strm);
  return ngtcp2_conn_close_stream_if_shut_rdwr(conn, strm, fr->app_error_code);
}
static int check_stateless_reset(const ngtcp2_dcid *dcid,
                                 const ngtcp2_path *path,
                                 const ngtcp2_pkt_stateless_reset *sr)
{
  return ngtcp2_path_eq(&dcid->ps.path, path) &&
         ngtcp2_verify_stateless_reset_token(dcid->token,
                                             sr->stateless_reset_token) == 0;
}
static int conn_on_stateless_reset(ngtcp2_conn *conn, const ngtcp2_path *path,
                                   const uint8_t *payload, size_t payloadlen)
{
  int rv = 1;
  ngtcp2_pv *pv = conn->pv;
  ngtcp2_dcid *dcid;
  ngtcp2_pkt_stateless_reset sr;
  size_t len, i;
  rv = ngtcp2_pkt_decode_stateless_reset(&sr, payload, payloadlen);
  if (rv != 0)
  {
    return rv;
  }
  if (!check_stateless_reset(&conn->dcid.current, path, &sr) &&
      (!pv || (!check_stateless_reset(&pv->dcid, path, &sr) &&
               (!(pv->flags & NGTCP2_PV_FLAG_FALLBACK_ON_FAILURE) ||
                !check_stateless_reset(&pv->fallback_dcid, path, &sr)))))
  {
    len = ((&conn->dcid.retired)->len);
    for (i = 0; i < len; ++i)
    {
      dcid = ngtcp2_ringbuf_get(&conn->dcid.retired, i);
      if (check_stateless_reset(dcid, path, &sr))
      {
        break;
      }
    }
    if (i == len)
    {
      len = ((&conn->dcid.bound)->len);
      for (i = 0; i < len; ++i)
      {
        dcid = ngtcp2_ringbuf_get(&conn->dcid.bound, i);
        if (check_stateless_reset(dcid, path, &sr))
        {
          break;
        }
      }
      if (i == len)
      {
        return NGTCP2_ERR_INVALID_ARGUMENT;
      }
    }
  }
  conn->state = NGTCP2_CS_DRAINING;
  ngtcp2_log_rx_sr(&conn->log, &sr);
  if (!conn->callbacks.recv_stateless_reset)
  {
    return 0;
  }
  rv = conn->callbacks.recv_stateless_reset(conn, &sr, conn->user_data);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  return 0;
}
static int conn_recv_max_streams(ngtcp2_conn *conn,
                                 const ngtcp2_max_streams *fr)
{
  uint64_t n;
  if (fr->max_streams > (1LL << 60))
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  n = ((fr->max_streams) < ((1LL << 60)) ? (fr->max_streams) : ((1LL << 60)));
  if (fr->type == NGTCP2_FRAME_MAX_STREAMS_BIDI)
  {
    if (conn->local.bidi.max_streams < n)
    {
      conn->local.bidi.max_streams = n;
      return conn_call_extend_max_local_streams_bidi(conn, n);
    }
    return 0;
  }
  if (conn->local.uni.max_streams < n)
  {
    conn->local.uni.max_streams = n;
    return conn_call_extend_max_local_streams_uni(conn, n);
  }
  return 0;
}
static int conn_retire_dcid_prior_to(ngtcp2_conn *conn, ngtcp2_ringbuf *rb,
                                     uint64_t retire_prior_to)
{
  size_t i;
  ngtcp2_dcid *dcid, *last;
  int rv;
  for (i = 0; i < ((rb)->len);)
  {
    dcid = ngtcp2_ringbuf_get(rb, i);
    if (dcid->seq >= retire_prior_to)
    {
      ++i;
      continue;
    }
    rv = conn_retire_dcid_seq(conn, dcid->seq);
    if (rv != 0)
    {
      return rv;
    }
    if (i == 0)
    {
      ngtcp2_ringbuf_pop_front(rb);
    }
    else if (i == ((rb)->len) - 1)
    {
      ngtcp2_ringbuf_pop_back(rb);
      break;
    }
    else
    {
      last = ngtcp2_ringbuf_get(rb, ((rb)->len) - 1);
      ngtcp2_dcid_copy(dcid, last);
      ngtcp2_ringbuf_pop_back(rb);
    }
  }
  return 0;
}
static int conn_recv_new_connection_id(ngtcp2_conn *conn,
                                       const ngtcp2_new_connection_id *fr)
{
  size_t i, len;
  ngtcp2_dcid *dcid;
  ngtcp2_pv *pv = conn->pv;
  int rv;
  int found = 0;
  size_t extra_dcid = 0;
  if (conn->dcid.current.cid.datalen == 0)
  {
    return NGTCP2_ERR_PROTO;
  }
  if (fr->retire_prior_to > fr->seq)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  rv = ngtcp2_dcid_verify_uniqueness(&conn->dcid.current, fr->seq, &fr->cid,
                                     fr->stateless_reset_token);
  if (rv != 0)
  {
    return rv;
  }
  if (ngtcp2_cid_eq(&conn->dcid.current.cid, &fr->cid))
  {
    found = 1;
  }
  if (pv)
  {
    rv = ngtcp2_dcid_verify_uniqueness(&pv->dcid, fr->seq, &fr->cid,
                                       fr->stateless_reset_token);
    if (rv != 0)
    {
      return rv;
    }
    if (ngtcp2_cid_eq(&pv->dcid.cid, &fr->cid))
    {
      found = 1;
    }
  }
  len = ((&conn->dcid.bound)->len);
  for (i = 0; i < len; ++i)
  {
    dcid = ngtcp2_ringbuf_get(&conn->dcid.bound, i);
    rv = ngtcp2_dcid_verify_uniqueness(dcid, fr->seq, &fr->cid,
                                       fr->stateless_reset_token);
    if (rv != 0)
    {
      return NGTCP2_ERR_PROTO;
    }
    if (ngtcp2_cid_eq(&dcid->cid, &fr->cid))
    {
      found = 1;
    }
  }
  len = ((&conn->dcid.unused)->len);
  for (i = 0; i < len; ++i)
  {
    dcid = ngtcp2_ringbuf_get(&conn->dcid.unused, i);
    rv = ngtcp2_dcid_verify_uniqueness(dcid, fr->seq, &fr->cid,
                                       fr->stateless_reset_token);
    if (rv != 0)
    {
      return NGTCP2_ERR_PROTO;
    }
    if (ngtcp2_cid_eq(&dcid->cid, &fr->cid))
    {
      found = 1;
    }
  }
  if (conn->dcid.retire_prior_to < fr->retire_prior_to)
  {
    conn->dcid.retire_prior_to = fr->retire_prior_to;
    rv =
        conn_retire_dcid_prior_to(conn, &conn->dcid.bound, fr->retire_prior_to);
    if (rv != 0)
    {
      return rv;
    }
    rv = conn_retire_dcid_prior_to(conn, &conn->dcid.unused,
                                   conn->dcid.retire_prior_to);
    if (rv != 0)
    {
      return rv;
    }
  }
  else if (fr->seq < conn->dcid.retire_prior_to)
  {
    if (conn->dcid.num_retire_queued < 8 * 2)
    {
      return conn_retire_dcid_seq(conn, fr->seq);
    }
    return 0;
  }
  if (found)
  {
    return 0;
  }
  if (ngtcp2_gaptr_is_pushed(&conn->dcid.seqgap, fr->seq, 1))
  {
    return 0;
  }
  rv = ngtcp2_gaptr_push(&conn->dcid.seqgap, fr->seq, 1);
  if (rv != 0)
  {
    return rv;
  }
  if (ngtcp2_ksl_len(&conn->dcid.seqgap.gap) > 32)
  {
    ngtcp2_gaptr_drop_first_gap(&conn->dcid.seqgap);
  }
  len = ((&conn->dcid.unused)->len);
  if (conn->dcid.current.seq >= conn->dcid.retire_prior_to)
  {
    ++extra_dcid;
  }
  if (pv)
  {
    if (pv->dcid.seq != conn->dcid.current.seq &&
        pv->dcid.seq >= conn->dcid.retire_prior_to)
    {
      ++extra_dcid;
    }
    if ((pv->flags & NGTCP2_PV_FLAG_FALLBACK_ON_FAILURE) &&
        pv->fallback_dcid.seq != conn->dcid.current.seq &&
        pv->fallback_dcid.seq >= conn->dcid.retire_prior_to)
    {
      ++extra_dcid;
    }
  }
  if (conn->local.settings.transport_params.active_connection_id_limit <=
      len + extra_dcid)
  {
    return NGTCP2_ERR_CONNECTION_ID_LIMIT;
  }
  if (len >= 8)
  {
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_CON, "too many connection ID");
    return 0;
  }
  dcid = ngtcp2_ringbuf_push_back(&conn->dcid.unused);
  ngtcp2_dcid_init(dcid, fr->seq, &fr->cid, fr->stateless_reset_token);
  return 0;
}
static int conn_post_process_recv_new_connection_id(ngtcp2_conn *conn,
                                                    ngtcp2_tstamp ts)
{
  ngtcp2_pv *pv = conn->pv;
  ngtcp2_dcid *dcid;
  int rv;
  if (conn->dcid.current.seq < conn->dcid.retire_prior_to)
  {
    if (((&conn->dcid.unused)->len) == 0)
    {
      return 0;
    }
    rv = conn_retire_dcid(conn, &conn->dcid.current, ts);
    if (rv != 0)
    {
      return rv;
    }
    dcid = ngtcp2_ringbuf_get(&conn->dcid.unused, 0);
    if (pv)
    {
      if (conn->dcid.current.seq == pv->dcid.seq)
      {
        ngtcp2_dcid_copy_no_path(&pv->dcid, dcid);
      }
      if ((pv->flags & NGTCP2_PV_FLAG_FALLBACK_ON_FAILURE) &&
          conn->dcid.current.seq == pv->fallback_dcid.seq)
      {
        ngtcp2_dcid_copy_no_path(&pv->fallback_dcid, dcid);
      }
    }
    ngtcp2_dcid_copy_no_path(&conn->dcid.current, dcid);
    ngtcp2_ringbuf_pop_front(&conn->dcid.unused);
    rv = conn_call_activate_dcid(conn, &conn->dcid.current);
    if (rv != 0)
    {
      return rv;
    }
  }
  if (pv)
  {
    if (pv->dcid.seq < conn->dcid.retire_prior_to)
    {
      if (((&conn->dcid.unused)->len))
      {
        rv = conn_retire_dcid(conn, &pv->dcid, ts);
        if (rv != 0)
        {
          return rv;
        }
        dcid = ngtcp2_ringbuf_get(&conn->dcid.unused, 0);
        if ((pv->flags & NGTCP2_PV_FLAG_FALLBACK_ON_FAILURE) &&
            pv->dcid.seq == pv->fallback_dcid.seq)
        {
          ngtcp2_dcid_copy_no_path(&pv->fallback_dcid, dcid);
        }
        ngtcp2_dcid_copy_no_path(&pv->dcid, dcid);
        ngtcp2_ringbuf_pop_front(&conn->dcid.unused);
        rv = conn_call_activate_dcid(conn, &pv->dcid);
        if (rv != 0)
        {
          return rv;
        }
      }
      else
      {
        ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PTV,
                        "path migration is aborted because connection ID is"
                        "retired and no unused connection ID is available");
        return conn_stop_pv(conn, ts);
      }
    }
    if ((pv->flags & NGTCP2_PV_FLAG_FALLBACK_ON_FAILURE) &&
        pv->fallback_dcid.seq < conn->dcid.retire_prior_to)
    {
      if (((&conn->dcid.unused)->len))
      {
        rv = conn_retire_dcid(conn, &pv->fallback_dcid, ts);
        if (rv != 0)
        {
          return rv;
        }
        dcid = ngtcp2_ringbuf_get(&conn->dcid.unused, 0);
        ngtcp2_dcid_copy_no_path(&pv->fallback_dcid, dcid);
        ngtcp2_ringbuf_pop_front(&conn->dcid.unused);
        rv = conn_call_activate_dcid(conn, &pv->fallback_dcid);
        if (rv != 0)
        {
          return rv;
        }
      }
      else
      {
        return conn_stop_pv(conn, ts);
      }
    }
  }
  return 0;
}
static int conn_recv_retire_connection_id(ngtcp2_conn *conn,
                                          const ngtcp2_pkt_hd *hd,
                                          const ngtcp2_retire_connection_id *fr,
                                          ngtcp2_tstamp ts)
{
  ngtcp2_ksl_it it;
  ngtcp2_scid *scid;
  if (conn->oscid.datalen == 0 || conn->scid.last_seq < fr->seq)
  {
    return NGTCP2_ERR_PROTO;
  }
  for (it = ngtcp2_ksl_begin(&conn->scid.set); !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                                                  __null);
       (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
  {
    scid = ngtcp2_ksl_it_get(&it);
    if (scid->seq == fr->seq)
    {
      if (ngtcp2_cid_eq(&scid->cid, &hd->dcid))
      {
        return NGTCP2_ERR_PROTO;
      }
      if (!(scid->flags & NGTCP2_SCID_FLAG_RETIRED))
      {
        scid->flags |= NGTCP2_SCID_FLAG_RETIRED;
        ++conn->scid.num_retired;
      }
      if (scid->pe.index !=
          (18446744073709551615UL))
      {
        ngtcp2_pq_remove(&conn->scid.used, &scid->pe);
        scid->pe.index =
            (18446744073709551615UL);
      }
      scid->ts_retired = ts;
      return ngtcp2_pq_push(&conn->scid.used, &scid->pe);
    }
  }
  return 0;
}
static int conn_recv_new_token(ngtcp2_conn *conn, const ngtcp2_new_token *fr)
{
  int rv;
  if (conn->server)
  {
    return NGTCP2_ERR_PROTO;
  }
  if (fr->token.len == 0)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  if (conn->callbacks.recv_new_token)
  {
    rv = conn->callbacks.recv_new_token(conn, &fr->token, conn->user_data);
    if (rv != 0)
    {
      return NGTCP2_ERR_CALLBACK_FAILURE;
    }
  }
  return 0;
}
static int conn_select_preferred_addr(ngtcp2_conn *conn)
{
  struct sockaddr_storage buf;
  ngtcp2_addr addr;
  int rv;
  ngtcp2_duration timeout;
  ngtcp2_pv *pv;
  ngtcp2_dcid *dcid;
  ngtcp2_addr_init(&addr, (struct sockaddr *)&buf, 0,
                   __null);
  if (((&conn->dcid.unused)->len) == 0)
  {
    return 0;
  }
  rv = conn_call_select_preferred_addr(conn, &addr);
  if (rv != 0)
  {
    return rv;
  }
  if (addr.addrlen == 0 ||
      ngtcp2_addr_eq(&conn->dcid.current.ps.path.remote, &addr))
  {
    return 0;
  }

  (static_cast<bool>(
       conn->pv ==
       __null)
       ? void(0)
       : __assert_fail(
             "conn->pv == NULL", "all.cpp", 25026, __extension__ __PRETTY_FUNCTION__));
  dcid = ngtcp2_ringbuf_get(&conn->dcid.unused, 0);
  timeout = 3 * conn_compute_pto(conn, &conn->pktns);
  timeout = ((timeout) > (6 * conn->cstat.initial_rtt) ? (timeout) : (6 * conn->cstat.initial_rtt));
  rv = ngtcp2_pv_new(&pv, dcid, timeout, NGTCP2_PV_FLAG_NONE, &conn->log,
                     conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  ngtcp2_ringbuf_pop_front(&conn->dcid.unused);
  conn->pv = pv;
  ngtcp2_addr_copy(&pv->dcid.ps.path.local, &conn->dcid.current.ps.path.local);
  ngtcp2_addr_copy(&pv->dcid.ps.path.remote, &addr);
  return conn_call_activate_dcid(conn, &pv->dcid);
}
static int conn_recv_handshake_done(ngtcp2_conn *conn, ngtcp2_tstamp ts)
{
  int rv;
  if (conn->server)
  {
    return NGTCP2_ERR_PROTO;
  }
  if (conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_CONFIRMED)
  {
    return 0;
  }
  conn->flags |= NGTCP2_CONN_FLAG_HANDSHAKE_CONFIRMED |
                 NGTCP2_CONN_FLAG_SERVER_ADDR_VERIFIED;
  conn->pktns.rtb.persistent_congestion_start_ts = ts;
  conn_discard_handshake_state(conn, ts);
  if (conn->remote.transport_params.preferred_address_present)
  {
    rv = conn_select_preferred_addr(conn);
    if (rv != 0)
    {
      return rv;
    }
  }
  if (conn->callbacks.handshake_confirmed)
  {
    rv = conn->callbacks.handshake_confirmed(conn, conn->user_data);
    if (rv != 0)
    {
      return NGTCP2_ERR_CALLBACK_FAILURE;
    }
  }
  ngtcp2_conn_set_loss_detection_timer(conn, ts);
  return 0;
}
static int conn_key_phase_changed(ngtcp2_conn *conn, const ngtcp2_pkt_hd *hd)
{
  ngtcp2_pktns *pktns = &conn->pktns;
  return !(pktns->crypto.rx.ckm->flags & NGTCP2_CRYPTO_KM_FLAG_KEY_PHASE_ONE) ^
         !(hd->flags & NGTCP2_PKT_FLAG_KEY_PHASE);
}
static int conn_prepare_key_update(ngtcp2_conn *conn, ngtcp2_tstamp ts)
{
  int rv;
  ngtcp2_tstamp confirmed_ts = conn->crypto.key_update.confirmed_ts;
  ngtcp2_duration pto = conn_compute_pto(conn, &conn->pktns);
  ngtcp2_pktns *pktns = &conn->pktns;
  ngtcp2_crypto_km *rx_ckm = pktns->crypto.rx.ckm;
  ngtcp2_crypto_km *tx_ckm = pktns->crypto.tx.ckm;
  ngtcp2_crypto_km *new_rx_ckm, *new_tx_ckm;
  ngtcp2_crypto_aead_ctx rx_aead_ctx = {0}, tx_aead_ctx = {0};
  size_t secretlen, ivlen;
  if ((conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_CONFIRMED) &&
      tx_ckm->use_count >= pktns->crypto.ctx.max_encryption &&
      ngtcp2_conn_initiate_key_update(conn, ts) != 0)
  {
    return NGTCP2_ERR_AEAD_LIMIT_REACHED;
  }
  if ((conn->flags & NGTCP2_CONN_FLAG_KEY_UPDATE_NOT_CONFIRMED) ||
      (confirmed_ts !=
           (18446744073709551615UL) &&
       confirmed_ts + pto > ts))
  {
    return 0;
  }
  if (conn->crypto.key_update.new_rx_ckm ||
      conn->crypto.key_update.new_tx_ckm)
  {

    (static_cast<bool>(
         conn->crypto.key_update.new_rx_ckm)
         ? void(0)
         : __assert_fail(
               "conn->crypto.key_update.new_rx_ckm", "all.cpp", 25110, __extension__ __PRETTY_FUNCTION__));

    (static_cast<bool>(
         conn->crypto.key_update.new_tx_ckm)
         ? void(0)
         : __assert_fail(
               "conn->crypto.key_update.new_tx_ckm", "all.cpp", 25111, __extension__ __PRETTY_FUNCTION__));
    return 0;
  }
  secretlen = rx_ckm->secret.len;
  ivlen = rx_ckm->iv.len;
  rv = ngtcp2_crypto_km_nocopy_new(&conn->crypto.key_update.new_rx_ckm,
                                   secretlen, ivlen, conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  rv = ngtcp2_crypto_km_nocopy_new(&conn->crypto.key_update.new_tx_ckm,
                                   secretlen, ivlen, conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  new_rx_ckm = conn->crypto.key_update.new_rx_ckm;
  new_tx_ckm = conn->crypto.key_update.new_tx_ckm;

  (static_cast<bool>(
       conn->callbacks.update_key)
       ? void(0)
       : __assert_fail(
             "conn->callbacks.update_key", "all.cpp", 25130, __extension__ __PRETTY_FUNCTION__));
  rv = conn->callbacks.update_key(
      conn, new_rx_ckm->secret.base, new_tx_ckm->secret.base, &rx_aead_ctx,
      new_rx_ckm->iv.base, &tx_aead_ctx, new_tx_ckm->iv.base,
      rx_ckm->secret.base, tx_ckm->secret.base, secretlen, conn->user_data);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  new_rx_ckm->aead_ctx = rx_aead_ctx;
  new_tx_ckm->aead_ctx = tx_aead_ctx;
  if (!(rx_ckm->flags & NGTCP2_CRYPTO_KM_FLAG_KEY_PHASE_ONE))
  {
    new_rx_ckm->flags |= NGTCP2_CRYPTO_KM_FLAG_KEY_PHASE_ONE;
    new_tx_ckm->flags |= NGTCP2_CRYPTO_KM_FLAG_KEY_PHASE_ONE;
  }
  if (conn->crypto.key_update.old_rx_ckm)
  {
    conn_call_delete_crypto_aead_ctx(
        conn, &conn->crypto.key_update.old_rx_ckm->aead_ctx);
    ngtcp2_crypto_km_del(conn->crypto.key_update.old_rx_ckm, conn->mem);
    conn->crypto.key_update.old_rx_ckm =
        __null;
  }
  return 0;
}
static void conn_rotate_keys(ngtcp2_conn *conn, int64_t pkt_num)
{
  ngtcp2_pktns *pktns = &conn->pktns;

  (static_cast<bool>(
       conn->crypto.key_update.new_rx_ckm)
       ? void(0)
       : __assert_fail(
             "conn->crypto.key_update.new_rx_ckm", "all.cpp", 25159, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       conn->crypto.key_update.new_tx_ckm)
       ? void(0)
       : __assert_fail(
             "conn->crypto.key_update.new_tx_ckm", "all.cpp", 25160, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       !conn->crypto.key_update.old_rx_ckm)
       ? void(0)
       : __assert_fail(
             "!conn->crypto.key_update.old_rx_ckm", "all.cpp", 25161, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       !(conn->flags & NGTCP2_CONN_FLAG_PPE_PENDING))
       ? void(0)
       : __assert_fail(
             "!(conn->flags & NGTCP2_CONN_FLAG_PPE_PENDING)", "all.cpp", 25162, __extension__ __PRETTY_FUNCTION__));
  conn->crypto.key_update.old_rx_ckm = pktns->crypto.rx.ckm;
  pktns->crypto.rx.ckm = conn->crypto.key_update.new_rx_ckm;
  conn->crypto.key_update.new_rx_ckm =
      __null;
  pktns->crypto.rx.ckm->pkt_num = pkt_num;

  (static_cast<bool>(
       pktns->crypto.tx.ckm)
       ? void(0)
       : __assert_fail(
             "pktns->crypto.tx.ckm", "all.cpp", 25167, __extension__ __PRETTY_FUNCTION__));
  conn_call_delete_crypto_aead_ctx(conn, &pktns->crypto.tx.ckm->aead_ctx);
  ngtcp2_crypto_km_del(pktns->crypto.tx.ckm, conn->mem);
  pktns->crypto.tx.ckm = conn->crypto.key_update.new_tx_ckm;
  conn->crypto.key_update.new_tx_ckm =
      __null;
  pktns->crypto.tx.ckm->pkt_num = pktns->tx.last_pkt_num + 1;
  conn->flags |= NGTCP2_CONN_FLAG_KEY_UPDATE_NOT_CONFIRMED;
}
static int conn_path_validation_in_progress(ngtcp2_conn *conn,
                                            const ngtcp2_path *path)
{
  ngtcp2_pv *pv = conn->pv;
  return pv && ngtcp2_path_eq(&pv->dcid.ps.path, path);
}
static int conn_recv_non_probing_pkt_on_new_path(ngtcp2_conn *conn,
                                                 const ngtcp2_path *path,
                                                 int new_cid_used,
                                                 ngtcp2_tstamp ts)
{
  ngtcp2_dcid dcid, *bound_dcid, *last;
  ngtcp2_pv *pv;
  int rv;
  ngtcp2_duration timeout;
  int require_new_cid;
  int local_addr_eq;
  uint32_t remote_addr_cmp;
  size_t len, i;

  (static_cast<bool>(
       conn->server)
       ? void(0)
       : __assert_fail(
             "conn->server", "all.cpp", 25196, __extension__ __PRETTY_FUNCTION__));
  if (conn->pv && (conn->pv->flags & NGTCP2_PV_FLAG_FALLBACK_ON_FAILURE) &&
      ngtcp2_path_eq(&conn->pv->fallback_dcid.ps.path, path))
  {
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PTV,
                    "path is migrated back to the original path");
    ngtcp2_dcid_copy(&conn->dcid.current, &conn->pv->fallback_dcid);
    conn_reset_congestion_state(conn);
    conn_reset_ecn_validation_state(conn);
    rv = conn_stop_pv(conn, ts);
    if (rv != 0)
    {
      return rv;
    }
    return 0;
  }
  remote_addr_cmp =
      ngtcp2_addr_compare(&conn->dcid.current.ps.path.remote, &path->remote);
  local_addr_eq =
      ngtcp2_addr_eq(&conn->dcid.current.ps.path.local, &path->local);
  require_new_cid = (new_cid_used && remote_addr_cmp) || !local_addr_eq;
  ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_CON,
                  "non-probing packet was received from new remote address");
  timeout = 3 * conn_compute_pto(conn, &conn->pktns);
  timeout = ((timeout) > (6 * conn->cstat.initial_rtt) ? (timeout) : (6 * conn->cstat.initial_rtt));
  if (conn->dcid.current.cid.datalen == 0)
  {
    ngtcp2_dcid_copy(&dcid, &conn->dcid.current);
  }
  else
  {
    len = ((&conn->dcid.bound)->len);
    for (i = 0; i < len; ++i)
    {
      bound_dcid = ngtcp2_ringbuf_get(&conn->dcid.bound, i);
      if (ngtcp2_path_eq(&bound_dcid->ps.path, path))
      {
        ngtcp2_log_info(
            &conn->log, NGTCP2_LOG_EVENT_CON,
            "Found DCID which has already been bound to the new path");
        ngtcp2_dcid_copy(&dcid, bound_dcid);
        if (i == 0)
        {
          ngtcp2_ringbuf_pop_front(&conn->dcid.bound);
        }
        else if (i == ((&conn->dcid.bound)->len) - 1)
        {
          ngtcp2_ringbuf_pop_back(&conn->dcid.bound);
        }
        else
        {
          last = ngtcp2_ringbuf_get(&conn->dcid.bound, len - 1);
          ngtcp2_dcid_copy(bound_dcid, last);
          ngtcp2_ringbuf_pop_back(&conn->dcid.bound);
        }
        require_new_cid = 0;
        rv = conn_call_activate_dcid(conn, &dcid);
        if (rv != 0)
        {
          return rv;
        }
        break;
      }
    }
    if (i == len)
    {
      if (require_new_cid)
      {
        if (((&conn->dcid.unused)->len) == 0)
        {
          return NGTCP2_ERR_CONN_ID_BLOCKED;
        }
        ngtcp2_dcid_copy(&dcid, ngtcp2_ringbuf_get(&conn->dcid.unused, 0));
        ngtcp2_ringbuf_pop_front(&conn->dcid.unused);
        rv = conn_call_activate_dcid(conn, &dcid);
        if (rv != 0)
        {
          return rv;
        }
      }
      else
      {
        ngtcp2_dcid_copy(&dcid, &conn->dcid.current);
      }
    }
  }
  ngtcp2_path_copy(&dcid.ps.path, path);
  rv = ngtcp2_pv_new(&pv, &dcid, timeout, NGTCP2_PV_FLAG_FALLBACK_ON_FAILURE,
                     &conn->log, conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  if (conn->pv && (conn->pv->flags & NGTCP2_PV_FLAG_FALLBACK_ON_FAILURE))
  {
    ngtcp2_dcid_copy(&pv->fallback_dcid, &conn->pv->fallback_dcid);
  }
  else
  {
    ngtcp2_dcid_copy(&pv->fallback_dcid, &conn->dcid.current);
  }
  ngtcp2_dcid_copy(&conn->dcid.current, &dcid);
  if (!local_addr_eq || (remote_addr_cmp & (NGTCP2_ADDR_COMPARE_FLAG_ADDR |
                                            NGTCP2_ADDR_COMPARE_FLAG_FAMILY)))
  {
    conn_reset_congestion_state(conn);
  }
  conn_reset_ecn_validation_state(conn);
  if (conn->pv)
  {
    ngtcp2_log_info(
        &conn->log, NGTCP2_LOG_EVENT_PTV,
        "path migration is aborted because new migration has started");
    rv = conn_stop_pv(conn, ts);
    if (rv != 0)
    {
      return rv;
    }
  }
  conn->pv = pv;
  return 0;
}
static int
conn_recv_delayed_handshake_pkt(ngtcp2_conn *conn, const ngtcp2_pkt_info *pi,
                                const ngtcp2_pkt_hd *hd, size_t pktlen,
                                const uint8_t *payload, size_t payloadlen,
                                ngtcp2_tstamp pkt_ts, ngtcp2_tstamp ts)
{
  ngtcp2_ssize nread;
  ngtcp2_max_frame mfr;
  ngtcp2_frame *fr = &mfr.fr;
  int rv;
  int require_ack = 0;
  ngtcp2_pktns *pktns;

  (static_cast<bool>(
       hd->type == NGTCP2_PKT_HANDSHAKE)
       ? void(0)
       : __assert_fail(
             "hd->type == NGTCP2_PKT_HANDSHAKE", "all.cpp", 25331, __extension__ __PRETTY_FUNCTION__));
  pktns = conn->hs_pktns;
  if (payloadlen == 0)
  {
    return NGTCP2_ERR_DISCARD_PKT;
  }
  ngtcp2_qlog_pkt_received_start(&conn->qlog, hd);
  for (; payloadlen;)
  {
    nread = ngtcp2_pkt_decode_frame(fr, payload, payloadlen);
    if (nread < 0)
    {
      return (int)nread;
    }
    payload += nread;
    payloadlen -= (size_t)nread;
    switch (fr->type)
    {
    case NGTCP2_FRAME_ACK:
    case NGTCP2_FRAME_ACK_ECN:
      fr->ack.ack_delay = 0;
      fr->ack.ack_delay_unscaled = 0;
      break;
    }
    ngtcp2_log_rx_fr(&conn->log, hd, fr);
    switch (fr->type)
    {
    case NGTCP2_FRAME_ACK:
    case NGTCP2_FRAME_ACK_ECN:
      if (!conn->server)
      {
        conn->flags |= NGTCP2_CONN_FLAG_SERVER_ADDR_VERIFIED;
      }
      rv = conn_recv_ack(conn, pktns, &fr->ack, pkt_ts, ts);
      if (rv != 0)
      {
        return rv;
      }
      break;
    case NGTCP2_FRAME_PADDING:
      break;
    case NGTCP2_FRAME_CONNECTION_CLOSE:
      conn_recv_connection_close(conn, &fr->connection_close);
      break;
    case NGTCP2_FRAME_CRYPTO:
    case NGTCP2_FRAME_PING:
      require_ack = 1;
      break;
    default:
      return NGTCP2_ERR_PROTO;
    }
    ngtcp2_qlog_write_frame(&conn->qlog, fr);
  }
  ngtcp2_qlog_pkt_received_end(&conn->qlog, hd, pktlen);
  rv = pktns_commit_recv_pkt_num(pktns, hd->pkt_num, require_ack, pkt_ts);
  if (rv != 0)
  {
    return rv;
  }
  pktns_increase_ecn_counts(pktns, pi);
  if (require_ack && (++pktns->acktr.rx_npkt >= 10 ||
                      (pi->ecn & NGTCP2_ECN_MASK) == NGTCP2_ECN_CE))
  {
    ngtcp2_acktr_immediate_ack(&pktns->acktr);
  }
  rv = ngtcp2_conn_sched_ack(conn, &pktns->acktr, hd->pkt_num, require_ack,
                             pkt_ts);
  if (rv != 0)
  {
    return rv;
  }
  conn_restart_timer_on_read(conn, ts);
  ngtcp2_qlog_metrics_updated(&conn->qlog, &conn->cstat);
  return 0;
}
static ngtcp2_ssize conn_recv_pkt(ngtcp2_conn *conn, const ngtcp2_path *path,
                                  const ngtcp2_pkt_info *pi, const uint8_t *pkt,
                                  size_t pktlen, ngtcp2_tstamp pkt_ts,
                                  ngtcp2_tstamp ts)
{
  ngtcp2_pkt_hd hd;
  int rv = 0;
  size_t hdpktlen;
  const uint8_t *payload;
  size_t payloadlen;
  ngtcp2_ssize nread, nwrite;
  ngtcp2_max_frame mfr;
  ngtcp2_frame *fr = &mfr.fr;
  int require_ack = 0;
  ngtcp2_crypto_aead *aead;
  ngtcp2_crypto_cipher *hp;
  ngtcp2_crypto_km *ckm;
  ngtcp2_crypto_cipher_ctx *hp_ctx;
  ngtcp2_hp_mask hp_mask;
  ngtcp2_decrypt decrypt;
  size_t aead_overhead;
  ngtcp2_pktns *pktns;
  int non_probing_pkt = 0;
  int key_phase_bit_changed = 0;
  int force_decrypt_failure = 0;
  int recv_ncid = 0;
  int new_cid_used = 0;
  if (pkt[0] & 0x80)
  {
    nread = ngtcp2_pkt_decode_hd_long(&hd, pkt, pktlen);
    if (nread < 0)
    {
      ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                      "could not decode long header");
      return NGTCP2_ERR_DISCARD_PKT;
    }
    if (pktlen < (size_t)nread + hd.len || conn->version != hd.version)
    {
      return NGTCP2_ERR_DISCARD_PKT;
    }
    pktlen = (size_t)nread + hd.len;
    if (!ngtcp2_cid_eq(&conn->dcid.current.cid, &hd.scid))
    {
      ngtcp2_log_rx_pkt_hd(&conn->log, &hd);
      ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                      "packet was ignored because of mismatched SCID");
      return NGTCP2_ERR_DISCARD_PKT;
    }
    switch (hd.type)
    {
    case NGTCP2_PKT_INITIAL:
      ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                      "delayed Initial packet was discarded");
      return (ngtcp2_ssize)pktlen;
    case NGTCP2_PKT_HANDSHAKE:
      if (!conn->hs_pktns)
      {
        ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                        "delayed Handshake packet was discarded");
        return (ngtcp2_ssize)pktlen;
      }
      pktns = conn->hs_pktns;
      ckm = pktns->crypto.rx.ckm;
      hp_ctx = &pktns->crypto.rx.hp_ctx;
      hp_mask = conn->callbacks.hp_mask;
      decrypt = conn->callbacks.decrypt;
      aead_overhead = conn->crypto.aead_overhead;
      break;
    case NGTCP2_PKT_0RTT:
      if (!conn->server || !conn->early.ckm)
      {
        return NGTCP2_ERR_DISCARD_PKT;
      }
      pktns = &conn->pktns;
      ckm = conn->early.ckm;
      hp_ctx = &conn->early.hp_ctx;
      hp_mask = conn->callbacks.hp_mask;
      decrypt = conn->callbacks.decrypt;
      aead_overhead = conn->crypto.aead_overhead;
      break;
    default:
      ngtcp2_log_rx_pkt_hd(&conn->log, &hd);
      ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                      "packet type 0x%02x was ignored", hd.type);
      return (ngtcp2_ssize)pktlen;
    }
  }
  else
  {
    nread = ngtcp2_pkt_decode_hd_short(&hd, pkt, pktlen, conn->oscid.datalen);
    if (nread < 0)
    {
      ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                      "could not decode short header");
      return NGTCP2_ERR_DISCARD_PKT;
    }
    pktns = &conn->pktns;
    ckm = pktns->crypto.rx.ckm;
    hp_ctx = &pktns->crypto.rx.hp_ctx;
    hp_mask = conn->callbacks.hp_mask;
    decrypt = conn->callbacks.decrypt;
    aead_overhead = conn->crypto.aead_overhead;
  }
  aead = &pktns->crypto.ctx.aead;
  hp = &pktns->crypto.ctx.hp;
  rv = conn_ensure_decrypt_hp_buffer(conn, (size_t)nread + 4);
  if (rv != 0)
  {
    return rv;
  }
  nwrite = decrypt_hp(&hd, conn->crypto.decrypt_hp_buf.base, hp, pkt, pktlen,
                      (size_t)nread, ckm, hp_ctx, hp_mask);
  if (nwrite < 0)
  {
    if (ngtcp2_err_is_fatal((int)nwrite))
    {
      return nwrite;
    }
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                    "could not decrypt packet number");
    return NGTCP2_ERR_DISCARD_PKT;
  }
  hdpktlen = (size_t)nwrite;
  payload = pkt + hdpktlen;
  payloadlen = pktlen - hdpktlen;
  hd.pkt_num = ngtcp2_pkt_adjust_pkt_num(pktns->rx.max_pkt_num, hd.pkt_num,
                                         pkt_num_bits(hd.pkt_numlen));
  if (hd.pkt_num > ((int64_t)((1ll << 62) - 1)))
  {
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                    "pkn=%"
                    "l"
                    "d"
                    " is greater than maximum pkn",
                    hd.pkt_num);
    return NGTCP2_ERR_DISCARD_PKT;
  }
  ngtcp2_log_rx_pkt_hd(&conn->log, &hd);
  if (hd.type == NGTCP2_PKT_SHORT)
  {
    key_phase_bit_changed = conn_key_phase_changed(conn, &hd);
  }
  rv = conn_ensure_decrypt_buffer(conn, payloadlen);
  if (rv != 0)
  {
    return rv;
  }
  if (key_phase_bit_changed)
  {

    (static_cast<bool>(
         hd.type == NGTCP2_PKT_SHORT)
         ? void(0)
         : __assert_fail(
               "hd.type == NGTCP2_PKT_SHORT", "all.cpp", 25552, __extension__ __PRETTY_FUNCTION__));
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT, "unexpected KEY_PHASE");
    if (ckm->pkt_num > hd.pkt_num)
    {
      if (conn->crypto.key_update.old_rx_ckm)
      {
        ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                        "decrypting with old key");
        ckm = conn->crypto.key_update.old_rx_ckm;
      }
      else
      {
        force_decrypt_failure = 1;
      }
    }
    else if (pktns->rx.max_pkt_num < hd.pkt_num)
    {

      (static_cast<bool>(
           ckm->pkt_num < hd.pkt_num)
           ? void(0)
           : __assert_fail(
                 "ckm->pkt_num < hd.pkt_num", "all.cpp", 25569, __extension__ __PRETTY_FUNCTION__));
      if (!conn->crypto.key_update.new_rx_ckm)
      {
        ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                        "new key is not available");
        force_decrypt_failure = 1;
      }
      else
      {
        ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                        "decrypting with new key");
        ckm = conn->crypto.key_update.new_rx_ckm;
      }
    }
    else
    {
      force_decrypt_failure = 1;
    }
  }
  nwrite = decrypt_pkt(conn->crypto.decrypt_buf.base, aead, payload, payloadlen,
                       conn->crypto.decrypt_hp_buf.base, hdpktlen, hd.pkt_num,
                       ckm, decrypt, aead_overhead);
  if (force_decrypt_failure)
  {
    nwrite = NGTCP2_ERR_TLS_DECRYPT;
  }
  if (nwrite < 0)
  {
    if (ngtcp2_err_is_fatal((int)nwrite))
    {
      return nwrite;
    }

    (static_cast<bool>(
         NGTCP2_ERR_TLS_DECRYPT == nwrite)
         ? void(0)
         : __assert_fail(
               "NGTCP2_ERR_TLS_DECRYPT == nwrite", "all.cpp", 25601, __extension__ __PRETTY_FUNCTION__));
    if (hd.type == NGTCP2_PKT_SHORT &&
        ++conn->crypto.decryption_failure_count >=
            pktns->crypto.ctx.max_decryption_failure)
    {
      return NGTCP2_ERR_AEAD_LIMIT_REACHED;
    }
    if (hd.flags & NGTCP2_PKT_FLAG_LONG_FORM)
    {
      ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                      "could not decrypt packet payload");
      return NGTCP2_ERR_DISCARD_PKT;
    }
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                    "could not decrypt packet payload");
    return NGTCP2_ERR_DISCARD_PKT;
  }
  rv = ngtcp2_pkt_verify_reserved_bits(conn->crypto.decrypt_hp_buf.base[0]);
  if (rv != 0)
  {
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                    "packet has incorrect reserved bits");
    return NGTCP2_ERR_PROTO;
  }
  if (pktns_pkt_num_is_duplicate(pktns, hd.pkt_num))
  {
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                    "packet was discarded because of duplicated packet number");
    return NGTCP2_ERR_DISCARD_PKT;
  }
  payload = conn->crypto.decrypt_buf.base;
  payloadlen = (size_t)nwrite;
  if (payloadlen == 0)
  {
    return NGTCP2_ERR_DISCARD_PKT;
  }
  if (hd.flags & NGTCP2_PKT_FLAG_LONG_FORM)
  {
    switch (hd.type)
    {
    case NGTCP2_PKT_HANDSHAKE:
      rv = conn_verify_dcid(conn,
                            __null, &hd);
      if (rv != 0)
      {
        if (ngtcp2_err_is_fatal(rv))
        {
          return rv;
        }
        ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                        "packet was ignored because of mismatched DCID");
        return NGTCP2_ERR_DISCARD_PKT;
      }
      rv = conn_recv_delayed_handshake_pkt(conn, pi, &hd, pktlen, payload,
                                           payloadlen, pkt_ts, ts);
      if (rv < 0)
      {
        return (ngtcp2_ssize)rv;
      }
      return (ngtcp2_ssize)pktlen;
    case NGTCP2_PKT_0RTT:
      if (!ngtcp2_cid_eq(&conn->rcid, &hd.dcid))
      {
        rv = conn_verify_dcid(conn,
                              __null, &hd);
        if (rv != 0)
        {
          if (ngtcp2_err_is_fatal(rv))
          {
            return rv;
          }
          ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                          "packet was ignored because of mismatched DCID");
          return NGTCP2_ERR_DISCARD_PKT;
        }
      }
      break;
    default:

      (static_cast<bool>(
           0)
           ? void(0)
           : __assert_fail(
                 "0", "all.cpp", 25677, __extension__ __PRETTY_FUNCTION__));
    }
  }
  else
  {
    rv = conn_verify_dcid(conn, &new_cid_used, &hd);
    if (rv != 0)
    {
      if (ngtcp2_err_is_fatal(rv))
      {
        return rv;
      }
      ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                      "packet was ignored because of mismatched DCID");
      return NGTCP2_ERR_DISCARD_PKT;
    }
    conn->flags |= NGTCP2_CONN_FLAG_RECV_PROTECTED_PKT;
  }
  ngtcp2_qlog_pkt_received_start(&conn->qlog, &hd);
  for (; payloadlen;)
  {
    nread = ngtcp2_pkt_decode_frame(fr, payload, payloadlen);
    if (nread < 0)
    {
      return nread;
    }
    payload += nread;
    payloadlen -= (size_t)nread;
    switch (fr->type)
    {
    case NGTCP2_FRAME_ACK:
    case NGTCP2_FRAME_ACK_ECN:
      if ((hd.flags & NGTCP2_PKT_FLAG_LONG_FORM) &&
          hd.type == NGTCP2_PKT_0RTT)
      {
        return NGTCP2_ERR_PROTO;
      }
      assign_recved_ack_delay_unscaled(
          &fr->ack, conn->remote.transport_params.ack_delay_exponent);
      break;
    }
    ngtcp2_log_rx_fr(&conn->log, &hd, fr);
    if (hd.type == NGTCP2_PKT_0RTT)
    {
      switch (fr->type)
      {
      case NGTCP2_FRAME_PADDING:
      case NGTCP2_FRAME_PING:
      case NGTCP2_FRAME_RESET_STREAM:
      case NGTCP2_FRAME_STOP_SENDING:
      case NGTCP2_FRAME_STREAM:
      case NGTCP2_FRAME_MAX_DATA:
      case NGTCP2_FRAME_MAX_STREAM_DATA:
      case NGTCP2_FRAME_MAX_STREAMS_BIDI:
      case NGTCP2_FRAME_MAX_STREAMS_UNI:
      case NGTCP2_FRAME_DATA_BLOCKED:
      case NGTCP2_FRAME_STREAM_DATA_BLOCKED:
      case NGTCP2_FRAME_STREAMS_BLOCKED_BIDI:
      case NGTCP2_FRAME_STREAMS_BLOCKED_UNI:
      case NGTCP2_FRAME_NEW_CONNECTION_ID:
      case NGTCP2_FRAME_PATH_CHALLENGE:
      case NGTCP2_FRAME_CONNECTION_CLOSE:
      case NGTCP2_FRAME_CONNECTION_CLOSE_APP:
        break;
      default:
        return NGTCP2_ERR_PROTO;
      }
    }
    switch (fr->type)
    {
    case NGTCP2_FRAME_ACK:
    case NGTCP2_FRAME_ACK_ECN:
    case NGTCP2_FRAME_PADDING:
    case NGTCP2_FRAME_CONNECTION_CLOSE:
    case NGTCP2_FRAME_CONNECTION_CLOSE_APP:
      break;
    default:
      require_ack = 1;
    }
    switch (fr->type)
    {
    case NGTCP2_FRAME_ACK:
    case NGTCP2_FRAME_ACK_ECN:
      if (!conn->server)
      {
        conn->flags |= NGTCP2_CONN_FLAG_SERVER_ADDR_VERIFIED;
      }
      rv = conn_recv_ack(conn, pktns, &fr->ack, pkt_ts, ts);
      if (rv != 0)
      {
        return rv;
      }
      non_probing_pkt = 1;
      break;
    case NGTCP2_FRAME_STREAM:
      rv = conn_recv_stream(conn, &fr->stream, ts);
      if (rv != 0)
      {
        return rv;
      }
      non_probing_pkt = 1;
      break;
    case NGTCP2_FRAME_CRYPTO:
      rv = conn_recv_crypto(conn, NGTCP2_CRYPTO_LEVEL_APP, &pktns->crypto.strm,
                            &fr->crypto);
      if (rv != 0)
      {
        return rv;
      }
      non_probing_pkt = 1;
      break;
    case NGTCP2_FRAME_RESET_STREAM:
      rv = conn_recv_reset_stream(conn, &fr->reset_stream);
      if (rv != 0)
      {
        return rv;
      }
      non_probing_pkt = 1;
      break;
    case NGTCP2_FRAME_STOP_SENDING:
      rv = conn_recv_stop_sending(conn, &fr->stop_sending);
      if (rv != 0)
      {
        return rv;
      }
      non_probing_pkt = 1;
      break;
    case NGTCP2_FRAME_MAX_STREAM_DATA:
      rv = conn_recv_max_stream_data(conn, &fr->max_stream_data);
      if (rv != 0)
      {
        return rv;
      }
      non_probing_pkt = 1;
      break;
    case NGTCP2_FRAME_MAX_DATA:
      conn_recv_max_data(conn, &fr->max_data);
      non_probing_pkt = 1;
      break;
    case NGTCP2_FRAME_MAX_STREAMS_BIDI:
    case NGTCP2_FRAME_MAX_STREAMS_UNI:
      rv = conn_recv_max_streams(conn, &fr->max_streams);
      if (rv != 0)
      {
        return rv;
      }
      non_probing_pkt = 1;
      break;
    case NGTCP2_FRAME_CONNECTION_CLOSE:
    case NGTCP2_FRAME_CONNECTION_CLOSE_APP:
      conn_recv_connection_close(conn, &fr->connection_close);
      break;
    case NGTCP2_FRAME_PING:
      non_probing_pkt = 1;
      break;
    case NGTCP2_FRAME_PATH_CHALLENGE:
      conn_recv_path_challenge(conn, path, &fr->path_challenge);
      break;
    case NGTCP2_FRAME_PATH_RESPONSE:
      rv = conn_recv_path_response(conn, &fr->path_response, ts);
      if (rv != 0)
      {
        return rv;
      }
      break;
    case NGTCP2_FRAME_NEW_CONNECTION_ID:
      rv = conn_recv_new_connection_id(conn, &fr->new_connection_id);
      if (rv != 0)
      {
        return rv;
      }
      recv_ncid = 1;
      break;
    case NGTCP2_FRAME_RETIRE_CONNECTION_ID:
      rv = conn_recv_retire_connection_id(conn, &hd, &fr->retire_connection_id,
                                          ts);
      if (rv != 0)
      {
        return rv;
      }
      non_probing_pkt = 1;
      break;
    case NGTCP2_FRAME_NEW_TOKEN:
      rv = conn_recv_new_token(conn, &fr->new_token);
      if (rv != 0)
      {
        return rv;
      }
      non_probing_pkt = 1;
      break;
    case NGTCP2_FRAME_HANDSHAKE_DONE:
      rv = conn_recv_handshake_done(conn, ts);
      if (rv != 0)
      {
        return rv;
      }
      non_probing_pkt = 1;
      break;
    case NGTCP2_FRAME_DATA_BLOCKED:
    case NGTCP2_FRAME_STREAMS_BLOCKED_BIDI:
    case NGTCP2_FRAME_STREAMS_BLOCKED_UNI:
      non_probing_pkt = 1;
      break;
    }
    ngtcp2_qlog_write_frame(&conn->qlog, fr);
  }
  ngtcp2_qlog_pkt_received_end(&conn->qlog, &hd, pktlen);
  if (recv_ncid)
  {
    rv = conn_post_process_recv_new_connection_id(conn, ts);
    if (rv != 0)
    {
      return rv;
    }
  }
  if (conn->server && hd.type == NGTCP2_PKT_SHORT && non_probing_pkt &&
      pktns->rx.max_pkt_num < hd.pkt_num &&
      !ngtcp2_path_eq(&conn->dcid.current.ps.path, path) &&
      !conn_path_validation_in_progress(conn, path))
  {
    rv = conn_recv_non_probing_pkt_on_new_path(conn, path, new_cid_used, ts);
    if (rv != 0)
    {
      if (ngtcp2_err_is_fatal(rv))
      {
        return rv;
      }

      (static_cast<bool>(
           NGTCP2_ERR_CONN_ID_BLOCKED == rv)
           ? void(0)
           : __assert_fail(
                 "NGTCP2_ERR_CONN_ID_BLOCKED == rv", "all.cpp", 25904, __extension__ __PRETTY_FUNCTION__));
    }
  }
  if (hd.type == NGTCP2_PKT_SHORT)
  {
    if (ckm == conn->crypto.key_update.new_rx_ckm)
    {
      ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_CON, "rotate keys");
      conn_rotate_keys(conn, hd.pkt_num);
    }
    else if (ckm->pkt_num > hd.pkt_num)
    {
      ckm->pkt_num = hd.pkt_num;
    }
  }
  rv = pktns_commit_recv_pkt_num(pktns, hd.pkt_num, require_ack, pkt_ts);
  if (rv != 0)
  {
    return rv;
  }
  pktns_increase_ecn_counts(pktns, pi);
  if (require_ack && (++pktns->acktr.rx_npkt >= 10 ||
                      (pi->ecn & NGTCP2_ECN_MASK) == NGTCP2_ECN_CE))
  {
    ngtcp2_acktr_immediate_ack(&pktns->acktr);
  }
  rv = ngtcp2_conn_sched_ack(conn, &pktns->acktr, hd.pkt_num, require_ack,
                             pkt_ts);
  if (rv != 0)
  {
    return rv;
  }
  conn_restart_timer_on_read(conn, ts);
  ngtcp2_qlog_metrics_updated(&conn->qlog, &conn->cstat);
  return conn->state == NGTCP2_CS_DRAINING ? NGTCP2_ERR_DRAINING
                                           : (ngtcp2_ssize)pktlen;
}
static int conn_process_buffered_protected_pkt(ngtcp2_conn *conn,
                                               ngtcp2_pktns *pktns,
                                               ngtcp2_tstamp ts)
{
  ngtcp2_ssize nread;
  ngtcp2_pkt_chain **ppc, *next;
  int rv;
  ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_CON,
                  "processing buffered protected packet");
  for (ppc = &pktns->rx.buffed_pkts; *ppc;)
  {
    next = (*ppc)->next;
    nread = conn_recv_pkt(conn, &(*ppc)->path.path, &(*ppc)->pi, (*ppc)->pkt,
                          (*ppc)->pktlen, (*ppc)->ts, ts);
    if (nread < 0 && !ngtcp2_err_is_fatal((int)nread) &&
        nread != NGTCP2_ERR_DRAINING)
    {
      rv = conn_on_stateless_reset(conn, &(*ppc)->path.path, (*ppc)->pkt,
                                   (*ppc)->pktlen);
      if (rv == 0)
      {
        ngtcp2_pkt_chain_del(*ppc, conn->mem);
        *ppc = next;
        return NGTCP2_ERR_DRAINING;
      }
    }
    ngtcp2_pkt_chain_del(*ppc, conn->mem);
    *ppc = next;
    if (nread < 0)
    {
      if (nread == NGTCP2_ERR_DISCARD_PKT)
      {
        continue;
      }
      return (int)nread;
    }
  }
  return 0;
}
static int conn_process_buffered_handshake_pkt(ngtcp2_conn *conn,
                                               ngtcp2_tstamp ts)
{
  ngtcp2_pktns *pktns = conn->hs_pktns;
  ngtcp2_ssize nread;
  ngtcp2_pkt_chain **ppc, *next;
  ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_CON,
                  "processing buffered handshake packet");
  for (ppc = &pktns->rx.buffed_pkts; *ppc;)
  {
    next = (*ppc)->next;
    nread =
        conn_recv_handshake_pkt(conn, &(*ppc)->path.path, &(*ppc)->pi,
                                (*ppc)->pkt, (*ppc)->pktlen, (*ppc)->ts, ts);
    ngtcp2_pkt_chain_del(*ppc, conn->mem);
    *ppc = next;
    if (nread < 0)
    {
      if (nread == NGTCP2_ERR_DISCARD_PKT)
      {
        continue;
      }
      return (int)nread;
    }
  }
  return 0;
}
static void conn_sync_stream_id_limit(ngtcp2_conn *conn)
{
  ngtcp2_transport_params *params = &conn->remote.transport_params;
  conn->local.bidi.max_streams = params->initial_max_streams_bidi;
  conn->local.uni.max_streams = params->initial_max_streams_uni;
}
static int conn_handshake_completed(ngtcp2_conn *conn)
{
  int rv;
  conn->flags |= NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED_HANDLED;
  rv = conn_call_handshake_completed(conn);
  if (rv != 0)
  {
    return rv;
  }
  if (conn->local.bidi.max_streams > 0)
  {
    rv = conn_call_extend_max_local_streams_bidi(conn,
                                                 conn->local.bidi.max_streams);
    if (rv != 0)
    {
      return rv;
    }
  }
  if (conn->local.uni.max_streams > 0)
  {
    rv = conn_call_extend_max_local_streams_uni(conn,
                                                conn->local.uni.max_streams);
    if (rv != 0)
    {
      return rv;
    }
  }
  return 0;
}
static int conn_recv_cpkt(ngtcp2_conn *conn, const ngtcp2_path *path,
                          const ngtcp2_pkt_info *pi, const uint8_t *pkt,
                          size_t pktlen, ngtcp2_tstamp ts)
{
  ngtcp2_ssize nread;
  int rv;
  const uint8_t *origpkt = pkt;
  size_t origpktlen = pktlen;
  conn->cstat.bytes_recv += pktlen;
  while (pktlen)
  {
    nread = conn_recv_pkt(conn, path, pi, pkt, pktlen, ts, ts);
    if (nread < 0)
    {
      if (ngtcp2_err_is_fatal((int)nread))
      {
        return (int)nread;
      }
      if (nread == NGTCP2_ERR_DRAINING)
      {
        return NGTCP2_ERR_DRAINING;
      }
      if (origpkt == pkt)
      {
        rv = conn_on_stateless_reset(conn, path, origpkt, origpktlen);
        if (rv == 0)
        {
          return NGTCP2_ERR_DRAINING;
        }
      }
      if (nread == NGTCP2_ERR_DISCARD_PKT)
      {
        return 0;
      }
      return (int)nread;
    }

    (static_cast<bool>(
         pktlen >= (size_t)nread)
         ? void(0)
         : __assert_fail(
               "pktlen >= (size_t)nread", "all.cpp", 26083, __extension__ __PRETTY_FUNCTION__));
    pkt += nread;
    pktlen -= (size_t)nread;
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_PKT,
                    "read packet %td left %zu", nread, pktlen);
  }
  return 0;
}
static int conn_is_retired_path(ngtcp2_conn *conn, const ngtcp2_path *path)
{
  size_t i, len = ((&conn->dcid.retired)->len);
  ngtcp2_dcid *dcid;
  for (i = 0; i < len; ++i)
  {
    dcid = ngtcp2_ringbuf_get(&conn->dcid.retired, i);
    if (ngtcp2_path_eq(&dcid->ps.path, path))
    {
      return 1;
    }
  }
  return 0;
}
static int conn_enqueue_handshake_done(ngtcp2_conn *conn)
{
  ngtcp2_pktns *pktns = &conn->pktns;
  ngtcp2_frame_chain *nfrc;
  int rv;

  (static_cast<bool>(
       conn->server)
       ? void(0)
       : __assert_fail(
             "conn->server", "all.cpp", 26112, __extension__ __PRETTY_FUNCTION__));
  rv = ngtcp2_frame_chain_new(&nfrc, conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  nfrc->fr.type = NGTCP2_FRAME_HANDSHAKE_DONE;
  nfrc->next = pktns->tx.frq;
  pktns->tx.frq = nfrc;
  return 0;
}
static int conn_read_handshake(ngtcp2_conn *conn, const ngtcp2_path *path,
                               const ngtcp2_pkt_info *pi, const uint8_t *pkt,
                               size_t pktlen, ngtcp2_tstamp ts)
{
  int rv;
  switch (conn->state)
  {
  case NGTCP2_CS_CLIENT_INITIAL:
    return 0;
  case NGTCP2_CS_CLIENT_WAIT_HANDSHAKE:
    rv = conn_recv_handshake_cpkt(conn, path, pi, pkt, pktlen, ts);
    if (rv < 0)
    {
      return rv;
    }
    if (conn->state == NGTCP2_CS_CLIENT_INITIAL)
    {
      return 0;
    }

    (static_cast<bool>(
         conn->hs_pktns)
         ? void(0)
         : __assert_fail(
               "conn->hs_pktns", "all.cpp", 26143, __extension__ __PRETTY_FUNCTION__));
    if (conn->hs_pktns->crypto.rx.ckm && conn->in_pktns)
    {
      rv = conn_process_buffered_handshake_pkt(conn, ts);
      if (rv != 0)
      {
        return rv;
      }
    }
    if ((conn->flags & (NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED |
                        NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED_HANDLED)) ==
        NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED)
    {
      rv = conn_handshake_completed(conn);
      if (rv != 0)
      {
        return rv;
      }
    }
    return 0;
  case NGTCP2_CS_SERVER_INITIAL:
    rv = conn_recv_handshake_cpkt(conn, path, pi, pkt, pktlen, ts);
    if (rv < 0)
    {
      return rv;
    }
    if (ngtcp2_strm_rx_offset(&conn->in_pktns->crypto.strm) == 0)
    {
      if (conn->in_pktns->crypto.strm.rx.rob &&
          ngtcp2_rob_data_buffered(conn->in_pktns->crypto.strm.rx.rob))
      {
        if (conn->local.settings.token.len)
        {
          return 0;
        }
        return NGTCP2_ERR_RETRY;
      }
      if (conn->in_pktns->rx.buffed_pkts)
      {
        return NGTCP2_ERR_RETRY;
      }
      return NGTCP2_ERR_DROP_CONN;
    }
    if (conn->early.ckm)
    {

      (static_cast<bool>(
           conn->in_pktns)
           ? void(0)
           : __assert_fail(
                 "conn->in_pktns", "all.cpp", 26188, __extension__ __PRETTY_FUNCTION__));
      rv = conn_process_buffered_protected_pkt(conn, conn->in_pktns, ts);
      if (rv != 0)
      {
        return rv;
      }
    }
    return 0;
  case NGTCP2_CS_SERVER_WAIT_HANDSHAKE:
    rv = conn_recv_handshake_cpkt(conn, path, pi, pkt, pktlen, ts);
    if (rv < 0)
    {
      return rv;
    }
    if (conn->hs_pktns->crypto.rx.ckm)
    {
      rv = conn_process_buffered_handshake_pkt(conn, ts);
      if (rv != 0)
      {
        return rv;
      }
    }
    if (conn->hs_pktns->rx.max_pkt_num != -1)
    {
      conn_discard_initial_state(conn, ts);
    }
    if (!(conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED))
    {
      if (!conn->cstat.loss_detection_timer)
      {
        ngtcp2_conn_set_loss_detection_timer(conn, ts);
        if (ngtcp2_conn_loss_detection_expiry(conn) <= ts)
        {
          rv = ngtcp2_conn_on_loss_detection_timer(conn, ts);
          if (rv != 0)
          {
            return rv;
          }
        }
      }
      return 0;
    }
    if (!(conn->flags & NGTCP2_CONN_FLAG_TRANSPORT_PARAM_RECVED))
    {
      return NGTCP2_ERR_REQUIRED_TRANSPORT_PARAM;
    }
    rv = conn_handshake_completed(conn);
    if (rv != 0)
    {
      return rv;
    }
    conn->state = NGTCP2_CS_POST_HANDSHAKE;
    rv = conn_call_activate_dcid(conn, &conn->dcid.current);
    if (rv != 0)
    {
      return rv;
    }
    rv = conn_process_buffered_protected_pkt(conn, &conn->pktns, ts);
    if (rv != 0)
    {
      return rv;
    }
    conn_discard_handshake_state(conn, ts);
    rv = conn_enqueue_handshake_done(conn);
    if (rv != 0)
    {
      return rv;
    }
    conn->pktns.rtb.persistent_congestion_start_ts = ts;
    ngtcp2_conn_set_loss_detection_timer(conn, ts);
    return 0;
  case NGTCP2_CS_CLOSING:
    return NGTCP2_ERR_CLOSING;
  case NGTCP2_CS_DRAINING:
    return NGTCP2_ERR_DRAINING;
  default:
    return 0;
  }
}
int ngtcp2_conn_read_pkt(ngtcp2_conn *conn, const ngtcp2_path *path,
                         const ngtcp2_pkt_info *pi, const uint8_t *pkt,
                         size_t pktlen, ngtcp2_tstamp ts)
{
  int rv = 0;
  conn->log.last_ts = ts;
  conn->qlog.last_ts = ts;
  ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_CON, "recv packet len=%zu",
                  pktlen);
  if (pktlen == 0)
  {
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  if (!conn->server && !ngtcp2_path_eq(&conn->dcid.current.ps.path, path) &&
      (!conn->pv || !ngtcp2_path_eq(&conn->pv->dcid.ps.path, path)) &&
      !conn_is_retired_path(conn, path))
  {
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_CON,
                    "ignore packet from unknown path");
    return 0;
  }
  switch (conn->state)
  {
  case NGTCP2_CS_CLIENT_INITIAL:
  case NGTCP2_CS_CLIENT_WAIT_HANDSHAKE:
  case NGTCP2_CS_CLIENT_TLS_HANDSHAKE_FAILED:
  case NGTCP2_CS_SERVER_INITIAL:
  case NGTCP2_CS_SERVER_WAIT_HANDSHAKE:
  case NGTCP2_CS_SERVER_TLS_HANDSHAKE_FAILED:
    if (conn->server && !ngtcp2_path_eq(&conn->dcid.current.ps.path, path))
    {
      ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_CON,
                      "ignore packet from unknown path during handshake");
      return 0;
    }
    return conn_read_handshake(conn, path, pi, pkt, pktlen, ts);
  case NGTCP2_CS_CLOSING:
    return NGTCP2_ERR_CLOSING;
  case NGTCP2_CS_DRAINING:
    return NGTCP2_ERR_DRAINING;
  case NGTCP2_CS_POST_HANDSHAKE:
    rv = conn_prepare_key_update(conn, ts);
    if (rv != 0)
    {
      return rv;
    }
    return conn_recv_cpkt(conn, path, pi, pkt, pktlen, ts);
  default:

    (static_cast<bool>(
         0)
         ? void(0)
         : __assert_fail(
               "0", "all.cpp", 26316, __extension__ __PRETTY_FUNCTION__));
  }
}
static int conn_check_pkt_num_exhausted(ngtcp2_conn *conn)
{
  ngtcp2_pktns *in_pktns = conn->in_pktns;
  ngtcp2_pktns *hs_pktns = conn->hs_pktns;
  return (in_pktns && in_pktns->tx.last_pkt_num == ((int64_t)((1ll << 62) - 1))) ||
         (hs_pktns && hs_pktns->tx.last_pkt_num == ((int64_t)((1ll << 62) - 1))) ||
         conn->pktns.tx.last_pkt_num == ((int64_t)((1ll << 62) - 1));
}
static size_t conn_server_hs_tx_left(ngtcp2_conn *conn)
{
  if (conn->flags & NGTCP2_CONN_FLAG_SADDR_VERIFIED)
  {
    return (18446744073709551615UL);
  }

  (static_cast<bool>(
       conn->cstat.bytes_recv * 3 >= conn->cstat.bytes_sent)
       ? void(0)
       : __assert_fail(
             "conn->cstat.bytes_recv * 3 >= conn->cstat.bytes_sent", "all.cpp", 26335, __extension__ __PRETTY_FUNCTION__));
  return conn->cstat.bytes_recv * 3 - conn->cstat.bytes_sent;
}
static ngtcp2_ssize conn_retransmit_retry_early(ngtcp2_conn *conn,
                                                ngtcp2_pkt_info *pi,
                                                uint8_t *dest, size_t destlen,
                                                ngtcp2_tstamp ts)
{
  return conn_write_pkt(conn, pi, dest, destlen,
                        __null, NGTCP2_PKT_0RTT,
                        NGTCP2_WRITE_PKT_FLAG_NONE, ts);
}
static int conn_handshake_probe_left(ngtcp2_conn *conn)
{
  return (conn->in_pktns && conn->in_pktns->rtb.probe_pkt_left) ||
         conn->hs_pktns->rtb.probe_pkt_left;
}
static ngtcp2_ssize conn_write_handshake(ngtcp2_conn *conn, ngtcp2_pkt_info *pi,
                                         uint8_t *dest, size_t destlen,
                                         size_t early_datalen,
                                         ngtcp2_tstamp ts)
{
  int rv;
  ngtcp2_ssize res = 0, nwrite = 0, early_spktlen = 0;
  size_t origlen = destlen;
  size_t server_hs_tx_left;
  ngtcp2_conn_stat *cstat = &conn->cstat;
  size_t pending_early_datalen;
  ngtcp2_dcid *dcid;
  ngtcp2_preferred_addr *paddr;
  switch (conn->state)
  {
  case NGTCP2_CS_CLIENT_INITIAL:
    pending_early_datalen = conn_retry_early_payloadlen(conn);
    if (pending_early_datalen)
    {
      early_datalen = pending_early_datalen;
    }
    if (!(conn->flags & NGTCP2_CONN_FLAG_RECV_RETRY))
    {
      nwrite =
          conn_write_client_initial(conn, pi, dest, destlen, early_datalen, ts);
      if (nwrite <= 0)
      {
        return nwrite;
      }
    }
    else
    {
      nwrite = conn_write_handshake_pkt(
          conn, pi, dest, destlen, NGTCP2_PKT_INITIAL,
          NGTCP2_WRITE_PKT_FLAG_NONE, early_datalen, ts);
      if (nwrite < 0)
      {
        return nwrite;
      }
    }
    if (pending_early_datalen)
    {
      early_spktlen = conn_retransmit_retry_early(conn, pi, dest + nwrite,
                                                  destlen - (size_t)nwrite, ts);
      if (early_spktlen < 0)
      {

        (static_cast<bool>(
             ngtcp2_err_is_fatal((int)early_spktlen))
             ? void(0)
             : __assert_fail(
                   "ngtcp2_err_is_fatal((int)early_spktlen)", "all.cpp", 26400, __extension__ __PRETTY_FUNCTION__));
        return early_spktlen;
      }
    }
    conn->state = NGTCP2_CS_CLIENT_WAIT_HANDSHAKE;
    res = nwrite + early_spktlen;
    cstat->bytes_sent += (size_t)res;
    return res;
  case NGTCP2_CS_CLIENT_WAIT_HANDSHAKE:
    if (!conn_handshake_probe_left(conn) && conn_cwnd_is_zero(conn))
    {
      destlen = 0;
    }
    else
    {
      if (!(conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED_HANDLED))
      {
        pending_early_datalen = conn_retry_early_payloadlen(conn);
        if (pending_early_datalen)
        {
          early_datalen = pending_early_datalen;
        }
      }
      nwrite =
          conn_write_handshake_pkts(conn, pi, dest, destlen, early_datalen, ts);
      if (nwrite < 0)
      {
        return nwrite;
      }
      res += nwrite;
      dest += nwrite;
      destlen -= (size_t)nwrite;
    }
    if (!(conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED))
    {
      nwrite = conn_retransmit_retry_early(conn, pi, dest, destlen, ts);
      if (nwrite < 0)
      {
        return nwrite;
      }
      res += nwrite;
      if (res == 0)
      {
        nwrite = conn_write_handshake_ack_pkts(conn, pi, dest, origlen, ts);
        if (nwrite < 0)
        {
          return nwrite;
        }
        res = nwrite;
      }
      cstat->bytes_sent += (size_t)res;
      return res;
    }
    if (!(conn->flags & NGTCP2_CONN_FLAG_TRANSPORT_PARAM_RECVED))
    {
      return NGTCP2_ERR_REQUIRED_TRANSPORT_PARAM;
    }
    conn->state = NGTCP2_CS_POST_HANDSHAKE;
    if (conn->remote.transport_params.preferred_address_present)
    {

      (static_cast<bool>(
           !ngtcp2_ringbuf_full(&conn->dcid.unused))
           ? void(0)
           : __assert_fail(
                 "!ngtcp2_ringbuf_full(&conn->dcid.unused)", "all.cpp", 26460, __extension__ __PRETTY_FUNCTION__));
      paddr = &conn->remote.transport_params.preferred_address;
      dcid = ngtcp2_ringbuf_push_back(&conn->dcid.unused);
      ngtcp2_dcid_init(dcid, 1, &paddr->cid, paddr->stateless_reset_token);
      rv = ngtcp2_gaptr_push(&conn->dcid.seqgap, 1, 1);
      if (rv != 0)
      {
        return (ngtcp2_ssize)rv;
      }
    }
    if (conn->remote.transport_params.stateless_reset_token_present)
    {

      (static_cast<bool>(
           conn->dcid.current.seq == 0)
           ? void(0)
           : __assert_fail(
                 "conn->dcid.current.seq == 0", "all.cpp", 26472, __extension__ __PRETTY_FUNCTION__));
      memcpy(conn->dcid.current.token,
             conn->remote.transport_params.stateless_reset_token,
             sizeof(conn->dcid.current.token));
    }
    rv = conn_call_activate_dcid(conn, &conn->dcid.current);
    if (rv != 0)
    {
      return rv;
    }
    conn_process_early_rtb(conn);
    rv = conn_process_buffered_protected_pkt(conn, &conn->pktns, ts);
    if (rv != 0)
    {
      return (ngtcp2_ssize)rv;
    }
    cstat->bytes_sent += (size_t)res;
    return res;
  case NGTCP2_CS_SERVER_INITIAL:
    nwrite = conn_write_handshake_pkts(conn, pi, dest, destlen,
                                       0, ts);
    if (nwrite < 0)
    {
      return nwrite;
    }
    if (nwrite)
    {
      conn->state = NGTCP2_CS_SERVER_WAIT_HANDSHAKE;
      cstat->bytes_sent += (size_t)nwrite;
    }
    return nwrite;
  case NGTCP2_CS_SERVER_WAIT_HANDSHAKE:
    if (!(conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED))
    {
      server_hs_tx_left = conn_server_hs_tx_left(conn);
      if (server_hs_tx_left == 0)
      {
        if (cstat->loss_detection_timer)
        {
          ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_RCV,
                          "loss detection timer canceled");
          cstat->loss_detection_timer = 0;
          cstat->pto_count = 0;
        }
        return 0;
      }
      if (conn_handshake_probe_left(conn) || !conn_cwnd_is_zero(conn))
      {
        nwrite = conn_write_handshake_pkts(conn, pi, dest, destlen,
                                           0, ts);
        if (nwrite < 0)
        {
          return nwrite;
        }
        res += nwrite;
        dest += nwrite;
        destlen -= (size_t)nwrite;
      }
      if (res == 0)
      {
        nwrite = conn_write_handshake_ack_pkts(conn, pi, dest, origlen, ts);
        if (nwrite < 0)
        {
          return nwrite;
        }
        res += nwrite;
        dest += nwrite;
        origlen -= (size_t)nwrite;
      }
      cstat->bytes_sent += (size_t)res;
      return res;
    }
    return 0;
  case NGTCP2_CS_CLOSING:
    return NGTCP2_ERR_CLOSING;
  case NGTCP2_CS_DRAINING:
    return NGTCP2_ERR_DRAINING;
  default:
    return 0;
  }
}
static ngtcp2_ssize conn_client_write_handshake(ngtcp2_conn *conn,
                                                ngtcp2_pkt_info *pi,
                                                uint8_t *dest, size_t destlen,
                                                ngtcp2_vmsg *vmsg,
                                                ngtcp2_tstamp ts)
{
  int send_stream = 0;
  ngtcp2_ssize spktlen, early_spktlen;
  int was_client_initial;
  size_t datalen;
  size_t early_datalen = 0;
  uint8_t wflags = NGTCP2_WRITE_PKT_FLAG_NONE;
  int ppe_pending = (conn->flags & NGTCP2_CONN_FLAG_PPE_PENDING) != 0;

  (static_cast<bool>(
       !conn->server)
       ? void(0)
       : __assert_fail(
             "!conn->server", "all.cpp", 26567, __extension__ __PRETTY_FUNCTION__));
  if (vmsg && vmsg->type == NGTCP2_VMSG_TYPE_STREAM &&
      !(conn->flags & NGTCP2_CONN_FLAG_EARLY_DATA_REJECTED))
  {
    datalen = ngtcp2_vec_len(vmsg->stream.data, vmsg->stream.datacnt);
    send_stream =
        conn_retry_early_payloadlen(conn) == 0 &&
        (datalen == 0 ||
         (datalen > 0 &&
          (vmsg->stream.strm->tx.max_offset - vmsg->stream.strm->tx.offset) &&
          (conn->tx.max_offset - conn->tx.offset)));
    if (send_stream)
    {
      early_datalen =
          conn_enforce_flow_control(conn, vmsg->stream.strm, datalen) +
          (1 + 8 + 8 + 8);
      if (vmsg->stream.flags & NGTCP2_WRITE_STREAM_FLAG_MORE)
      {
        wflags |= NGTCP2_WRITE_PKT_FLAG_MORE;
      }
    }
    else
    {
      vmsg =
          __null;
    }
  }
  if (!ppe_pending)
  {
    was_client_initial = conn->state == NGTCP2_CS_CLIENT_INITIAL;
    spktlen = conn_write_handshake(conn, pi, dest, destlen, early_datalen, ts);
    if (spktlen < 0)
    {
      return spktlen;
    }
    if (conn->pktns.crypto.tx.ckm || !conn->early.ckm || !send_stream)
    {
      return spktlen;
    }
  }
  else
  {

    (static_cast<bool>(
         !conn->pktns.crypto.tx.ckm)
         ? void(0)
         : __assert_fail(
               "!conn->pktns.crypto.tx.ckm", "all.cpp", 26608, __extension__ __PRETTY_FUNCTION__));

    (static_cast<bool>(
         conn->early.ckm)
         ? void(0)
         : __assert_fail(
               "conn->early.ckm", "all.cpp", 26609, __extension__ __PRETTY_FUNCTION__));
    was_client_initial = conn->pkt.was_client_initial;
    spktlen = conn->pkt.hs_spktlen;
  }
  if (spktlen && was_client_initial)
  {
    wflags |= NGTCP2_WRITE_PKT_FLAG_REQUIRE_PADDING;
  }
  dest += spktlen;
  destlen -= (size_t)spktlen;
  if (conn_cwnd_is_zero(conn))
  {
    return spktlen;
  }
  early_spktlen = conn_write_pkt(conn, pi, dest, destlen, vmsg, NGTCP2_PKT_0RTT,
                                 wflags, ts);
  if (early_spktlen < 0)
  {
    switch (early_spktlen)
    {
    case NGTCP2_ERR_STREAM_DATA_BLOCKED:
      return spktlen;
    case NGTCP2_ERR_WRITE_MORE:
      conn->pkt.was_client_initial = was_client_initial;
      conn->pkt.hs_spktlen = spktlen;
      break;
    }
    return early_spktlen;
  }
  conn->cstat.bytes_sent += (size_t)early_spktlen;
  return spktlen + early_spktlen;
}
void ngtcp2_conn_handshake_completed(ngtcp2_conn *conn)
{
  conn->flags |= NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED;
  if (conn->server)
  {
    conn->flags |= NGTCP2_CONN_FLAG_HANDSHAKE_CONFIRMED;
  }
}
int ngtcp2_conn_get_handshake_completed(ngtcp2_conn *conn)
{
  return (conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED) &&
         (conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED_HANDLED);
}
int ngtcp2_conn_sched_ack(ngtcp2_conn *conn, ngtcp2_acktr *acktr,
                          int64_t pkt_num, int active_ack, ngtcp2_tstamp ts)
{
  int rv;
  (void)conn;
  rv = ngtcp2_acktr_add(acktr, pkt_num, active_ack, ts);
  if (rv != 0)
  {

    (static_cast<bool>(
         rv != NGTCP2_ERR_INVALID_ARGUMENT)
         ? void(0)
         : __assert_fail(
               "rv != NGTCP2_ERR_INVALID_ARGUMENT", "all.cpp", 26665, __extension__ __PRETTY_FUNCTION__));
    return rv;
  }
  return 0;
}
int ngtcp2_accept(ngtcp2_pkt_hd *dest, const uint8_t *pkt, size_t pktlen)
{
  ngtcp2_ssize nread;
  ngtcp2_pkt_hd hd, *p;
  if (dest)
  {
    p = dest;
  }
  else
  {
    p = &hd;
  }
  if (pktlen == 0 || (pkt[0] & 0x80) == 0)
  {
    return -1;
  }
  nread = ngtcp2_pkt_decode_hd_long(p, pkt, pktlen);
  if (nread < 0)
  {
    return -1;
  }
  switch (p->type)
  {
  case NGTCP2_PKT_INITIAL:
    if (pktlen < 1200)
    {
      return -1;
    }
    if (p->token.len == 0 && p->dcid.datalen < 8)
    {
      return -1;
    }
    break;
  case NGTCP2_PKT_0RTT:
    break;
  default:
    return -1;
  }
  if (p->version < 0xff00001du || 0xff000020u < p->version)
  {
    return 1;
  }
  return 0;
}
void ngtcp2_conn_set_aead_overhead(ngtcp2_conn *conn, size_t aead_overhead)
{
  conn->crypto.aead_overhead = aead_overhead;
}
size_t ngtcp2_conn_get_aead_overhead(ngtcp2_conn *conn)
{
  return conn->crypto.aead_overhead;
}
int ngtcp2_conn_install_initial_key(
    ngtcp2_conn *conn, const ngtcp2_crypto_aead_ctx *rx_aead_ctx,
    const uint8_t *rx_iv, const ngtcp2_crypto_cipher_ctx *rx_hp_ctx,
    const ngtcp2_crypto_aead_ctx *tx_aead_ctx, const uint8_t *tx_iv,
    const ngtcp2_crypto_cipher_ctx *tx_hp_ctx, size_t ivlen)
{
  ngtcp2_pktns *pktns = conn->in_pktns;
  int rv;

  (static_cast<bool>(
       pktns)
       ? void(0)
       : __assert_fail(
             "pktns", "all.cpp", 26734, __extension__ __PRETTY_FUNCTION__));
  conn_call_delete_crypto_cipher_ctx(conn, &pktns->crypto.rx.hp_ctx);
  pktns->crypto.rx.hp_ctx.native_handle =
      __null;
  if (pktns->crypto.rx.ckm)
  {
    conn_call_delete_crypto_aead_ctx(conn, &pktns->crypto.rx.ckm->aead_ctx);
    ngtcp2_crypto_km_del(pktns->crypto.rx.ckm, conn->mem);
    pktns->crypto.rx.ckm =
        __null;
  }
  conn_call_delete_crypto_cipher_ctx(conn, &pktns->crypto.tx.hp_ctx);
  pktns->crypto.tx.hp_ctx.native_handle =
      __null;
  if (pktns->crypto.tx.ckm)
  {
    conn_call_delete_crypto_aead_ctx(conn, &pktns->crypto.tx.ckm->aead_ctx);
    ngtcp2_crypto_km_del(pktns->crypto.tx.ckm, conn->mem);
    pktns->crypto.tx.ckm =
        __null;
  }
  rv = ngtcp2_crypto_km_new(&pktns->crypto.rx.ckm,
                            __null, 0,
                            __null, rx_iv, ivlen,
                            conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  rv = ngtcp2_crypto_km_new(&pktns->crypto.tx.ckm,
                            __null, 0,
                            __null, tx_iv, ivlen,
                            conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  pktns->crypto.rx.ckm->aead_ctx = *rx_aead_ctx;
  pktns->crypto.rx.hp_ctx = *rx_hp_ctx;
  pktns->crypto.tx.ckm->aead_ctx = *tx_aead_ctx;
  pktns->crypto.tx.hp_ctx = *tx_hp_ctx;
  return 0;
}
int ngtcp2_conn_install_rx_handshake_key(
    ngtcp2_conn *conn, const ngtcp2_crypto_aead_ctx *aead_ctx,
    const uint8_t *iv, size_t ivlen, const ngtcp2_crypto_cipher_ctx *hp_ctx)
{
  ngtcp2_pktns *pktns = conn->hs_pktns;
  int rv;

  (static_cast<bool>(
       pktns)
       ? void(0)
       : __assert_fail(
             "pktns", "all.cpp", 26776, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       !pktns->crypto.rx.hp_ctx.native_handle)
       ? void(0)
       : __assert_fail(
             "!pktns->crypto.rx.hp_ctx.native_handle", "all.cpp", 26777, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       !pktns->crypto.rx.ckm)
       ? void(0)
       : __assert_fail(
             "!pktns->crypto.rx.ckm", "all.cpp", 26778, __extension__ __PRETTY_FUNCTION__));
  rv = ngtcp2_crypto_km_new(&pktns->crypto.rx.ckm,
                            __null, 0, aead_ctx, iv, ivlen,
                            conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  pktns->crypto.rx.hp_ctx = *hp_ctx;
  return 0;
}
int ngtcp2_conn_install_tx_handshake_key(
    ngtcp2_conn *conn, const ngtcp2_crypto_aead_ctx *aead_ctx,
    const uint8_t *iv, size_t ivlen, const ngtcp2_crypto_cipher_ctx *hp_ctx)
{
  ngtcp2_pktns *pktns = conn->hs_pktns;
  int rv;

  (static_cast<bool>(
       pktns)
       ? void(0)
       : __assert_fail(
             "pktns", "all.cpp", 26795, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       !pktns->crypto.tx.hp_ctx.native_handle)
       ? void(0)
       : __assert_fail(
             "!pktns->crypto.tx.hp_ctx.native_handle", "all.cpp", 26796, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       !pktns->crypto.tx.ckm)
       ? void(0)
       : __assert_fail(
             "!pktns->crypto.tx.ckm", "all.cpp", 26797, __extension__ __PRETTY_FUNCTION__));
  rv = ngtcp2_crypto_km_new(&pktns->crypto.tx.ckm,
                            __null, 0, aead_ctx, iv, ivlen,
                            conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  pktns->crypto.tx.hp_ctx = *hp_ctx;
  if (conn->server)
  {
    return ngtcp2_conn_commit_local_transport_params(conn);
  }
  return 0;
}
int ngtcp2_conn_install_early_key(ngtcp2_conn *conn,
                                  const ngtcp2_crypto_aead_ctx *aead_ctx,
                                  const uint8_t *iv, size_t ivlen,
                                  const ngtcp2_crypto_cipher_ctx *hp_ctx)
{
  int rv;

  (static_cast<bool>(
       !conn->early.hp_ctx.native_handle)
       ? void(0)
       : __assert_fail(
             "!conn->early.hp_ctx.native_handle", "all.cpp", 26818, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       !conn->early.ckm)
       ? void(0)
       : __assert_fail(
             "!conn->early.ckm", "all.cpp", 26819, __extension__ __PRETTY_FUNCTION__));
  rv = ngtcp2_crypto_km_new(&conn->early.ckm,
                            __null, 0, aead_ctx, iv, ivlen,
                            conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  conn->early.hp_ctx = *hp_ctx;
  return 0;
}
int ngtcp2_conn_install_rx_key(ngtcp2_conn *conn, const uint8_t *secret,
                               size_t secretlen,
                               const ngtcp2_crypto_aead_ctx *aead_ctx,
                               const uint8_t *iv, size_t ivlen,
                               const ngtcp2_crypto_cipher_ctx *hp_ctx)
{
  ngtcp2_pktns *pktns = &conn->pktns;
  int rv;

  (static_cast<bool>(
       !pktns->crypto.rx.hp_ctx.native_handle)
       ? void(0)
       : __assert_fail(
             "!pktns->crypto.rx.hp_ctx.native_handle", "all.cpp", 26838, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       !pktns->crypto.rx.ckm)
       ? void(0)
       : __assert_fail(
             "!pktns->crypto.rx.ckm", "all.cpp", 26839, __extension__ __PRETTY_FUNCTION__));
  rv = ngtcp2_crypto_km_new(&pktns->crypto.rx.ckm, secret, secretlen, aead_ctx,
                            iv, ivlen, conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  pktns->crypto.rx.hp_ctx = *hp_ctx;
  return 0;
}
int ngtcp2_conn_install_tx_key(ngtcp2_conn *conn, const uint8_t *secret,
                               size_t secretlen,
                               const ngtcp2_crypto_aead_ctx *aead_ctx,
                               const uint8_t *iv, size_t ivlen,
                               const ngtcp2_crypto_cipher_ctx *hp_ctx)
{
  ngtcp2_pktns *pktns = &conn->pktns;
  int rv;

  (static_cast<bool>(
       !pktns->crypto.tx.hp_ctx.native_handle)
       ? void(0)
       : __assert_fail(
             "!pktns->crypto.tx.hp_ctx.native_handle", "all.cpp", 26858, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       !pktns->crypto.tx.ckm)
       ? void(0)
       : __assert_fail(
             "!pktns->crypto.tx.ckm", "all.cpp", 26859, __extension__ __PRETTY_FUNCTION__));
  rv = ngtcp2_crypto_km_new(&pktns->crypto.tx.ckm, secret, secretlen, aead_ctx,
                            iv, ivlen, conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  pktns->crypto.tx.hp_ctx = *hp_ctx;
  conn->remote.transport_params = conn->remote.pending_transport_params;
  conn_sync_stream_id_limit(conn);
  conn->tx.max_offset = conn->remote.transport_params.initial_max_data;
  return 0;
}
int ngtcp2_conn_initiate_key_update(ngtcp2_conn *conn, ngtcp2_tstamp ts)
{
  ngtcp2_tstamp confirmed_ts = conn->crypto.key_update.confirmed_ts;
  ngtcp2_duration pto = conn_compute_pto(conn, &conn->pktns);

  (static_cast<bool>(
       conn->state == NGTCP2_CS_POST_HANDSHAKE)
       ? void(0)
       : __assert_fail(
             "conn->state == NGTCP2_CS_POST_HANDSHAKE", "all.cpp", 26877, __extension__ __PRETTY_FUNCTION__));
  if (!(conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_CONFIRMED) ||
      (conn->flags & NGTCP2_CONN_FLAG_KEY_UPDATE_NOT_CONFIRMED) ||
      !conn->crypto.key_update.new_tx_ckm ||
      !conn->crypto.key_update.new_rx_ckm ||
      (confirmed_ts !=
           (18446744073709551615UL) &&
       confirmed_ts + 3 * pto > ts))
  {
    return NGTCP2_ERR_INVALID_STATE;
  }
  conn_rotate_keys(conn, ((int64_t)((1ll << 62) - 1)));
  return 0;
}
ngtcp2_tstamp ngtcp2_conn_loss_detection_expiry(ngtcp2_conn *conn)
{
  if (conn->cstat.loss_detection_timer)
  {
    return conn->cstat.loss_detection_timer;
  }
  return (18446744073709551615UL);
}
ngtcp2_tstamp ngtcp2_conn_internal_expiry(ngtcp2_conn *conn)
{
  ngtcp2_tstamp res =
      (18446744073709551615UL);
  ngtcp2_duration pto = conn_compute_pto(conn, &conn->pktns);
  ngtcp2_scid *scid;
  ngtcp2_dcid *dcid;
  if (conn->pv)
  {
    res = ngtcp2_pv_next_expiry(conn->pv);
  }
  if (!ngtcp2_pq_empty(&conn->scid.used))
  {
    scid = ((ngtcp2_scid *)(void *)((char *)(ngtcp2_pq_top(&conn->scid.used)) -
                                    __builtin_offsetof(
                                        ngtcp2_scid,
                                        pe)));
    if (scid->ts_retired !=
        (18446744073709551615UL))
    {
      res = ((res) < (scid->ts_retired + pto) ? (res) : (scid->ts_retired + pto));
    }
  }
  if (((&conn->dcid.retired)->len))
  {
    dcid = ngtcp2_ringbuf_get(&conn->dcid.retired, 0);
    res = ((res) < (dcid->ts_retired + pto) ? (res) : (dcid->ts_retired + pto));
  }
  return res;
}
ngtcp2_tstamp ngtcp2_conn_ack_delay_expiry(ngtcp2_conn *conn)
{
  ngtcp2_acktr *acktr = &conn->pktns.acktr;
  if (!(acktr->flags & NGTCP2_ACKTR_FLAG_CANCEL_TIMER) &&
      acktr->first_unacked_ts !=
          (18446744073709551615UL))
  {
    return acktr->first_unacked_ts + conn_compute_ack_delay(conn);
  }
  return (18446744073709551615UL);
}
ngtcp2_tstamp ngtcp2_conn_get_expiry(ngtcp2_conn *conn)
{
  ngtcp2_tstamp t1 = ngtcp2_conn_loss_detection_expiry(conn);
  ngtcp2_tstamp t2 = ngtcp2_conn_ack_delay_expiry(conn);
  ngtcp2_tstamp t3 = ngtcp2_conn_internal_expiry(conn);
  ngtcp2_tstamp t4 = ngtcp2_conn_lost_pkt_expiry(conn);
  ngtcp2_tstamp res = ((t1) < (t2) ? (t1) : (t2));
  res = ((res) < (t3) ? (res) : (t3));
  return ((res) < (t4) ? (res) : (t4));
}
int ngtcp2_conn_handle_expiry(ngtcp2_conn *conn, ngtcp2_tstamp ts)
{
  int rv;
  ngtcp2_conn_cancel_expired_ack_delay_timer(conn, ts);
  ngtcp2_conn_remove_lost_pkt(conn, ts);
  if (conn->pv)
  {
    ngtcp2_pv_cancel_expired_timer(conn->pv, ts);
  }
  if (ngtcp2_conn_loss_detection_expiry(conn) <= ts)
  {
    rv = ngtcp2_conn_on_loss_detection_timer(conn, ts);
    if (rv != 0)
    {
      return rv;
    }
  }
  return 0;
}
static void acktr_cancel_expired_ack_delay_timer(ngtcp2_acktr *acktr,
                                                 ngtcp2_tstamp ts)
{
  if (!(acktr->flags & NGTCP2_ACKTR_FLAG_CANCEL_TIMER) &&
      acktr->first_unacked_ts <= ts)
  {
    acktr->flags |= NGTCP2_ACKTR_FLAG_CANCEL_TIMER;
  }
}
void ngtcp2_conn_cancel_expired_ack_delay_timer(ngtcp2_conn *conn,
                                                ngtcp2_tstamp ts)
{
  if (conn->in_pktns)
  {
    acktr_cancel_expired_ack_delay_timer(&conn->in_pktns->acktr, ts);
  }
  if (conn->hs_pktns)
  {
    acktr_cancel_expired_ack_delay_timer(&conn->hs_pktns->acktr, ts);
  }
  acktr_cancel_expired_ack_delay_timer(&conn->pktns.acktr, ts);
}
ngtcp2_tstamp ngtcp2_conn_lost_pkt_expiry(ngtcp2_conn *conn)
{
  ngtcp2_tstamp res =
                    (18446744073709551615UL),
                ts;
  if (conn->in_pktns)
  {
    ts = ngtcp2_rtb_lost_pkt_ts(&conn->in_pktns->rtb);
    if (ts !=
        (18446744073709551615UL))
    {
      ts += conn_compute_pto(conn, conn->in_pktns);
      res = ((res) < (ts) ? (res) : (ts));
    }
  }
  if (conn->hs_pktns)
  {
    ts = ngtcp2_rtb_lost_pkt_ts(&conn->hs_pktns->rtb);
    if (ts !=
        (18446744073709551615UL))
    {
      ts += conn_compute_pto(conn, conn->hs_pktns);
      res = ((res) < (ts) ? (res) : (ts));
    }
  }
  ts = ngtcp2_rtb_lost_pkt_ts(&conn->pktns.rtb);
  if (ts !=
      (18446744073709551615UL))
  {
    ts += conn_compute_pto(conn, &conn->pktns);
    res = ((res) < (ts) ? (res) : (ts));
  }
  return res;
}
void ngtcp2_conn_remove_lost_pkt(ngtcp2_conn *conn, ngtcp2_tstamp ts)
{
  ngtcp2_tstamp pto;
  if (conn->in_pktns)
  {
    pto = conn_compute_pto(conn, conn->in_pktns);
    ngtcp2_rtb_remove_expired_lost_pkt(&conn->in_pktns->rtb, pto, ts);
  }
  if (conn->hs_pktns)
  {
    pto = conn_compute_pto(conn, conn->hs_pktns);
    ngtcp2_rtb_remove_expired_lost_pkt(&conn->hs_pktns->rtb, pto, ts);
  }
  pto = conn_compute_pto(conn, &conn->pktns);
  ngtcp2_rtb_remove_expired_lost_pkt(&conn->pktns.rtb, pto, ts);
}
static int
conn_client_validate_transport_params(ngtcp2_conn *conn,
                                      const ngtcp2_transport_params *params)
{
  if (!ngtcp2_cid_eq(&conn->rcid, &params->original_dcid))
  {
    return NGTCP2_ERR_TRANSPORT_PARAM;
  }
  if (conn->flags & NGTCP2_CONN_FLAG_RECV_RETRY)
  {
    if (!params->retry_scid_present)
    {
      return NGTCP2_ERR_TRANSPORT_PARAM;
    }
    if (!ngtcp2_cid_eq(&conn->retry_scid, &params->retry_scid))
    {
      return NGTCP2_ERR_TRANSPORT_PARAM;
    }
  }
  else if (params->retry_scid_present)
  {
    return NGTCP2_ERR_TRANSPORT_PARAM;
  }
  if (params->preferred_address_present &&
      conn->dcid.current.cid.datalen == 0)
  {
    return NGTCP2_ERR_TRANSPORT_PARAM;
  }
  return 0;
}
int ngtcp2_conn_set_remote_transport_params(
    ngtcp2_conn *conn, const ngtcp2_transport_params *params)
{
  int rv;

  (static_cast<bool>(
       !(conn->flags & NGTCP2_CONN_FLAG_TRANSPORT_PARAM_RECVED))
       ? void(0)
       : __assert_fail(
             "!(conn->flags & NGTCP2_CONN_FLAG_TRANSPORT_PARAM_RECVED)", "all.cpp", 27073, __extension__ __PRETTY_FUNCTION__));
  if (params->active_connection_id_limit <
      2)
  {
    return NGTCP2_ERR_TRANSPORT_PARAM;
  }
  if (!ngtcp2_cid_eq(&conn->dcid.current.cid, &params->initial_scid))
  {
    return NGTCP2_ERR_TRANSPORT_PARAM;
  }
  if (!conn->server)
  {
    rv = conn_client_validate_transport_params(conn, params);
    if (rv != 0)
    {
      return rv;
    }
  }
  ngtcp2_log_remote_tp(&conn->log,
                       conn->server
                           ? NGTCP2_TRANSPORT_PARAMS_TYPE_CLIENT_HELLO
                           : NGTCP2_TRANSPORT_PARAMS_TYPE_ENCRYPTED_EXTENSIONS,
                       params);
  ngtcp2_qlog_parameters_set_transport_params(&conn->qlog, params, conn->server,
                                              NGTCP2_QLOG_SIDE_REMOTE);
  if (conn->pktns.crypto.tx.ckm)
  {
    conn->remote.transport_params = *params;
    conn_sync_stream_id_limit(conn);
    conn->tx.max_offset = conn->remote.transport_params.initial_max_data;
  }
  else
  {
    conn->remote.pending_transport_params = *params;
  }
  conn->flags |= NGTCP2_CONN_FLAG_TRANSPORT_PARAM_RECVED;
  return 0;
}
void ngtcp2_conn_get_remote_transport_params(ngtcp2_conn *conn,
                                             ngtcp2_transport_params *params)
{
  if (conn->pktns.crypto.rx.ckm)
  {
    *params = conn->remote.transport_params;
  }
  else
  {
    *params = conn->remote.pending_transport_params;
  }
}
void ngtcp2_conn_set_early_remote_transport_params(
    ngtcp2_conn *conn, const ngtcp2_transport_params *params)
{
  ngtcp2_transport_params *p = &conn->remote.transport_params;

  (static_cast<bool>(
       !conn->server)
       ? void(0)
       : __assert_fail(
             "!conn->server", "all.cpp", 27129, __extension__ __PRETTY_FUNCTION__));
  memset(p, 0, sizeof(*p));
  p->initial_max_streams_bidi = params->initial_max_streams_bidi;
  p->initial_max_streams_uni = params->initial_max_streams_uni;
  p->initial_max_stream_data_bidi_local =
      params->initial_max_stream_data_bidi_local;
  p->initial_max_stream_data_bidi_remote =
      params->initial_max_stream_data_bidi_remote;
  p->initial_max_stream_data_uni = params->initial_max_stream_data_uni;
  p->initial_max_data = params->initial_max_data;
  conn_sync_stream_id_limit(conn);
  conn->tx.max_offset = p->initial_max_data;
  ngtcp2_qlog_parameters_set_transport_params(&conn->qlog, p, conn->server,
                                              NGTCP2_QLOG_SIDE_REMOTE);
}
int ngtcp2_conn_set_local_transport_params(
    ngtcp2_conn *conn, const ngtcp2_transport_params *params)
{

  (static_cast<bool>(
       conn->server)
       ? void(0)
       : __assert_fail(
             "conn->server", "all.cpp", 27148, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       params->active_connection_id_limit <= 8)
       ? void(0)
       : __assert_fail(
             "params->active_connection_id_limit <= NGTCP2_MAX_DCID_POOL_SIZE", "all.cpp", 27149, __extension__ __PRETTY_FUNCTION__));
  if (conn->hs_pktns ==
          __null ||
      conn->hs_pktns->crypto.tx.ckm)
  {
    return NGTCP2_ERR_INVALID_STATE;
  }
  conn->local.settings.transport_params = *params;
  return 0;
}
int ngtcp2_conn_commit_local_transport_params(ngtcp2_conn *conn)
{
  const ngtcp2_mem *mem = conn->mem;
  ngtcp2_transport_params *params = &conn->local.settings.transport_params;
  ngtcp2_scid *scident;
  ngtcp2_ksl_it it;
  int rv;

  (static_cast<bool>(1 == ngtcp2_ksl_len(&conn->scid.set)) ? void(0) : __assert_fail("1 == ngtcp2_ksl_len(&conn->scid.set)", "all.cpp", 27165, __extension__ __PRETTY_FUNCTION__));
  if (params->active_connection_id_limit == 0)
  {
    params->active_connection_id_limit =
        2;
  }
  params->initial_scid = conn->oscid;
  if (conn->oscid.datalen == 0)
  {
    params->preferred_address_present = 0;
  }
  if (conn->server)
  {
    if (params->stateless_reset_token_present)
    {
      it = ngtcp2_ksl_begin(&conn->scid.set);
      scident = ngtcp2_ksl_it_get(&it);
      memcpy(scident->token, params->stateless_reset_token,
             16);
    }
    if (params->preferred_address_present)
    {
      scident = ngtcp2_mem_malloc(mem, sizeof(*scident));
      if (scident == __null)
      {
        return NGTCP2_ERR_NOMEM;
      }
      ngtcp2_scid_init(scident, 1, &params->preferred_address.cid,
                       params->preferred_address.stateless_reset_token);
      rv = ngtcp2_ksl_insert(&conn->scid.set, __null, &scident->cid, scident);
      if (rv != 0)
      {
        ngtcp2_mem_free(mem, scident);
        return rv;
      }
      conn->scid.last_seq = 1;
    }
  }
  conn->rx.window = conn->rx.unsent_max_offset = conn->rx.max_offset =
      params->initial_max_data;
  conn->remote.bidi.unsent_max_streams = params->initial_max_streams_bidi;
  conn->remote.bidi.max_streams = params->initial_max_streams_bidi;
  conn->remote.uni.unsent_max_streams = params->initial_max_streams_uni;
  conn->remote.uni.max_streams = params->initial_max_streams_uni;
  ngtcp2_qlog_parameters_set_transport_params(&conn->qlog, params, conn->server,
                                              NGTCP2_QLOG_SIDE_LOCAL);
  return 0;
}
void ngtcp2_conn_get_local_transport_params(ngtcp2_conn *conn,
                                            ngtcp2_transport_params *params)
{
  *params = conn->local.settings.transport_params;
}
int ngtcp2_conn_open_bidi_stream(ngtcp2_conn *conn, int64_t *pstream_id,
                                 void *stream_user_data)
{
  int rv;
  ngtcp2_strm *strm;
  if (ngtcp2_conn_get_streams_bidi_left(conn) == 0)
  {
    return NGTCP2_ERR_STREAM_ID_BLOCKED;
  }
  strm = ngtcp2_mem_malloc(conn->mem, sizeof(ngtcp2_strm));
  if (strm == __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  rv = ngtcp2_conn_init_stream(conn, strm, conn->local.bidi.next_stream_id,
                               stream_user_data);
  if (rv != 0)
  {
    ngtcp2_mem_free(conn->mem, strm);
    return rv;
  }
  *pstream_id = conn->local.bidi.next_stream_id;
  conn->local.bidi.next_stream_id += 4;
  return 0;
}
int ngtcp2_conn_open_uni_stream(ngtcp2_conn *conn, int64_t *pstream_id,
                                void *stream_user_data)
{
  int rv;
  ngtcp2_strm *strm;
  if (ngtcp2_conn_get_streams_uni_left(conn) == 0)
  {
    return NGTCP2_ERR_STREAM_ID_BLOCKED;
  }
  strm = ngtcp2_mem_malloc(conn->mem, sizeof(ngtcp2_strm));
  if (strm == __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  rv = ngtcp2_conn_init_stream(conn, strm, conn->local.uni.next_stream_id,
                               stream_user_data);
  if (rv != 0)
  {
    ngtcp2_mem_free(conn->mem, strm);
    return rv;
  }
  ngtcp2_strm_shutdown(strm, NGTCP2_STRM_FLAG_SHUT_RD);
  *pstream_id = conn->local.uni.next_stream_id;
  conn->local.uni.next_stream_id += 4;
  return 0;
}
ngtcp2_strm *ngtcp2_conn_find_stream(ngtcp2_conn *conn, int64_t stream_id)
{
  ngtcp2_map_entry *me;
  me = ngtcp2_map_find(&conn->strms, (uint64_t)stream_id);
  if (me == __null)
  {
    return __null;
  }
  return ((ngtcp2_strm *)(void *)((char *)(me) - __builtin_offsetof(ngtcp2_strm, me)));
}
ngtcp2_ssize ngtcp2_conn_write_stream(ngtcp2_conn *conn, ngtcp2_path *path,
                                      ngtcp2_pkt_info *pi, uint8_t *dest,
                                      size_t destlen, ngtcp2_ssize *pdatalen,
                                      uint32_t flags, int64_t stream_id,
                                      const uint8_t *data, size_t datalen,
                                      ngtcp2_tstamp ts)
{
  ngtcp2_vec datav;
  datav.len = datalen;
  datav.base = (uint8_t *)data;
  return ngtcp2_conn_writev_stream(conn, path, pi, dest, destlen, pdatalen,
                                   flags, stream_id, &datav, 1, ts);
}
ngtcp2_ssize ngtcp2_conn_writev_stream(ngtcp2_conn *conn, ngtcp2_path *path,
                                       ngtcp2_pkt_info *pi, uint8_t *dest,
                                       size_t destlen, ngtcp2_ssize *pdatalen,
                                       uint32_t flags, int64_t stream_id,
                                       const ngtcp2_vec *datav, size_t datavcnt,
                                       ngtcp2_tstamp ts)
{
  ngtcp2_vmsg vmsg, *pvmsg;
  ngtcp2_strm *strm;
  if (pdatalen)
  {
    *pdatalen = -1;
  }
  if (stream_id != -1)
  {
    strm = ngtcp2_conn_find_stream(conn, stream_id);
    if (strm ==
        __null)
    {
      return NGTCP2_ERR_STREAM_NOT_FOUND;
    }
    if (strm->flags & NGTCP2_STRM_FLAG_SHUT_WR)
    {
      return NGTCP2_ERR_STREAM_SHUT_WR;
    }
    vmsg.type = NGTCP2_VMSG_TYPE_STREAM;
    vmsg.stream.strm = strm;
    vmsg.stream.flags = flags;
    vmsg.stream.data = datav;
    vmsg.stream.datacnt = datavcnt;
    vmsg.stream.pdatalen = pdatalen;
    pvmsg = &vmsg;
  }
  else
  {
    pvmsg =
        __null;
  }
  return ngtcp2_conn_write_vmsg(conn, path, pi, dest, destlen, pvmsg, ts);
}
ngtcp2_ssize ngtcp2_conn_write_vmsg(ngtcp2_conn *conn, ngtcp2_path *path,
                                    ngtcp2_pkt_info *pi, uint8_t *dest,
                                    size_t destlen, ngtcp2_vmsg *vmsg,
                                    ngtcp2_tstamp ts)
{
  ngtcp2_ssize nwrite;
  ngtcp2_pktns *pktns = &conn->pktns;
  size_t origlen = destlen;
  int rv;
  uint8_t wflags = NGTCP2_WRITE_PKT_FLAG_NONE;
  int ppe_pending = (conn->flags & NGTCP2_CONN_FLAG_PPE_PENDING) != 0;
  ngtcp2_ssize res = 0;
  size_t server_hs_tx_left;
  conn->log.last_ts = ts;
  conn->qlog.last_ts = ts;
  if (path)
  {
    ngtcp2_path_copy(path, &conn->dcid.current.ps.path);
  }
  if (!ppe_pending && pi)
  {
    pi->ecn = NGTCP2_ECN_NOT_ECT;
  }
  switch (conn->state)
  {
  case NGTCP2_CS_CLIENT_INITIAL:
  case NGTCP2_CS_CLIENT_WAIT_HANDSHAKE:
  case NGTCP2_CS_CLIENT_TLS_HANDSHAKE_FAILED:
    nwrite = conn_client_write_handshake(conn, pi, dest, destlen, vmsg, ts);
    if (nwrite < 0)
    {
      return nwrite;
    }
    if (conn->state != NGTCP2_CS_POST_HANDSHAKE)
    {
      return nwrite;
    }
    res = nwrite;
    dest += nwrite;
    destlen -= (size_t)nwrite;
    break;
  case NGTCP2_CS_SERVER_INITIAL:
  case NGTCP2_CS_SERVER_WAIT_HANDSHAKE:
  case NGTCP2_CS_SERVER_TLS_HANDSHAKE_FAILED:
    if (!ppe_pending)
    {
      server_hs_tx_left = conn_server_hs_tx_left(conn);
      destlen = ((destlen) < (server_hs_tx_left) ? (destlen) : (server_hs_tx_left));
      nwrite = conn_write_handshake(conn, pi, dest, destlen, 0, ts);
      if (nwrite < 0)
      {
        return nwrite;
      }
      if (conn->flags & NGTCP2_CONN_FLAG_SADDR_VERIFIED)
      {
        destlen = origlen;
      }
      else
      {
        origlen = destlen;
      }
      res = nwrite;
      dest += nwrite;
      destlen -= (size_t)nwrite;
    }
    if (conn->state != NGTCP2_CS_POST_HANDSHAKE &&
        conn->pktns.crypto.tx.ckm == __null)
    {
      return res;
    }
    break;
  case NGTCP2_CS_POST_HANDSHAKE:
    break;
  case NGTCP2_CS_CLOSING:
    return NGTCP2_ERR_CLOSING;
  case NGTCP2_CS_DRAINING:
    return NGTCP2_ERR_DRAINING;
  default:
    return 0;
  }

  (static_cast<bool>(
       pktns->crypto.tx.ckm)
       ? void(0)
       : __assert_fail(
             "pktns->crypto.tx.ckm", "all.cpp", 27417, __extension__ __PRETTY_FUNCTION__));
  if (conn_check_pkt_num_exhausted(conn))
  {
    return NGTCP2_ERR_PKT_NUM_EXHAUSTED;
  }
  rv = conn_remove_retired_connection_id(conn, ts);
  if (rv != 0)
  {
    return rv;
  }
  if (vmsg)
  {
    switch (vmsg->type)
    {
    case NGTCP2_VMSG_TYPE_STREAM:
      if (vmsg->stream.flags & NGTCP2_WRITE_STREAM_FLAG_MORE)
      {
        wflags |= NGTCP2_WRITE_PKT_FLAG_MORE;
      }
      break;
    default:
      break;
    }
  }
  if (ppe_pending)
  {
    res = conn->pkt.hs_spktlen;
    conn->pkt.hs_spktlen = 0;
    nwrite = conn_write_pkt(conn, pi, dest, destlen, vmsg, NGTCP2_PKT_SHORT,
                            wflags, ts);
    goto fin;
  }
  else
  {
    if (conn->state == NGTCP2_CS_POST_HANDSHAKE)
    {
      rv = conn_prepare_key_update(conn, ts);
      if (rv != 0)
      {
        return rv;
      }
    }
    if (!conn->pktns.rtb.probe_pkt_left && conn_cwnd_is_zero(conn))
    {
      destlen = 0;
    }
    else
    {
      nwrite = conn_write_path_response(conn, path, pi, dest, destlen, ts);
      if (nwrite)
      {
        goto fin;
      }
      if (conn->pv)
      {
        nwrite = conn_write_path_challenge(conn, path, pi, dest, destlen, ts);
        if (nwrite)
        {
          goto fin;
        }
      }
    }
  }
  if (res == 0)
  {
    if (conn_handshake_remnants_left(conn))
    {
      if (conn_handshake_probe_left(conn))
      {
        destlen = origlen;
      }
      nwrite = conn_write_handshake_pkts(conn, pi, dest, destlen, 0, ts);
      if (nwrite < 0)
      {
        return nwrite;
      }
      if (nwrite > 0)
      {
        res = nwrite;
        dest += nwrite;
        destlen -= (size_t)nwrite;
      }
    }
  }
  if (conn->pktns.rtb.probe_pkt_left)
  {
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_CON,
                    "transmit probe pkt left=%zu",
                    conn->pktns.rtb.probe_pkt_left);
    nwrite = conn_write_pkt(conn, pi, dest, destlen, vmsg, NGTCP2_PKT_SHORT,
                            wflags, ts);
    goto fin;
  }
  nwrite = conn_write_pkt(conn, pi, dest, destlen, vmsg, NGTCP2_PKT_SHORT,
                          wflags, ts);
  if (nwrite)
  {

    (static_cast<bool>(
         nwrite != NGTCP2_ERR_NOBUF)
         ? void(0)
         : __assert_fail(
               "nwrite != NGTCP2_ERR_NOBUF", "all.cpp", 27514, __extension__ __PRETTY_FUNCTION__));
    goto fin;
  }
  if (res == 0)
  {
    nwrite = conn_write_ack_pkt(conn, pi, dest, origlen, NGTCP2_PKT_SHORT, ts);
  }
fin:
  conn->pkt.hs_spktlen = 0;
  if (nwrite >= 0)
  {
    conn->cstat.bytes_sent += (size_t)nwrite;
    res += nwrite;
    return res;
  }
  if (conn->flags & NGTCP2_CONN_FLAG_PPE_PENDING)
  {
    conn->pkt.hs_spktlen = res;
  }
  return nwrite;
}
static ngtcp2_ssize
conn_write_connection_close(ngtcp2_conn *conn, ngtcp2_pkt_info *pi,
                            uint8_t *dest, size_t destlen, uint8_t pkt_type,
                            uint64_t error_code, ngtcp2_tstamp ts)
{
  ngtcp2_pktns *in_pktns = conn->in_pktns;
  ngtcp2_pktns *hs_pktns = conn->hs_pktns;
  ngtcp2_ssize res = 0, nwrite;
  ngtcp2_frame fr;
  fr.type = NGTCP2_FRAME_CONNECTION_CLOSE;
  fr.connection_close.error_code = error_code;
  fr.connection_close.frame_type = 0;
  fr.connection_close.reasonlen = 0;
  fr.connection_close.reason =
      __null;
  if (!(conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_CONFIRMED) &&
      pkt_type != NGTCP2_PKT_INITIAL)
  {
    if (in_pktns && conn->server)
    {
      nwrite = ngtcp2_conn_write_single_frame_pkt(
          conn, pi, dest, destlen, NGTCP2_PKT_INITIAL, &conn->dcid.current.cid,
          &fr, NGTCP2_RTB_FLAG_NONE,
          __null, ts);
      if (nwrite < 0)
      {
        return nwrite;
      }
      dest += nwrite;
      destlen -= (size_t)nwrite;
      res += nwrite;
    }
    if (pkt_type != NGTCP2_PKT_HANDSHAKE && hs_pktns &&
        hs_pktns->crypto.tx.ckm)
    {
      nwrite = ngtcp2_conn_write_single_frame_pkt(
          conn, pi, dest, destlen, NGTCP2_PKT_HANDSHAKE,
          &conn->dcid.current.cid, &fr, NGTCP2_RTB_FLAG_NONE,
          __null, ts);
      if (nwrite < 0)
      {
        return nwrite;
      }
      dest += nwrite;
      destlen -= (size_t)nwrite;
      res += nwrite;
    }
  }
  nwrite = ngtcp2_conn_write_single_frame_pkt(conn, pi, dest, destlen, pkt_type,
                                              &conn->dcid.current.cid, &fr,
                                              NGTCP2_RTB_FLAG_NONE,
                                              __null, ts);
  if (nwrite < 0)
  {
    return nwrite;
  }
  res += nwrite;
  if (res == 0)
  {
    return NGTCP2_ERR_NOBUF;
  }
  return res;
}
ngtcp2_ssize ngtcp2_conn_write_connection_close(
    ngtcp2_conn *conn, ngtcp2_path *path, ngtcp2_pkt_info *pi, uint8_t *dest,
    size_t destlen, uint64_t error_code, ngtcp2_tstamp ts)
{
  ngtcp2_pktns *in_pktns = conn->in_pktns;
  ngtcp2_pktns *hs_pktns = conn->hs_pktns;
  uint8_t pkt_type;
  ngtcp2_ssize nwrite;
  conn->log.last_ts = ts;
  conn->qlog.last_ts = ts;
  if (conn_check_pkt_num_exhausted(conn))
  {
    return NGTCP2_ERR_PKT_NUM_EXHAUSTED;
  }
  switch (conn->state)
  {
  case NGTCP2_CS_CLIENT_INITIAL:
  case NGTCP2_CS_CLOSING:
  case NGTCP2_CS_DRAINING:
    return NGTCP2_ERR_INVALID_STATE;
  default:
    break;
  }
  if (path)
  {
    ngtcp2_path_copy(path, &conn->dcid.current.ps.path);
  }
  if (pi)
  {
    pi->ecn = NGTCP2_ECN_NOT_ECT;
  }
  if (conn->state == NGTCP2_CS_POST_HANDSHAKE ||
      (conn->server && conn->pktns.crypto.tx.ckm))
  {
    pkt_type = NGTCP2_PKT_SHORT;
  }
  else if (hs_pktns && hs_pktns->crypto.tx.ckm)
  {
    pkt_type = NGTCP2_PKT_HANDSHAKE;
  }
  else if (in_pktns && in_pktns->crypto.tx.ckm)
  {
    pkt_type = NGTCP2_PKT_INITIAL;
  }
  else
  {
    return NGTCP2_ERR_INVALID_STATE;
  }
  nwrite = conn_write_connection_close(conn, pi, dest, destlen, pkt_type,
                                       error_code, ts);
  if (nwrite < 0)
  {
    return nwrite;
  }
  conn->state = NGTCP2_CS_CLOSING;
  return nwrite;
}
ngtcp2_ssize ngtcp2_conn_write_application_close(
    ngtcp2_conn *conn, ngtcp2_path *path, ngtcp2_pkt_info *pi, uint8_t *dest,
    size_t destlen, uint64_t app_error_code, ngtcp2_tstamp ts)
{
  ngtcp2_ssize nwrite;
  ngtcp2_ssize res = 0;
  ngtcp2_frame fr;
  conn->log.last_ts = ts;
  conn->qlog.last_ts = ts;
  if (conn_check_pkt_num_exhausted(conn))
  {
    return NGTCP2_ERR_PKT_NUM_EXHAUSTED;
  }
  switch (conn->state)
  {
  case NGTCP2_CS_CLIENT_INITIAL:
  case NGTCP2_CS_CLOSING:
  case NGTCP2_CS_DRAINING:
    return NGTCP2_ERR_INVALID_STATE;
  default:
    break;
  }
  if (path)
  {
    ngtcp2_path_copy(path, &conn->dcid.current.ps.path);
  }
  if (pi)
  {
    pi->ecn = NGTCP2_ECN_NOT_ECT;
  }
  if (!(conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_CONFIRMED))
  {
    nwrite = conn_write_connection_close(conn, pi, dest, destlen,
                                         conn->hs_pktns->crypto.tx.ckm
                                             ? NGTCP2_PKT_HANDSHAKE
                                             : NGTCP2_PKT_INITIAL,
                                         0xcu, ts);
    if (nwrite < 0)
    {
      return nwrite;
    }
    res = nwrite;
    dest += nwrite;
    destlen -= (size_t)nwrite;
  }
  if (conn->state != NGTCP2_CS_POST_HANDSHAKE)
  {

    (static_cast<bool>(
         res)
         ? void(0)
         : __assert_fail(
               "res", "all.cpp", 27702, __extension__ __PRETTY_FUNCTION__));
    if (!conn->server || !conn->pktns.crypto.tx.ckm)
    {
      return res;
    }
  }

  (static_cast<bool>(
       conn->pktns.crypto.tx.ckm)
       ? void(0)
       : __assert_fail(
             "conn->pktns.crypto.tx.ckm", "all.cpp", 27708, __extension__ __PRETTY_FUNCTION__));
  fr.type = NGTCP2_FRAME_CONNECTION_CLOSE_APP;
  fr.connection_close.error_code = app_error_code;
  fr.connection_close.frame_type = 0;
  fr.connection_close.reasonlen = 0;
  fr.connection_close.reason =
      __null;
  nwrite = ngtcp2_conn_write_single_frame_pkt(
      conn, pi, dest, destlen, NGTCP2_PKT_SHORT, &conn->dcid.current.cid, &fr,
      NGTCP2_RTB_FLAG_NONE,
      __null, ts);
  if (nwrite < 0)
  {
    return nwrite;
  }
  res += nwrite;
  if (res == 0)
  {
    return NGTCP2_ERR_NOBUF;
  }
  conn->state = NGTCP2_CS_CLOSING;
  return res;
}
int ngtcp2_conn_is_in_closing_period(ngtcp2_conn *conn)
{
  return conn->state == NGTCP2_CS_CLOSING;
}
int ngtcp2_conn_is_in_draining_period(ngtcp2_conn *conn)
{
  return conn->state == NGTCP2_CS_DRAINING;
}
int ngtcp2_conn_close_stream(ngtcp2_conn *conn, ngtcp2_strm *strm,
                             uint64_t app_error_code)
{
  int rv;
  if (!strm->app_error_code)
  {
    app_error_code = strm->app_error_code;
  }
  rv = ngtcp2_map_remove(&conn->strms, strm->me.key);
  if (rv != 0)
  {

    (static_cast<bool>(rv != NGTCP2_ERR_INVALID_ARGUMENT) ? void(0) : __assert_fail("rv != NGTCP2_ERR_INVALID_ARGUMENT", "all.cpp", 27751, __extension__ __PRETTY_FUNCTION__));
    return rv;
  }
  rv = conn_call_stream_close(conn, strm, app_error_code);
  if (rv != 0)
  {
    goto fin;
  }
  if (ngtcp2_strm_is_tx_queued(strm))
  {
    ngtcp2_pq_remove(&conn->tx.strmq, &strm->pe);
  }
fin:
  ngtcp2_strm_free(strm);
  ngtcp2_mem_free(conn->mem, strm);
  return rv;
}
int ngtcp2_conn_close_stream_if_shut_rdwr(ngtcp2_conn *conn, ngtcp2_strm *strm,
                                          uint64_t app_error_code)
{
  if ((strm->flags & NGTCP2_STRM_FLAG_SHUT_RDWR) ==
          NGTCP2_STRM_FLAG_SHUT_RDWR &&
      ((strm->flags & NGTCP2_STRM_FLAG_RECV_RST) ||
       ngtcp2_strm_rx_offset(strm) == strm->rx.last_offset) &&
      (((strm->flags & NGTCP2_STRM_FLAG_SENT_RST) &&
        (strm->flags & NGTCP2_STRM_FLAG_RST_ACKED)) ||
       (!(strm->flags & NGTCP2_STRM_FLAG_SENT_RST) &&
        ngtcp2_strm_is_all_tx_data_acked(strm))))
  {
    return ngtcp2_conn_close_stream(conn, strm, app_error_code);
  }
  return 0;
}
static int conn_shutdown_stream_write(ngtcp2_conn *conn, ngtcp2_strm *strm,
                                      uint64_t app_error_code)
{
  if (strm->flags & NGTCP2_STRM_FLAG_SENT_RST)
  {
    return 0;
  }
  strm->flags |= NGTCP2_STRM_FLAG_SHUT_WR | NGTCP2_STRM_FLAG_SENT_RST;
  strm->app_error_code = app_error_code;
  ngtcp2_strm_streamfrq_clear(strm);
  return conn_reset_stream(conn, strm, app_error_code);
}
static int conn_shutdown_stream_read(ngtcp2_conn *conn, ngtcp2_strm *strm,
                                     uint64_t app_error_code)
{
  if (strm->flags & NGTCP2_STRM_FLAG_STOP_SENDING)
  {
    return 0;
  }
  if ((strm->flags & NGTCP2_STRM_FLAG_SHUT_RD) &&
      ngtcp2_strm_rx_offset(strm) == strm->rx.last_offset)
  {
    return 0;
  }
  if (!(strm->flags &
        (NGTCP2_STRM_FLAG_STOP_SENDING | NGTCP2_STRM_FLAG_RECV_RST)))
  {
    ngtcp2_conn_extend_max_offset(conn, strm->rx.last_offset -
                                            ngtcp2_strm_rx_offset(strm));
  }
  strm->flags |= NGTCP2_STRM_FLAG_STOP_SENDING;
  strm->app_error_code = app_error_code;
  return conn_stop_sending(conn, strm, app_error_code);
}
int ngtcp2_conn_shutdown_stream(ngtcp2_conn *conn, int64_t stream_id,
                                uint64_t app_error_code)
{
  int rv;
  ngtcp2_strm *strm;
  strm = ngtcp2_conn_find_stream(conn, stream_id);
  if (strm == __null)
  {
    return NGTCP2_ERR_STREAM_NOT_FOUND;
  }
  rv = conn_shutdown_stream_read(conn, strm, app_error_code);
  if (rv != 0)
  {
    return rv;
  }
  rv = conn_shutdown_stream_write(conn, strm, app_error_code);
  if (rv != 0)
  {
    return rv;
  }
  return 0;
}
int ngtcp2_conn_shutdown_stream_write(ngtcp2_conn *conn, int64_t stream_id,
                                      uint64_t app_error_code)
{
  ngtcp2_strm *strm;
  strm = ngtcp2_conn_find_stream(conn, stream_id);
  if (strm == __null)
  {
    return NGTCP2_ERR_STREAM_NOT_FOUND;
  }
  return conn_shutdown_stream_write(conn, strm, app_error_code);
}
int ngtcp2_conn_shutdown_stream_read(ngtcp2_conn *conn, int64_t stream_id,
                                     uint64_t app_error_code)
{
  ngtcp2_strm *strm;
  strm = ngtcp2_conn_find_stream(conn, stream_id);
  if (strm == __null)
  {
    return NGTCP2_ERR_STREAM_NOT_FOUND;
  }
  return conn_shutdown_stream_read(conn, strm, app_error_code);
}
static int conn_extend_max_stream_offset(ngtcp2_conn *conn, ngtcp2_strm *strm,
                                         uint64_t datalen)
{
  ngtcp2_strm *top;
  if (datalen > ((1ULL << 62) - 1) ||
      strm->rx.unsent_max_offset > ((1ULL << 62) - 1) - datalen)
  {
    strm->rx.unsent_max_offset = ((1ULL << 62) - 1);
  }
  else
  {
    strm->rx.unsent_max_offset += datalen;
  }
  if (!(strm->flags &
        (NGTCP2_STRM_FLAG_SHUT_RD | NGTCP2_STRM_FLAG_STOP_SENDING)) &&
      !ngtcp2_strm_is_tx_queued(strm) &&
      conn_should_send_max_stream_data(conn, strm))
  {
    if (!ngtcp2_pq_empty(&conn->tx.strmq))
    {
      top = ngtcp2_conn_tx_strmq_top(conn);
      strm->cycle = top->cycle;
    }
    strm->cycle = conn_tx_strmq_first_cycle(conn);
    return ngtcp2_conn_tx_strmq_push(conn, strm);
  }
  return 0;
}
int ngtcp2_conn_extend_max_stream_offset(ngtcp2_conn *conn, int64_t stream_id,
                                         uint64_t datalen)
{
  ngtcp2_strm *strm;
  strm = ngtcp2_conn_find_stream(conn, stream_id);
  if (strm == __null)
  {
    return NGTCP2_ERR_STREAM_NOT_FOUND;
  }
  return conn_extend_max_stream_offset(conn, strm, datalen);
}
void ngtcp2_conn_extend_max_offset(ngtcp2_conn *conn, uint64_t datalen)
{
  if (((1ULL << 62) - 1) < datalen ||
      conn->rx.unsent_max_offset > ((1ULL << 62) - 1) - datalen)
  {
    conn->rx.unsent_max_offset = ((1ULL << 62) - 1);
    return;
  }
  conn->rx.unsent_max_offset += datalen;
}
void ngtcp2_conn_extend_max_streams_bidi(ngtcp2_conn *conn, size_t n)
{
  handle_max_remote_streams_extension(&conn->remote.bidi.unsent_max_streams, n);
}
void ngtcp2_conn_extend_max_streams_uni(ngtcp2_conn *conn, size_t n)
{
  handle_max_remote_streams_extension(&conn->remote.uni.unsent_max_streams, n);
}
const ngtcp2_cid *ngtcp2_conn_get_dcid(ngtcp2_conn *conn)
{
  return &conn->dcid.current.cid;
}
uint32_t ngtcp2_conn_get_negotiated_version(ngtcp2_conn *conn)
{
  return conn->version;
}
int ngtcp2_conn_early_data_rejected(ngtcp2_conn *conn)
{
  ngtcp2_pktns *pktns = &conn->pktns;
  ngtcp2_rtb *rtb = &conn->pktns.rtb;
  int rv;
  conn->flags |= NGTCP2_CONN_FLAG_EARLY_DATA_REJECTED;
  rv = ngtcp2_rtb_remove_all(rtb, conn, pktns, &conn->cstat);
  if (rv != 0)
  {
    return rv;
  }
  return rv;
}
void ngtcp2_conn_update_rtt(ngtcp2_conn *conn, ngtcp2_duration rtt,
                            ngtcp2_duration ack_delay, ngtcp2_tstamp ts)
{
  ngtcp2_conn_stat *cstat = &conn->cstat;
  ngtcp2_duration min_rtt;
  rtt = ((rtt) > (((uint64_t)1000000ULL)) ? (rtt) : (((uint64_t)1000000ULL)));
  cstat->latest_rtt = rtt;
  if (cstat->min_rtt ==
      (18446744073709551615UL))
  {
    cstat->min_rtt = rtt;
    cstat->smoothed_rtt = rtt;
    cstat->rttvar = rtt / 2;
    cstat->first_rtt_sample_ts = ts;
  }
  else
  {
    min_rtt = ((cstat->min_rtt) < (rtt) ? (cstat->min_rtt) : (rtt));
    if (conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_CONFIRMED)
    {
      ack_delay =
          ((ack_delay) < (conn->remote.transport_params.max_ack_delay) ? (ack_delay) : (conn->remote.transport_params.max_ack_delay));
    }
    else if (ack_delay > 0 && rtt < cstat->min_rtt + ack_delay)
    {
      ngtcp2_log_info(
          &conn->log, NGTCP2_LOG_EVENT_RCV,
          "ignore rtt sample because ack_delay is too large latest_rtt=%lu min_rtt=%lu ack_delay=%lu",
          (uint64_t)(rtt / ((uint64_t)1000000ULL)),
          (uint64_t)(cstat->min_rtt / ((uint64_t)1000000ULL)),
          (uint64_t)(ack_delay / ((uint64_t)1000000ULL)));
      return;
    }
    if (rtt > min_rtt + ack_delay)
    {
      rtt -= ack_delay;
    }
    cstat->min_rtt = min_rtt;
    cstat->rttvar = (cstat->rttvar * 3 + (cstat->smoothed_rtt < rtt
                                              ? rtt - cstat->smoothed_rtt
                                              : cstat->smoothed_rtt - rtt)) /
                    4;
    cstat->smoothed_rtt = (cstat->smoothed_rtt * 7 + rtt) / 8;
  }
  ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_RCV,
                  "latest_rtt=%lu min_rtt=%lu smoothed_rtt=%lu rttvar=%lu ack_delay=%lu",
                  (uint64_t)(cstat->latest_rtt / ((uint64_t)1000000ULL)),
                  (uint64_t)(cstat->min_rtt / ((uint64_t)1000000ULL)),
                  cstat->smoothed_rtt / ((uint64_t)1000000ULL),
                  cstat->rttvar / ((uint64_t)1000000ULL),
                  (uint64_t)(ack_delay / ((uint64_t)1000000ULL)));
}
void ngtcp2_conn_get_conn_stat(ngtcp2_conn *conn, ngtcp2_conn_stat *cstat)
{
  *cstat = conn->cstat;
}
static ngtcp2_pktns *conn_get_earliest_pktns(ngtcp2_conn *conn,
                                             ngtcp2_tstamp *pts,
                                             const ngtcp2_tstamp *times)
{
  ngtcp2_pktns *ns[] = {conn->in_pktns, conn->hs_pktns, &conn->pktns};
  ngtcp2_pktns *res = ns[0];
  size_t i;
  ngtcp2_tstamp earliest_ts = times[NGTCP2_PKTNS_ID_INITIAL];
  for (i = NGTCP2_PKTNS_ID_HANDSHAKE; i < NGTCP2_PKTNS_ID_MAX; ++i)
  {
    if (ns[i] == __null || ns[i]->rtb.num_retransmittable == 0 ||
        (times[i] == (18446744073709551615UL) || (earliest_ts != (18446744073709551615UL) && times[i] >= earliest_ts) || (i == NGTCP2_PKTNS_ID_APP && !(conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_CONFIRMED))))
    {
      continue;
    }
    earliest_ts = times[i];
    res = ns[i];
  }
  if (res == __null && !conn->server)
  {
    earliest_ts = (18446744073709551615UL);
    if (conn->hs_pktns && conn->hs_pktns->crypto.tx.ckm)
    {
      res = conn->hs_pktns;
    }
    else
    {
      res = conn->in_pktns;
    }
  }
  if (pts)
  {
    *pts = earliest_ts;
  }
  return res;
}
void ngtcp2_conn_set_loss_detection_timer(ngtcp2_conn *conn, ngtcp2_tstamp ts)
{
  ngtcp2_conn_stat *cstat = &conn->cstat;
  ngtcp2_duration timeout;
  ngtcp2_pktns *in_pktns = conn->in_pktns;
  ngtcp2_pktns *hs_pktns = conn->hs_pktns;
  ngtcp2_pktns *pktns = &conn->pktns;
  ngtcp2_pktns *earliest_pktns;
  ngtcp2_tstamp earliest_loss_time;
  ngtcp2_tstamp last_tx_pkt_ts;
  conn_get_earliest_pktns(conn, &earliest_loss_time, cstat->loss_time);
  if (earliest_loss_time != (18446744073709551615UL))
  {
    cstat->loss_detection_timer = earliest_loss_time;
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_RCV,
                    "loss_detection_timer=%lu nonzero crypto loss time",
                    cstat->loss_detection_timer);
    return;
  }
  if ((!in_pktns || in_pktns->rtb.num_retransmittable == 0) &&
      (!hs_pktns || hs_pktns->rtb.num_retransmittable == 0) &&
      (pktns->rtb.num_retransmittable == 0 ||
       !(conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_CONFIRMED)) &&
      (conn->server ||
       (conn->flags & (NGTCP2_CONN_FLAG_SERVER_ADDR_VERIFIED |
                       NGTCP2_CONN_FLAG_HANDSHAKE_CONFIRMED))))
  {
    if (cstat->loss_detection_timer)
    {
      ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_RCV,
                      "loss detection timer canceled");
      cstat->loss_detection_timer = 0;
      cstat->pto_count = 0;
    }
    return;
  }
  earliest_pktns =
      conn_get_earliest_pktns(conn, &last_tx_pkt_ts, cstat->last_tx_pkt_ts);

  (static_cast<bool>(
       earliest_pktns)
       ? void(0)
       : __assert_fail(
             "earliest_pktns", "all.cpp", 28094, __extension__ __PRETTY_FUNCTION__));
  if (last_tx_pkt_ts ==
      (18446744073709551615UL))
  {
    last_tx_pkt_ts = ts;
  }
  timeout = conn_compute_pto(conn, earliest_pktns) * (1ULL << cstat->pto_count);
  cstat->loss_detection_timer = last_tx_pkt_ts + timeout;
  ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_RCV,
                  "loss_detection_timer=%"
                  "l"
                  "u"
                  " last_tx_pkt_ts=%"
                  "l"
                  "u"

                  " timeout=%"
                  "l"
                  "u",
                  cstat->loss_detection_timer, last_tx_pkt_ts,
                  (uint64_t)(timeout / ((uint64_t)1000000ULL)));
}
int ngtcp2_conn_on_loss_detection_timer(ngtcp2_conn *conn, ngtcp2_tstamp ts)
{
  ngtcp2_conn_stat *cstat = &conn->cstat;
  int rv;
  ngtcp2_pktns *in_pktns = conn->in_pktns;
  ngtcp2_pktns *hs_pktns = conn->hs_pktns;
  ngtcp2_tstamp earliest_loss_time;
  ngtcp2_pktns *loss_pktns =
      conn_get_earliest_pktns(conn, &earliest_loss_time, cstat->loss_time);
  ngtcp2_pktns *earliest_pktns;
  conn->log.last_ts = ts;
  conn->qlog.last_ts = ts;
  switch (conn->state)
  {
  case NGTCP2_CS_CLOSING:
  case NGTCP2_CS_DRAINING:
    cstat->loss_detection_timer = 0;
    cstat->pto_count = 0;
    return 0;
  default:
    break;
  }
  if (!cstat->loss_detection_timer)
  {
    return 0;
  }
  ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_RCV,
                  "loss detection timer fired");
  if (earliest_loss_time !=
      (18446744073709551615UL))
  {
    rv = ngtcp2_conn_detect_lost_pkt(conn, loss_pktns, cstat, ts);
    if (rv != 0)
    {
      return rv;
    }
    ngtcp2_conn_set_loss_detection_timer(conn, ts);
    return 0;
  }
  if (!conn->server && !(conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED))
  {
    if (hs_pktns->crypto.tx.ckm)
    {
      hs_pktns->rtb.probe_pkt_left = 1;
    }
    else
    {
      in_pktns->rtb.probe_pkt_left = 1;
    }
  }
  else
  {
    earliest_pktns = conn_get_earliest_pktns(conn,
                                             __null, cstat->last_tx_pkt_ts);

    (static_cast<bool>(
         earliest_pktns)
         ? void(0)
         : __assert_fail(
               "earliest_pktns", "all.cpp", 28160, __extension__ __PRETTY_FUNCTION__));
    switch (earliest_pktns->rtb.pktns_id)
    {
    case NGTCP2_PKTNS_ID_INITIAL:

      (static_cast<bool>(
           in_pktns)
           ? void(0)
           : __assert_fail(
                 "in_pktns", "all.cpp", 28164, __extension__ __PRETTY_FUNCTION__));
      in_pktns->rtb.probe_pkt_left = 1;
      if (!conn->server)
      {
        break;
      }
    case NGTCP2_PKTNS_ID_HANDSHAKE:

      (static_cast<bool>(
           hs_pktns)
           ? void(0)
           : __assert_fail(
                 "hs_pktns", "all.cpp", 28171, __extension__ __PRETTY_FUNCTION__));
      hs_pktns->rtb.probe_pkt_left = 1;
      break;
    case NGTCP2_PKTNS_ID_APP:
      conn->pktns.rtb.probe_pkt_left = 2;
      break;
    default:

      (static_cast<bool>(
           0)
           ? void(0)
           : __assert_fail(
                 "0", "all.cpp", 28178, __extension__ __PRETTY_FUNCTION__));
    }
  }
  ++cstat->pto_count;
  ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_RCV, "pto_count=%zu",
                  cstat->pto_count);
  ngtcp2_conn_set_loss_detection_timer(conn, ts);
  return 0;
}
int ngtcp2_conn_submit_crypto_data(ngtcp2_conn *conn,
                                   ngtcp2_crypto_level crypto_level,
                                   const uint8_t *data, const size_t datalen)
{
  ngtcp2_pktns *pktns;
  ngtcp2_frame_chain *frc;
  ngtcp2_crypto *fr;
  int rv;
  if (datalen == 0)
  {
    return 0;
  }
  switch (crypto_level)
  {
  case NGTCP2_CRYPTO_LEVEL_INITIAL:

    (static_cast<bool>(
         conn->in_pktns)
         ? void(0)
         : __assert_fail(
               "conn->in_pktns", "all.cpp", 28203, __extension__ __PRETTY_FUNCTION__));
    pktns = conn->in_pktns;
    break;
  case NGTCP2_CRYPTO_LEVEL_HANDSHAKE:

    (static_cast<bool>(
         conn->hs_pktns)
         ? void(0)
         : __assert_fail(
               "conn->hs_pktns", "all.cpp", 28207, __extension__ __PRETTY_FUNCTION__));
    pktns = conn->hs_pktns;
    break;
  case NGTCP2_CRYPTO_LEVEL_APP:
    pktns = &conn->pktns;
    break;
  default:
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  rv = ngtcp2_frame_chain_new(&frc, conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  fr = &frc->fr.crypto;
  fr->type = NGTCP2_FRAME_CRYPTO;
  fr->offset = pktns->crypto.tx.offset;
  fr->datacnt = 1;
  fr->data[0].len = datalen;
  fr->data[0].base = (uint8_t *)data;
  rv = ngtcp2_ksl_insert(&pktns->crypto.tx.frq, __null, &fr->offset, frc);
  if (rv != 0)
  {
    ngtcp2_frame_chain_del(frc, conn->mem);
    return rv;
  }
  pktns->crypto.strm.tx.offset += datalen;
  pktns->crypto.tx.offset += datalen;
  return 0;
}
int ngtcp2_conn_submit_new_token(ngtcp2_conn *conn, const uint8_t *token,
                                 size_t tokenlen)
{
  int rv;
  ngtcp2_frame_chain *nfrc;
  uint8_t *p;

  (static_cast<bool>(conn->server) ? void(0) : __assert_fail("conn->server", "all.cpp", 28244, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(token) ? void(0) : __assert_fail("token", "all.cpp", 28245, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(tokenlen) ? void(0) : __assert_fail("tokenlen", "all.cpp", 28246, __extension__ __PRETTY_FUNCTION__));
  rv = ngtcp2_frame_chain_extralen_new(&nfrc, tokenlen, conn->mem);
  if (rv != 0)
  {
    return rv;
  }
  nfrc->fr.type = NGTCP2_FRAME_NEW_TOKEN;
  p = (uint8_t *)nfrc + sizeof(*nfrc);
  memcpy(p, token, tokenlen);
  ngtcp2_vec_init(&nfrc->fr.new_token.token, p, tokenlen);
  nfrc->next = conn->pktns.tx.frq;
  conn->pktns.tx.frq = nfrc;
  return 0;
}
ngtcp2_strm *ngtcp2_conn_tx_strmq_top(ngtcp2_conn *conn)
{

  (static_cast<bool>(!ngtcp2_pq_empty(&conn->tx.strmq)) ? void(0) : __assert_fail("!ngtcp2_pq_empty(&conn->tx.strmq)", "all.cpp", 28263, __extension__ __PRETTY_FUNCTION__));
  return ((ngtcp2_strm *)(void *)((char *)(ngtcp2_pq_top(&conn->tx.strmq)) - __builtin_offsetof(ngtcp2_strm, pe)));
}
void ngtcp2_conn_tx_strmq_pop(ngtcp2_conn *conn)
{
  ngtcp2_strm *strm = ngtcp2_conn_tx_strmq_top(conn);

  (static_cast<bool>(strm) ? void(0) : __assert_fail("strm", "all.cpp", 28270, __extension__ __PRETTY_FUNCTION__));
  ngtcp2_pq_pop(&conn->tx.strmq);
  strm->pe.index = (18446744073709551615UL);
}
int ngtcp2_conn_tx_strmq_push(ngtcp2_conn *conn, ngtcp2_strm *strm)
{
  return ngtcp2_pq_push(&conn->tx.strmq, &strm->pe);
}
size_t ngtcp2_conn_get_num_scid(ngtcp2_conn *conn)
{
  return ngtcp2_ksl_len(&conn->scid.set);
}
size_t ngtcp2_conn_get_scid(ngtcp2_conn *conn, ngtcp2_cid *dest)
{
  ngtcp2_ksl_it it;
  ngtcp2_scid *scid;
  for (it = ngtcp2_ksl_begin(&conn->scid.set); !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                                                  __null);
       (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
  {
    scid = ngtcp2_ksl_it_get(&it);
    *dest++ = scid->cid;
  }
  return ngtcp2_ksl_len(&conn->scid.set);
}
size_t ngtcp2_conn_get_num_active_dcid(ngtcp2_conn *conn)
{
  size_t n = 1;
  ngtcp2_pv *pv = conn->pv;
  if (!(conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED_HANDLED))
  {
    return 0;
  }
  if (pv)
  {
    if (pv->dcid.seq != conn->dcid.current.seq)
    {
      ++n;
    }
    if ((pv->flags & NGTCP2_PV_FLAG_FALLBACK_ON_FAILURE) &&
        pv->fallback_dcid.seq != conn->dcid.current.seq &&
        pv->fallback_dcid.seq != pv->dcid.seq)
    {
      ++n;
    }
  }
  n += ((&conn->dcid.retired)->len);
  return n;
}
static void copy_dcid_to_cid_token(ngtcp2_cid_token *dest,
                                   const ngtcp2_dcid *src)
{
  dest->seq = src->seq;
  dest->cid = src->cid;
  ngtcp2_path_storage_init2(&dest->ps, &src->ps.path);
  dest->token_present =
      (uint8_t)!ngtcp2_check_invalid_stateless_reset_token(src->token);
  memcpy(dest->token, src->token, 16);
}
size_t ngtcp2_conn_get_active_dcid(ngtcp2_conn *conn, ngtcp2_cid_token *dest)
{
  ngtcp2_pv *pv = conn->pv;
  ngtcp2_cid_token *orig = dest;
  ngtcp2_dcid *dcid;
  size_t len, i;
  if (!(conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED_HANDLED))
  {
    return 0;
  }
  copy_dcid_to_cid_token(dest, &conn->dcid.current);
  ++dest;
  if (pv)
  {
    if (pv->dcid.seq != conn->dcid.current.seq)
    {
      copy_dcid_to_cid_token(dest, &pv->dcid);
      ++dest;
    }
    if ((pv->flags & NGTCP2_PV_FLAG_FALLBACK_ON_FAILURE) &&
        pv->fallback_dcid.seq != conn->dcid.current.seq &&
        pv->fallback_dcid.seq != pv->dcid.seq)
    {
      copy_dcid_to_cid_token(dest, &pv->fallback_dcid);
      ++dest;
    }
  }
  len = ((&conn->dcid.retired)->len);
  for (i = 0; i < len; ++i)
  {
    dcid = ngtcp2_ringbuf_get(&conn->dcid.retired, i);
    copy_dcid_to_cid_token(dest, dcid);
    ++dest;
  }
  return (size_t)(dest - orig);
}
void ngtcp2_conn_set_local_addr(ngtcp2_conn *conn, const ngtcp2_addr *addr)
{
  ngtcp2_addr *dest = &conn->dcid.current.ps.path.local;

  (static_cast<bool>(
       addr->addrlen <= sizeof(conn->dcid.current.ps.local_addrbuf))
       ? void(0)
       : __assert_fail(
             "addr->addrlen <= sizeof(conn->dcid.current.ps.local_addrbuf)", "all.cpp", 28374, __extension__ __PRETTY_FUNCTION__));
  ngtcp2_addr_copy(dest, addr);
}
void ngtcp2_conn_set_remote_addr(ngtcp2_conn *conn, const ngtcp2_addr *addr)
{
  ngtcp2_addr *dest = &conn->dcid.current.ps.path.remote;

  (static_cast<bool>(
       addr->addrlen <= sizeof(conn->dcid.current.ps.remote_addrbuf))
       ? void(0)
       : __assert_fail(
             "addr->addrlen <= sizeof(conn->dcid.current.ps.remote_addrbuf)", "all.cpp", 28381, __extension__ __PRETTY_FUNCTION__));
  ngtcp2_addr_copy(dest, addr);
}
const ngtcp2_addr *ngtcp2_conn_get_remote_addr(ngtcp2_conn *conn)
{
  return &conn->dcid.current.ps.path.remote;
}
int ngtcp2_conn_initiate_migration(ngtcp2_conn *conn, const ngtcp2_path *path,
                                   ngtcp2_tstamp ts)
{
  int rv;
  ngtcp2_dcid *dcid;

  (static_cast<bool>(
       !conn->server)
       ? void(0)
       : __assert_fail(
             "!conn->server", "all.cpp", 28395, __extension__ __PRETTY_FUNCTION__));
  conn->log.last_ts = ts;
  conn->qlog.last_ts = ts;
  if (conn->remote.transport_params.disable_active_migration ||
      !(conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_CONFIRMED))
  {
    return NGTCP2_ERR_INVALID_STATE;
  }
  if (((&conn->dcid.unused)->len) == 0)
  {
    return NGTCP2_ERR_CONN_ID_BLOCKED;
  }
  if (ngtcp2_path_eq(&conn->dcid.current.ps.path, path))
  {
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  dcid = ngtcp2_ringbuf_get(&conn->dcid.unused, 0);
  rv = conn_stop_pv(conn, ts);
  if (rv != 0)
  {
    return rv;
  }
  rv = conn_retire_dcid(conn, &conn->dcid.current, ts);
  if (rv != 0)
  {
    return rv;
  }
  ngtcp2_dcid_copy(&conn->dcid.current, dcid);
  ngtcp2_path_copy(&conn->dcid.current.ps.path, path);
  ngtcp2_ringbuf_pop_front(&conn->dcid.unused);
  rv = conn_call_activate_dcid(conn, &conn->dcid.current);
  if (rv != 0)
  {
    return rv;
  }
  conn_reset_congestion_state(conn);
  conn_reset_ecn_validation_state(conn);
  return 0;
}
uint64_t ngtcp2_conn_get_max_local_streams_uni(ngtcp2_conn *conn)
{
  return conn->local.uni.max_streams;
}
uint64_t ngtcp2_conn_get_max_data_left(ngtcp2_conn *conn)
{
  return conn->tx.max_offset - conn->tx.offset;
}
uint64_t ngtcp2_conn_get_streams_bidi_left(ngtcp2_conn *conn)
{
  uint64_t n = ngtcp2_ord_stream_id(conn->local.bidi.next_stream_id);
  return n > conn->local.bidi.max_streams
             ? 0
             : conn->local.bidi.max_streams - n + 1;
}
uint64_t ngtcp2_conn_get_streams_uni_left(ngtcp2_conn *conn)
{
  uint64_t n = ngtcp2_ord_stream_id(conn->local.uni.next_stream_id);
  return n > conn->local.uni.max_streams ? 0
                                         : conn->local.uni.max_streams - n + 1;
}
ngtcp2_tstamp ngtcp2_conn_get_idle_expiry(ngtcp2_conn *conn)
{
  ngtcp2_duration trpto;
  ngtcp2_duration idle_timeout;
  if (!(conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED) ||
      conn->remote.transport_params.max_idle_timeout == 0 ||
      (conn->local.settings.transport_params.max_idle_timeout &&
       conn->local.settings.transport_params.max_idle_timeout <
           conn->remote.transport_params.max_idle_timeout))
  {
    idle_timeout = conn->local.settings.transport_params.max_idle_timeout;
  }
  else
  {
    idle_timeout = conn->remote.transport_params.max_idle_timeout;
  }
  if (idle_timeout == 0)
  {
    return (18446744073709551615UL);
  }
  trpto = 3 * conn_compute_pto(
                  conn, (conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED)
                            ? &conn->pktns
                            : conn->hs_pktns);
  return conn->idle_ts + ((idle_timeout) > (trpto) ? (idle_timeout) : (trpto));
}
ngtcp2_duration ngtcp2_conn_get_pto(ngtcp2_conn *conn)
{
  return conn_compute_pto(conn,
                          (conn->flags & NGTCP2_CONN_FLAG_HANDSHAKE_COMPLETED)
                              ? &conn->pktns
                              : conn->hs_pktns);
}
void ngtcp2_conn_set_initial_crypto_ctx(ngtcp2_conn *conn,
                                        const ngtcp2_crypto_ctx *ctx)
{

  (static_cast<bool>(
       conn->in_pktns)
       ? void(0)
       : __assert_fail(
             "conn->in_pktns", "all.cpp", 28498, __extension__ __PRETTY_FUNCTION__));
  conn->in_pktns->crypto.ctx = *ctx;
}
const ngtcp2_crypto_ctx *ngtcp2_conn_get_initial_crypto_ctx(ngtcp2_conn *conn)
{

  (static_cast<bool>(
       conn->in_pktns)
       ? void(0)
       : __assert_fail(
             "conn->in_pktns", "all.cpp", 28504, __extension__ __PRETTY_FUNCTION__));
  return &conn->in_pktns->crypto.ctx;
}
void ngtcp2_conn_set_retry_aead(ngtcp2_conn *conn,
                                const ngtcp2_crypto_aead *aead,
                                const ngtcp2_crypto_aead_ctx *aead_ctx)
{

  (static_cast<bool>(
       !conn->crypto.retry_aead_ctx.native_handle)
       ? void(0)
       : __assert_fail(
             "!conn->crypto.retry_aead_ctx.native_handle", "all.cpp", 28512, __extension__ __PRETTY_FUNCTION__));
  conn->crypto.retry_aead = *aead;
  conn->crypto.retry_aead_ctx = *aead_ctx;
}
void ngtcp2_conn_set_crypto_ctx(ngtcp2_conn *conn,
                                const ngtcp2_crypto_ctx *ctx)
{

  (static_cast<bool>(
       conn->hs_pktns)
       ? void(0)
       : __assert_fail(
             "conn->hs_pktns", "all.cpp", 28520, __extension__ __PRETTY_FUNCTION__));
  conn->hs_pktns->crypto.ctx = *ctx;
  conn->pktns.crypto.ctx = *ctx;
}
const ngtcp2_crypto_ctx *ngtcp2_conn_get_crypto_ctx(ngtcp2_conn *conn)
{
  return &conn->pktns.crypto.ctx;
}
void *ngtcp2_conn_get_tls_native_handle(ngtcp2_conn *conn)
{
  return conn->crypto.tls_native_handle;
}
void ngtcp2_conn_set_tls_native_handle(ngtcp2_conn *conn,
                                       void *tls_native_handle)
{
  conn->crypto.tls_native_handle = tls_native_handle;
}
void ngtcp2_conn_get_connection_close_error_code(
    ngtcp2_conn *conn, ngtcp2_connection_close_error_code *ccec)
{
  *ccec = conn->rx.ccec;
}
void ngtcp2_conn_set_tls_error(ngtcp2_conn *conn, int liberr)
{
  conn->crypto.tls_error = liberr;
}
int ngtcp2_conn_get_tls_error(ngtcp2_conn *conn)
{
  return conn->crypto.tls_error;
}
int ngtcp2_conn_is_local_stream(ngtcp2_conn *conn, int64_t stream_id)
{
  return conn_local_stream(conn, stream_id);
}
int ngtcp2_conn_is_server(ngtcp2_conn *conn) { return conn->server; }
int ngtcp2_conn_after_retry(ngtcp2_conn *conn)
{
  return (conn->flags & NGTCP2_CONN_FLAG_RECV_RETRY) != 0;
}
int ngtcp2_conn_set_stream_user_data(ngtcp2_conn *conn, int64_t stream_id,
                                     void *stream_user_data)
{
  ngtcp2_strm *strm = ngtcp2_conn_find_stream(conn, stream_id);
  if (strm ==
      __null)
  {
    return NGTCP2_ERR_STREAM_NOT_FOUND;
  }
  strm->stream_user_data = stream_user_data;
  return 0;
}
void ngtcp2_path_challenge_entry_init(ngtcp2_path_challenge_entry *pcent,
                                      const ngtcp2_path *path,
                                      const uint8_t *data)
{
  ngtcp2_path_storage_init2(&pcent->ps, path);
  memcpy(pcent->data, data, sizeof(pcent->data));
}
void ngtcp2_settings_default(ngtcp2_settings *settings)
{
  memset(settings, 0, sizeof(*settings));
  settings->cc_algo = NGTCP2_CC_ALGO_CUBIC;
  settings->initial_rtt = (333 * ((uint64_t)1000000ULL));
  settings->transport_params.max_udp_payload_size =
      65527;
  settings->transport_params.ack_delay_exponent =
      3;
  settings->transport_params.max_ack_delay = (25 * ((uint64_t)1000000ULL));
  settings->transport_params.active_connection_id_limit =
      2;
}
ngtcp2_ssize ngtcp2_pkt_write_connection_close(
    uint8_t *dest, size_t destlen, uint32_t version, const ngtcp2_cid *dcid,
    const ngtcp2_cid *scid, uint64_t error_code, ngtcp2_encrypt encrypt,
    const ngtcp2_crypto_aead *aead, const ngtcp2_crypto_aead_ctx *aead_ctx,
    const uint8_t *iv, ngtcp2_hp_mask hp_mask, const ngtcp2_crypto_cipher *hp,
    const ngtcp2_crypto_cipher_ctx *hp_ctx)
{
  ngtcp2_pkt_hd hd;
  ngtcp2_crypto_km ckm;
  ngtcp2_crypto_cc cc;
  ngtcp2_ppe ppe;
  ngtcp2_frame fr = {0};
  int rv;
  ngtcp2_pkt_hd_init(&hd, NGTCP2_PKT_FLAG_LONG_FORM, NGTCP2_PKT_INITIAL, dcid,
                     scid, 0, 1, version,
                     0);
  ngtcp2_vec_init(&ckm.secret,
                  __null, 0);
  ngtcp2_vec_init(&ckm.iv, iv, 12);
  ckm.aead_ctx = *aead_ctx;
  ckm.pkt_num = 0;
  ckm.flags = NGTCP2_CRYPTO_KM_FLAG_NONE;
  cc.aead_overhead = 16;
  cc.aead = *aead;
  cc.hp = *hp;
  cc.ckm = &ckm;
  cc.hp_ctx = *hp_ctx;
  cc.encrypt = encrypt;
  cc.hp_mask = hp_mask;
  ngtcp2_ppe_init(&ppe, dest, destlen, &cc);
  rv = ngtcp2_ppe_encode_hd(&ppe, &hd);
  if (rv != 0)
  {

    (static_cast<bool>(
         NGTCP2_ERR_NOBUF == rv)
         ? void(0)
         : __assert_fail(
               "NGTCP2_ERR_NOBUF == rv", "all.cpp", 28635, __extension__ __PRETTY_FUNCTION__));
    return rv;
  }
  if (!ngtcp2_ppe_ensure_hp_sample(&ppe))
  {
    return NGTCP2_ERR_NOBUF;
  }
  fr.type = NGTCP2_FRAME_CONNECTION_CLOSE;
  fr.connection_close.error_code = error_code;
  rv = ngtcp2_ppe_encode_frame(&ppe, &fr);
  if (rv != 0)
  {

    (static_cast<bool>(
         NGTCP2_ERR_NOBUF == rv)
         ? void(0)
         : __assert_fail(
               "NGTCP2_ERR_NOBUF == rv", "all.cpp", 28647, __extension__ __PRETTY_FUNCTION__));
    return rv;
  }
  return ngtcp2_ppe_final(&ppe,
                          __null);
}
int ngtcp2_is_bidi_stream(int64_t stream_id) { return bidi_stream(stream_id); }
uint64_t ngtcp2_get_uint64(const uint8_t *p)
{
  uint64_t n;
  memcpy(&n, p, 8);
  return ((uint64_t)(ntohl((uint32_t)(n))) << 32 | ntohl((uint32_t)((n) >> 32)));
}
uint64_t ngtcp2_get_uint48(const uint8_t *p)
{
  uint64_t n = 0;
  memcpy(((uint8_t *)&n) + 2, p, 6);
  return ((uint64_t)(ntohl((uint32_t)(n))) << 32 | ntohl((uint32_t)((n) >> 32)));
}
uint32_t ngtcp2_get_uint32(const uint8_t *p)
{
  uint32_t n;
  memcpy(&n, p, 4);
  return ntohl(n);
}
uint32_t ngtcp2_get_uint24(const uint8_t *p)
{
  uint32_t n = 0;
  memcpy(((uint8_t *)&n) + 1, p, 3);
  return ntohl(n);
}
uint16_t ngtcp2_get_uint16(const uint8_t *p)
{
  uint16_t n;
  memcpy(&n, p, 2);
  return ntohs(n);
}
uint64_t ngtcp2_get_varint(size_t *plen, const uint8_t *p)
{
  union
  {
    char b[8];
    uint16_t n16;
    uint32_t n32;
    uint64_t n64;
  } n;
  *plen = 1u << (*p >> 6);
  switch (*plen)
  {
  case 1:
    return *p;
  case 2:
    memcpy(&n, p, 2);
    n.b[0] &= 0x3f;
    return ntohs(n.n16);
  case 4:
    memcpy(&n, p, 4);
    n.b[0] &= 0x3f;
    return ntohl(n.n32);
  case 8:
    memcpy(&n, p, 8);
    n.b[0] &= 0x3f;
    return ((uint64_t)(ntohl((uint32_t)(n.n64))) << 32 | ntohl((uint32_t)((n.n64) >> 32)));
  default:

    (static_cast<bool>(
         0)
         ? void(0)
         : __assert_fail(
               "0", "all.cpp", 28722, __extension__ __PRETTY_FUNCTION__));
  }
  return 0;
}
int64_t ngtcp2_get_pkt_num(const uint8_t *p, size_t pkt_numlen)
{
  switch (pkt_numlen)
  {
  case 1:
    return *p;
  case 2:
    return (int64_t)ngtcp2_get_uint16(p);
  case 3:
    return (int64_t)ngtcp2_get_uint24(p);
  case 4:
    return (int64_t)ngtcp2_get_uint32(p);
  default:

    (static_cast<bool>(
         0)
         ? void(0)
         : __assert_fail(
               "0", "all.cpp", 28740, __extension__ __PRETTY_FUNCTION__));
  }
}
uint8_t *ngtcp2_put_uint64be(uint8_t *p, uint64_t n)
{
  n = ((uint64_t)(ntohl((uint32_t)(n))) << 32 | ntohl((uint32_t)((n) >> 32)));
  return ngtcp2_cpymem(p, (const uint8_t *)&n, sizeof(n));
}
uint8_t *ngtcp2_put_uint48be(uint8_t *p, uint64_t n)
{
  n = ((uint64_t)(ntohl((uint32_t)(n))) << 32 | ntohl((uint32_t)((n) >> 32)));
  return ngtcp2_cpymem(p, ((const uint8_t *)&n) + 2, 6);
}
uint8_t *ngtcp2_put_uint32be(uint8_t *p, uint32_t n)
{
  n = htonl(n);
  return ngtcp2_cpymem(p, (const uint8_t *)&n, sizeof(n));
}
uint8_t *ngtcp2_put_uint24be(uint8_t *p, uint32_t n)
{
  n = htonl(n);
  return ngtcp2_cpymem(p, ((const uint8_t *)&n) + 1, 3);
}
uint8_t *ngtcp2_put_uint16be(uint8_t *p, uint16_t n)
{
  n = htons(n);
  return ngtcp2_cpymem(p, (const uint8_t *)&n, sizeof(n));
}
uint8_t *ngtcp2_put_varint(uint8_t *p, uint64_t n)
{
  uint8_t *rv;
  if (n < 64)
  {
    *p++ = (uint8_t)n;
    return p;
  }
  if (n < 16384)
  {
    rv = ngtcp2_put_uint16be(p, (uint16_t)n);
    *p |= 0x40;
    return rv;
  }
  if (n < 1073741824)
  {
    rv = ngtcp2_put_uint32be(p, (uint32_t)n);
    *p |= 0x80;
    return rv;
  }

  (static_cast<bool>(
       n < 4611686018427387904ULL)
       ? void(0)
       : __assert_fail(
             "n < 4611686018427387904ULL", "all.cpp", 28794, __extension__ __PRETTY_FUNCTION__));
  rv = ngtcp2_put_uint64be(p, n);
  *p |= 0xc0;
  return rv;
}
uint8_t *ngtcp2_put_varint14(uint8_t *p, uint16_t n)
{
  uint8_t *rv;

  (static_cast<bool>(
       n < 16384)
       ? void(0)
       : __assert_fail(
             "n < 16384", "all.cpp", 28803, __extension__ __PRETTY_FUNCTION__));
  rv = ngtcp2_put_uint16be(p, n);
  *p |= 0x40;
  return rv;
}
uint8_t *ngtcp2_put_pkt_num(uint8_t *p, int64_t pkt_num, size_t len)
{
  switch (len)
  {
  case 1:
    *p++ = (uint8_t)pkt_num;
    return p;
  case 2:
    ngtcp2_put_uint16be(p, (uint16_t)pkt_num);
    return p + 2;
  case 3:
    ngtcp2_put_uint24be(p, (uint32_t)pkt_num);
    return p + 3;
  case 4:
    ngtcp2_put_uint32be(p, (uint32_t)pkt_num);
    return p + 4;
  default:

    (static_cast<bool>(
         0)
         ? void(0)
         : __assert_fail(
               "0", "all.cpp", 28826, __extension__ __PRETTY_FUNCTION__));
  }
}
size_t ngtcp2_get_varint_len(const uint8_t *p) { return 1u << (*p >> 6); }
size_t ngtcp2_put_varint_len(uint64_t n)
{
  if (n < 64)
  {
    return 1;
  }
  if (n < 16384)
  {
    return 2;
  }
  if (n < 1073741824)
  {
    return 4;
  }

  (static_cast<bool>(
       n < 4611686018427387904ULL)
       ? void(0)
       : __assert_fail(
             "n < 4611686018427387904ULL", "all.cpp", 28846, __extension__ __PRETTY_FUNCTION__));
  return 8;
}
int64_t ngtcp2_nth_server_bidi_id(uint64_t n)
{
  if (n == 0)
  {
    return 0;
  }
  if ((((1ULL << 62) - 1) >> 2) < n - 1)
  {
    return ((int64_t)0x3ffffffffffffffdll);
  }
  return (int64_t)(((n - 1) << 2) | 0x01);
}
int64_t ngtcp2_nth_client_bidi_id(uint64_t n)
{
  if (n == 0)
  {
    return 0;
  }
  if ((((1ULL << 62) - 1) >> 2) < n - 1)
  {
    return ((int64_t)0x3ffffffffffffffcll);
  }
  return (int64_t)((n - 1) << 2);
}
int64_t ngtcp2_nth_server_uni_id(uint64_t n)
{
  if (n == 0)
  {
    return 0;
  }
  if ((((1ULL << 62) - 1) >> 2) < n - 1)
  {
    return ((int64_t)0x3fffffffffffffffll);
  }
  return (int64_t)(((n - 1) << 2) | 0x03);
}
int64_t ngtcp2_nth_client_uni_id(uint64_t n)
{
  if (n == 0)
  {
    return 0;
  }
  if ((((1ULL << 62) - 1) >> 2) < n - 1)
  {
    return ((int64_t)0x3ffffffffffffffell);
  }
  return (int64_t)(((n - 1) << 2) | 0x02);
}
uint64_t ngtcp2_ord_stream_id(int64_t stream_id)
{
  return (uint64_t)(stream_id >> 2) + 1;
}
int ngtcp2_crypto_km_new(ngtcp2_crypto_km **pckm, const uint8_t *secret,
                         size_t secretlen,
                         const ngtcp2_crypto_aead_ctx *aead_ctx,
                         const uint8_t *iv, size_t ivlen,
                         const ngtcp2_mem *mem)
{
  int rv = ngtcp2_crypto_km_nocopy_new(pckm, secretlen, ivlen, mem);
  if (rv != 0)
  {
    return rv;
  }
  if (secretlen)
  {
    memcpy((*pckm)->secret.base, secret, secretlen);
  }
  if (aead_ctx)
  {
    (*pckm)->aead_ctx = *aead_ctx;
  }
  memcpy((*pckm)->iv.base, iv, ivlen);
  return 0;
}
int ngtcp2_crypto_km_nocopy_new(ngtcp2_crypto_km **pckm, size_t secretlen,
                                size_t ivlen, const ngtcp2_mem *mem)
{
  size_t len;
  uint8_t *p;
  len = sizeof(ngtcp2_crypto_km) + secretlen + ivlen;
  *pckm = ngtcp2_mem_malloc(mem, len);
  if (*pckm ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  p = (uint8_t *)(*pckm) + sizeof(ngtcp2_crypto_km);
  (*pckm)->secret.base = p;
  (*pckm)->secret.len = secretlen;
  p += secretlen;
  (*pckm)->iv.base = p;
  (*pckm)->iv.len = ivlen;
  (*pckm)->aead_ctx.native_handle =
      __null;
  (*pckm)->pkt_num = -1;
  (*pckm)->use_count = 0;
  (*pckm)->flags = NGTCP2_CRYPTO_KM_FLAG_NONE;
  return 0;
}
void ngtcp2_crypto_km_del(ngtcp2_crypto_km *ckm, const ngtcp2_mem *mem)
{
  if (ckm ==
      __null)
  {
    return;
  }
  ngtcp2_mem_free(mem, ckm);
}
void ngtcp2_crypto_create_nonce(uint8_t *dest, const uint8_t *iv, size_t ivlen,
                                int64_t pkt_num)
{
  size_t i;
  uint64_t n;
  memcpy(dest, iv, ivlen);
  n = ((uint64_t)(ntohl((uint32_t)((uint64_t)pkt_num))) << 32 | ntohl((uint32_t)(((uint64_t)pkt_num) >> 32)));
  for (i = 0; i < 8; ++i)
  {
    dest[ivlen - 8 + i] ^= ((uint8_t *)&n)[i];
  }
}
static size_t varint_paramlen(ngtcp2_transport_param_id id, uint64_t param)
{
  size_t valuelen = ngtcp2_put_varint_len(param);
  return ngtcp2_put_varint_len(id) + ngtcp2_put_varint_len(valuelen) + valuelen;
}
static uint8_t *write_varint_param(uint8_t *p, ngtcp2_transport_param_id id,
                                   uint64_t value)
{
  p = ngtcp2_put_varint(p, id);
  p = ngtcp2_put_varint(p, ngtcp2_put_varint_len(value));
  return ngtcp2_put_varint(p, value);
}
static size_t cid_paramlen(ngtcp2_transport_param_id id,
                           const ngtcp2_cid *cid)
{
  return ngtcp2_put_varint_len(id) + ngtcp2_put_varint_len(cid->datalen) +
         cid->datalen;
}
static uint8_t *write_cid_param(uint8_t *p, ngtcp2_transport_param_id id,
                                const ngtcp2_cid *cid)
{

  (static_cast<bool>(
       cid->datalen == 0 || cid->datalen >= 1)
       ? void(0)
       : __assert_fail(
             "cid->datalen == 0 || cid->datalen >= NGTCP2_MIN_CIDLEN", "all.cpp", 29000, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       cid->datalen <= 20)
       ? void(0)
       : __assert_fail(
             "cid->datalen <= NGTCP2_MAX_CIDLEN", "all.cpp", 29001, __extension__ __PRETTY_FUNCTION__));
  p = ngtcp2_put_varint(p, id);
  p = ngtcp2_put_varint(p, cid->datalen);
  if (cid->datalen)
  {
    p = ngtcp2_cpymem(p, cid->data, cid->datalen);
  }
  return p;
}
ngtcp2_ssize
ngtcp2_encode_transport_params(uint8_t *dest, size_t destlen,
                               ngtcp2_transport_params_type exttype,
                               const ngtcp2_transport_params *params)
{
  uint8_t *p;
  size_t len = 0;
  size_t preferred_addrlen = 0;
  switch (exttype)
  {
  case NGTCP2_TRANSPORT_PARAMS_TYPE_CLIENT_HELLO:
    break;
  case NGTCP2_TRANSPORT_PARAMS_TYPE_ENCRYPTED_EXTENSIONS:
    len +=
        cid_paramlen(NGTCP2_TRANSPORT_PARAM_ORIGINAL_DESTINATION_CONNECTION_ID,
                     &params->original_dcid);
    if (params->stateless_reset_token_present)
    {
      len +=
          ngtcp2_put_varint_len(NGTCP2_TRANSPORT_PARAM_STATELESS_RESET_TOKEN) +
          ngtcp2_put_varint_len(16) +
          16;
    }
    if (params->preferred_address_present)
    {

      (static_cast<bool>(
           params->preferred_address.cid.datalen >= 1)
           ? void(0)
           : __assert_fail(
                 "params->preferred_address.cid.datalen >= NGTCP2_MIN_CIDLEN", "all.cpp", 29036, __extension__ __PRETTY_FUNCTION__));

      (static_cast<bool>(
           params->preferred_address.cid.datalen <= 20)
           ? void(0)
           : __assert_fail(
                 "params->preferred_address.cid.datalen <= NGTCP2_MAX_CIDLEN", "all.cpp", 29037, __extension__ __PRETTY_FUNCTION__));
      preferred_addrlen = 4 + 2 +
                          16 + 2 + 1 +
                          params->preferred_address.cid.datalen +
                          16;
      len += ngtcp2_put_varint_len(NGTCP2_TRANSPORT_PARAM_PREFERRED_ADDRESS) +
             ngtcp2_put_varint_len(preferred_addrlen) + preferred_addrlen;
    }
    if (params->retry_scid_present)
    {
      len += cid_paramlen(NGTCP2_TRANSPORT_PARAM_RETRY_SOURCE_CONNECTION_ID,
                          &params->retry_scid);
    }
    break;
  default:
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  len += cid_paramlen(NGTCP2_TRANSPORT_PARAM_INITIAL_SOURCE_CONNECTION_ID,
                      &params->initial_scid);
  if (params->initial_max_stream_data_bidi_local)
  {
    len += varint_paramlen(
        NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_STREAM_DATA_BIDI_LOCAL,
        params->initial_max_stream_data_bidi_local);
  }
  if (params->initial_max_stream_data_bidi_remote)
  {
    len += varint_paramlen(
        NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_STREAM_DATA_BIDI_REMOTE,
        params->initial_max_stream_data_bidi_remote);
  }
  if (params->initial_max_stream_data_uni)
  {
    len += varint_paramlen(NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_STREAM_DATA_UNI,
                           params->initial_max_stream_data_uni);
  }
  if (params->initial_max_data)
  {
    len += varint_paramlen(NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_DATA,
                           params->initial_max_data);
  }
  if (params->initial_max_streams_bidi)
  {
    len += varint_paramlen(NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_STREAMS_BIDI,
                           params->initial_max_streams_bidi);
  }
  if (params->initial_max_streams_uni)
  {
    len += varint_paramlen(NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_STREAMS_UNI,
                           params->initial_max_streams_uni);
  }
  if (params->max_udp_payload_size != 65527)
  {
    len += varint_paramlen(NGTCP2_TRANSPORT_PARAM_MAX_UDP_PAYLOAD_SIZE,
                           params->max_udp_payload_size);
  }
  if (params->ack_delay_exponent != 3)
  {
    len += varint_paramlen(NGTCP2_TRANSPORT_PARAM_ACK_DELAY_EXPONENT,
                           params->ack_delay_exponent);
  }
  if (params->disable_active_migration)
  {
    len +=
        ngtcp2_put_varint_len(NGTCP2_TRANSPORT_PARAM_DISABLE_ACTIVE_MIGRATION) +
        ngtcp2_put_varint_len(0);
  }
  if (params->max_ack_delay != (25 * ((uint64_t)1000000ULL)))
  {
    len += varint_paramlen(NGTCP2_TRANSPORT_PARAM_MAX_ACK_DELAY,
                           params->max_ack_delay / ((uint64_t)1000000ULL));
  }
  if (params->max_idle_timeout)
  {
    len += varint_paramlen(NGTCP2_TRANSPORT_PARAM_MAX_IDLE_TIMEOUT,
                           params->max_idle_timeout / ((uint64_t)1000000ULL));
  }
  if (params->active_connection_id_limit &&
      params->active_connection_id_limit !=
          2)
  {
    len += varint_paramlen(NGTCP2_TRANSPORT_PARAM_ACTIVE_CONNECTION_ID_LIMIT,
                           params->active_connection_id_limit);
  }
  if (destlen < len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = dest;
  if (exttype == NGTCP2_TRANSPORT_PARAMS_TYPE_ENCRYPTED_EXTENSIONS)
  {
    p = write_cid_param(
        p, NGTCP2_TRANSPORT_PARAM_ORIGINAL_DESTINATION_CONNECTION_ID,
        &params->original_dcid);
    if (params->stateless_reset_token_present)
    {
      p = ngtcp2_put_varint(p, NGTCP2_TRANSPORT_PARAM_STATELESS_RESET_TOKEN);
      p = ngtcp2_put_varint(p, sizeof(params->stateless_reset_token));
      p = ngtcp2_cpymem(p, params->stateless_reset_token,
                        sizeof(params->stateless_reset_token));
    }
    if (params->preferred_address_present)
    {
      p = ngtcp2_put_varint(p, NGTCP2_TRANSPORT_PARAM_PREFERRED_ADDRESS);
      p = ngtcp2_put_varint(p, preferred_addrlen);
      p = ngtcp2_cpymem(p, params->preferred_address.ipv4_addr,
                        sizeof(params->preferred_address.ipv4_addr));
      p = ngtcp2_put_uint16be(p, params->preferred_address.ipv4_port);
      p = ngtcp2_cpymem(p, params->preferred_address.ipv6_addr,
                        sizeof(params->preferred_address.ipv6_addr));
      p = ngtcp2_put_uint16be(p, params->preferred_address.ipv6_port);
      *p++ = (uint8_t)params->preferred_address.cid.datalen;
      if (params->preferred_address.cid.datalen)
      {
        p = ngtcp2_cpymem(p, params->preferred_address.cid.data,
                          params->preferred_address.cid.datalen);
      }
      p = ngtcp2_cpymem(
          p, params->preferred_address.stateless_reset_token,
          sizeof(params->preferred_address.stateless_reset_token));
    }
    if (params->retry_scid_present)
    {
      p = write_cid_param(p, NGTCP2_TRANSPORT_PARAM_RETRY_SOURCE_CONNECTION_ID,
                          &params->retry_scid);
    }
  }
  p = write_cid_param(p, NGTCP2_TRANSPORT_PARAM_INITIAL_SOURCE_CONNECTION_ID,
                      &params->initial_scid);
  if (params->initial_max_stream_data_bidi_local)
  {
    p = write_varint_param(
        p, NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_STREAM_DATA_BIDI_LOCAL,
        params->initial_max_stream_data_bidi_local);
  }
  if (params->initial_max_stream_data_bidi_remote)
  {
    p = write_varint_param(
        p, NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_STREAM_DATA_BIDI_REMOTE,
        params->initial_max_stream_data_bidi_remote);
  }
  if (params->initial_max_stream_data_uni)
  {
    p = write_varint_param(p,
                           NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_STREAM_DATA_UNI,
                           params->initial_max_stream_data_uni);
  }
  if (params->initial_max_data)
  {
    p = write_varint_param(p, NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_DATA,
                           params->initial_max_data);
  }
  if (params->initial_max_streams_bidi)
  {
    p = write_varint_param(p, NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_STREAMS_BIDI,
                           params->initial_max_streams_bidi);
  }
  if (params->initial_max_streams_uni)
  {
    p = write_varint_param(p, NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_STREAMS_UNI,
                           params->initial_max_streams_uni);
  }
  if (params->max_udp_payload_size != 65527)
  {
    p = write_varint_param(p, NGTCP2_TRANSPORT_PARAM_MAX_UDP_PAYLOAD_SIZE,
                           params->max_udp_payload_size);
  }
  if (params->ack_delay_exponent != 3)
  {
    p = write_varint_param(p, NGTCP2_TRANSPORT_PARAM_ACK_DELAY_EXPONENT,
                           params->ack_delay_exponent);
  }
  if (params->disable_active_migration)
  {
    p = ngtcp2_put_varint(p, NGTCP2_TRANSPORT_PARAM_DISABLE_ACTIVE_MIGRATION);
    p = ngtcp2_put_varint(p, 0);
  }
  if (params->max_ack_delay != (25 * ((uint64_t)1000000ULL)))
  {
    p = write_varint_param(p, NGTCP2_TRANSPORT_PARAM_MAX_ACK_DELAY,
                           params->max_ack_delay / ((uint64_t)1000000ULL));
  }
  if (params->max_idle_timeout)
  {
    p = write_varint_param(p, NGTCP2_TRANSPORT_PARAM_MAX_IDLE_TIMEOUT,
                           params->max_idle_timeout / ((uint64_t)1000000ULL));
  }
  if (params->active_connection_id_limit &&
      params->active_connection_id_limit !=
          2)
  {
    p = write_varint_param(p, NGTCP2_TRANSPORT_PARAM_ACTIVE_CONNECTION_ID_LIMIT,
                           params->active_connection_id_limit);
  }

  (static_cast<bool>(
       (size_t)(p - dest) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - dest) == len", "all.cpp", 29232, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
static ngtcp2_ssize decode_varint(uint64_t *pdest, const uint8_t *p,
                                  const uint8_t *end)
{
  size_t len;
  if (p == end)
  {
    return -1;
  }
  len = ngtcp2_get_varint_len(p);
  if ((uint64_t)(end - p) < len)
  {
    return -1;
  }
  *pdest = ngtcp2_get_varint(&len, p);
  return (ngtcp2_ssize)len;
}
static ngtcp2_ssize decode_varint_param(uint64_t *pdest, const uint8_t *p,
                                        const uint8_t *end)
{
  const uint8_t *begin = p;
  ngtcp2_ssize nread;
  uint64_t valuelen;
  size_t n;
  nread = decode_varint(&valuelen, p, end);
  if (nread < 0)
  {
    return -1;
  }
  p += nread;
  if (p == end)
  {
    return -1;
  }
  if ((uint64_t)(end - p) < valuelen)
  {
    return -1;
  }
  if (ngtcp2_get_varint_len(p) != valuelen)
  {
    return -1;
  }
  *pdest = ngtcp2_get_varint(&n, p);
  p += valuelen;
  return (ngtcp2_ssize)(p - begin);
}
static ngtcp2_ssize decode_cid_param(ngtcp2_cid *pdest, const uint8_t *p,
                                     const uint8_t *end)
{
  const uint8_t *begin = p;
  uint64_t valuelen;
  ngtcp2_ssize nread = decode_varint(&valuelen, p, end);
  if (nread < 0)
  {
    return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
  }
  p += nread;
  if ((valuelen != 0 && valuelen < 1) ||
      valuelen > 20 || (size_t)(end - p) < valuelen)
  {
    return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
  }
  ngtcp2_cid_init(pdest, p, (size_t)valuelen);
  p += valuelen;
  return (ngtcp2_ssize)(p - begin);
}
int ngtcp2_decode_transport_params(ngtcp2_transport_params *params,
                                   ngtcp2_transport_params_type exttype,
                                   const uint8_t *data, size_t datalen)
{
  const uint8_t *p, *end;
  size_t len;
  uint64_t param_type;
  uint64_t valuelen;
  ngtcp2_ssize nread;
  int initial_scid_present = 0;
  int original_dcid_present = 0;
  p = data;
  end = data + datalen;
  memset(params, 0, sizeof(*params));
  params->initial_max_streams_bidi = 0;
  params->initial_max_streams_uni = 0;
  params->initial_max_stream_data_bidi_local = 0;
  params->initial_max_stream_data_bidi_remote = 0;
  params->initial_max_stream_data_uni = 0;
  params->max_udp_payload_size = 65527;
  params->ack_delay_exponent = 3;
  params->stateless_reset_token_present = 0;
  params->preferred_address_present = 0;
  params->disable_active_migration = 0;
  params->max_ack_delay = (25 * ((uint64_t)1000000ULL));
  params->max_idle_timeout = 0;
  params->active_connection_id_limit =
      2;
  params->retry_scid_present = 0;
  memset(&params->retry_scid, 0, sizeof(params->retry_scid));
  memset(&params->initial_scid, 0, sizeof(params->initial_scid));
  memset(&params->original_dcid, 0, sizeof(params->original_dcid));
  if (datalen == 0)
  {
    return 0;
  }
  for (; (size_t)(end - p) >= 2;)
  {
    nread = decode_varint(&param_type, p, end);
    if (nread < 0)
    {
      return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
    }
    p += nread;
    switch (param_type)
    {
    case NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_STREAM_DATA_BIDI_LOCAL:
      nread = decode_varint_param(&params->initial_max_stream_data_bidi_local,
                                  p, end);
      if (nread < 0)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      p += nread;
      break;
    case NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_STREAM_DATA_BIDI_REMOTE:
      nread = decode_varint_param(&params->initial_max_stream_data_bidi_remote,
                                  p, end);
      if (nread < 0)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      p += nread;
      break;
    case NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_STREAM_DATA_UNI:
      nread = decode_varint_param(&params->initial_max_stream_data_uni, p, end);
      if (nread < 0)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      p += nread;
      break;
    case NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_DATA:
      nread = decode_varint_param(&params->initial_max_data, p, end);
      if (nread < 0)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      p += nread;
      break;
    case NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_STREAMS_BIDI:
      nread = decode_varint_param(&params->initial_max_streams_bidi, p, end);
      if (nread < 0)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      if (params->initial_max_streams_bidi > (1LL << 60))
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      p += nread;
      break;
    case NGTCP2_TRANSPORT_PARAM_INITIAL_MAX_STREAMS_UNI:
      nread = decode_varint_param(&params->initial_max_streams_uni, p, end);
      if (nread < 0)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      if (params->initial_max_streams_uni > (1LL << 60))
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      p += nread;
      break;
    case NGTCP2_TRANSPORT_PARAM_MAX_IDLE_TIMEOUT:
      nread = decode_varint_param(&params->max_idle_timeout, p, end);
      if (nread < 0)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      params->max_idle_timeout *= ((uint64_t)1000000ULL);
      p += nread;
      break;
    case NGTCP2_TRANSPORT_PARAM_MAX_UDP_PAYLOAD_SIZE:
      nread = decode_varint_param(&params->max_udp_payload_size, p, end);
      if (nread < 0)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      p += nread;
      break;
    case NGTCP2_TRANSPORT_PARAM_STATELESS_RESET_TOKEN:
      if (exttype != NGTCP2_TRANSPORT_PARAMS_TYPE_ENCRYPTED_EXTENSIONS)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      nread = decode_varint(&valuelen, p, end);
      if (nread < 0)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      p += nread;
      if ((size_t)valuelen != sizeof(params->stateless_reset_token))
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      if ((size_t)(end - p) < sizeof(params->stateless_reset_token))
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      memcpy(params->stateless_reset_token, p,
             sizeof(params->stateless_reset_token));
      params->stateless_reset_token_present = 1;
      p += sizeof(params->stateless_reset_token);
      break;
    case NGTCP2_TRANSPORT_PARAM_ACK_DELAY_EXPONENT:
      nread = decode_varint_param(&params->ack_delay_exponent, p, end);
      if (nread < 0 || params->ack_delay_exponent > 20)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      p += nread;
      break;
    case NGTCP2_TRANSPORT_PARAM_PREFERRED_ADDRESS:
      if (exttype != NGTCP2_TRANSPORT_PARAMS_TYPE_ENCRYPTED_EXTENSIONS)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      nread = decode_varint(&valuelen, p, end);
      if (nread < 0)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      p += nread;
      if ((size_t)(end - p) < valuelen)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      len = 4 + 2 + 16 +
            2 + 1 + 16;
      if (valuelen < len)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      memcpy(params->preferred_address.ipv4_addr, p,
             sizeof(params->preferred_address.ipv4_addr));
      p += sizeof(params->preferred_address.ipv4_addr);
      params->preferred_address.ipv4_port = ngtcp2_get_uint16(p);
      p += sizeof(uint16_t);
      memcpy(params->preferred_address.ipv6_addr, p,
             sizeof(params->preferred_address.ipv6_addr));
      p += sizeof(params->preferred_address.ipv6_addr);
      params->preferred_address.ipv6_port = ngtcp2_get_uint16(p);
      p += sizeof(uint16_t);
      params->preferred_address.cid.datalen = *p++;
      len += params->preferred_address.cid.datalen;
      if (valuelen != len ||
          params->preferred_address.cid.datalen > 20 ||
          params->preferred_address.cid.datalen < 1)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      if (params->preferred_address.cid.datalen)
      {
        memcpy(params->preferred_address.cid.data, p,
               params->preferred_address.cid.datalen);
        p += params->preferred_address.cid.datalen;
      }
      memcpy(params->preferred_address.stateless_reset_token, p,
             sizeof(params->preferred_address.stateless_reset_token));
      p += sizeof(params->preferred_address.stateless_reset_token);
      params->preferred_address_present = 1;
      break;
    case NGTCP2_TRANSPORT_PARAM_DISABLE_ACTIVE_MIGRATION:
      nread = decode_varint(&valuelen, p, end);
      if (nread < 0 || valuelen != 0)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      p += nread;
      params->disable_active_migration = 1;
      break;
    case NGTCP2_TRANSPORT_PARAM_ORIGINAL_DESTINATION_CONNECTION_ID:
      if (exttype != NGTCP2_TRANSPORT_PARAMS_TYPE_ENCRYPTED_EXTENSIONS)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      nread = decode_cid_param(&params->original_dcid, p, end);
      if (nread < 0)
      {
        return (int)nread;
      }
      original_dcid_present = 1;
      p += nread;
      break;
    case NGTCP2_TRANSPORT_PARAM_RETRY_SOURCE_CONNECTION_ID:
      if (exttype != NGTCP2_TRANSPORT_PARAMS_TYPE_ENCRYPTED_EXTENSIONS)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      nread = decode_cid_param(&params->retry_scid, p, end);
      if (nread < 0)
      {
        return (int)nread;
      }
      params->retry_scid_present = 1;
      p += nread;
      break;
    case NGTCP2_TRANSPORT_PARAM_INITIAL_SOURCE_CONNECTION_ID:
      nread = decode_cid_param(&params->initial_scid, p, end);
      if (nread < 0)
      {
        return (int)nread;
      }
      initial_scid_present = 1;
      p += nread;
      break;
    case NGTCP2_TRANSPORT_PARAM_MAX_ACK_DELAY:
      nread = decode_varint_param(&params->max_ack_delay, p, end);
      if (nread < 0 || params->max_ack_delay >= 16384)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      params->max_ack_delay *= ((uint64_t)1000000ULL);
      p += nread;
      break;
    case NGTCP2_TRANSPORT_PARAM_ACTIVE_CONNECTION_ID_LIMIT:
      nread = decode_varint_param(&params->active_connection_id_limit, p, end);
      if (nread < 0)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      p += nread;
      break;
    default:
      nread = decode_varint(&valuelen, p, end);
      if (nread < 0)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      p += nread;
      if ((size_t)(end - p) < valuelen)
      {
        return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
      }
      p += valuelen;
      break;
    }
  }
  if (end - p != 0)
  {
    return NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM;
  }
  if (!initial_scid_present ||
      (exttype == NGTCP2_TRANSPORT_PARAMS_TYPE_ENCRYPTED_EXTENSIONS &&
       !original_dcid_present))
  {
    return NGTCP2_ERR_REQUIRED_TRANSPORT_PARAM;
  }
  return 0;
}
const char *ngtcp2_strerror(int liberr)
{
  switch (liberr)
  {
  case 0:
    return "NO_ERROR";
  case NGTCP2_ERR_INVALID_ARGUMENT:
    return "ERR_INVALID_ARGUMENT";
  case NGTCP2_ERR_NOBUF:
    return "ERR_NOBUF";
  case NGTCP2_ERR_PROTO:
    return "ERR_PROTO";
  case NGTCP2_ERR_INVALID_STATE:
    return "ERR_INVALID_STATE";
  case NGTCP2_ERR_ACK_FRAME:
    return "ERR_ACK_FRAME";
  case NGTCP2_ERR_STREAM_ID_BLOCKED:
    return "ERR_STREAM_ID_BLOCKED";
  case NGTCP2_ERR_STREAM_IN_USE:
    return "ERR_STREAM_IN_USE";
  case NGTCP2_ERR_STREAM_DATA_BLOCKED:
    return "ERR_STREAM_DATA_BLOCKED";
  case NGTCP2_ERR_FLOW_CONTROL:
    return "ERR_FLOW_CONTROL";
  case NGTCP2_ERR_CONNECTION_ID_LIMIT:
    return "ERR_CONNECTION_ID_LIMIT";
  case NGTCP2_ERR_STREAM_LIMIT:
    return "ERR_STREAM_LIMIT";
  case NGTCP2_ERR_FINAL_SIZE:
    return "ERR_FINAL_SIZE";
  case NGTCP2_ERR_CRYPTO:
    return "ERR_CRYPTO";
  case NGTCP2_ERR_PKT_NUM_EXHAUSTED:
    return "ERR_PKT_NUM_EXHAUSTED";
  case NGTCP2_ERR_NOMEM:
    return "ERR_NOMEM";
  case NGTCP2_ERR_REQUIRED_TRANSPORT_PARAM:
    return "ERR_REQUIRED_TRANSPORT_PARAM";
  case NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM:
    return "ERR_MALFORMED_TRANSPORT_PARAM";
  case NGTCP2_ERR_FRAME_ENCODING:
    return "ERR_FRAME_ENCODING";
  case NGTCP2_ERR_TLS_DECRYPT:
    return "ERR_TLS_DECRYPT";
  case NGTCP2_ERR_STREAM_SHUT_WR:
    return "ERR_STREAM_SHUT_WR";
  case NGTCP2_ERR_STREAM_NOT_FOUND:
    return "ERR_STREAM_NOT_FOUND";
  case NGTCP2_ERR_STREAM_STATE:
    return "ERR_STREAM_STATE";
  case NGTCP2_ERR_RECV_VERSION_NEGOTIATION:
    return "ERR_RECV_VERSION_NEGOTIATION";
  case NGTCP2_ERR_CLOSING:
    return "ERR_CLOSING";
  case NGTCP2_ERR_DRAINING:
    return "ERR_DRAINING";
  case NGTCP2_ERR_TRANSPORT_PARAM:
    return "ERR_TRANSPORT_PARAM";
  case NGTCP2_ERR_DISCARD_PKT:
    return "ERR_DISCARD_PKT";
  case NGTCP2_ERR_PATH_VALIDATION_FAILED:
    return "ERR_PATH_VALIDATION_FAILED";
  case NGTCP2_ERR_CONN_ID_BLOCKED:
    return "ERR_CONN_ID_BLOCKED";
  case NGTCP2_ERR_CALLBACK_FAILURE:
    return "ERR_CALLBACK_FAILURE";
  case NGTCP2_ERR_INTERNAL:
    return "ERR_INTERNAL";
  case NGTCP2_ERR_CRYPTO_BUFFER_EXCEEDED:
    return "ERR_CRYPTO_BUFFER_EXCEEDED";
  case NGTCP2_ERR_WRITE_MORE:
    return "ERR_WRITE_MORE";
  case NGTCP2_ERR_RETRY:
    return "ERR_RETRY";
  case NGTCP2_ERR_DROP_CONN:
    return "ERR_DROP_CONN";
  case NGTCP2_ERR_AEAD_LIMIT_REACHED:
    return "ERR_AEAD_LIMIT_REACHED";
  default:
    return "(unknown)";
  }
}
int ngtcp2_err_is_fatal(int liberr) { return liberr < NGTCP2_ERR_FATAL; }
uint64_t ngtcp2_err_infer_quic_transport_error_code(int liberr)
{
  switch (liberr)
  {
  case 0:
    return 0x0u;
  case NGTCP2_ERR_ACK_FRAME:
  case NGTCP2_ERR_FRAME_ENCODING:
    return 0x7u;
  case NGTCP2_ERR_FLOW_CONTROL:
    return 0x3u;
  case NGTCP2_ERR_CONNECTION_ID_LIMIT:
    return 0x9u;
  case NGTCP2_ERR_STREAM_LIMIT:
    return 0x4u;
  case NGTCP2_ERR_FINAL_SIZE:
    return 0x6u;
  case NGTCP2_ERR_REQUIRED_TRANSPORT_PARAM:
  case NGTCP2_ERR_MALFORMED_TRANSPORT_PARAM:
  case NGTCP2_ERR_TRANSPORT_PARAM:
    return 0x8u;
  case NGTCP2_ERR_INVALID_ARGUMENT:
    return 0x1u;
  case NGTCP2_ERR_STREAM_STATE:
    return 0x5u;
  case NGTCP2_ERR_CRYPTO_BUFFER_EXCEEDED:
    return 0xdu;
  case NGTCP2_ERR_AEAD_LIMIT_REACHED:
    return 0xfu;
  default:
    return 0xau;
  }
}
int ngtcp2_gaptr_init(ngtcp2_gaptr *gaptr, const ngtcp2_mem *mem)
{
  int rv;
  ngtcp2_range range = {0,
                        (18446744073709551615UL)};
  rv = ngtcp2_ksl_init(&gaptr->gap, ngtcp2_ksl_range_compar,
                       sizeof(ngtcp2_range), mem);
  if (rv != 0)
  {
    return rv;
  }
  rv = ngtcp2_ksl_insert(&gaptr->gap,
                         __null, &range,
                         __null);
  if (rv != 0)
  {
    ngtcp2_ksl_free(&gaptr->gap);
    return rv;
  }
  gaptr->mem = mem;
  return 0;
}
void ngtcp2_gaptr_free(ngtcp2_gaptr *gaptr)
{
  if (gaptr ==
      __null)
  {
    return;
  }
  ngtcp2_ksl_free(&gaptr->gap);
}
int ngtcp2_gaptr_push(ngtcp2_gaptr *gaptr, uint64_t offset, size_t datalen)
{
  int rv;
  ngtcp2_range k, m, l, r, q = {offset, offset + datalen};
  ngtcp2_ksl_it it;
  it = ngtcp2_ksl_lower_bound_compar(&gaptr->gap, &q,
                                     ngtcp2_ksl_range_exclusive_compar);
  for (; !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                            __null);)
  {
    k = *(ngtcp2_range *)((ngtcp2_ksl_key *)((ngtcp2_ksl_node *)(void *)(((&it)->blk)->nodes + ((&it)->ksl)->nodelen * ((&it)->i)))->key);
    m = ngtcp2_range_intersect(&q, &k);
    if (!ngtcp2_range_len(&m))
    {
      break;
    }
    if (ngtcp2_range_eq(&k, &m))
    {
      ngtcp2_ksl_remove(&gaptr->gap, &it, &k);
      continue;
    }
    ngtcp2_range_cut(&l, &r, &k, &m);
    if (ngtcp2_range_len(&l))
    {
      ngtcp2_ksl_update_key(&gaptr->gap, &k, &l);
      if (ngtcp2_range_len(&r))
      {
        rv = ngtcp2_ksl_insert(&gaptr->gap, &it, &r,
                               __null);
        if (rv != 0)
        {
          return rv;
        }
      }
    }
    else if (ngtcp2_range_len(&r))
    {
      ngtcp2_ksl_update_key(&gaptr->gap, &k, &r);
    }
    (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0);
  }
  return 0;
}
uint64_t ngtcp2_gaptr_first_gap_offset(ngtcp2_gaptr *gaptr)
{
  ngtcp2_ksl_it it = ngtcp2_ksl_begin(&gaptr->gap);
  ngtcp2_range r = *(ngtcp2_range *)((ngtcp2_ksl_key *)((ngtcp2_ksl_node *)(void *)(((&it)->blk)->nodes + ((&it)->ksl)->nodelen * ((&it)->i)))->key);
  return r.begin;
}
ngtcp2_ksl_it ngtcp2_gaptr_get_first_gap_after(ngtcp2_gaptr *gaptr,
                                               uint64_t offset)
{
  ngtcp2_range q = {offset, offset + 1};
  return ngtcp2_ksl_lower_bound_compar(&gaptr->gap, &q,
                                       ngtcp2_ksl_range_exclusive_compar);
}
int ngtcp2_gaptr_is_pushed(ngtcp2_gaptr *gaptr, uint64_t offset,
                           size_t datalen)
{
  ngtcp2_range q = {offset, offset + datalen};
  ngtcp2_ksl_it it = ngtcp2_ksl_lower_bound_compar(
      &gaptr->gap, &q, ngtcp2_ksl_range_exclusive_compar);
  ngtcp2_range k = *(ngtcp2_range *)((ngtcp2_ksl_key *)((ngtcp2_ksl_node *)(void *)(((&it)->blk)->nodes + ((&it)->ksl)->nodelen * ((&it)->i)))->key);
  ngtcp2_range m = ngtcp2_range_intersect(&q, &k);
  return ngtcp2_range_len(&m) == 0;
}
void ngtcp2_gaptr_drop_first_gap(ngtcp2_gaptr *gaptr)
{
  ngtcp2_ksl_it it = ngtcp2_ksl_begin(&gaptr->gap);
  ngtcp2_range r;

  (static_cast<bool>(
       !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                          __null))
       ? void(0)
       : __assert_fail(
             "!ngtcp2_ksl_it_end(&it)", "all.cpp", 29822, __extension__ __PRETTY_FUNCTION__));
  r = *(ngtcp2_range *)((ngtcp2_ksl_key *)((ngtcp2_ksl_node *)(void *)(((&it)->blk)->nodes + ((&it)->ksl)->nodelen * ((&it)->i)))->key);
  ngtcp2_ksl_remove(&gaptr->gap,
                    __null, &r);
}
int ngtcp2_idtr_init(ngtcp2_idtr *idtr, int server, const ngtcp2_mem *mem)
{
  int rv;
  rv = ngtcp2_gaptr_init(&idtr->gap, mem);
  if (rv != 0)
  {
    return rv;
  }
  idtr->server = server;
  return 0;
}
void ngtcp2_idtr_free(ngtcp2_idtr *idtr)
{
  if (idtr ==
      __null)
  {
    return;
  }
  ngtcp2_gaptr_free(&idtr->gap);
}
int ngtcp2_idtr_open(ngtcp2_idtr *idtr, int64_t stream_id)
{
  uint64_t q;

  (static_cast<bool>(
       (idtr->server && (stream_id % 2)) || (!idtr->server && (stream_id % 2)) == 0)
       ? void(0)
       : __assert_fail(
             "(idtr->server && (stream_id % 2)) || (!idtr->server && (stream_id % 2)) == 0",
             "all.cpp",
             29852, __extension__ __PRETTY_FUNCTION__))

      ;
  q = id_from_stream_id(stream_id);
  if (ngtcp2_gaptr_is_pushed(&idtr->gap, q, 1))
  {
    return NGTCP2_ERR_STREAM_IN_USE;
  }
  return ngtcp2_gaptr_push(&idtr->gap, q, 1);
}
int ngtcp2_idtr_is_open(ngtcp2_idtr *idtr, int64_t stream_id)
{
  uint64_t q;

  (static_cast<bool>(
       (idtr->server && (stream_id % 2)) || (!idtr->server && (stream_id % 2)) == 0)
       ? void(0)
       : __assert_fail(
             "(idtr->server && (stream_id % 2)) || (!idtr->server && (stream_id % 2)) == 0",
             "all.cpp",
             29865, __extension__ __PRETTY_FUNCTION__))

      ;
  q = id_from_stream_id(stream_id);
  return ngtcp2_gaptr_is_pushed(&idtr->gap, q, 1);
}
uint64_t ngtcp2_idtr_first_gap(ngtcp2_idtr *idtr)
{
  return ngtcp2_gaptr_first_gap_offset(&idtr->gap);
}
static void ksl_node_set_key(ngtcp2_ksl *ksl, ngtcp2_ksl_node *node,
                             const void *key)
{
  memcpy(node->key, key, ksl->keylen);
}
int ngtcp2_ksl_init(ngtcp2_ksl *ksl, ngtcp2_ksl_compar compar, size_t keylen,
                    const ngtcp2_mem *mem)
{
  size_t nodelen = ksl_nodelen(keylen);
  size_t blklen = ksl_blklen(nodelen);
  ngtcp2_ksl_blk *head;
  ksl->head = ngtcp2_mem_malloc(mem, blklen);
  if (!ksl->head)
  {
    return NGTCP2_ERR_NOMEM;
  }
  ksl->front = ksl->back = ksl->head;
  ksl->compar = compar;
  ksl->keylen = keylen;
  ksl->nodelen = nodelen;
  ksl->n = 0;
  ksl->mem = mem;
  head = ksl->head;
  head->next = head->prev =
      __null;
  head->n = 0;
  head->leaf = 1;
  return 0;
}
static void ksl_free_blk(ngtcp2_ksl *ksl, ngtcp2_ksl_blk *blk)
{
  size_t i;
  if (!blk->leaf)
  {
    for (i = 0; i < blk->n; ++i)
    {
      ksl_free_blk(ksl, ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)))->blk);
    }
  }
  ngtcp2_mem_free(ksl->mem, blk);
}
void ngtcp2_ksl_free(ngtcp2_ksl *ksl)
{
  if (!ksl)
  {
    return;
  }
  ksl_free_blk(ksl, ksl->head);
}
static ngtcp2_ksl_blk *ksl_split_blk(ngtcp2_ksl *ksl, ngtcp2_ksl_blk *blk)
{
  ngtcp2_ksl_blk *rblk;
  rblk = ngtcp2_mem_malloc(ksl->mem, ksl_blklen(ksl->nodelen));
  if (rblk ==
      __null)
  {
    return __null;
  }
  rblk->next = blk->next;
  blk->next = rblk;
  if (rblk->next)
  {
    rblk->next->prev = rblk;
  }
  else if (ksl->back == blk)
  {
    ksl->back = rblk;
  }
  rblk->prev = blk;
  rblk->leaf = blk->leaf;
  rblk->n = blk->n / 2;
  memcpy(rblk->nodes, blk->nodes + ksl->nodelen * (blk->n - rblk->n),
         ksl->nodelen * rblk->n);
  blk->n -= rblk->n;

  (static_cast<bool>(
       blk->n >= (16 - 1))
       ? void(0)
       : __assert_fail(
             "blk->n >= NGTCP2_KSL_MIN_NBLK", "all.cpp", 29951, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       rblk->n >= (16 - 1))
       ? void(0)
       : __assert_fail(
             "rblk->n >= NGTCP2_KSL_MIN_NBLK", "all.cpp", 29952, __extension__ __PRETTY_FUNCTION__));
  return rblk;
}
static int ksl_split_node(ngtcp2_ksl *ksl, ngtcp2_ksl_blk *blk, size_t i)
{
  ngtcp2_ksl_node *node;
  ngtcp2_ksl_blk *lblk = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)))->blk, *rblk;
  rblk = ksl_split_blk(ksl, lblk);
  if (rblk ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  memmove(blk->nodes + (i + 2) * ksl->nodelen,
          blk->nodes + (i + 1) * ksl->nodelen,
          ksl->nodelen * (blk->n - (i + 1)));
  node = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i + 1)));
  node->blk = rblk;
  ++blk->n;
  ksl_node_set_key(ksl, node, ((ngtcp2_ksl_node *)(void *)((rblk)->nodes + (ksl)->nodelen * (rblk->n - 1)))->key);
  node = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)));
  ksl_node_set_key(ksl, node, ((ngtcp2_ksl_node *)(void *)((lblk)->nodes + (ksl)->nodelen * (lblk->n - 1)))->key);
  return 0;
}
static int ksl_split_head(ngtcp2_ksl *ksl)
{
  ngtcp2_ksl_blk *rblk =
                     __null,
                 *lblk, *nhead = __null;
  ngtcp2_ksl_node *node;
  rblk = ksl_split_blk(ksl, ksl->head);
  if (rblk ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  lblk = ksl->head;
  nhead = ngtcp2_mem_malloc(ksl->mem, ksl_blklen(ksl->nodelen));
  if (nhead ==
      __null)
  {
    ngtcp2_mem_free(ksl->mem, rblk);
    return NGTCP2_ERR_NOMEM;
  }
  nhead->next = nhead->prev =
      __null;
  nhead->n = 2;
  nhead->leaf = 0;
  node = ((ngtcp2_ksl_node *)(void *)((nhead)->nodes + (ksl)->nodelen * (0)));
  ksl_node_set_key(ksl, node, ((ngtcp2_ksl_node *)(void *)((lblk)->nodes + (ksl)->nodelen * (lblk->n - 1)))->key);
  node->blk = lblk;
  node = ((ngtcp2_ksl_node *)(void *)((nhead)->nodes + (ksl)->nodelen * (1)));
  ksl_node_set_key(ksl, node, ((ngtcp2_ksl_node *)(void *)((rblk)->nodes + (ksl)->nodelen * (rblk->n - 1)))->key);
  node->blk = rblk;
  ksl->head = nhead;
  return 0;
}
static void ksl_insert_node(ngtcp2_ksl *ksl, ngtcp2_ksl_blk *blk, size_t i,
                            const ngtcp2_ksl_key *key, void *data)
{
  ngtcp2_ksl_node *node;

  (static_cast<bool>(
       blk->n < (2 * 16 - 1))
       ? void(0)
       : __assert_fail(
             "blk->n < NGTCP2_KSL_MAX_NBLK", "all.cpp", 30010, __extension__ __PRETTY_FUNCTION__));
  memmove(blk->nodes + (i + 1) * ksl->nodelen, blk->nodes + i * ksl->nodelen,
          ksl->nodelen * (blk->n - i));
  node = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)));
  ksl_node_set_key(ksl, node, key);
  node->data = data;
  ++blk->n;
}
static size_t ksl_bsearch(ngtcp2_ksl *ksl, ngtcp2_ksl_blk *blk,
                          const ngtcp2_ksl_key *key, ngtcp2_ksl_compar compar)
{
  ngtcp2_ssize left = -1, right = (ngtcp2_ssize)blk->n, mid;
  ngtcp2_ksl_node *node;
  while (right - left > 1)
  {
    mid = (left + right) / 2;
    node = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * ((size_t)mid)));
    if (compar((ngtcp2_ksl_key *)node->key, key))
    {
      left = mid;
    }
    else
    {
      right = mid;
    }
  }
  return (size_t)right;
}
int ngtcp2_ksl_insert(ngtcp2_ksl *ksl, ngtcp2_ksl_it *it,
                      const ngtcp2_ksl_key *key, void *data)
{
  ngtcp2_ksl_blk *blk = ksl->head;
  ngtcp2_ksl_node *node;
  size_t i;
  int rv;
  if (blk->n == (2 * 16 - 1))
  {
    rv = ksl_split_head(ksl);
    if (rv != 0)
    {
      return rv;
    }
    blk = ksl->head;
  }
  for (;;)
  {
    i = ksl_bsearch(ksl, blk, key, ksl->compar);
    if (blk->leaf)
    {
      if (i < blk->n &&
          !ksl->compar(key, ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)))->key))
      {
        if (it)
        {
          *it = ngtcp2_ksl_end(ksl);
        }
        return NGTCP2_ERR_INVALID_ARGUMENT;
      }
      ksl_insert_node(ksl, blk, i, key, data);
      ++ksl->n;
      if (it)
      {
        ngtcp2_ksl_it_init(it, ksl, blk, i);
      }
      return 0;
    }
    if (i == blk->n)
    {
      for (; !blk->leaf;)
      {
        node = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (blk->n - 1)));
        if (node->blk->n == (2 * 16 - 1))
        {
          rv = ksl_split_node(ksl, blk, blk->n - 1);
          if (rv != 0)
          {
            return rv;
          }
          node = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (blk->n - 1)));
        }
        ksl_node_set_key(ksl, node, key);
        blk = node->blk;
      }
      ksl_insert_node(ksl, blk, blk->n, key, data);
      ++ksl->n;
      if (it)
      {
        ngtcp2_ksl_it_init(it, ksl, blk, blk->n - 1);
      }
      return 0;
    }
    node = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)));
    if (node->blk->n == (2 * 16 - 1))
    {
      rv = ksl_split_node(ksl, blk, i);
      if (rv != 0)
      {
        return rv;
      }
      if (ksl->compar((ngtcp2_ksl_key *)node->key, key))
      {
        node = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i + 1)));
        if (ksl->compar((ngtcp2_ksl_key *)node->key, key))
        {
          ksl_node_set_key(ksl, node, key);
        }
      }
    }
    blk = node->blk;
  }
}
static void ksl_remove_node(ngtcp2_ksl *ksl, ngtcp2_ksl_blk *blk, size_t i)
{
  memmove(blk->nodes + i * ksl->nodelen, blk->nodes + (i + 1) * ksl->nodelen,
          ksl->nodelen * (blk->n - (i + 1)));
  --blk->n;
}
static ngtcp2_ksl_blk *ksl_merge_node(ngtcp2_ksl *ksl, ngtcp2_ksl_blk *blk,
                                      size_t i)
{
  ngtcp2_ksl_blk *lblk, *rblk;

  (static_cast<bool>(
       i + 1 < blk->n)
       ? void(0)
       : __assert_fail(
             "i + 1 < blk->n", "all.cpp", 30135, __extension__ __PRETTY_FUNCTION__));
  lblk = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)))->blk;
  rblk = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i + 1)))->blk;

  (static_cast<bool>(
       lblk->n + rblk->n < (2 * 16 - 1))
       ? void(0)
       : __assert_fail(
             "lblk->n + rblk->n < NGTCP2_KSL_MAX_NBLK", "all.cpp", 30138, __extension__ __PRETTY_FUNCTION__));
  memcpy(lblk->nodes + ksl->nodelen * lblk->n, rblk->nodes,
         ksl->nodelen * rblk->n);
  lblk->n += rblk->n;
  lblk->next = rblk->next;
  if (lblk->next)
  {
    lblk->next->prev = lblk;
  }
  else if (ksl->back == rblk)
  {
    ksl->back = lblk;
  }
  ngtcp2_mem_free(ksl->mem, rblk);
  if (ksl->head == blk && blk->n == 2)
  {
    ngtcp2_mem_free(ksl->mem, ksl->head);
    ksl->head = lblk;
  }
  else
  {
    ksl_remove_node(ksl, blk, i + 1);
    ksl_node_set_key(ksl, ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i))),
                     ((ngtcp2_ksl_node *)(void *)((lblk)->nodes + (ksl)->nodelen * (lblk->n - 1)))->key);
  }
  return lblk;
}
static void ksl_shift_left(ngtcp2_ksl *ksl, ngtcp2_ksl_blk *blk, size_t i)
{
  ngtcp2_ksl_node *lnode, *rnode, *dest, *src;

  (static_cast<bool>(
       i > 0)
       ? void(0)
       : __assert_fail(
             "i > 0", "all.cpp", 30169, __extension__ __PRETTY_FUNCTION__));
  lnode = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i - 1)));
  rnode = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)));

  (static_cast<bool>(
       lnode->blk->n < (2 * 16 - 1))
       ? void(0)
       : __assert_fail(
             "lnode->blk->n < NGTCP2_KSL_MAX_NBLK", "all.cpp", 30172, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       rnode->blk->n > (16 - 1))
       ? void(0)
       : __assert_fail(
             "rnode->blk->n > NGTCP2_KSL_MIN_NBLK", "all.cpp", 30173, __extension__ __PRETTY_FUNCTION__));
  dest = ((ngtcp2_ksl_node *)(void *)((lnode->blk)->nodes + (ksl)->nodelen * (lnode->blk->n)));
  src = ((ngtcp2_ksl_node *)(void *)((rnode->blk)->nodes + (ksl)->nodelen * (0)));
  memcpy(dest, src, ksl->nodelen);
  ksl_node_set_key(ksl, lnode, dest->key);
  ++lnode->blk->n;
  --rnode->blk->n;
  memmove(rnode->blk->nodes, rnode->blk->nodes + ksl->nodelen,
          ksl->nodelen * rnode->blk->n);
}
static void ksl_shift_right(ngtcp2_ksl *ksl, ngtcp2_ksl_blk *blk, size_t i)
{
  ngtcp2_ksl_node *lnode, *rnode, *dest, *src;

  (static_cast<bool>(
       i < blk->n - 1)
       ? void(0)
       : __assert_fail(
             "i < blk->n - 1", "all.cpp", 30187, __extension__ __PRETTY_FUNCTION__));
  lnode = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)));
  rnode = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i + 1)));

  (static_cast<bool>(
       lnode->blk->n > (16 - 1))
       ? void(0)
       : __assert_fail(
             "lnode->blk->n > NGTCP2_KSL_MIN_NBLK", "all.cpp", 30190, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       rnode->blk->n < (2 * 16 - 1))
       ? void(0)
       : __assert_fail(
             "rnode->blk->n < NGTCP2_KSL_MAX_NBLK", "all.cpp", 30191, __extension__ __PRETTY_FUNCTION__));
  memmove(rnode->blk->nodes + ksl->nodelen, rnode->blk->nodes,
          ksl->nodelen * rnode->blk->n);
  ++rnode->blk->n;
  dest = ((ngtcp2_ksl_node *)(void *)((rnode->blk)->nodes + (ksl)->nodelen * (0)));
  src = ((ngtcp2_ksl_node *)(void *)((lnode->blk)->nodes + (ksl)->nodelen * (lnode->blk->n - 1)));
  memcpy(dest, src, ksl->nodelen);
  --lnode->blk->n;
  ksl_node_set_key(
      ksl, lnode, ((ngtcp2_ksl_node *)(void *)((lnode->blk)->nodes + (ksl)->nodelen * (lnode->blk->n - 1)))->key);
}
int ngtcp2_ksl_remove(ngtcp2_ksl *ksl, ngtcp2_ksl_it *it,
                      const ngtcp2_ksl_key *key)
{
  ngtcp2_ksl_blk *blk = ksl->head;
  ngtcp2_ksl_node *node;
  size_t i;
  if (!blk->leaf && blk->n == 2 &&
      ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (0)))->blk->n == (16 - 1) &&
      ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (1)))->blk->n == (16 - 1))
  {
    blk = ksl_merge_node(ksl, ksl->head, 0);
  }
  for (;;)
  {
    i = ksl_bsearch(ksl, blk, key, ksl->compar);
    if (i == blk->n)
    {
      if (it)
      {
        *it = ngtcp2_ksl_end(ksl);
      }
      return NGTCP2_ERR_INVALID_ARGUMENT;
    }
    if (blk->leaf)
    {
      if (ksl->compar(key, ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)))->key))
      {
        if (it)
        {
          *it = ngtcp2_ksl_end(ksl);
        }
        return NGTCP2_ERR_INVALID_ARGUMENT;
      }
      ksl_remove_node(ksl, blk, i);
      --ksl->n;
      if (it)
      {
        if (blk->n == i && blk->next)
        {
          ngtcp2_ksl_it_init(it, ksl, blk->next, 0);
        }
        else
        {
          ngtcp2_ksl_it_init(it, ksl, blk, i);
        }
      }
      return 0;
    }
    node = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)));
    if (node->blk->n == (16 - 1))
    {
      if (i > 0 &&
          ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i - 1)))->blk->n > (16 - 1))
      {
        ksl_shift_right(ksl, blk, i - 1);
        blk = node->blk;
      }
      else if (i + 1 < blk->n &&
               ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i + 1)))->blk->n >
                   (16 - 1))
      {
        ksl_shift_left(ksl, blk, i + 1);
        blk = node->blk;
      }
      else if (i > 0)
      {
        blk = ksl_merge_node(ksl, blk, i - 1);
      }
      else
      {

        (static_cast<bool>(
             i + 1 < blk->n)
             ? void(0)
             : __assert_fail(
                   "i + 1 < blk->n", "all.cpp", 30273, __extension__ __PRETTY_FUNCTION__));
        blk = ksl_merge_node(ksl, blk, i);
      }
    }
    else
    {
      blk = node->blk;
    }
  }
}
ngtcp2_ksl_it ngtcp2_ksl_lower_bound(ngtcp2_ksl *ksl,
                                     const ngtcp2_ksl_key *key)
{
  ngtcp2_ksl_blk *blk = ksl->head;
  ngtcp2_ksl_it it;
  size_t i;
  for (;;)
  {
    i = ksl_bsearch(ksl, blk, key, ksl->compar);
    if (blk->leaf)
    {
      if (i == blk->n && blk->next)
      {
        blk = blk->next;
        i = 0;
      }
      ngtcp2_ksl_it_init(&it, ksl, blk, i);
      return it;
    }
    if (i == blk->n)
    {
      for (; !blk->leaf; blk = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (blk->n - 1)))->blk)
        ;
      if (blk->next)
      {
        blk = blk->next;
        i = 0;
      }
      else
      {
        i = blk->n;
      }
      ngtcp2_ksl_it_init(&it, ksl, blk, i);
      return it;
    }
    blk = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)))->blk;
  }
}
ngtcp2_ksl_it ngtcp2_ksl_lower_bound_compar(ngtcp2_ksl *ksl,
                                            const ngtcp2_ksl_key *key,
                                            ngtcp2_ksl_compar compar)
{
  ngtcp2_ksl_blk *blk = ksl->head;
  ngtcp2_ksl_it it;
  size_t i;
  for (;;)
  {
    i = ksl_bsearch(ksl, blk, key, compar);
    if (blk->leaf)
    {
      if (i == blk->n && blk->next)
      {
        blk = blk->next;
        i = 0;
      }
      ngtcp2_ksl_it_init(&it, ksl, blk, i);
      return it;
    }
    if (i == blk->n)
    {
      for (; !blk->leaf; blk = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (blk->n - 1)))->blk)
        ;
      if (blk->next)
      {
        blk = blk->next;
        i = 0;
      }
      else
      {
        i = blk->n;
      }
      ngtcp2_ksl_it_init(&it, ksl, blk, i);
      return it;
    }
    blk = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)))->blk;
  }
}
void ngtcp2_ksl_update_key(ngtcp2_ksl *ksl, const ngtcp2_ksl_key *old_key,
                           const ngtcp2_ksl_key *new_key)
{
  ngtcp2_ksl_blk *blk = ksl->head;
  ngtcp2_ksl_node *node;
  size_t i;
  for (;;)
  {
    i = ksl_bsearch(ksl, blk, old_key, ksl->compar);

    (static_cast<bool>(
         i < blk->n)
         ? void(0)
         : __assert_fail(
               "i < blk->n", "all.cpp", 30372, __extension__ __PRETTY_FUNCTION__));
    node = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)));
    if (blk->leaf)
    {

      (static_cast<bool>(
           key_equal(ksl->compar, (ngtcp2_ksl_key *)node->key, old_key))
           ? void(0)
           : __assert_fail(
                 "key_equal(ksl->compar, (ngtcp2_ksl_key *)node->key, old_key)", "all.cpp", 30376, __extension__ __PRETTY_FUNCTION__));
      ksl_node_set_key(ksl, node, new_key);
      return;
    }
    if (key_equal(ksl->compar, (ngtcp2_ksl_key *)node->key, old_key) ||
        ksl->compar((ngtcp2_ksl_key *)node->key, new_key))
    {
      ksl_node_set_key(ksl, node, new_key);
    }
    blk = node->blk;
  }
}
static void ksl_print(ngtcp2_ksl *ksl, ngtcp2_ksl_blk *blk, size_t level)
{
  size_t i;
  ngtcp2_ksl_node *node;
  fprintf(
      stderr, "LV=%zu n=%zu\n", level, blk->n);
  if (blk->leaf)
  {
    for (i = 0; i < blk->n; ++i)
    {
      node = ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)));
      fprintf(
          stderr, " %"
                  "l"
                  "d",
          *(int64_t *)(void *)node->key);
    }
    fprintf(
        stderr, "\n");
    return;
  }
  for (i = 0; i < blk->n; ++i)
  {
    ksl_print(ksl, ((ngtcp2_ksl_node *)(void *)((blk)->nodes + (ksl)->nodelen * (i)))->blk, level + 1);
  }
}
size_t ngtcp2_ksl_len(ngtcp2_ksl *ksl) { return ksl->n; }
void ngtcp2_ksl_clear(ngtcp2_ksl *ksl)
{
  size_t i;
  ngtcp2_ksl_blk *head;
  if (!ksl->head->leaf)
  {
    for (i = 0; i < ksl->head->n; ++i)
    {
      ksl_free_blk(ksl, ((ngtcp2_ksl_node *)(void *)((ksl->head)->nodes + (ksl)->nodelen * (i)))->blk);
    }
  }
  ksl->front = ksl->back = ksl->head;
  ksl->n = 0;
  head = ksl->head;
  head->next = head->prev =
      __null;
  head->n = 0;
  head->leaf = 1;
}
void ngtcp2_ksl_print(ngtcp2_ksl *ksl) { ksl_print(ksl, ksl->head, 0); }
ngtcp2_ksl_it ngtcp2_ksl_begin(const ngtcp2_ksl *ksl)
{
  ngtcp2_ksl_it it;
  ngtcp2_ksl_it_init(&it, ksl, ksl->front, 0);
  return it;
}
ngtcp2_ksl_it ngtcp2_ksl_end(const ngtcp2_ksl *ksl)
{
  ngtcp2_ksl_it it;
  ngtcp2_ksl_it_init(&it, ksl, ksl->back, ksl->back->n);
  return it;
}
void ngtcp2_ksl_it_init(ngtcp2_ksl_it *it, const ngtcp2_ksl *ksl,
                        ngtcp2_ksl_blk *blk, size_t i)
{
  it->ksl = ksl;
  it->blk = blk;
  it->i = i;
}
void *ngtcp2_ksl_it_get(const ngtcp2_ksl_it *it)
{

  (static_cast<bool>(
       it->i < it->blk->n)
       ? void(0)
       : __assert_fail(
             "it->i < it->blk->n", "all.cpp", 30457, __extension__ __PRETTY_FUNCTION__));
  return ((ngtcp2_ksl_node *)(void *)((it->blk)->nodes + (it->ksl)->nodelen * (it->i)))->data;
}
void ngtcp2_ksl_it_prev(ngtcp2_ksl_it *it)
{

  (static_cast<bool>(
       !ngtcp2_ksl_it_begin(it))
       ? void(0)
       : __assert_fail(
             "!ngtcp2_ksl_it_begin(it)", "all.cpp", 30463, __extension__ __PRETTY_FUNCTION__));
  if (it->i == 0)
  {
    it->blk = it->blk->prev;
    it->i = it->blk->n - 1;
  }
  else
  {
    --it->i;
  }
}
int ngtcp2_ksl_it_begin(const ngtcp2_ksl_it *it)
{
  return it->i == 0 && it->blk->prev ==
                           __null;
}
int ngtcp2_ksl_range_compar(const ngtcp2_ksl_key *lhs,
                            const ngtcp2_ksl_key *rhs)
{
  const ngtcp2_range *a = lhs, *b = rhs;
  return a->begin < b->begin;
}
int ngtcp2_ksl_range_exclusive_compar(const ngtcp2_ksl_key *lhs,
                                      const ngtcp2_ksl_key *rhs)
{
  const ngtcp2_range *a = lhs, *b = rhs;
  return a->begin < b->begin &&
         !(((a->begin) > (b->begin) ? (a->begin) : (b->begin)) < ((a->end) < (b->end) ? (a->end) : (b->end)));
}
void ngtcp2_log_init(ngtcp2_log *log, const ngtcp2_cid *scid,
                     ngtcp2_printf log_printf, ngtcp2_tstamp ts,
                     void *user_data)
{
  if (scid)
  {
    ngtcp2_encode_hex(log->scid, scid->data, scid->datalen);
  }
  else
  {
    log->scid[0] = '\0';
  }
  log->log_printf = log_printf;
  log->ts = log->last_ts = ts;
  log->user_data = user_data;
}
static const char *strerrorcode(uint64_t error_code)
{
  switch (error_code)
  {
  case 0x0u:
    return "NO_ERROR";
  case 0x1u:
    return "INTERNAL_ERROR";
  case 0x2u:
    return "CONNECTION_REFUSED";
  case 0x3u:
    return "FLOW_CONTROL_ERROR";
  case 0x4u:
    return "STREAM_LIMIT_ERROR";
  case 0x5u:
    return "STREAM_STATE_ERROR";
  case 0x6u:
    return "FINAL_SIZE_ERROR";
  case 0x7u:
    return "FRAME_ENCODING_ERROR";
  case 0x8u:
    return "TRANSPORT_PARAMETER_ERROR";
  case 0x9u:
    return "CONNECTION_ID_LIMIT_ERROR";
  case 0xau:
    return "PROTOCOL_VIOLATION";
  case 0xbu:
    return "INVALID_TOKEN";
  case 0xcu:
    return "APPLICATION_ERROR";
  case 0xdu:
    return "CRYPTO_BUFFER_EXCEEDED";
  case 0xeu:
    return "KEY_UPDATE_ERROR";
  default:
    if (0x100u <= error_code && error_code <= 0x1ffu)
    {
      return "CRYPTO_ERROR";
    }
    return "(unknown)";
  }
}
static const char *strapperrorcode(uint64_t app_error_code)
{
  (void)app_error_code;
  return "(unknown)";
}
static const char *strpkttype_long(uint8_t type)
{
  switch (type)
  {
  case NGTCP2_PKT_VERSION_NEGOTIATION:
    return "VN";
  case NGTCP2_PKT_INITIAL:
    return "Initial";
  case NGTCP2_PKT_RETRY:
    return "Retry";
  case NGTCP2_PKT_HANDSHAKE:
    return "Handshake";
  case NGTCP2_PKT_0RTT:
    return "0RTT";
  default:
    return "(unknown)";
  }
}
static const char *strpkttype(const ngtcp2_pkt_hd *hd)
{
  if (hd->flags & NGTCP2_PKT_FLAG_LONG_FORM)
  {
    return strpkttype_long(hd->type);
  }
  return "Short";
}
static const char *strevent(ngtcp2_log_event ev)
{
  switch (ev)
  {
  case NGTCP2_LOG_EVENT_CON:
    return "con";
  case NGTCP2_LOG_EVENT_PKT:
    return "pkt";
  case NGTCP2_LOG_EVENT_FRM:
    return "frm";
  case NGTCP2_LOG_EVENT_RCV:
    return "rcv";
  case NGTCP2_LOG_EVENT_CRY:
    return "cry";
  case NGTCP2_LOG_EVENT_PTV:
    return "ptv";
  case NGTCP2_LOG_EVENT_NONE:
  default:
    return "non";
  }
}
static uint64_t timestamp_cast(uint64_t ns) { return ns / ((uint64_t)1000000ULL); }
static void log_fr_stream(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                          const ngtcp2_stream *fr, const char *dir)
{
  // log->log_printf(log->user_data,("I%08""l""u"" 0x%s %s"" %s %""l""d"" %s(0x%02x)"" STREAM(0x%02x) id=0x%""l""x"" fin=%d offset=%""l""u"" len=%zu uni=%d"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type | fr->flags,fr->stream_id, fr->fin, fr->offset,ngtcp2_vec_len(fr->data, fr->datacnt),(fr->stream_id & 0x2) != 0);
}
static void log_fr_ack(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                       const ngtcp2_ack *fr, const char *dir)
{
  int64_t largest_ack, min_ack;
  size_t i;
  // log->log_printf(log->user_data,("I%08""l""u"" 0x%s %s"" %s %""l""d"" %s(0x%02x)"" ACK(0x%02x) largest_ack=%""l""d"" ack_delay=%""l""u""(%""l""u"") ack_block_count=%zu"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type, fr->largest_ack,fr->ack_delay_unscaled / ((uint64_t)1000000ULL), fr->ack_delay,fr->num_blks);
  largest_ack = fr->largest_ack;
  min_ack = fr->largest_ack - (int64_t)fr->first_ack_blklen;
  log->log_printf(log->user_data,
                  ("I%08"
                   "l"
                   "u"
                   " 0x%s %s"
                   " %s %"
                   "l"
                   "d"
                   " %s(0x%02x)"
                   " ACK(0x%02x) block=[%"
                   "l"
                   "d"
                   "..%"
                   "l"
                   "d"

                   "] block_count=%"
                   "l"
                   "u"),
                  timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type, largest_ack, min_ack,
                  fr->first_ack_blklen);
  for (i = 0; i < fr->num_blks; ++i)
  {
    const ngtcp2_ack_blk *blk = &fr->blks[i];
    largest_ack = min_ack - (int64_t)blk->gap - 2;
    min_ack = largest_ack - (int64_t)blk->blklen;
    log->log_printf(log->user_data,
                    ("I%08"
                     "l"
                     "u"
                     " 0x%s %s"
                     " %s %"
                     "l"
                     "d"
                     " %s(0x%02x)"
                     " ACK(0x%02x) block=[%"
                     "l"
                     "d"
                     "..%"
                     "l"
                     "d"

                     "] gap=%"
                     "l"
                     "u"
                     " block_count=%"
                     "l"
                     "u"),
                    timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type, largest_ack,
                    min_ack, blk->gap, blk->blklen);
  }
  if (fr->type == NGTCP2_FRAME_ACK_ECN)
  {
    // log->log_printf(log->user_data,("I%08""l""u"" 0x%s %s"" %s %""l""d"" %s(0x%02x)"" ACK(0x%02x) ect0=%""l""u"" ect1=%""l""u"" ce=%""l""u"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type, fr->ecn.ect0,fr->ecn.ect1, fr->ecn.ce);
  }
}
static void log_fr_padding(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                           const ngtcp2_padding *fr, const char *dir)
{
  log->log_printf(log->user_data, ("I%08"
                                   "l"
                                   "u"
                                   " 0x%s %s"
                                   " %s %"
                                   "l"
                                   "d"
                                   " %s(0x%02x)"
                                   " PADDING(0x%02x) len=%zu"),
                  timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type, fr->len);
}
static void log_fr_reset_stream(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                                const ngtcp2_reset_stream *fr,
                                const char *dir)
{
  log->log_printf(
      log->user_data,
      ("I%08"
       "l"
       "u"
       " 0x%s %s"
       " %s %"
       "l"
       "d"
       " %s(0x%02x)"
       " RESET_STREAM(0x%02x) id=0x%"
       "l"
       "x"

       " app_error_code=%s(0x%"
       "l"
       "x"
       ") final_size=%"
       "l"
       "u"),
      timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type, fr->stream_id,
      strapperrorcode(fr->app_error_code), fr->app_error_code, fr->final_size);
}
static void log_fr_connection_close(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                                    const ngtcp2_connection_close *fr,
                                    const char *dir)
{
  char reason[256];
  size_t reasonlen = ((sizeof(reason) - 1) < (fr->reasonlen) ? (sizeof(reason) - 1) : (fr->reasonlen));
  log->log_printf(log->user_data,
                  ("I%08"
                   "l"
                   "u"
                   " 0x%s %s"
                   " %s %"
                   "l"
                   "d"
                   " %s(0x%02x)"
                   " CONNECTION_CLOSE(0x%02x) error_code=%s(0x%"
                   "l"
                   "x"
                   ") "
                   "frame_type=%"
                   "l"
                   "x"
                   " reason_len=%zu reason=[%s]"),
                  timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type,
                  fr->type == NGTCP2_FRAME_CONNECTION_CLOSE
                      ? strerrorcode(fr->error_code)
                      : strapperrorcode(fr->error_code),
                  fr->error_code, fr->frame_type, fr->reasonlen,
                  ngtcp2_encode_printable_ascii(reason, fr->reason, reasonlen));
}
static void log_fr_max_data(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                            const ngtcp2_max_data *fr, const char *dir)
{
  log->log_printf(log->user_data,
                  ("I%08"
                   "l"
                   "u"
                   " 0x%s %s"
                   " %s %"
                   "l"
                   "d"
                   " %s(0x%02x)"
                   " MAX_DATA(0x%02x) max_data=%"
                   "l"
                   "u"),
                  timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type, fr->max_data);
}
static void log_fr_max_stream_data(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                                   const ngtcp2_max_stream_data *fr,
                                   const char *dir)
{
  log->log_printf(log->user_data,
                  ("I%08"
                   "l"
                   "u"
                   " 0x%s %s"
                   " %s %"
                   "l"
                   "d"
                   " %s(0x%02x)"
                   " MAX_STREAM_DATA(0x%02x) id=0x%"
                   "l"
                   "x"

                   " max_stream_data=%"
                   "l"
                   "u"),
                  timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type, fr->stream_id,
                  fr->max_stream_data);
}
static void log_fr_max_streams(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                               const ngtcp2_max_streams *fr, const char *dir)
{
  log->log_printf(log->user_data,
                  ("I%08"
                   "l"
                   "u"
                   " 0x%s %s"
                   " %s %"
                   "l"
                   "d"
                   " %s(0x%02x)"
                   " MAX_STREAMS(0x%02x) max_streams=%"
                   "l"
                   "u"),
                  timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type, fr->max_streams);
}
static void log_fr_ping(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                        const ngtcp2_ping *fr, const char *dir)
{
  log->log_printf(log->user_data, ("I%08"
                                   "l"
                                   "u"
                                   " 0x%s %s"
                                   " %s %"
                                   "l"
                                   "d"
                                   " %s(0x%02x)"
                                   " PING(0x%02x)"),
                  timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type);
}
static void log_fr_data_blocked(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                                const ngtcp2_data_blocked *fr,
                                const char *dir)
{
  log->log_printf(log->user_data,
                  ("I%08"
                   "l"
                   "u"
                   " 0x%s %s"
                   " %s %"
                   "l"
                   "d"
                   " %s(0x%02x)"
                   " DATA_BLOCKED(0x%02x) offset=%"
                   "l"
                   "u"),
                  timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type, fr->offset);
}
static void log_fr_stream_data_blocked(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                                       const ngtcp2_stream_data_blocked *fr,
                                       const char *dir)
{
  log->log_printf(log->user_data,
                  ("I%08"
                   "l"
                   "u"
                   " 0x%s %s"
                   " %s %"
                   "l"
                   "d"
                   " %s(0x%02x)"
                   " STREAM_DATA_BLOCKED(0x%02x) id=0x%"
                   "l"
                   "x"

                   " offset=%"
                   "l"
                   "u"),
                  timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type, fr->stream_id,
                  fr->offset);
}
static void log_fr_streams_blocked(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                                   const ngtcp2_streams_blocked *fr,
                                   const char *dir)
{
  log->log_printf(
      log->user_data,
      ("I%08"
       "l"
       "u"
       " 0x%s %s"
       " %s %"
       "l"
       "d"
       " %s(0x%02x)"
       " STREAMS_BLOCKED(0x%02x) stream_limit=%"
       "l"
       "u"),
      timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type, fr->stream_limit);
}
static void log_fr_new_connection_id(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                                     const ngtcp2_new_connection_id *fr,
                                     const char *dir)
{
  uint8_t buf[sizeof(fr->stateless_reset_token) * 2 + 1];
  uint8_t cid[sizeof(fr->cid.data) * 2 + 1];
  // log->log_printf(log->user_data,("I%08""l""u"" 0x%s %s"" %s %""l""d"" %s(0x%02x)"" NEW_CONNECTION_ID(0x%02x) seq=%""l""u"" cid=0x%s retire_prior_to=%""l""u"" stateless_reset_token=0x%s"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type, fr->seq,(const char *)ngtcp2_encode_hex(cid, fr->cid.data, fr->cid.datalen),fr->retire_prior_to,(const char *)ngtcp2_encode_hex(buf, fr->stateless_reset_token,sizeof(fr->stateless_reset_token)));
}
static void log_fr_stop_sending(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                                const ngtcp2_stop_sending *fr,
                                const char *dir)
{
  // log->log_printf(log->user_data,("I%08""l""u"" 0x%s %s"" %s %""l""d"" %s(0x%02x)"" STOP_SENDING(0x%02x) id=0x%""l""x"" app_error_code=%s(0x%""l""x"")"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type, fr->stream_id,strapperrorcode(fr->app_error_code), fr->app_error_code);
}
static void log_fr_path_challenge(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                                  const ngtcp2_path_challenge *fr,
                                  const char *dir)
{
  uint8_t buf[sizeof(fr->data) * 2 + 1];
  // log->log_printf(log->user_data, ("I%08""l""u"" 0x%s %s"" %s %""l""d"" %s(0x%02x)"" PATH_CHALLENGE(0x%02x) data=0x%s"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type,(const char *)ngtcp2_encode_hex(buf, fr->data, sizeof(fr->data)));
}
static void log_fr_path_response(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                                 const ngtcp2_path_response *fr,
                                 const char *dir)
{
  uint8_t buf[sizeof(fr->data) * 2 + 1];
  // log->log_printf(log->user_data, ("I%08""l""u"" 0x%s %s"" %s %""l""d"" %s(0x%02x)"" PATH_RESPONSE(0x%02x) data=0x%s"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type,(const char *)ngtcp2_encode_hex(buf, fr->data, sizeof(fr->data)));
  }
static void log_fr_crypto(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                          const ngtcp2_crypto *fr, const char *dir)
{
  size_t datalen = 0;
  size_t i;
  for (i = 0; i < fr->datacnt; ++i)
  {
    datalen += fr->data[i].len;
  }
  // log->log_printf(log->user_data,("I%08""l""u"" 0x%s %s"" %s %""l""d"" %s(0x%02x)"" CRYPTO(0x%02x) offset=%""l""u"" len=%""l""u"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type, fr->offset, datalen);
}
static void log_fr_new_token(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                             const ngtcp2_new_token *fr, const char *dir)
{
  uint8_t buf[128 + 1 + 1];
  uint8_t *p;
  if (fr->token.len > 64)
  {
    p = ngtcp2_encode_hex(buf, fr->token.base, 64);
    p[128] = '*';
    p[129] = '\0';
  }
  else
  {
    p = ngtcp2_encode_hex(buf, fr->token.base, fr->token.len);
  }
  // log->log_printf(log->user_data, ("I%08lu 0x%s %s %s %ld %s(0x%02x) NEW_TOKEN(0x%02x) token=0x%s len=%zu"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type, (const char *)p, fr->token.len);
}
static void log_fr_retire_connection_id(ngtcp2_log *log,
                                        const ngtcp2_pkt_hd *hd,
                                        const ngtcp2_retire_connection_id *fr,
                                        const char *dir)
{
  // log->log_printf(log->user_data,("I%08lu 0x%s %s %s %ld %s(0x%02x) RETIRE_CONNECTION_ID(0x%02x) seq=%lu"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type, fr->seq);
}
static void log_fr_handshake_done(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                                  const ngtcp2_handshake_done *fr,
                                  const char *dir)
{
  // log->log_printf(log->user_data, ("I%08lu 0x%s %s %s %ld %s(0x%02x) HANDSHAKE_DONE(0x%02x)"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "frm", (dir), hd->pkt_num, strpkttype(hd), hd->type, fr->type);
}
static void log_fr(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                   const ngtcp2_frame *fr, const char *dir)
{
  switch (fr->type)
  {
  case NGTCP2_FRAME_STREAM:
    log_fr_stream(log, hd, &fr->stream, dir);
    break;
  case NGTCP2_FRAME_ACK:
  case NGTCP2_FRAME_ACK_ECN:
    log_fr_ack(log, hd, &fr->ack, dir);
    break;
  case NGTCP2_FRAME_PADDING:
    log_fr_padding(log, hd, &fr->padding, dir);
    break;
  case NGTCP2_FRAME_RESET_STREAM:
    log_fr_reset_stream(log, hd, &fr->reset_stream, dir);
    break;
  case NGTCP2_FRAME_CONNECTION_CLOSE:
  case NGTCP2_FRAME_CONNECTION_CLOSE_APP:
    log_fr_connection_close(log, hd, &fr->connection_close, dir);
    break;
  case NGTCP2_FRAME_MAX_DATA:
    log_fr_max_data(log, hd, &fr->max_data, dir);
    break;
  case NGTCP2_FRAME_MAX_STREAM_DATA:
    log_fr_max_stream_data(log, hd, &fr->max_stream_data, dir);
    break;
  case NGTCP2_FRAME_MAX_STREAMS_BIDI:
  case NGTCP2_FRAME_MAX_STREAMS_UNI:
    log_fr_max_streams(log, hd, &fr->max_streams, dir);
    break;
  case NGTCP2_FRAME_PING:
    log_fr_ping(log, hd, &fr->ping, dir);
    break;
  case NGTCP2_FRAME_DATA_BLOCKED:
    log_fr_data_blocked(log, hd, &fr->data_blocked, dir);
    break;
  case NGTCP2_FRAME_STREAM_DATA_BLOCKED:
    log_fr_stream_data_blocked(log, hd, &fr->stream_data_blocked, dir);
    break;
  case NGTCP2_FRAME_STREAMS_BLOCKED_BIDI:
  case NGTCP2_FRAME_STREAMS_BLOCKED_UNI:
    log_fr_streams_blocked(log, hd, &fr->streams_blocked, dir);
    break;
  case NGTCP2_FRAME_NEW_CONNECTION_ID:
    log_fr_new_connection_id(log, hd, &fr->new_connection_id, dir);
    break;
  case NGTCP2_FRAME_STOP_SENDING:
    log_fr_stop_sending(log, hd, &fr->stop_sending, dir);
    break;
  case NGTCP2_FRAME_PATH_CHALLENGE:
    log_fr_path_challenge(log, hd, &fr->path_challenge, dir);
    break;
  case NGTCP2_FRAME_PATH_RESPONSE:
    log_fr_path_response(log, hd, &fr->path_response, dir);
    break;
  case NGTCP2_FRAME_CRYPTO:
    log_fr_crypto(log, hd, &fr->crypto, dir);
    break;
  case NGTCP2_FRAME_NEW_TOKEN:
    log_fr_new_token(log, hd, &fr->new_token, dir);
    break;
  case NGTCP2_FRAME_RETIRE_CONNECTION_ID:
    log_fr_retire_connection_id(log, hd, &fr->retire_connection_id, dir);
    break;
  case NGTCP2_FRAME_HANDSHAKE_DONE:
    log_fr_handshake_done(log, hd, &fr->handshake_done, dir);
    break;
  default:

    (static_cast<bool>(
         0)
         ? void(0)
         : __assert_fail(
               "0", "all.cpp", 30952, __extension__ __PRETTY_FUNCTION__));
  }
}
void ngtcp2_log_rx_fr(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                      const ngtcp2_frame *fr)
{
  if (!log->log_printf)
  {
    return;
  }
  log_fr(log, hd, fr, "rx");
}
void ngtcp2_log_tx_fr(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                      const ngtcp2_frame *fr)
{
  if (!log->log_printf)
  {
    return;
  }
  log_fr(log, hd, fr, "tx");
}
void ngtcp2_log_rx_vn(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                      const uint32_t *sv, size_t nsv)
{
  size_t i;
  if (!log->log_printf)
  {
    return;
  }
  for (i = 0; i < nsv; ++i)
  {
    // log->log_printf(log->user_data, ("I%08lu 0x%s %s %s %ld %s(0x%02x) v=0x%08x"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "pkt", ("rx"), hd->pkt_num, strpkttype(hd), hd->type, sv[i]);
  }
}
void ngtcp2_log_rx_sr(ngtcp2_log *log, const ngtcp2_pkt_stateless_reset *sr)
{
  uint8_t buf[sizeof(sr->stateless_reset_token) * 2 + 1];
  ngtcp2_pkt_hd shd;
  ngtcp2_pkt_hd *hd = &shd;
  if (!log->log_printf)
  {
    return;
  }
  memset(&shd, 0, sizeof(shd));
  // log->log_printf(log->user_data, ("I%08lu 0x%s %s %s %ld %s(0x%02x) token=0x%s randlen=%zu"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "pkt", ("rx"), hd->pkt_num, strpkttype(hd), hd->type,(const char *)ngtcp2_encode_hex(buf, sr->stateless_reset_token,sizeof(sr->stateless_reset_token)),sr->randlen);
}
void ngtcp2_log_remote_tp(ngtcp2_log *log, uint8_t exttype,
                          const ngtcp2_transport_params *params)
{
  uint8_t token[16 * 2 + 1];
  uint8_t addr[16 * 2 + 7 + 1];
  uint8_t cid[20 * 2 + 1];
  if (!log->log_printf)
  {
    return;
  }
  if (exttype == NGTCP2_TRANSPORT_PARAMS_TYPE_ENCRYPTED_EXTENSIONS)
  {
    if (params->stateless_reset_token_present)
    {
      // log->log_printf(log->user_data,("I%08lu 0x%s %s remote transport_parameters stateless_reset_token=0x%s"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry",(const char *)ngtcp2_encode_hex(token, params->stateless_reset_token,sizeof(params->stateless_reset_token)));
    }
    if (params->preferred_address_present)
    {
      // log->log_printf(log->user_data,("I%08lu 0x%s %s remote transport_parameters preferred_address.ipv4_addr=%s"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry",(const char *)ngtcp2_encode_ipv4(addr, params->preferred_address.ipv4_addr));
      // log->log_printf(log->user_data, ("I%08""l""u"" 0x%s %s"" remote transport_parameters"" preferred_address.ipv4_port=%u"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry", params->preferred_address.ipv4_port);
      // log->log_printf(log->user_data,("I%08""l""u"" 0x%s %s"" remote transport_parameters"" preferred_address.ipv6_addr=%s"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry",(const char *)ngtcp2_encode_ipv6(addr, params->preferred_address.ipv6_addr));
      // log->log_printf(log->user_data, ("I%08""l""u"" 0x%s %s"" remote transport_parameters"" preferred_address.ipv6_port=%u"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry", params->preferred_address.ipv6_port);
      // log->log_printf(log->user_data,("I%08""l""u"" 0x%s %s"" remote transport_parameters"" preferred_address.cid=0x%s"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry",(const char *)ngtcp2_encode_hex(cid, params->preferred_address.cid.data,params->preferred_address.cid.datalen));
      // log->log_printf(log->user_data,("I%08""l""u"" 0x%s %s"" remote transport_parameters"" preferred_address.stateless_reset_token=0x%s"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry",(const char *)ngtcp2_encode_hex(token, params->preferred_address.stateless_reset_token,sizeof(params->preferred_address.stateless_reset_token)));
    }
    // log->log_printf(log->user_data,("I%08""l""u"" 0x%s %s"" remote transport_parameters"" original_destination_connection_id=0x%s"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry",(const char *)ngtcp2_encode_hex(cid, params->original_dcid.data,params->original_dcid.datalen));
    if (params->retry_scid_present)
    {
      // log->log_printf(log->user_data, ("I%08""l""u"" 0x%s %s"" remote transport_parameters"" retry_source_connection_id=0x%s"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry",(const char *)ngtcp2_encode_hex(cid, params->retry_scid.data,params->retry_scid.datalen));
    }
  }
  // log->log_printf(log->user_data, ("I%08""l""u"" 0x%s %s"" remote transport_parameters"" initial_source_connection_id=0x%s"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry",(const char *)ngtcp2_encode_hex(cid, params->initial_scid.data,params->initial_scid.datalen));
  // log->log_printf(log->user_data,("I%08""l""u"" 0x%s %s"" remote transport_parameters"" initial_max_stream_data_bidi_local=%""l""u"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry", params->initial_max_stream_data_bidi_local);
  // log->log_printf(log->user_data,("I%08""l""u"" 0x%s %s"" remote transport_parameters"" initial_max_stream_data_bidi_remote=%""l""u"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry", params->initial_max_stream_data_bidi_remote);
  // log->log_printf(log->user_data,("I%08""l""u"" 0x%s %s"" remote transport_parameters"" initial_max_stream_data_uni=%""l""u"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry", params->initial_max_stream_data_uni);
  // log->log_printf(log->user_data, ("I%08""l""u"" 0x%s %s"" remote transport_parameters"" initial_max_data=%""l""u"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry", params->initial_max_data);
  // log->log_printf(log->user_data,("I%08""l""u"" 0x%s %s"" remote transport_parameters"" initial_max_bidi_streams=%""l""u"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry", params->initial_max_streams_bidi);
  // log->log_printf(log->user_data,("I%08""l""u"" 0x%s %s"" remote transport_parameters"" initial_max_uni_streams=%""l""u"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry", params->initial_max_streams_uni);
  // log->log_printf(log->user_data, ("I%08""l""u"" 0x%s %s"" remote transport_parameters"" max_idle_timeout=%""l""u"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry",params->max_idle_timeout / ((uint64_t)1000000ULL));
  // log->log_printf(log->user_data,("I%08""l""u"" 0x%s %s"" remote transport_parameters"" max_udp_payload_size=%""l""u"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry", params->max_udp_payload_size);
  // log->log_printf(log->user_data,("I%08""l""u"" 0x%s %s"" remote transport_parameters"" ack_delay_exponent=%""l""u"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry", params->ack_delay_exponent);
  // log->log_printf(log->user_data, ("I%08""l""u"" 0x%s %s"" remote transport_parameters"" max_ack_delay=%""l""u"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry",params->max_ack_delay / ((uint64_t)1000000ULL));
  // log->log_printf(log->user_data,("I%08""l""u"" 0x%s %s"" remote transport_parameters"" active_connection_id_limit=%""l""u"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry", params->active_connection_id_limit);
  // log->log_printf(log->user_data,("I%08""l""u"" 0x%s %s"" remote transport_parameters"" disable_active_migration=%d"),timestamp_cast(log->last_ts - log->ts), (const char *)log->scid, "cry", params->disable_active_migration);
}
void ngtcp2_log_pkt_lost(ngtcp2_log *log, int64_t pkt_num, uint8_t type,
                         uint8_t flags, ngtcp2_tstamp sent_ts)
{
  if (!log->log_printf)
  {
    return;
  }
  ngtcp2_log_info(log, NGTCP2_LOG_EVENT_RCV,"pkn=%""l""d"" lost type=%s(0x%02x) sent_ts=%""l""u",pkt_num,(flags & NGTCP2_PKT_FLAG_LONG_FORM) ? strpkttype_long(type) : "Short",type, sent_ts);
}
static void log_pkt_hd(ngtcp2_log *log, const ngtcp2_pkt_hd *hd,
                       const char *dir)
{
  uint8_t dcid[sizeof(hd->dcid.data) * 2 + 1];
  uint8_t scid[sizeof(hd->scid.data) * 2 + 1];
  if (!log->log_printf)
  {
    return;
  }
  ngtcp2_log_info(
      log, NGTCP2_LOG_EVENT_PKT,
      "%s pkn=%"
      "l"
      "d"
      " dcid=0x%s scid=0x%s type=%s(0x%02x) len=%zu k=%d",
      dir, hd->pkt_num,
      (const char *)ngtcp2_encode_hex(dcid, hd->dcid.data, hd->dcid.datalen),
      (const char *)ngtcp2_encode_hex(scid, hd->scid.data, hd->scid.datalen),
      (hd->flags & NGTCP2_PKT_FLAG_LONG_FORM) ? strpkttype_long(hd->type)
                                              : "Short",
      hd->type, hd->len, (hd->flags & NGTCP2_PKT_FLAG_KEY_PHASE) != 0);
}
void ngtcp2_log_rx_pkt_hd(ngtcp2_log *log, const ngtcp2_pkt_hd *hd)
{
  log_pkt_hd(log, hd, "rx");
}
void ngtcp2_log_tx_pkt_hd(ngtcp2_log *log, const ngtcp2_pkt_hd *hd)
{
  log_pkt_hd(log, hd, "tx");
}
void ngtcp2_log_info(ngtcp2_log *log, ngtcp2_log_event ev, const char *fmt,
                     ...)
{
  va_list ap;
  int n;
  char buf[4096];
  if (!log->log_printf)
  {
    return;
  }

  __builtin_va_start(
      ap,
      fmt);
  n = vsnprintf(buf, sizeof(buf), fmt, ap);

  __builtin_va_end(
      ap);
  if (n < 0 || (size_t)n >= sizeof(buf))
  {
    return;
  }
  // log->log_printf(log->user_data, ("I%08""l""u"" 0x%s %s"" %s"),timestamp_cast(log->last_ts - log->ts), log->scid,strevent(ev), buf);
}
void ngtcp2_log_tx_cancel(ngtcp2_log *log, const ngtcp2_pkt_hd *hd)
{
  ngtcp2_log_info(log, NGTCP2_LOG_EVENT_PKT,
                  "cancel tx pkn=%"
                  "l"
                  "d"
                  " type=%s(0x%02x)",
                  hd->pkt_num,
                  strpkttype(hd), hd->type);
}
int ngtcp2_map_init(ngtcp2_map *map, const ngtcp2_mem *mem)
{
  map->mem = mem;
  map->tablelen = 256;
  map->table = ngtcp2_mem_calloc(mem, map->tablelen, sizeof(ngtcp2_map_bucket));
  if (map->table ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  map->size = 0;
  return 0;
}
void ngtcp2_map_free(ngtcp2_map *map)
{
  size_t i;
  ngtcp2_map_bucket *bkt;
  if (!map)
  {
    return;
  }
  for (i = 0; i < map->tablelen; ++i)
  {
    bkt = &map->table[i];
    if (bkt->ksl)
    {
      ngtcp2_ksl_free(bkt->ksl);
      ngtcp2_mem_free(map->mem, bkt->ksl);
    }
  }
  ngtcp2_mem_free(map->mem, map->table);
}
void ngtcp2_map_each_free(ngtcp2_map *map,
                          int (*func)(ngtcp2_map_entry *entry, void *ptr),
                          void *ptr)
{
  uint32_t i;
  ngtcp2_map_bucket *bkt;
  ngtcp2_ksl_it it;
  for (i = 0; i < map->tablelen; ++i)
  {
    bkt = &map->table[i];
    if (bkt->ptr)
    {
      func(bkt->ptr, ptr);
      bkt->ptr =
          __null;

      (static_cast<bool>(
           bkt->ksl ==
               __null ||
           ngtcp2_ksl_len(bkt->ksl) == 0)
           ? void(0)
           : __assert_fail(
                 "bkt->ksl == NULL || ngtcp2_ksl_len(bkt->ksl) == 0", "all.cpp", 31242, __extension__ __PRETTY_FUNCTION__));
      continue;
    }
    if (bkt->ksl)
    {
      for (it = ngtcp2_ksl_begin(bkt->ksl); !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                                               __null);
           (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
      {
        func(ngtcp2_ksl_it_get(&it), ptr);
      }
      ngtcp2_ksl_free(bkt->ksl);
      ngtcp2_mem_free(map->mem, bkt->ksl);
      bkt->ksl =
          __null;
    }
  }
}
int ngtcp2_map_each(ngtcp2_map *map,
                    int (*func)(ngtcp2_map_entry *entry, void *ptr),
                    void *ptr)
{
  int rv;
  uint32_t i;
  ngtcp2_map_bucket *bkt;
  ngtcp2_ksl_it it;
  for (i = 0; i < map->tablelen; ++i)
  {
    bkt = &map->table[i];
    if (bkt->ptr)
    {
      rv = func(bkt->ptr, ptr);
      if (rv != 0)
      {
        return rv;
      }

      (static_cast<bool>(
           bkt->ksl ==
               __null ||
           ngtcp2_ksl_len(bkt->ksl) == 0)
           ? void(0)
           : __assert_fail(
                 "bkt->ksl == NULL || ngtcp2_ksl_len(bkt->ksl) == 0", "all.cpp", 31277, __extension__ __PRETTY_FUNCTION__));
      continue;
    }
    if (bkt->ksl)
    {
      for (it = ngtcp2_ksl_begin(bkt->ksl); !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                                               __null);
           (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
      {
        rv = func(ngtcp2_ksl_it_get(&it), ptr);
        if (rv != 0)
        {
          return rv;
        }
      }
    }
  }
  return 0;
}
void ngtcp2_map_entry_init(ngtcp2_map_entry *entry, key_type key)
{
  entry->key = key;
  entry->next =
      __null;
}
static int map_insert(ngtcp2_map *map, ngtcp2_map_bucket *table,
                      uint32_t tablelen, ngtcp2_map_entry *entry)
{
  uint32_t h = hash(entry->key, tablelen);
  ngtcp2_map_bucket *bkt = &table[h];
  const ngtcp2_mem *mem = map->mem;
  int rv;
  if (bkt->ptr ==
          __null &&
      (bkt->ksl ==
           __null ||
       ngtcp2_ksl_len(bkt->ksl) == 0))
  {
    bkt->ptr = entry;
    return 0;
  }
  if (!bkt->ksl)
  {
    bkt->ksl = ngtcp2_mem_malloc(mem, sizeof(*bkt->ksl));
    if (bkt->ksl ==
        __null)
    {
      return NGTCP2_ERR_NOMEM;
    }
    ngtcp2_ksl_init(bkt->ksl, less, sizeof(key_type), mem);
  }
  if (bkt->ptr)
  {
    rv = ngtcp2_ksl_insert(bkt->ksl,
                           __null, &bkt->ptr->key, bkt->ptr);
    if (rv != 0)
    {
      return rv;
    }
    bkt->ptr =
        __null;
  }
  return ngtcp2_ksl_insert(bkt->ksl,
                           __null, &entry->key, entry);
}
static int map_resize(ngtcp2_map *map, uint32_t new_tablelen)
{
  uint32_t i;
  ngtcp2_map_bucket *new_table;
  ngtcp2_map_bucket *bkt;
  ngtcp2_ksl_it it;
  int rv;
  new_table =
      ngtcp2_mem_calloc(map->mem, new_tablelen, sizeof(ngtcp2_map_bucket));
  if (new_table ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  for (i = 0; i < map->tablelen; ++i)
  {
    bkt = &map->table[i];
    if (bkt->ptr)
    {
      rv = map_insert(map, new_table, new_tablelen, bkt->ptr);
      if (rv != 0)
      {
        goto fail;
      }

      (static_cast<bool>(
           bkt->ksl ==
               __null ||
           ngtcp2_ksl_len(bkt->ksl) == 0)
           ? void(0)
           : __assert_fail(
                 "bkt->ksl == NULL || ngtcp2_ksl_len(bkt->ksl) == 0", "all.cpp", 31358, __extension__ __PRETTY_FUNCTION__));
      continue;
    }
    if (bkt->ksl)
    {
      for (it = ngtcp2_ksl_begin(bkt->ksl); !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                                               __null);
           (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
      {
        rv = map_insert(map, new_table, new_tablelen, ngtcp2_ksl_it_get(&it));
        if (rv != 0)
        {
          goto fail;
        }
      }
    }
  }
  for (i = 0; i < map->tablelen; ++i)
  {
    bkt = &map->table[i];
    if (bkt->ksl)
    {
      ngtcp2_ksl_free(bkt->ksl);
      ngtcp2_mem_free(map->mem, bkt->ksl);
    }
  }
  ngtcp2_mem_free(map->mem, map->table);
  map->tablelen = new_tablelen;
  map->table = new_table;
  return 0;
fail:
  for (i = 0; i < new_tablelen; ++i)
  {
    bkt = &new_table[i];
    if (bkt->ksl)
    {
      ngtcp2_ksl_free(bkt->ksl);
      ngtcp2_mem_free(map->mem, bkt->ksl);
    }
  }
  return rv;
}
int ngtcp2_map_insert(ngtcp2_map *map, ngtcp2_map_entry *new_entry)
{
  int rv;
  if ((map->size + 1) * 4 > map->tablelen * 3)
  {
    rv = map_resize(map, map->tablelen * 2);
    if (rv != 0)
    {
      return rv;
    }
  }
  rv = map_insert(map, map->table, map->tablelen, new_entry);
  if (rv != 0)
  {
    return rv;
  }
  ++map->size;
  return 0;
}
ngtcp2_map_entry *ngtcp2_map_find(ngtcp2_map *map, key_type key)
{
  ngtcp2_map_bucket *bkt = &map->table[hash(key, map->tablelen)];
  ngtcp2_ksl_it it;
  if (bkt->ptr)
  {
    if (bkt->ptr->key == key)
    {
      return bkt->ptr;
    }
    return __null;
  }
  if (bkt->ksl)
  {
    it = ngtcp2_ksl_lower_bound(bkt->ksl, &key);
    if (((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                          __null) ||
        *(key_type *)((ngtcp2_ksl_key *)((ngtcp2_ksl_node *)(void *)(((&it)->blk)->nodes + ((&it)->ksl)->nodelen * ((&it)->i)))->key) != key)
    {
      return __null;
    }
    return ngtcp2_ksl_it_get(&it);
  }
  return __null;
}
int ngtcp2_map_remove(ngtcp2_map *map, key_type key)
{
  ngtcp2_map_bucket *bkt = &map->table[hash(key, map->tablelen)];
  int rv;
  if (bkt->ptr)
  {
    if (bkt->ptr->key == key)
    {
      bkt->ptr =
          __null;
      --map->size;
      return 0;
    }
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  if (bkt->ksl)
  {
    rv = ngtcp2_ksl_remove(bkt->ksl,
                           __null, &key);
    if (rv != 0)
    {
      return rv;
    }
    --map->size;
    return 0;
  }
  return NGTCP2_ERR_INVALID_ARGUMENT;
}
void ngtcp2_map_clear(ngtcp2_map *map)
{
  uint32_t i;
  ngtcp2_map_bucket *bkt;
  for (i = 0; i < map->tablelen; ++i)
  {
    bkt = &map->table[i];
    bkt->ptr =
        __null;
    if (bkt->ksl)
    {
      ngtcp2_ksl_free(bkt->ksl);
      ngtcp2_mem_free(map->mem, bkt->ksl);
      bkt->ksl =
          __null;
    }
  }
  map->size = 0;
}
size_t ngtcp2_map_size(ngtcp2_map *map) { return map->size; }
const ngtcp2_mem *ngtcp2_mem_default(void)
{
  return (ngtcp2_mem *)&mem_default;
}
void *ngtcp2_mem_malloc(const ngtcp2_mem *mem, size_t size)
{
  return mem->malloc(size, mem->mem_user_data);
}
void ngtcp2_mem_free(const ngtcp2_mem *mem, void *ptr)
{
  mem->free(ptr, mem->mem_user_data);
}
void ngtcp2_mem_free2(ngtcp2_free free_func, void *ptr, void *mem_user_data)
{
  free_func(ptr, mem_user_data);
}
void *ngtcp2_mem_calloc(const ngtcp2_mem *mem, size_t nmemb, size_t size)
{
  return mem->calloc(nmemb, size, mem->mem_user_data);
}
void *ngtcp2_mem_realloc(const ngtcp2_mem *mem, void *ptr, size_t size)
{
  return mem->realloc(ptr, size, mem->mem_user_data);
}
void ngtcp2_path_init(ngtcp2_path *path, const ngtcp2_addr *local,
                      const ngtcp2_addr *remote)
{
  path->local = *local;
  path->remote = *remote;
}
void ngtcp2_path_copy(ngtcp2_path *dest, const ngtcp2_path *src)
{
  ngtcp2_addr_copy(&dest->local, &src->local);
  ngtcp2_addr_copy(&dest->remote, &src->remote);
}
int ngtcp2_path_eq(const ngtcp2_path *a, const ngtcp2_path *b)
{
  return ngtcp2_addr_eq(&a->local, &b->local) &&
         ngtcp2_addr_eq(&a->remote, &b->remote);
}
void ngtcp2_path_storage_init(ngtcp2_path_storage *ps,
                              const struct sockaddr *local_addr,
                              size_t local_addrlen, void *local_user_data,
                              const struct sockaddr *remote_addr,
                              size_t remote_addrlen, void *remote_user_data)
{
  ngtcp2_addr_init(&ps->path.local, (const struct sockaddr *)&ps->local_addrbuf,
                   0, local_user_data);
  ngtcp2_addr_init(&ps->path.remote,
                   (const struct sockaddr *)&ps->remote_addrbuf, 0,
                   remote_user_data);
  ngtcp2_addr_copy_byte(&ps->path.local, local_addr, local_addrlen);
  ngtcp2_addr_copy_byte(&ps->path.remote, remote_addr, remote_addrlen);
}
void ngtcp2_path_storage_init2(ngtcp2_path_storage *ps,
                               const ngtcp2_path *path)
{
  ngtcp2_path_storage_init(ps, path->local.addr, path->local.addrlen,
                           path->local.user_data, path->remote.addr,
                           path->remote.addrlen, path->remote.user_data);
}
void ngtcp2_path_storage_zero(ngtcp2_path_storage *ps)
{
  ngtcp2_addr_init(&ps->path.local, (const struct sockaddr *)&ps->local_addrbuf,
                   0,
                   __null);
  ngtcp2_addr_init(&ps->path.remote,
                   (const struct sockaddr *)&ps->remote_addrbuf, 0,
                   __null);
}
int ngtcp2_pkt_chain_new(ngtcp2_pkt_chain **ppc, const ngtcp2_path *path,
                         const ngtcp2_pkt_info *pi, const uint8_t *pkt,
                         size_t pktlen, ngtcp2_tstamp ts,
                         const ngtcp2_mem *mem)
{
  *ppc = ngtcp2_mem_malloc(mem, sizeof(ngtcp2_pkt_chain) + pktlen);
  if (*ppc ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  ngtcp2_path_storage_init2(&(*ppc)->path, path);
  (*ppc)->pi = *pi;
  (*ppc)->next =
      __null;
  (*ppc)->pkt = (uint8_t *)(*ppc) + sizeof(ngtcp2_pkt_chain);
  (*ppc)->pktlen = pktlen;
  (*ppc)->ts = ts;
  memcpy((*ppc)->pkt, pkt, pktlen);
  return 0;
}
void ngtcp2_pkt_chain_del(ngtcp2_pkt_chain *pc, const ngtcp2_mem *mem)
{
  ngtcp2_mem_free(mem, pc);
}
int ngtcp2_pkt_decode_version_cid(uint32_t *pversion, const uint8_t **pdcid,
                                  size_t *pdcidlen, const uint8_t **pscid,
                                  size_t *pscidlen, const uint8_t *data,
                                  size_t datalen, size_t short_dcidlen)
{
  size_t len;
  uint32_t version;
  size_t dcidlen, scidlen;

  (static_cast<bool>(
       datalen)
       ? void(0)
       : __assert_fail(
             "datalen", "all.cpp", 31618, __extension__ __PRETTY_FUNCTION__));
  if (data[0] & 0x80)
  {
    len = 1 + 4 + 1 + 1;
    if (datalen < len)
    {
      return NGTCP2_ERR_INVALID_ARGUMENT;
    }
    dcidlen = data[5];
    len += dcidlen;
    if (datalen < len)
    {
      return NGTCP2_ERR_INVALID_ARGUMENT;
    }
    scidlen = data[5 + 1 + dcidlen];
    len += scidlen;
    if (datalen < len)
    {
      return NGTCP2_ERR_INVALID_ARGUMENT;
    }
    version = ngtcp2_get_uint32(&data[1]);
    if ((version == 0 || (0xff00001du <= version &&
                          version <= 0xff000020u)) &&
        (dcidlen > 20 || scidlen > 20))
    {
      return NGTCP2_ERR_INVALID_ARGUMENT;
    }
    *pversion = version;
    *pdcid = &data[6];
    *pdcidlen = dcidlen;
    *pscid = &data[6 + dcidlen + 1];
    *pscidlen = scidlen;
    if (version &&
        (version < 0xff00001du || 0xff000020u < version))
    {
      return 1;
    }
    return 0;
  }

  (static_cast<bool>(
       short_dcidlen <= 20)
       ? void(0)
       : __assert_fail(
             "short_dcidlen <= NGTCP2_MAX_CIDLEN", "all.cpp", 31657, __extension__ __PRETTY_FUNCTION__));
  len = 1 + short_dcidlen;
  if (datalen < len)
  {
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  *pversion = 0;
  *pdcid = &data[1];
  *pdcidlen = short_dcidlen;
  *pscid =
      __null;
  *pscidlen = 0;
  return 0;
}
void ngtcp2_pkt_hd_init(ngtcp2_pkt_hd *hd, uint8_t flags, uint8_t type,
                        const ngtcp2_cid *dcid, const ngtcp2_cid *scid,
                        int64_t pkt_num, size_t pkt_numlen, uint32_t version,
                        size_t len)
{
  hd->flags = flags;
  hd->type = type;
  if (dcid)
  {
    hd->dcid = *dcid;
  }
  else
  {
    ngtcp2_cid_zero(&hd->dcid);
  }
  if (scid)
  {
    hd->scid = *scid;
  }
  else
  {
    ngtcp2_cid_zero(&hd->scid);
  }
  hd->pkt_num = pkt_num;
  hd->token.base =
      __null;
  hd->token.len = 0;
  hd->pkt_numlen = pkt_numlen;
  hd->version = version;
  hd->len = len;
}
static int has_mask(uint8_t b, uint8_t mask) { return (b & mask) == mask; }
ngtcp2_ssize ngtcp2_pkt_decode_hd_long(ngtcp2_pkt_hd *dest, const uint8_t *pkt,
                                       size_t pktlen)
{
  uint8_t type;
  uint32_t version;
  size_t dcil, scil;
  const uint8_t *p;
  size_t len = 0;
  size_t n;
  size_t ntokenlen = 0;
  const uint8_t *token =
      __null;
  size_t tokenlen = 0;
  uint64_t vi;
  if (pktlen < 5)
  {
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  if (!(pkt[0] & 0x80))
  {
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  version = ngtcp2_get_uint32(&pkt[1]);
  if (version == 0)
  {
    type = NGTCP2_PKT_VERSION_NEGOTIATION;
    len = 5 + 2;
  }
  else
  {
    if (!(pkt[0] & 0x40))
    {
      return NGTCP2_ERR_INVALID_ARGUMENT;
    }
    type = ngtcp2_pkt_get_type_long(pkt[0]);
    switch (type)
    {
    case NGTCP2_PKT_INITIAL:
      len = 1 + (1 + 4 + 1 + 1 + 1 + 1) -
            1;
      break;
    case NGTCP2_PKT_RETRY:
      len = 5 + 2;
      break;
    case NGTCP2_PKT_HANDSHAKE:
    case NGTCP2_PKT_0RTT:
      len = (1 + 4 + 1 + 1 + 1 + 1) - 1;
      break;
    default:

      (static_cast<bool>(
           0)
           ? void(0)
           : __assert_fail(
                 "0", "all.cpp", 31752, __extension__ __PRETTY_FUNCTION__));
    }
  }
  if (pktlen < len)
  {
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  p = &pkt[5];
  dcil = *p;
  if (dcil > 20)
  {
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  len += dcil;
  if (pktlen < len)
  {
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  p += 1 + dcil;
  scil = *p;
  if (scil > 20)
  {
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  len += scil;
  if (pktlen < len)
  {
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  p += 1 + scil;
  if (type == NGTCP2_PKT_INITIAL)
  {
    ntokenlen = ngtcp2_get_varint_len(p);
    len += ntokenlen - 1;
    if (pktlen < len)
    {
      return NGTCP2_ERR_INVALID_ARGUMENT;
    }
    vi = ngtcp2_get_varint(&ntokenlen, p);
    if (pktlen - len < vi)
    {
      return NGTCP2_ERR_INVALID_ARGUMENT;
    }
    tokenlen = (size_t)vi;
    len += tokenlen;
    p += ntokenlen;
    if (tokenlen)
    {
      token = p;
    }
    p += tokenlen;
  }
  switch (type)
  {
  case NGTCP2_PKT_VERSION_NEGOTIATION:
  case NGTCP2_PKT_RETRY:
    break;
  default:
    n = ngtcp2_get_varint_len(p);
    len += n - 1;
    if (pktlen < len)
    {
      return NGTCP2_ERR_INVALID_ARGUMENT;
    }
  }
  dest->flags = NGTCP2_PKT_FLAG_LONG_FORM;
  dest->type = type;
  dest->version = version;
  dest->pkt_num = 0;
  dest->pkt_numlen = 0;
  p = &pkt[6];
  ngtcp2_cid_init(&dest->dcid, p, dcil);
  p += dcil + 1;
  ngtcp2_cid_init(&dest->scid, p, scil);
  p += scil;
  dest->token.base = (uint8_t *)token;
  dest->token.len = tokenlen;
  p += ntokenlen + tokenlen;
  switch (type)
  {
  case NGTCP2_PKT_VERSION_NEGOTIATION:
  case NGTCP2_PKT_RETRY:
    dest->len = 0;
    break;
  default:
    vi = ngtcp2_get_varint(&n, p);
    if (vi >
        (18446744073709551615UL))
    {
      return NGTCP2_ERR_INVALID_ARGUMENT;
    }
    dest->len = (size_t)vi;
    p += n;
  }

  (static_cast<bool>(
       (size_t)(p - pkt) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - pkt) == len", "all.cpp", 31845, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_decode_hd_short(ngtcp2_pkt_hd *dest, const uint8_t *pkt,
                                        size_t pktlen, size_t dcidlen)
{
  size_t len = 1 + dcidlen;
  const uint8_t *p = pkt;

  (static_cast<bool>(
       dcidlen <= 20)
       ? void(0)
       : __assert_fail(
             "dcidlen <= NGTCP2_MAX_CIDLEN", "all.cpp", 31854, __extension__ __PRETTY_FUNCTION__));
  if (pktlen < len)
  {
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  if ((pkt[0] & 0x80) ||
      (pkt[0] & 0x40) == 0)
  {
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  p = &pkt[1];
  dest->type = NGTCP2_PKT_SHORT;
  ngtcp2_cid_init(&dest->dcid, p, dcidlen);
  p += dcidlen;
  ngtcp2_cid_zero(&dest->scid);
  dest->flags = NGTCP2_PKT_FLAG_NONE;
  dest->version = 0;
  dest->len = 0;
  dest->pkt_num = 0;
  dest->pkt_numlen = 0;

  (static_cast<bool>(
       (size_t)(p - pkt) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - pkt) == len", "all.cpp", 31874, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_encode_hd_long(uint8_t *out, size_t outlen,
                                       const ngtcp2_pkt_hd *hd)
{
  uint8_t *p;
  size_t len = (1 + 4 + 1 + 1 + 1 + 1) + hd->dcid.datalen + hd->scid.datalen -
               2;
  if (hd->type != NGTCP2_PKT_RETRY)
  {
    len += 2 + hd->pkt_numlen;
  }
  if (hd->type == NGTCP2_PKT_INITIAL)
  {
    len += ngtcp2_put_varint_len(hd->token.len) + hd->token.len;
  }
  if (outlen < len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = out;
  *p++ = (uint8_t)(0x80 | 0x40 |
                   (hd->type << 4) | (uint8_t)(hd->pkt_numlen - 1));
  p = ngtcp2_put_uint32be(p, hd->version);
  *p++ = (uint8_t)hd->dcid.datalen;
  if (hd->dcid.datalen)
  {
    p = ngtcp2_cpymem(p, hd->dcid.data, hd->dcid.datalen);
  }
  *p++ = (uint8_t)hd->scid.datalen;
  if (hd->scid.datalen)
  {
    p = ngtcp2_cpymem(p, hd->scid.data, hd->scid.datalen);
  }
  if (hd->type == NGTCP2_PKT_INITIAL)
  {
    p = ngtcp2_put_varint(p, hd->token.len);
    if (hd->token.len)
    {
      p = ngtcp2_cpymem(p, hd->token.base, hd->token.len);
    }
  }
  if (hd->type != NGTCP2_PKT_RETRY)
  {
    p = ngtcp2_put_varint14(p, (uint16_t)hd->len);
    p = ngtcp2_put_pkt_num(p, hd->pkt_num, hd->pkt_numlen);
  }

  (static_cast<bool>(
       (size_t)(p - out) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - out) == len", "all.cpp", 31924, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_encode_hd_short(uint8_t *out, size_t outlen,
                                        const ngtcp2_pkt_hd *hd)
{
  uint8_t *p;
  size_t len = 1 + hd->dcid.datalen + hd->pkt_numlen;
  if (outlen < len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = out;
  *p = 0x40 | (uint8_t)(hd->pkt_numlen - 1);
  if (hd->flags & NGTCP2_PKT_FLAG_KEY_PHASE)
  {
    *p |= 0x04;
  }
  ++p;
  if (hd->dcid.datalen)
  {
    p = ngtcp2_cpymem(p, hd->dcid.data, hd->dcid.datalen);
  }
  p = ngtcp2_put_pkt_num(p, hd->pkt_num, hd->pkt_numlen);

  (static_cast<bool>(
       (size_t)(p - out) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - out) == len", "all.cpp", 31949, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_decode_frame(ngtcp2_frame *dest, const uint8_t *payload,
                                     size_t payloadlen)
{
  uint8_t type;
  if (payloadlen == 0)
  {
    return 0;
  }
  type = payload[0];
  switch (type)
  {
  case NGTCP2_FRAME_PADDING:
    return (ngtcp2_ssize)ngtcp2_pkt_decode_padding_frame(&dest->padding,
                                                         payload, payloadlen);
  case NGTCP2_FRAME_RESET_STREAM:
    return ngtcp2_pkt_decode_reset_stream_frame(&dest->reset_stream, payload,
                                                payloadlen);
  case NGTCP2_FRAME_CONNECTION_CLOSE:
  case NGTCP2_FRAME_CONNECTION_CLOSE_APP:
    return ngtcp2_pkt_decode_connection_close_frame(&dest->connection_close,
                                                    payload, payloadlen);
  case NGTCP2_FRAME_MAX_DATA:
    return ngtcp2_pkt_decode_max_data_frame(&dest->max_data, payload,
                                            payloadlen);
  case NGTCP2_FRAME_MAX_STREAM_DATA:
    return ngtcp2_pkt_decode_max_stream_data_frame(&dest->max_stream_data,
                                                   payload, payloadlen);
  case NGTCP2_FRAME_MAX_STREAMS_BIDI:
  case NGTCP2_FRAME_MAX_STREAMS_UNI:
    return ngtcp2_pkt_decode_max_streams_frame(&dest->max_streams, payload,
                                               payloadlen);
  case NGTCP2_FRAME_PING:
    return ngtcp2_pkt_decode_ping_frame(&dest->ping, payload, payloadlen);
  case NGTCP2_FRAME_DATA_BLOCKED:
    return ngtcp2_pkt_decode_data_blocked_frame(&dest->data_blocked, payload,
                                                payloadlen);
  case NGTCP2_FRAME_STREAM_DATA_BLOCKED:
    return ngtcp2_pkt_decode_stream_data_blocked_frame(
        &dest->stream_data_blocked, payload, payloadlen);
  case NGTCP2_FRAME_STREAMS_BLOCKED_BIDI:
  case NGTCP2_FRAME_STREAMS_BLOCKED_UNI:
    return ngtcp2_pkt_decode_streams_blocked_frame(&dest->streams_blocked,
                                                   payload, payloadlen);
  case NGTCP2_FRAME_NEW_CONNECTION_ID:
    return ngtcp2_pkt_decode_new_connection_id_frame(&dest->new_connection_id,
                                                     payload, payloadlen);
  case NGTCP2_FRAME_STOP_SENDING:
    return ngtcp2_pkt_decode_stop_sending_frame(&dest->stop_sending, payload,
                                                payloadlen);
  case NGTCP2_FRAME_ACK:
  case NGTCP2_FRAME_ACK_ECN:
    return ngtcp2_pkt_decode_ack_frame(&dest->ack, payload, payloadlen);
  case NGTCP2_FRAME_PATH_CHALLENGE:
    return ngtcp2_pkt_decode_path_challenge_frame(&dest->path_challenge,
                                                  payload, payloadlen);
  case NGTCP2_FRAME_PATH_RESPONSE:
    return ngtcp2_pkt_decode_path_response_frame(&dest->path_response, payload,
                                                 payloadlen);
  case NGTCP2_FRAME_CRYPTO:
    return ngtcp2_pkt_decode_crypto_frame(&dest->crypto, payload, payloadlen);
  case NGTCP2_FRAME_NEW_TOKEN:
    return ngtcp2_pkt_decode_new_token_frame(&dest->new_token, payload,
                                             payloadlen);
  case NGTCP2_FRAME_RETIRE_CONNECTION_ID:
    return ngtcp2_pkt_decode_retire_connection_id_frame(
        &dest->retire_connection_id, payload, payloadlen);
  case NGTCP2_FRAME_HANDSHAKE_DONE:
    return ngtcp2_pkt_decode_handshake_done_frame(&dest->handshake_done,
                                                  payload, payloadlen);
  default:
    if (has_mask(type, NGTCP2_FRAME_STREAM))
    {
      return ngtcp2_pkt_decode_stream_frame(&dest->stream, payload, payloadlen);
    }
    return NGTCP2_ERR_FRAME_ENCODING;
  }
}
ngtcp2_ssize ngtcp2_pkt_decode_stream_frame(ngtcp2_stream *dest,
                                            const uint8_t *payload,
                                            size_t payloadlen)
{
  uint8_t type;
  size_t len = 1 + 1;
  const uint8_t *p;
  size_t datalen;
  size_t ndatalen = 0;
  size_t n;
  uint64_t vi;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  type = payload[0];
  p = payload + 1;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p += n;
  if (type & 0x04)
  {
    ++len;
    if (payloadlen < len)
    {
      return NGTCP2_ERR_FRAME_ENCODING;
    }
    n = ngtcp2_get_varint_len(p);
    len += n - 1;
    if (payloadlen < len)
    {
      return NGTCP2_ERR_FRAME_ENCODING;
    }
    p += n;
  }
  if (type & 0x02)
  {
    ++len;
    if (payloadlen < len)
    {
      return NGTCP2_ERR_FRAME_ENCODING;
    }
    ndatalen = ngtcp2_get_varint_len(p);
    len += ndatalen - 1;
    if (payloadlen < len)
    {
      return NGTCP2_ERR_FRAME_ENCODING;
    }
    vi = ngtcp2_get_varint(&ndatalen, p);
    if (payloadlen - len < vi)
    {
      return NGTCP2_ERR_FRAME_ENCODING;
    }
    datalen = (size_t)vi;
    len += datalen;
  }
  else
  {
    len = payloadlen;
  }
  p = payload + 1;
  dest->type = NGTCP2_FRAME_STREAM;
  dest->flags = (uint8_t)(type & ~NGTCP2_FRAME_STREAM);
  dest->fin = (type & 0x01) != 0;
  dest->stream_id = (int64_t)ngtcp2_get_varint(&n, p);
  p += n;
  if (type & 0x04)
  {
    dest->offset = ngtcp2_get_varint(&n, p);
    p += n;
  }
  else
  {
    dest->offset = 0;
  }
  if (type & 0x02)
  {
    p += ndatalen;
  }
  else
  {
    datalen = payloadlen - (size_t)(p - payload);
  }
  if (datalen)
  {
    dest->data[0].len = datalen;
    dest->data[0].base = (uint8_t *)p;
    dest->datacnt = 1;
    p += datalen;
  }
  else
  {
    dest->datacnt = 0;
  }

  (static_cast<bool>(
       (size_t)(p - payload) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - payload) == len", "all.cpp", 32129, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_decode_ack_frame(ngtcp2_ack *dest,
                                         const uint8_t *payload,
                                         size_t payloadlen)
{
  size_t num_blks, max_num_blks;
  size_t nnum_blks;
  size_t len = 1 + 1 + 1 + 1 + 1;
  const uint8_t *p;
  size_t i, j;
  ngtcp2_ack_blk *blk;
  size_t n;
  uint8_t type;
  uint64_t vi;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  type = payload[0];
  p = payload + 1;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p += n;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p += n;
  nnum_blks = ngtcp2_get_varint_len(p);
  len += nnum_blks - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  vi = ngtcp2_get_varint(&nnum_blks, p);
  if (vi >
          (18446744073709551615UL) / (1 + 1) ||
      payloadlen - len < vi * (1 + 1))
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  num_blks = (size_t)vi;
  len += num_blks * (1 + 1);
  p += nnum_blks;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p += n;
  for (i = 0; i < num_blks; ++i)
  {
    for (j = 0; j < 2; ++j)
    {
      n = ngtcp2_get_varint_len(p);
      len += n - 1;
      if (payloadlen < len)
      {
        return NGTCP2_ERR_FRAME_ENCODING;
      }
      p += n;
    }
  }
  if (type == NGTCP2_FRAME_ACK_ECN)
  {
    len += 3;
    if (payloadlen < len)
    {
      return NGTCP2_ERR_FRAME_ENCODING;
    }
    for (i = 0; i < 3; ++i)
    {
      n = ngtcp2_get_varint_len(p);
      len += n - 1;
      if (payloadlen < len)
      {
        return NGTCP2_ERR_FRAME_ENCODING;
      }
      p += n;
    }
  }
  max_num_blks = ((32) < (num_blks) ? (32) : (num_blks));
  p = payload + 1;
  dest->type = type;
  dest->largest_ack = (int64_t)ngtcp2_get_varint(&n, p);
  p += n;
  dest->ack_delay = ngtcp2_get_varint(&n, p);
  dest->ack_delay_unscaled = 0;
  p += n;
  dest->num_blks = max_num_blks;
  p += nnum_blks;
  dest->first_ack_blklen = ngtcp2_get_varint(&n, p);
  p += n;
  for (i = 0; i < max_num_blks; ++i)
  {
    blk = &dest->blks[i];
    blk->gap = ngtcp2_get_varint(&n, p);
    p += n;
    blk->blklen = ngtcp2_get_varint(&n, p);
    p += n;
  }
  for (i = max_num_blks; i < num_blks; ++i)
  {
    p += ngtcp2_get_varint_len(p);
    p += ngtcp2_get_varint_len(p);
  }
  if (type == NGTCP2_FRAME_ACK_ECN)
  {
    dest->ecn.ect0 = ngtcp2_get_varint(&n, p);
    p += n;
    dest->ecn.ect1 = ngtcp2_get_varint(&n, p);
    p += n;
    dest->ecn.ce = ngtcp2_get_varint(&n, p);
    p += n;
  }

  (static_cast<bool>(
       (size_t)(p - payload) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - payload) == len", "all.cpp", 32252, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
size_t ngtcp2_pkt_decode_padding_frame(ngtcp2_padding *dest,
                                       const uint8_t *payload,
                                       size_t payloadlen)
{
  const uint8_t *p, *ep;

  (static_cast<bool>(
       payloadlen > 0)
       ? void(0)
       : __assert_fail(
             "payloadlen > 0", "all.cpp", 32261, __extension__ __PRETTY_FUNCTION__));
  p = payload + 1;
  ep = payload + payloadlen;
  for (; p != ep && *p == NGTCP2_FRAME_PADDING; ++p)
    ;
  dest->type = NGTCP2_FRAME_PADDING;
  dest->len = (size_t)(p - payload);
  return dest->len;
}
ngtcp2_ssize ngtcp2_pkt_decode_reset_stream_frame(ngtcp2_reset_stream *dest,
                                                  const uint8_t *payload,
                                                  size_t payloadlen)
{
  size_t len = 1 + 1 + 1 + 1;
  const uint8_t *p;
  size_t n;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p = payload + 1;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p += n;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p += n;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p = payload + 1;
  dest->type = NGTCP2_FRAME_RESET_STREAM;
  dest->stream_id = (int64_t)ngtcp2_get_varint(&n, p);
  p += n;
  dest->app_error_code = ngtcp2_get_varint(&n, p);
  p += n;
  dest->final_size = ngtcp2_get_varint(&n, p);
  p += n;

  (static_cast<bool>(
       (size_t)(p - payload) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - payload) == len", "all.cpp", 32311, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_decode_connection_close_frame(
    ngtcp2_connection_close *dest, const uint8_t *payload, size_t payloadlen)
{
  size_t len = 1 + 1 + 1;
  const uint8_t *p;
  size_t reasonlen;
  size_t nreasonlen;
  size_t n;
  uint8_t type;
  uint64_t vi;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  type = payload[0];
  p = payload + 1;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p += n;
  if (type == NGTCP2_FRAME_CONNECTION_CLOSE)
  {
    ++len;
    n = ngtcp2_get_varint_len(p);
    len += n - 1;
    if (payloadlen < len)
    {
      return NGTCP2_ERR_FRAME_ENCODING;
    }
    p += n;
  }
  nreasonlen = ngtcp2_get_varint_len(p);
  len += nreasonlen - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  vi = ngtcp2_get_varint(&nreasonlen, p);
  if (payloadlen - len < vi)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  reasonlen = (size_t)vi;
  len += reasonlen;
  p = payload + 1;
  dest->type = type;
  dest->error_code = ngtcp2_get_varint(&n, p);
  p += n;
  if (type == NGTCP2_FRAME_CONNECTION_CLOSE)
  {
    dest->frame_type = ngtcp2_get_varint(&n, p);
    p += n;
  }
  else
  {
    dest->frame_type = 0;
  }
  dest->reasonlen = reasonlen;
  p += nreasonlen;
  if (reasonlen == 0)
  {
    dest->reason =
        __null;
  }
  else
  {
    dest->reason = (uint8_t *)p;
    p += reasonlen;
  }

  (static_cast<bool>(
       (size_t)(p - payload) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - payload) == len", "all.cpp", 32386, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_decode_max_data_frame(ngtcp2_max_data *dest,
                                              const uint8_t *payload,
                                              size_t payloadlen)
{
  size_t len = 1 + 1;
  const uint8_t *p;
  size_t n;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p = payload + 1;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  dest->type = NGTCP2_FRAME_MAX_DATA;
  dest->max_data = ngtcp2_get_varint(&n, p);
  p += n;

  (static_cast<bool>(
       (size_t)(p - payload) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - payload) == len", "all.cpp", 32411, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_decode_max_stream_data_frame(
    ngtcp2_max_stream_data *dest, const uint8_t *payload, size_t payloadlen)
{
  size_t len = 1 + 1 + 1;
  const uint8_t *p;
  size_t n;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p = payload + 1;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p += n;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p = payload + 1;
  dest->type = NGTCP2_FRAME_MAX_STREAM_DATA;
  dest->stream_id = (int64_t)ngtcp2_get_varint(&n, p);
  p += n;
  dest->max_stream_data = ngtcp2_get_varint(&n, p);
  p += n;

  (static_cast<bool>(
       (size_t)(p - payload) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - payload) == len", "all.cpp", 32445, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_decode_max_streams_frame(ngtcp2_max_streams *dest,
                                                 const uint8_t *payload,
                                                 size_t payloadlen)
{
  size_t len = 1 + 1;
  const uint8_t *p;
  size_t n;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p = payload + 1;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  dest->type = payload[0];
  dest->max_streams = ngtcp2_get_varint(&n, p);
  p += n;

  (static_cast<bool>(
       (size_t)(p - payload) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - payload) == len", "all.cpp", 32470, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_decode_ping_frame(ngtcp2_ping *dest,
                                          const uint8_t *payload,
                                          size_t payloadlen)
{
  (void)payload;
  (void)payloadlen;
  dest->type = NGTCP2_FRAME_PING;
  return 1;
}
ngtcp2_ssize ngtcp2_pkt_decode_data_blocked_frame(ngtcp2_data_blocked *dest,
                                                  const uint8_t *payload,
                                                  size_t payloadlen)
{
  size_t len = 1 + 1;
  const uint8_t *p;
  size_t n;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p = payload + 1;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  dest->type = NGTCP2_FRAME_DATA_BLOCKED;
  dest->offset = ngtcp2_get_varint(&n, p);
  p += n;

  (static_cast<bool>(
       (size_t)(p - payload) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - payload) == len", "all.cpp", 32505, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize
ngtcp2_pkt_decode_stream_data_blocked_frame(ngtcp2_stream_data_blocked *dest,
                                            const uint8_t *payload,
                                            size_t payloadlen)
{
  size_t len = 1 + 1 + 1;
  const uint8_t *p;
  size_t n;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p = payload + 1;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p += n;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p = payload + 1;
  dest->type = NGTCP2_FRAME_STREAM_DATA_BLOCKED;
  dest->stream_id = (int64_t)ngtcp2_get_varint(&n, p);
  p += n;
  dest->offset = ngtcp2_get_varint(&n, p);
  p += n;

  (static_cast<bool>(
       (size_t)(p - payload) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - payload) == len", "all.cpp", 32541, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_decode_streams_blocked_frame(
    ngtcp2_streams_blocked *dest, const uint8_t *payload, size_t payloadlen)
{
  size_t len = 1 + 1;
  const uint8_t *p;
  size_t n;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p = payload + 1;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  dest->type = payload[0];
  dest->stream_limit = ngtcp2_get_varint(&n, p);
  p += n;

  (static_cast<bool>(
       (size_t)(p - payload) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - payload) == len", "all.cpp", 32565, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_decode_new_connection_id_frame(
    ngtcp2_new_connection_id *dest, const uint8_t *payload, size_t payloadlen)
{
  size_t len = 1 + 1 + 1 + 1 + 16;
  const uint8_t *p;
  size_t n;
  size_t cil;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p = payload + 1;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p += n;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p += n;
  cil = *p;
  if (cil < 1 || cil > 20)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  len += cil;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p = payload + 1;
  dest->type = NGTCP2_FRAME_NEW_CONNECTION_ID;
  dest->seq = ngtcp2_get_varint(&n, p);
  p += n;
  dest->retire_prior_to = ngtcp2_get_varint(&n, p);
  p += n + 1;
  ngtcp2_cid_init(&dest->cid, p, cil);
  p += cil;
  memcpy(dest->stateless_reset_token, p, 16);
  p += 16;

  (static_cast<bool>(
       (size_t)(p - payload) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - payload) == len", "all.cpp", 32615, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_decode_stop_sending_frame(ngtcp2_stop_sending *dest,
                                                  const uint8_t *payload,
                                                  size_t payloadlen)
{
  size_t len = 1 + 1 + 1;
  const uint8_t *p;
  size_t n;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p = payload + 1;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p += n;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p = payload + 1;
  dest->type = NGTCP2_FRAME_STOP_SENDING;
  dest->stream_id = (int64_t)ngtcp2_get_varint(&n, p);
  p += n;
  dest->app_error_code = ngtcp2_get_varint(&n, p);
  p += n;

  (static_cast<bool>(
       (size_t)(p - payload) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - payload) == len", "all.cpp", 32650, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_decode_path_challenge_frame(ngtcp2_path_challenge *dest,
                                                    const uint8_t *payload,
                                                    size_t payloadlen)
{
  size_t len = 1 + 8;
  const uint8_t *p;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p = payload + 1;
  dest->type = NGTCP2_FRAME_PATH_CHALLENGE;
  ngtcp2_cpymem(dest->data, p, sizeof(dest->data));
  p += sizeof(dest->data);

  (static_cast<bool>(
       (size_t)(p - payload) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - payload) == len", "all.cpp", 32668, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_decode_path_response_frame(ngtcp2_path_response *dest,
                                                   const uint8_t *payload,
                                                   size_t payloadlen)
{
  size_t len = 1 + 8;
  const uint8_t *p;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p = payload + 1;
  dest->type = NGTCP2_FRAME_PATH_RESPONSE;
  ngtcp2_cpymem(dest->data, p, sizeof(dest->data));
  p += sizeof(dest->data);

  (static_cast<bool>(
       (size_t)(p - payload) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - payload) == len", "all.cpp", 32686, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_decode_crypto_frame(ngtcp2_crypto *dest,
                                            const uint8_t *payload,
                                            size_t payloadlen)
{
  size_t len = 1 + 1 + 1;
  const uint8_t *p;
  size_t datalen;
  size_t ndatalen;
  size_t n;
  uint64_t vi;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p = payload + 1;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p += n;
  ndatalen = ngtcp2_get_varint_len(p);
  len += ndatalen - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  vi = ngtcp2_get_varint(&ndatalen, p);
  if (payloadlen - len < vi)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  datalen = (size_t)vi;
  len += datalen;
  p = payload + 1;
  dest->type = NGTCP2_FRAME_CRYPTO;
  dest->offset = ngtcp2_get_varint(&n, p);
  p += n;
  dest->data[0].len = datalen;
  p += ndatalen;
  if (dest->data[0].len)
  {
    dest->data[0].base = (uint8_t *)p;
    p += dest->data[0].len;
    dest->datacnt = 1;
  }
  else
  {
    dest->data[0].base =
        __null;
    dest->datacnt = 0;
  }

  (static_cast<bool>(
       (size_t)(p - payload) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - payload) == len", "all.cpp", 32742, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_decode_new_token_frame(ngtcp2_new_token *dest,
                                               const uint8_t *payload,
                                               size_t payloadlen)
{
  size_t len = 1 + 1;
  const uint8_t *p;
  size_t n;
  size_t datalen;
  uint64_t vi;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p = payload + 1;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  vi = ngtcp2_get_varint(&n, p);
  if (payloadlen - len < vi)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  datalen = (size_t)vi;
  len += datalen;
  dest->type = NGTCP2_FRAME_NEW_TOKEN;
  dest->token.len = datalen;
  p += n;
  dest->token.base = (uint8_t *)p;
  p += dest->token.len;

  (static_cast<bool>(
       (size_t)(p - payload) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - payload) == len", "all.cpp", 32778, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize
ngtcp2_pkt_decode_retire_connection_id_frame(ngtcp2_retire_connection_id *dest,
                                             const uint8_t *payload,
                                             size_t payloadlen)
{
  size_t len = 1 + 1;
  const uint8_t *p;
  size_t n;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  p = payload + 1;
  n = ngtcp2_get_varint_len(p);
  len += n - 1;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_FRAME_ENCODING;
  }
  dest->type = NGTCP2_FRAME_RETIRE_CONNECTION_ID;
  dest->seq = ngtcp2_get_varint(&n, p);
  p += n;

  (static_cast<bool>(
       (size_t)(p - payload) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - payload) == len", "all.cpp", 32804, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_decode_handshake_done_frame(ngtcp2_handshake_done *dest,
                                                    const uint8_t *payload,
                                                    size_t payloadlen)
{
  (void)payload;
  (void)payloadlen;
  dest->type = NGTCP2_FRAME_HANDSHAKE_DONE;
  return 1;
}
ngtcp2_ssize ngtcp2_pkt_encode_frame(uint8_t *out, size_t outlen,
                                     ngtcp2_frame *fr)
{
  switch (fr->type)
  {
  case NGTCP2_FRAME_STREAM:
    return ngtcp2_pkt_encode_stream_frame(out, outlen, &fr->stream);
  case NGTCP2_FRAME_ACK:
  case NGTCP2_FRAME_ACK_ECN:
    return ngtcp2_pkt_encode_ack_frame(out, outlen, &fr->ack);
  case NGTCP2_FRAME_PADDING:
    return ngtcp2_pkt_encode_padding_frame(out, outlen, &fr->padding);
  case NGTCP2_FRAME_RESET_STREAM:
    return ngtcp2_pkt_encode_reset_stream_frame(out, outlen, &fr->reset_stream);
  case NGTCP2_FRAME_CONNECTION_CLOSE:
  case NGTCP2_FRAME_CONNECTION_CLOSE_APP:
    return ngtcp2_pkt_encode_connection_close_frame(out, outlen,
                                                    &fr->connection_close);
  case NGTCP2_FRAME_MAX_DATA:
    return ngtcp2_pkt_encode_max_data_frame(out, outlen, &fr->max_data);
  case NGTCP2_FRAME_MAX_STREAM_DATA:
    return ngtcp2_pkt_encode_max_stream_data_frame(out, outlen,
                                                   &fr->max_stream_data);
  case NGTCP2_FRAME_MAX_STREAMS_BIDI:
  case NGTCP2_FRAME_MAX_STREAMS_UNI:
    return ngtcp2_pkt_encode_max_streams_frame(out, outlen, &fr->max_streams);
  case NGTCP2_FRAME_PING:
    return ngtcp2_pkt_encode_ping_frame(out, outlen, &fr->ping);
  case NGTCP2_FRAME_DATA_BLOCKED:
    return ngtcp2_pkt_encode_data_blocked_frame(out, outlen, &fr->data_blocked);
  case NGTCP2_FRAME_STREAM_DATA_BLOCKED:
    return ngtcp2_pkt_encode_stream_data_blocked_frame(
        out, outlen, &fr->stream_data_blocked);
  case NGTCP2_FRAME_STREAMS_BLOCKED_BIDI:
  case NGTCP2_FRAME_STREAMS_BLOCKED_UNI:
    return ngtcp2_pkt_encode_streams_blocked_frame(out, outlen,
                                                   &fr->streams_blocked);
  case NGTCP2_FRAME_NEW_CONNECTION_ID:
    return ngtcp2_pkt_encode_new_connection_id_frame(out, outlen,
                                                     &fr->new_connection_id);
  case NGTCP2_FRAME_STOP_SENDING:
    return ngtcp2_pkt_encode_stop_sending_frame(out, outlen, &fr->stop_sending);
  case NGTCP2_FRAME_PATH_CHALLENGE:
    return ngtcp2_pkt_encode_path_challenge_frame(out, outlen,
                                                  &fr->path_challenge);
  case NGTCP2_FRAME_PATH_RESPONSE:
    return ngtcp2_pkt_encode_path_response_frame(out, outlen,
                                                 &fr->path_response);
  case NGTCP2_FRAME_CRYPTO:
    return ngtcp2_pkt_encode_crypto_frame(out, outlen, &fr->crypto);
  case NGTCP2_FRAME_NEW_TOKEN:
    return ngtcp2_pkt_encode_new_token_frame(out, outlen, &fr->new_token);
  case NGTCP2_FRAME_RETIRE_CONNECTION_ID:
    return ngtcp2_pkt_encode_retire_connection_id_frame(
        out, outlen, &fr->retire_connection_id);
  case NGTCP2_FRAME_HANDSHAKE_DONE:
    return ngtcp2_pkt_encode_handshake_done_frame(out, outlen,
                                                  &fr->handshake_done);
  default:
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
}
ngtcp2_ssize ngtcp2_pkt_encode_stream_frame(uint8_t *out, size_t outlen,
                                            ngtcp2_stream *fr)
{
  size_t len = 1;
  uint8_t flags = 0x02;
  uint8_t *p;
  size_t i;
  size_t datalen = 0;
  if (fr->fin)
  {
    flags |= 0x01;
  }
  if (fr->offset)
  {
    flags |= 0x04;
    len += ngtcp2_put_varint_len(fr->offset);
  }
  len += ngtcp2_put_varint_len((uint64_t)fr->stream_id);
  for (i = 0; i < fr->datacnt; ++i)
  {
    datalen += fr->data[i].len;
  }
  len += ngtcp2_put_varint_len(datalen);
  len += datalen;
  if (outlen < len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = out;
  *p++ = flags | NGTCP2_FRAME_STREAM;
  fr->flags = flags;
  p = ngtcp2_put_varint(p, (uint64_t)fr->stream_id);
  if (fr->offset)
  {
    p = ngtcp2_put_varint(p, fr->offset);
  }
  p = ngtcp2_put_varint(p, datalen);
  for (i = 0; i < fr->datacnt; ++i)
  {

    (static_cast<bool>(
         fr->data[i].len)
         ? void(0)
         : __assert_fail(
               "fr->data[i].len", "all.cpp", 32920, __extension__ __PRETTY_FUNCTION__));

    (static_cast<bool>(
         fr->data[i].base)
         ? void(0)
         : __assert_fail(
               "fr->data[i].base", "all.cpp", 32921, __extension__ __PRETTY_FUNCTION__));
    p = ngtcp2_cpymem(p, fr->data[i].base, fr->data[i].len);
  }

  (static_cast<bool>(
       (size_t)(p - out) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - out) == len", "all.cpp", 32924, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_encode_ack_frame(uint8_t *out, size_t outlen,
                                         ngtcp2_ack *fr)
{
  size_t len = 1 + ngtcp2_put_varint_len((uint64_t)fr->largest_ack) +
               ngtcp2_put_varint_len(fr->ack_delay) +
               ngtcp2_put_varint_len(fr->num_blks) +
               ngtcp2_put_varint_len(fr->first_ack_blklen);
  uint8_t *p;
  size_t i;
  const ngtcp2_ack_blk *blk;
  for (i = 0; i < fr->num_blks; ++i)
  {
    blk = &fr->blks[i];
    len += ngtcp2_put_varint_len(blk->gap);
    len += ngtcp2_put_varint_len(blk->blklen);
  }
  if (fr->type == NGTCP2_FRAME_ACK_ECN)
  {
    len += ngtcp2_put_varint_len(fr->ecn.ect0) +
           ngtcp2_put_varint_len(fr->ecn.ect1) +
           ngtcp2_put_varint_len(fr->ecn.ce);
  }
  if (outlen < len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = out;
  *p++ = fr->type;
  p = ngtcp2_put_varint(p, (uint64_t)fr->largest_ack);
  p = ngtcp2_put_varint(p, fr->ack_delay);
  p = ngtcp2_put_varint(p, fr->num_blks);
  p = ngtcp2_put_varint(p, fr->first_ack_blklen);
  for (i = 0; i < fr->num_blks; ++i)
  {
    blk = &fr->blks[i];
    p = ngtcp2_put_varint(p, blk->gap);
    p = ngtcp2_put_varint(p, blk->blklen);
  }
  if (fr->type == NGTCP2_FRAME_ACK_ECN)
  {
    p = ngtcp2_put_varint(p, fr->ecn.ect0);
    p = ngtcp2_put_varint(p, fr->ecn.ect1);
    p = ngtcp2_put_varint(p, fr->ecn.ce);
  }

  (static_cast<bool>(
       (size_t)(p - out) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - out) == len", "all.cpp", 32972, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_encode_padding_frame(uint8_t *out, size_t outlen,
                                             const ngtcp2_padding *fr)
{
  if (outlen < fr->len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  memset(out, 0, fr->len);
  return (ngtcp2_ssize)fr->len;
}
ngtcp2_ssize
ngtcp2_pkt_encode_reset_stream_frame(uint8_t *out, size_t outlen,
                                     const ngtcp2_reset_stream *fr)
{
  size_t len = 1 + ngtcp2_put_varint_len((uint64_t)fr->stream_id) +
               ngtcp2_put_varint_len(fr->app_error_code) +
               ngtcp2_put_varint_len(fr->final_size);
  uint8_t *p;
  if (outlen < len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = out;
  *p++ = NGTCP2_FRAME_RESET_STREAM;
  p = ngtcp2_put_varint(p, (uint64_t)fr->stream_id);
  p = ngtcp2_put_varint(p, fr->app_error_code);
  p = ngtcp2_put_varint(p, fr->final_size);

  (static_cast<bool>(
       (size_t)(p - out) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - out) == len", "all.cpp", 33004, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize
ngtcp2_pkt_encode_connection_close_frame(uint8_t *out, size_t outlen,
                                         const ngtcp2_connection_close *fr)
{
  size_t len = 1 + ngtcp2_put_varint_len(fr->error_code) +
               (fr->type == NGTCP2_FRAME_CONNECTION_CLOSE
                    ? ngtcp2_put_varint_len(fr->frame_type)
                    : 0) +
               ngtcp2_put_varint_len(fr->reasonlen) + fr->reasonlen;
  uint8_t *p;
  if (outlen < len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = out;
  *p++ = fr->type;
  p = ngtcp2_put_varint(p, fr->error_code);
  if (fr->type == NGTCP2_FRAME_CONNECTION_CLOSE)
  {
    p = ngtcp2_put_varint(p, fr->frame_type);
  }
  p = ngtcp2_put_varint(p, fr->reasonlen);
  if (fr->reasonlen)
  {
    p = ngtcp2_cpymem(p, fr->reason, fr->reasonlen);
  }

  (static_cast<bool>(
       (size_t)(p - out) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - out) == len", "all.cpp", 33034, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_encode_max_data_frame(uint8_t *out, size_t outlen,
                                              const ngtcp2_max_data *fr)
{
  size_t len = 1 + ngtcp2_put_varint_len(fr->max_data);
  uint8_t *p;
  if (outlen < len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = out;
  *p++ = NGTCP2_FRAME_MAX_DATA;
  p = ngtcp2_put_varint(p, fr->max_data);

  (static_cast<bool>(
       (size_t)(p - out) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - out) == len", "all.cpp", 33050, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize
ngtcp2_pkt_encode_max_stream_data_frame(uint8_t *out, size_t outlen,
                                        const ngtcp2_max_stream_data *fr)
{
  size_t len = 1 + ngtcp2_put_varint_len((uint64_t)fr->stream_id) +
               ngtcp2_put_varint_len(fr->max_stream_data);
  uint8_t *p;
  if (outlen < len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = out;
  *p++ = NGTCP2_FRAME_MAX_STREAM_DATA;
  p = ngtcp2_put_varint(p, (uint64_t)fr->stream_id);
  p = ngtcp2_put_varint(p, fr->max_stream_data);

  (static_cast<bool>(
       (size_t)(p - out) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - out) == len", "all.cpp", 33069, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_encode_max_streams_frame(uint8_t *out, size_t outlen,
                                                 const ngtcp2_max_streams *fr)
{
  size_t len = 1 + ngtcp2_put_varint_len(fr->max_streams);
  uint8_t *p;
  if (outlen < len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = out;
  *p++ = fr->type;
  p = ngtcp2_put_varint(p, fr->max_streams);

  (static_cast<bool>(
       (size_t)(p - out) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - out) == len", "all.cpp", 33085, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_encode_ping_frame(uint8_t *out, size_t outlen,
                                          const ngtcp2_ping *fr)
{
  (void)fr;
  if (outlen < 1)
  {
    return NGTCP2_ERR_NOBUF;
  }
  *out++ = NGTCP2_FRAME_PING;
  return 1;
}
ngtcp2_ssize
ngtcp2_pkt_encode_data_blocked_frame(uint8_t *out, size_t outlen,
                                     const ngtcp2_data_blocked *fr)
{
  size_t len = 1 + ngtcp2_put_varint_len(fr->offset);
  uint8_t *p;
  if (outlen < len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = out;
  *p++ = NGTCP2_FRAME_DATA_BLOCKED;
  p = ngtcp2_put_varint(p, fr->offset);

  (static_cast<bool>(
       (size_t)(p - out) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - out) == len", "all.cpp", 33114, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_encode_stream_data_blocked_frame(
    uint8_t *out, size_t outlen, const ngtcp2_stream_data_blocked *fr)
{
  size_t len = 1 + ngtcp2_put_varint_len((uint64_t)fr->stream_id) +
               ngtcp2_put_varint_len(fr->offset);
  uint8_t *p;
  if (outlen < len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = out;
  *p++ = NGTCP2_FRAME_STREAM_DATA_BLOCKED;
  p = ngtcp2_put_varint(p, (uint64_t)fr->stream_id);
  p = ngtcp2_put_varint(p, fr->offset);

  (static_cast<bool>(
       (size_t)(p - out) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - out) == len", "all.cpp", 33132, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize
ngtcp2_pkt_encode_streams_blocked_frame(uint8_t *out, size_t outlen,
                                        const ngtcp2_streams_blocked *fr)
{
  size_t len = 1 + ngtcp2_put_varint_len(fr->stream_limit);
  uint8_t *p;
  if (outlen < len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = out;
  *p++ = fr->type;
  p = ngtcp2_put_varint(p, fr->stream_limit);

  (static_cast<bool>(
       (size_t)(p - out) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - out) == len", "all.cpp", 33149, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize
ngtcp2_pkt_encode_new_connection_id_frame(uint8_t *out, size_t outlen,
                                          const ngtcp2_new_connection_id *fr)
{
  size_t len = 1 + ngtcp2_put_varint_len(fr->seq) +
               ngtcp2_put_varint_len(fr->retire_prior_to) + 1 +
               fr->cid.datalen + 16;
  uint8_t *p;
  if (outlen < len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = out;
  *p++ = NGTCP2_FRAME_NEW_CONNECTION_ID;
  p = ngtcp2_put_varint(p, fr->seq);
  p = ngtcp2_put_varint(p, fr->retire_prior_to);
  *p++ = (uint8_t)fr->cid.datalen;
  p = ngtcp2_cpymem(p, fr->cid.data, fr->cid.datalen);
  p = ngtcp2_cpymem(p, fr->stateless_reset_token,
                    16);

  (static_cast<bool>(
       (size_t)(p - out) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - out) == len", "all.cpp", 33173, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize
ngtcp2_pkt_encode_stop_sending_frame(uint8_t *out, size_t outlen,
                                     const ngtcp2_stop_sending *fr)
{
  size_t len = 1 + ngtcp2_put_varint_len((uint64_t)fr->stream_id) +
               ngtcp2_put_varint_len(fr->app_error_code);
  uint8_t *p;
  if (outlen < len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = out;
  *p++ = NGTCP2_FRAME_STOP_SENDING;
  p = ngtcp2_put_varint(p, (uint64_t)fr->stream_id);
  p = ngtcp2_put_varint(p, fr->app_error_code);

  (static_cast<bool>(
       (size_t)(p - out) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - out) == len", "all.cpp", 33192, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize
ngtcp2_pkt_encode_path_challenge_frame(uint8_t *out, size_t outlen,
                                       const ngtcp2_path_challenge *fr)
{
  size_t len = 1 + 8;
  uint8_t *p;
  if (outlen < len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = out;
  *p++ = NGTCP2_FRAME_PATH_CHALLENGE;
  p = ngtcp2_cpymem(p, fr->data, sizeof(fr->data));

  (static_cast<bool>(
       (size_t)(p - out) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - out) == len", "all.cpp", 33209, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize
ngtcp2_pkt_encode_path_response_frame(uint8_t *out, size_t outlen,
                                      const ngtcp2_path_response *fr)
{
  size_t len = 1 + 8;
  uint8_t *p;
  if (outlen < len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = out;
  *p++ = NGTCP2_FRAME_PATH_RESPONSE;
  p = ngtcp2_cpymem(p, fr->data, sizeof(fr->data));

  (static_cast<bool>(
       (size_t)(p - out) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - out) == len", "all.cpp", 33226, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_encode_crypto_frame(uint8_t *out, size_t outlen,
                                            const ngtcp2_crypto *fr)
{
  size_t len = 1;
  uint8_t *p;
  size_t i;
  size_t datalen = 0;
  len += ngtcp2_put_varint_len(fr->offset);
  for (i = 0; i < fr->datacnt; ++i)
  {
    datalen += fr->data[i].len;
  }
  len += ngtcp2_put_varint_len(datalen);
  len += datalen;
  if (outlen < len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = out;
  *p++ = NGTCP2_FRAME_CRYPTO;
  p = ngtcp2_put_varint(p, fr->offset);
  p = ngtcp2_put_varint(p, datalen);
  for (i = 0; i < fr->datacnt; ++i)
  {

    (static_cast<bool>(
         fr->data[i].base)
         ? void(0)
         : __assert_fail(
               "fr->data[i].base", "all.cpp", 33254, __extension__ __PRETTY_FUNCTION__));
    p = ngtcp2_cpymem(p, fr->data[i].base, fr->data[i].len);
  }

  (static_cast<bool>(
       (size_t)(p - out) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - out) == len", "all.cpp", 33257, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_encode_new_token_frame(uint8_t *out, size_t outlen,
                                               const ngtcp2_new_token *fr)
{
  size_t len = 1 + ngtcp2_put_varint_len(fr->token.len) + fr->token.len;
  uint8_t *p;

  (static_cast<bool>(
       fr->token.len)
       ? void(0)
       : __assert_fail(
             "fr->token.len", "all.cpp", 33266, __extension__ __PRETTY_FUNCTION__));
  if (outlen < len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = out;
  *p++ = NGTCP2_FRAME_NEW_TOKEN;
  p = ngtcp2_put_varint(p, fr->token.len);
  p = ngtcp2_cpymem(p, fr->token.base, fr->token.len);

  (static_cast<bool>(
       (size_t)(p - out) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - out) == len", "all.cpp", 33275, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize ngtcp2_pkt_encode_retire_connection_id_frame(
    uint8_t *out, size_t outlen, const ngtcp2_retire_connection_id *fr)
{
  size_t len = 1 + ngtcp2_put_varint_len(fr->seq);
  uint8_t *p;
  if (outlen < len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = out;
  *p++ = NGTCP2_FRAME_RETIRE_CONNECTION_ID;
  p = ngtcp2_put_varint(p, fr->seq);

  (static_cast<bool>(
       (size_t)(p - out) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - out) == len", "all.cpp", 33291, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
ngtcp2_ssize
ngtcp2_pkt_encode_handshake_done_frame(uint8_t *out, size_t outlen,
                                       const ngtcp2_handshake_done *fr)
{
  (void)fr;
  if (outlen < 1)
  {
    return NGTCP2_ERR_NOBUF;
  }
  *out++ = NGTCP2_FRAME_HANDSHAKE_DONE;
  return 1;
}
ngtcp2_ssize ngtcp2_pkt_write_version_negotiation(
    uint8_t *dest, size_t destlen, uint8_t unused_random, const uint8_t *dcid,
    size_t dcidlen, const uint8_t *scid, size_t scidlen, const uint32_t *sv,
    size_t nsv)
{
  size_t len = 1 + 4 + 1 + dcidlen + 1 + scidlen + nsv * 4;
  uint8_t *p;
  size_t i;

  (static_cast<bool>(
       dcidlen < 256)
       ? void(0)
       : __assert_fail(
             "dcidlen < 256", "all.cpp", 33316, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       scidlen < 256)
       ? void(0)
       : __assert_fail(
             "scidlen < 256", "all.cpp", 33317, __extension__ __PRETTY_FUNCTION__));
  if (destlen < len)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = dest;
  *p++ = 0x80 | unused_random;
  p = ngtcp2_put_uint32be(p, 0);
  *p++ = (uint8_t)dcidlen;
  if (dcidlen)
  {
    p = ngtcp2_cpymem(p, dcid, dcidlen);
  }
  *p++ = (uint8_t)scidlen;
  if (scidlen)
  {
    p = ngtcp2_cpymem(p, scid, scidlen);
  }
  for (i = 0; i < nsv; ++i)
  {
    p = ngtcp2_put_uint32be(p, sv[i]);
  }

  (static_cast<bool>(
       (size_t)(p - dest) == len)
       ? void(0)
       : __assert_fail(
             "(size_t)(p - dest) == len", "all.cpp", 33339, __extension__ __PRETTY_FUNCTION__));
  return (ngtcp2_ssize)len;
}
size_t ngtcp2_pkt_decode_version_negotiation(uint32_t *dest,
                                             const uint8_t *payload,
                                             size_t payloadlen)
{
  const uint8_t *end = payload + payloadlen;

  (static_cast<bool>(
       (payloadlen % sizeof(uint32_t)) == 0)
       ? void(0)
       : __assert_fail(
             "(payloadlen % sizeof(uint32_t)) == 0", "all.cpp", 33348, __extension__ __PRETTY_FUNCTION__));
  for (; payload != end; payload += sizeof(uint32_t))
  {
    *dest++ = ngtcp2_get_uint32(payload);
  }
  return payloadlen / sizeof(uint32_t);
}
int ngtcp2_pkt_decode_stateless_reset(ngtcp2_pkt_stateless_reset *sr,
                                      const uint8_t *payload,
                                      size_t payloadlen)
{
  const uint8_t *p = payload;
  if (payloadlen <
      5 + 16)
  {
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  sr->rand = p;
  sr->randlen = payloadlen - 16;
  p += sr->randlen;
  memcpy(sr->stateless_reset_token, p, 16);
  return 0;
}
int ngtcp2_pkt_decode_retry(ngtcp2_pkt_retry *dest, const uint8_t *payload,
                            size_t payloadlen)
{
  size_t len = 1 + 16;
  if (payloadlen < len)
  {
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  dest->token.base = (uint8_t *)payload;
  dest->token.len = (size_t)(payloadlen - 16);
  ngtcp2_cpymem(dest->tag, payload + dest->token.len, 16);
  return 0;
}
int64_t ngtcp2_pkt_adjust_pkt_num(int64_t max_pkt_num, int64_t pkt_num,
                                  size_t n)
{
  int64_t expected = max_pkt_num + 1;
  int64_t win = (int64_t)1 << n;
  int64_t hwin = win / 2;
  int64_t mask = win - 1;
  int64_t cand = (expected & ~mask) | pkt_num;
  if (cand <= expected - hwin)
  {

    (static_cast<bool>(
         cand <= (int64_t)((1ULL << 62) - 1) - win)
         ? void(0)
         : __assert_fail(
               "cand <= (int64_t)NGTCP2_MAX_VARINT - win", "all.cpp", 33397, __extension__ __PRETTY_FUNCTION__));
    return cand + win;
  }
  if (cand > expected + hwin && cand >= win)
  {
    return cand - win;
  }
  return cand;
}
int ngtcp2_pkt_validate_ack(ngtcp2_ack *fr)
{
  int64_t largest_ack = fr->largest_ack;
  size_t i;
  if (largest_ack < (int64_t)fr->first_ack_blklen)
  {
    return NGTCP2_ERR_ACK_FRAME;
  }
  largest_ack -= (int64_t)fr->first_ack_blklen;
  for (i = 0; i < fr->num_blks; ++i)
  {
    if (largest_ack < (int64_t)fr->blks[i].gap + 2)
    {
      return NGTCP2_ERR_ACK_FRAME;
    }
    largest_ack -= (int64_t)fr->blks[i].gap + 2;
    if (largest_ack < (int64_t)fr->blks[i].blklen)
    {
      return NGTCP2_ERR_ACK_FRAME;
    }
    largest_ack -= (int64_t)fr->blks[i].blklen;
  }
  return 0;
}
ngtcp2_ssize
ngtcp2_pkt_write_stateless_reset(uint8_t *dest, size_t destlen,
                                 const uint8_t *stateless_reset_token,
                                 const uint8_t *rand, size_t randlen)
{
  uint8_t *p;
  if (destlen <
      5 + 16)
  {
    return NGTCP2_ERR_NOBUF;
  }
  if (randlen < 5)
  {
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  p = dest;
  randlen = ((destlen - 16) < (randlen) ? (destlen - 16) : (randlen));
  p = ngtcp2_cpymem(p, rand, randlen);
  p = ngtcp2_cpymem(p, stateless_reset_token, 16);
  *dest = (uint8_t)((*dest & 0x7fu) | 0x40u);
  return p - dest;
}
ngtcp2_ssize ngtcp2_pkt_write_retry(
    uint8_t *dest, size_t destlen, uint32_t version, const ngtcp2_cid *dcid,
    const ngtcp2_cid *scid, const ngtcp2_cid *odcid, const uint8_t *token,
    size_t tokenlen, ngtcp2_encrypt encrypt, const ngtcp2_crypto_aead *aead,
    const ngtcp2_crypto_aead_ctx *aead_ctx)
{
  ngtcp2_pkt_hd hd;
  uint8_t pseudo_retry[1500];
  ngtcp2_ssize pseudo_retrylen;
  uint8_t tag[16];
  int rv;
  uint8_t *p;
  size_t offset;

  (static_cast<bool>(
       tokenlen > 0)
       ? void(0)
       : __assert_fail(
             "tokenlen > 0", "all.cpp", 33468, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       !ngtcp2_cid_eq(scid, odcid))
       ? void(0)
       : __assert_fail(
             "!ngtcp2_cid_eq(scid, odcid)", "all.cpp", 33469, __extension__ __PRETTY_FUNCTION__));
  if (odcid->datalen < 8)
  {
    return NGTCP2_ERR_INVALID_ARGUMENT;
  }
  ngtcp2_pkt_hd_init(&hd, NGTCP2_PKT_FLAG_LONG_FORM, NGTCP2_PKT_RETRY, dcid,
                     scid, 0, 1, version,
                     0);
  pseudo_retrylen =
      ngtcp2_pkt_encode_pseudo_retry(pseudo_retry, sizeof(pseudo_retry), &hd,
                                     0, odcid, token, tokenlen);
  if (pseudo_retrylen < 0)
  {
    return pseudo_retrylen;
  }
  rv = encrypt(tag, aead, aead_ctx, (const uint8_t *)"", 0,
               (const uint8_t *)"\xe5\x49\x30\xf9\x7f\x21\x36\xf0\x53\x0a\x8c\x1c",
               sizeof("\xe5\x49\x30\xf9\x7f\x21\x36\xf0\x53\x0a\x8c\x1c") - 1, pseudo_retry,
               (size_t)pseudo_retrylen);
  if (rv != 0)
  {
    return rv;
  }
  offset = 1 + odcid->datalen;
  if (destlen < (size_t)pseudo_retrylen + sizeof(tag) - offset)
  {
    return NGTCP2_ERR_NOBUF;
  }
  p = ngtcp2_cpymem(dest, pseudo_retry + offset,
                    (size_t)pseudo_retrylen - offset);
  p = ngtcp2_cpymem(p, tag, sizeof(tag));
  return p - dest;
}
ngtcp2_ssize ngtcp2_pkt_encode_pseudo_retry(
    uint8_t *dest, size_t destlen, const ngtcp2_pkt_hd *hd, uint8_t unused,
    const ngtcp2_cid *odcid, const uint8_t *token, size_t tokenlen)
{
  uint8_t *p = dest;
  ngtcp2_ssize nwrite;
  if (destlen < 1 + odcid->datalen)
  {
    return NGTCP2_ERR_NOBUF;
  }
  *p++ = (uint8_t)odcid->datalen;
  p = ngtcp2_cpymem(p, odcid->data, odcid->datalen);
  destlen -= (size_t)(p - dest);
  nwrite = ngtcp2_pkt_encode_hd_long(p, destlen, hd);
  if (nwrite < 0)
  {
    return nwrite;
  }
  if (destlen < (size_t)nwrite + tokenlen)
  {
    return NGTCP2_ERR_NOBUF;
  }
  *p &= 0xf0;
  *p |= unused;
  p += nwrite;
  p = ngtcp2_cpymem(p, token, tokenlen);
  return p - dest;
}
int ngtcp2_pkt_verify_retry_tag(const ngtcp2_pkt_retry *retry,
                                const uint8_t *pkt, size_t pktlen,
                                ngtcp2_encrypt encrypt,
                                const ngtcp2_crypto_aead *aead,
                                const ngtcp2_crypto_aead_ctx *aead_ctx)
{
  uint8_t pseudo_retry[1500];
  size_t pseudo_retrylen;
  uint8_t *p = pseudo_retry;
  int rv;
  uint8_t tag[16];

  (static_cast<bool>(
       pktlen >= sizeof(retry->tag))
       ? void(0)
       : __assert_fail(
             "pktlen >= sizeof(retry->tag)", "all.cpp", 33543, __extension__ __PRETTY_FUNCTION__));
  if (sizeof(pseudo_retry) <
      1 + retry->odcid.datalen + pktlen - sizeof(retry->tag))
  {
    return NGTCP2_ERR_PROTO;
  }
  *p++ = (uint8_t)retry->odcid.datalen;
  p = ngtcp2_cpymem(p, retry->odcid.data, retry->odcid.datalen);
  p = ngtcp2_cpymem(p, pkt, pktlen - sizeof(retry->tag));
  pseudo_retrylen = (size_t)(p - pseudo_retry);
  rv = encrypt(tag, aead, aead_ctx, (const uint8_t *)"", 0,
               (const uint8_t *)"\xe5\x49\x30\xf9\x7f\x21\x36\xf0\x53\x0a\x8c\x1c",
               sizeof("\xe5\x49\x30\xf9\x7f\x21\x36\xf0\x53\x0a\x8c\x1c") - 1, pseudo_retry, pseudo_retrylen);
  if (rv != 0)
  {
    return rv;
  }
  if (0 != memcmp(retry->tag, tag, sizeof(retry->tag)))
  {
    return NGTCP2_ERR_PROTO;
  }
  return 0;
}
size_t ngtcp2_pkt_stream_max_datalen(int64_t stream_id, uint64_t offset,
                                     size_t len, size_t left)
{
  size_t n = 1 + ngtcp2_put_varint_len((uint64_t)stream_id) +
             (offset ? ngtcp2_put_varint_len(offset) : 0);
  if (left <= n)
  {
    return (size_t)-1;
  }
  left -= n;
  if (left > 8 + 1073741823 && len > 1073741823)
  {
    len = ((len) < (4611686018427387903lu) ? (len) : (4611686018427387903lu));
    return ((len) < (left - 8) ? (len) : (left - 8));
  }
  if (left > 4 + 16383 && len > 16383)
  {
    len = ((len) < (1073741823) ? (len) : (1073741823));
    return ((len) < (left - 4) ? (len) : (left - 4));
  }
  if (left > 2 + 63 && len > 63)
  {
    len = ((len) < (16383) ? (len) : (16383));
    return ((len) < (left - 2) ? (len) : (left - 2));
  }
  len = ((len) < (63) ? (len) : (63));
  return ((len) < (left - 1) ? (len) : (left - 1));
}
size_t ngtcp2_pkt_crypto_max_datalen(uint64_t offset, size_t len, size_t left)
{
  size_t n = 1 + ngtcp2_put_varint_len(offset);
  if (left <= n + 1)
  {
    return (size_t)-1;
  }
  left -= n;
  if (left > 8 + 1073741823 && len > 1073741823)
  {
    len = ((len) < (4611686018427387903lu) ? (len) : (4611686018427387903lu));
    return ((len) < (left - 8) ? (len) : (left - 8));
  }
  if (left > 4 + 16383 && len > 16383)
  {
    len = ((len) < (1073741823) ? (len) : (1073741823));
    return ((len) < (left - 4) ? (len) : (left - 4));
  }
  if (left > 2 + 63 && len > 63)
  {
    len = ((len) < (16383) ? (len) : (16383));
    return ((len) < (left - 2) ? (len) : (left - 2));
  }
  len = ((len) < (63) ? (len) : (63));
  return ((len) < (left - 1) ? (len) : (left - 1));
}
uint8_t ngtcp2_pkt_get_type_long(uint8_t c)
{
  return (uint8_t)((c & 0x30) >> 4);
}
int ngtcp2_pkt_verify_reserved_bits(uint8_t c)
{
  if (c & 0x80)
  {
    return (c & 0x0c) == 0 ? 0 : NGTCP2_ERR_PROTO;
  }
  return (c & 0x18) == 0 ? 0 : NGTCP2_ERR_PROTO;
}
void ngtcp2_ppe_init(ngtcp2_ppe *ppe, uint8_t *out, size_t outlen,
                     ngtcp2_crypto_cc *cc)
{
  ngtcp2_buf_init(&ppe->buf, out, outlen);
  ppe->hdlen = 0;
  ppe->len_offset = 0;
  ppe->pkt_num_offset = 0;
  ppe->pkt_numlen = 0;
  ppe->pkt_num = 0;
  ppe->sample_offset = 0;
  ppe->cc = cc;
}
int ngtcp2_ppe_encode_hd(ngtcp2_ppe *ppe, const ngtcp2_pkt_hd *hd)
{
  ngtcp2_ssize rv;
  ngtcp2_buf *buf = &ppe->buf;
  ngtcp2_crypto_cc *cc = ppe->cc;
  if (ngtcp2_buf_left(buf) < cc->aead_overhead)
  {
    return NGTCP2_ERR_NOBUF;
  }
  if (hd->flags & NGTCP2_PKT_FLAG_LONG_FORM)
  {
    ppe->len_offset = 1 + 4 + 1 + hd->dcid.datalen + 1 + hd->scid.datalen;
    if (hd->type == NGTCP2_PKT_INITIAL)
    {
      ppe->len_offset += ngtcp2_put_varint_len(hd->token.len) + hd->token.len;
    }
    ppe->pkt_num_offset = ppe->len_offset + 2;
    rv = ngtcp2_pkt_encode_hd_long(
        buf->last, ngtcp2_buf_left(buf) - cc->aead_overhead, hd);
  }
  else
  {
    ppe->pkt_num_offset = 1 + hd->dcid.datalen;
    rv = ngtcp2_pkt_encode_hd_short(
        buf->last, ngtcp2_buf_left(buf) - cc->aead_overhead, hd);
  }
  if (rv < 0)
  {
    return (int)rv;
  }
  ppe->sample_offset = ppe->pkt_num_offset + 4;
  buf->last += rv;
  ppe->pkt_numlen = hd->pkt_numlen;
  ppe->hdlen = (size_t)rv;
  ppe->pkt_num = hd->pkt_num;
  return 0;
}
int ngtcp2_ppe_encode_frame(ngtcp2_ppe *ppe, ngtcp2_frame *fr)
{
  ngtcp2_ssize rv;
  ngtcp2_buf *buf = &ppe->buf;
  ngtcp2_crypto_cc *cc = ppe->cc;
  if (ngtcp2_buf_left(buf) < cc->aead_overhead)
  {
    return NGTCP2_ERR_NOBUF;
  }
  rv = ngtcp2_pkt_encode_frame(buf->last,
                               ngtcp2_buf_left(buf) - cc->aead_overhead, fr);
  if (rv < 0)
  {
    return (int)rv;
  }
  buf->last += rv;
  return 0;
}
ngtcp2_ssize ngtcp2_ppe_final(ngtcp2_ppe *ppe, const uint8_t **ppkt)
{
  ngtcp2_buf *buf = &ppe->buf;
  ngtcp2_crypto_cc *cc = ppe->cc;
  uint8_t *payload = buf->begin + ppe->hdlen;
  size_t payloadlen = ngtcp2_buf_len(buf) - ppe->hdlen;
  uint8_t mask[16];
  uint8_t *p;
  size_t i;
  int rv;

  (static_cast<bool>(
       cc->encrypt)
       ? void(0)
       : __assert_fail(
             "cc->encrypt", "all.cpp", 33726, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       cc->hp_mask)
       ? void(0)
       : __assert_fail(
             "cc->hp_mask", "all.cpp", 33727, __extension__ __PRETTY_FUNCTION__));
  if (ppe->len_offset)
  {
    ngtcp2_put_varint14(
        buf->begin + ppe->len_offset,
        (uint16_t)(payloadlen + ppe->pkt_numlen + cc->aead_overhead));
  }
  ngtcp2_crypto_create_nonce(ppe->nonce, cc->ckm->iv.base, cc->ckm->iv.len,
                             ppe->pkt_num);
  rv = cc->encrypt(payload, &cc->aead, &cc->ckm->aead_ctx, payload, payloadlen,
                   ppe->nonce, cc->ckm->iv.len, buf->begin, ppe->hdlen);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  buf->last = payload + payloadlen + cc->aead_overhead;

  (static_cast<bool>(
       ppe->sample_offset + 16 <= ngtcp2_buf_len(buf))
       ? void(0)
       : __assert_fail(
             "ppe->sample_offset + NGTCP2_HP_SAMPLELEN <= ngtcp2_buf_len(buf)", "all.cpp", 33743, __extension__ __PRETTY_FUNCTION__));
  rv = cc->hp_mask(mask, &cc->hp, &cc->hp_ctx, buf->begin + ppe->sample_offset);
  if (rv != 0)
  {
    return NGTCP2_ERR_CALLBACK_FAILURE;
  }
  p = buf->begin;
  if (*p & 0x80)
  {
    *p = (uint8_t)(*p ^ (mask[0] & 0x0f));
  }
  else
  {
    *p = (uint8_t)(*p ^ (mask[0] & 0x1f));
  }
  p = buf->begin + ppe->pkt_num_offset;
  for (i = 0; i < ppe->pkt_numlen; ++i)
  {
    *(p + i) ^= mask[i + 1];
  }
  if (ppkt !=
      __null)
  {
    *ppkt = buf->begin;
  }
  return (ngtcp2_ssize)ngtcp2_buf_len(buf);
}
size_t ngtcp2_ppe_left(ngtcp2_ppe *ppe)
{
  ngtcp2_crypto_cc *cc = ppe->cc;
  if (ngtcp2_buf_left(&ppe->buf) < cc->aead_overhead)
  {
    return 0;
  }
  return ngtcp2_buf_left(&ppe->buf) - cc->aead_overhead;
}
size_t ngtcp2_ppe_pktlen(ngtcp2_ppe *ppe)
{
  ngtcp2_crypto_cc *cc = ppe->cc;
  return ngtcp2_buf_len(&ppe->buf) + cc->aead_overhead;
}
size_t ngtcp2_ppe_padding(ngtcp2_ppe *ppe)
{
  ngtcp2_crypto_cc *cc = ppe->cc;
  ngtcp2_buf *buf = &ppe->buf;
  size_t len;

  (static_cast<bool>(
       ngtcp2_buf_left(buf) >= cc->aead_overhead)
       ? void(0)
       : __assert_fail(
             "ngtcp2_buf_left(buf) >= cc->aead_overhead", "all.cpp", 33791, __extension__ __PRETTY_FUNCTION__));
  len = ngtcp2_buf_left(buf) - cc->aead_overhead;
  memset(buf->last, 0, len);
  buf->last += len;
  return len;
}
size_t ngtcp2_ppe_padding_hp_sample(ngtcp2_ppe *ppe)
{
  ngtcp2_crypto_cc *cc = ppe->cc;
  ngtcp2_buf *buf = &ppe->buf;
  size_t max_samplelen;
  size_t len = 0;

  (static_cast<bool>(
       cc->aead_overhead)
       ? void(0)
       : __assert_fail(
             "cc->aead_overhead", "all.cpp", 33804, __extension__ __PRETTY_FUNCTION__));
  max_samplelen = ngtcp2_buf_len(buf) + cc->aead_overhead - ppe->sample_offset;
  if (max_samplelen < 16)
  {
    len = 16 - max_samplelen;

    (static_cast<bool>(
         ngtcp2_ppe_left(ppe) >= len)
         ? void(0)
         : __assert_fail(
               "ngtcp2_ppe_left(ppe) >= len", "all.cpp", 33809, __extension__ __PRETTY_FUNCTION__));
    memset(buf->last, 0, len);
    buf->last += len;
  }
  return len;
}
size_t ngtcp2_ppe_padding_size(ngtcp2_ppe *ppe, size_t n)
{
  ngtcp2_crypto_cc *cc = ppe->cc;
  ngtcp2_buf *buf = &ppe->buf;
  size_t pktlen = ngtcp2_buf_len(buf) + cc->aead_overhead;
  size_t len;
  if (pktlen >= n)
  {
    return 0;
  }
  len = n - pktlen;
  buf->last = ngtcp2_setmem(buf->last, 0, len);
  return len;
}
int ngtcp2_ppe_ensure_hp_sample(ngtcp2_ppe *ppe)
{
  ngtcp2_buf *buf = &ppe->buf;
  return ngtcp2_buf_left(buf) >= (4 - ppe->pkt_numlen) + 16;
}
void ngtcp2_pq_init(ngtcp2_pq *pq, ngtcp2_less less, const ngtcp2_mem *mem)
{
  pq->mem = mem;
  pq->capacity = 0;
  pq->q =
      __null;
  pq->length = 0;
  pq->less = less;
}
void ngtcp2_pq_free(ngtcp2_pq *pq)
{
  ngtcp2_mem_free(pq->mem, pq->q);
  pq->q =
      __null;
}
static void swap(ngtcp2_pq *pq, size_t i, size_t j)
{
  ngtcp2_pq_entry *a = pq->q[i];
  ngtcp2_pq_entry *b = pq->q[j];
  pq->q[i] = b;
  b->index = i;
  pq->q[j] = a;
  a->index = j;
}
static void bubble_up(ngtcp2_pq *pq, size_t index)
{
  size_t parent;
  while (index != 0)
  {
    parent = (index - 1) / 2;
    if (!pq->less(pq->q[index], pq->q[parent]))
    {
      return;
    }
    swap(pq, parent, index);
    index = parent;
  }
}
int ngtcp2_pq_push(ngtcp2_pq *pq, ngtcp2_pq_entry *item)
{
  if (pq->capacity <= pq->length)
  {
    void *nq;
    size_t ncapacity;
    ncapacity = ((4) > ((pq->capacity * 2)) ? (4) : ((pq->capacity * 2)));
    nq = ngtcp2_mem_realloc(pq->mem, pq->q,
                            ncapacity * sizeof(ngtcp2_pq_entry *));
    if (nq ==
        __null)
    {
      return NGTCP2_ERR_NOMEM;
    }
    pq->capacity = ncapacity;
    pq->q = nq;
  }
  pq->q[pq->length] = item;
  item->index = pq->length;
  ++pq->length;
  bubble_up(pq, pq->length - 1);
  return 0;
}
ngtcp2_pq_entry *ngtcp2_pq_top(ngtcp2_pq *pq)
{

  (static_cast<bool>(
       pq->length)
       ? void(0)
       : __assert_fail(
             "pq->length", "all.cpp", 33905, __extension__ __PRETTY_FUNCTION__));
  return pq->q[0];
}
static void bubble_down(ngtcp2_pq *pq, size_t index)
{
  size_t i, j, minindex;
  for (;;)
  {
    j = index * 2 + 1;
    minindex = index;
    for (i = 0; i < 2; ++i, ++j)
    {
      if (j >= pq->length)
      {
        break;
      }
      if (pq->less(pq->q[j], pq->q[minindex]))
      {
        minindex = j;
      }
    }
    if (minindex == index)
    {
      return;
    }
    swap(pq, index, minindex);
    index = minindex;
  }
}
void ngtcp2_pq_pop(ngtcp2_pq *pq)
{
  if (pq->length > 0)
  {
    pq->q[0] = pq->q[pq->length - 1];
    pq->q[0]->index = 0;
    --pq->length;
    bubble_down(pq, 0);
  }
}
void ngtcp2_pq_remove(ngtcp2_pq *pq, ngtcp2_pq_entry *item)
{

  (static_cast<bool>(
       pq->q[item->index] == item)
       ? void(0)
       : __assert_fail(
             "pq->q[item->index] == item", "all.cpp", 33949, __extension__ __PRETTY_FUNCTION__));
  if (item->index == 0)
  {
    ngtcp2_pq_pop(pq);
    return;
  }
  if (item->index == pq->length - 1)
  {
    --pq->length;
    return;
  }
  pq->q[item->index] = pq->q[pq->length - 1];
  pq->q[item->index]->index = item->index;
  --pq->length;
  if (pq->less(item, pq->q[item->index]))
  {
    bubble_down(pq, item->index);
  }
  else
  {
    bubble_up(pq, item->index);
  }
}
int ngtcp2_pq_empty(ngtcp2_pq *pq) { return pq->length == 0; }
size_t ngtcp2_pq_size(ngtcp2_pq *pq) { return pq->length; }
int ngtcp2_pq_each(ngtcp2_pq *pq, ngtcp2_pq_item_cb fun, void *arg)
{
  size_t i;
  if (pq->length == 0)
  {
    return 0;
  }
  for (i = 0; i < pq->length; ++i)
  {
    if ((*fun)(pq->q[i], arg))
    {
      return 1;
    }
  }
  return 0;
}
void ngtcp2_pv_entry_init(ngtcp2_pv_entry *pvent, const uint8_t *data,
                          ngtcp2_tstamp expiry)
{
  memcpy(pvent->data, data, sizeof(pvent->data));
  pvent->expiry = expiry;
}
int ngtcp2_pv_new(ngtcp2_pv **ppv, const ngtcp2_dcid *dcid,
                  ngtcp2_duration timeout, uint8_t flags, ngtcp2_log *log,
                  const ngtcp2_mem *mem)
{
  int rv;
  (*ppv) = ngtcp2_mem_malloc(mem, sizeof(ngtcp2_pv));
  if (*ppv ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  rv = ngtcp2_ringbuf_init(&(*ppv)->ents, 8,
                           sizeof(ngtcp2_pv_entry), mem);
  if (rv != 0)
  {
    ngtcp2_mem_free(mem, *ppv);
    return 0;
  }
  ngtcp2_dcid_copy(&(*ppv)->dcid, dcid);
  (*ppv)->mem = mem;
  (*ppv)->log = log;
  (*ppv)->timeout = timeout;
  (*ppv)->started_ts =
      (18446744073709551615UL);
  (*ppv)->probe_pkt_left = 2;
  (*ppv)->round = 0;
  (*ppv)->flags = flags;
  return 0;
}
void ngtcp2_pv_del(ngtcp2_pv *pv)
{
  if (pv ==
      __null)
  {
    return;
  }
  ngtcp2_ringbuf_free(&pv->ents);
  ngtcp2_mem_free(pv->mem, pv);
}
void ngtcp2_pv_add_entry(ngtcp2_pv *pv, const uint8_t *data,
                         ngtcp2_tstamp expiry, ngtcp2_tstamp ts)
{
  ngtcp2_pv_entry *ent;

  (static_cast<bool>(
       pv->probe_pkt_left)
       ? void(0)
       : __assert_fail(
             "pv->probe_pkt_left", "all.cpp", 34050, __extension__ __PRETTY_FUNCTION__));
  if (((&pv->ents)->len) == 0)
  {
    pv->started_ts = ts;
  }
  ent = ngtcp2_ringbuf_push_back(&pv->ents);
  ngtcp2_pv_entry_init(ent, data, expiry);
  pv->flags &= (uint8_t)~NGTCP2_PV_FLAG_CANCEL_TIMER;
  --pv->probe_pkt_left;
}
int ngtcp2_pv_validate(ngtcp2_pv *pv, const uint8_t *data)
{
  size_t len = ((&pv->ents)->len);
  size_t i;
  ngtcp2_pv_entry *ent;
  if (len == 0)
  {
    return NGTCP2_ERR_INVALID_STATE;
  }
  for (i = 0; i < len; ++i)
  {
    ent = ngtcp2_ringbuf_get(&pv->ents, i);
    if (memcmp(ent->data, data, sizeof(ent->data)) == 0)
    {
      ngtcp2_log_info(pv->log, NGTCP2_LOG_EVENT_PTV, "path has been validated");
      return 0;
    }
  }
  return NGTCP2_ERR_INVALID_ARGUMENT;
}
void ngtcp2_pv_handle_entry_expiry(ngtcp2_pv *pv, ngtcp2_tstamp ts)
{
  ngtcp2_pv_entry *ent;
  if (((&pv->ents)->len) == 0)
  {
    return;
  }
  ent = ngtcp2_ringbuf_get(&pv->ents, ((&pv->ents)->len) - 1);
  if (ent->expiry > ts)
  {
    return;
  }
  ++pv->round;
  pv->probe_pkt_left = 2;
}
int ngtcp2_pv_should_send_probe(ngtcp2_pv *pv)
{
  return pv->probe_pkt_left > 0;
}
int ngtcp2_pv_validation_timed_out(ngtcp2_pv *pv, ngtcp2_tstamp ts)
{
  ngtcp2_tstamp t;
  ngtcp2_pv_entry *ent;
  if (pv->started_ts ==
      (18446744073709551615UL))
  {
    return 0;
  }

  (static_cast<bool>(
       ((&pv->ents)->len))
       ? void(0)
       : __assert_fail(
             "ngtcp2_ringbuf_len(&pv->ents)", "all.cpp", 34111, __extension__ __PRETTY_FUNCTION__));
  ent = ngtcp2_ringbuf_get(&pv->ents, ((&pv->ents)->len) - 1);
  t = pv->started_ts + pv->timeout;
  t = ((t) > (ent->expiry) ? (t) : (ent->expiry));
  return t <= ts;
}
ngtcp2_tstamp ngtcp2_pv_next_expiry(ngtcp2_pv *pv)
{
  ngtcp2_pv_entry *ent;
  if ((pv->flags & NGTCP2_PV_FLAG_CANCEL_TIMER) ||
      ((&pv->ents)->len) == 0)
  {
    return (18446744073709551615UL);
  }
  ent = ngtcp2_ringbuf_get(&pv->ents, ((&pv->ents)->len) - 1);
  return ent->expiry;
}
void ngtcp2_pv_cancel_expired_timer(ngtcp2_pv *pv, ngtcp2_tstamp ts)
{
  ngtcp2_tstamp expiry = ngtcp2_pv_next_expiry(pv);
  if (expiry > ts)
  {
    return;
  }
  pv->flags |= NGTCP2_PV_FLAG_CANCEL_TIMER;
}
void ngtcp2_qlog_init(ngtcp2_qlog *qlog, ngtcp2_qlog_write write,
                      ngtcp2_tstamp ts, void *user_data)
{
  qlog->write = write;
  qlog->ts = qlog->last_ts = ts;
  qlog->user_data = user_data;
}
static uint8_t *write_string(uint8_t *p, const ngtcp2_vec *s)
{
  *p++ = '"';
  if (s->len)
  {
    p = ngtcp2_cpymem(p, s->base, s->len);
  }
  *p++ = '"';
  return p;
}
static uint8_t *write_hex(uint8_t *p, const ngtcp2_vec *s)
{
  const uint8_t *b = s->base, *end = s->base + s->len;
  *p++ = '"';
  for (; b != end; ++b)
  {
    *p++ = (uint8_t) "0123456789abcdef"[*b >> 4];
    *p++ = (uint8_t) "0123456789abcdef"[*b & 0xf];
  }
  *p++ = '"';
  return p;
}
static uint8_t *write_cid(uint8_t *p, const ngtcp2_cid *cid)
{
  ngtcp2_vec value;
  return write_hex(p, ngtcp2_vec_init(&value, cid->data, cid->datalen));
}
static uint8_t *write_number(uint8_t *p, uint64_t n)
{
  size_t nlen = 0;
  uint64_t t;
  uint8_t *res;
  if (n == 0)
  {
    *p++ = '0';
    return p;
  }
  for (t = n; t; t /= 10, ++nlen)
    ;
  p += nlen;
  res = p;
  for (; n; n /= 10)
  {
    *--p = (uint8_t)((n % 10) + '0');
  }
  return res;
}
static uint8_t *write_numstr(uint8_t *p, uint64_t n)
{
  *p++ = '"';
  p = write_number(p, n);
  *p++ = '"';
  return p;
}
static uint8_t *write_tstamp(uint8_t *p, ngtcp2_tstamp ts)
{
  return write_number(p, ts / ((uint64_t)1000000ULL));
}
static uint8_t *write_duration(uint8_t *p, ngtcp2_duration duration)
{
  return write_number(p, duration / ((uint64_t)1000000ULL));
}
static uint8_t *write_bool(uint8_t *p, int b)
{
  if (b)
  {
    return ngtcp2_cpymem(p, "true", sizeof("true") - 1);
  }
  return ngtcp2_cpymem(p, "false", sizeof("false") - 1);
}
static uint8_t *write_pair(uint8_t *p, const ngtcp2_vec *name,
                           const ngtcp2_vec *value)
{
  p = write_string(p, name);
  *p++ = ':';
  return write_string(p, value);
}
static uint8_t *write_pair_hex(uint8_t *p, const ngtcp2_vec *name,
                               const ngtcp2_vec *value)
{
  p = write_string(p, name);
  *p++ = ':';
  return write_hex(p, value);
}
static uint8_t *write_pair_numstr(uint8_t *p, const ngtcp2_vec *name,
                                  uint64_t value)
{
  p = write_string(p, name);
  *p++ = ':';
  p = write_numstr(p, value);
  return p;
}
static uint8_t *write_pair_number(uint8_t *p, const ngtcp2_vec *name,
                                  uint64_t value)
{
  p = write_string(p, name);
  *p++ = ':';
  return write_number(p, value);
}
static uint8_t *write_pair_duration(uint8_t *p, const ngtcp2_vec *name,
                                    ngtcp2_tstamp duration)
{
  p = write_string(p, name);
  *p++ = ':';
  return write_duration(p, duration);
}
static uint8_t *write_pair_bool(uint8_t *p, const ngtcp2_vec *name, int b)
{
  p = write_string(p, name);
  *p++ = ':';
  return write_bool(p, b);
}
static uint8_t *write_pair_cid(uint8_t *p, const ngtcp2_vec *name,
                               const ngtcp2_cid *cid)
{
  p = write_string(p, name);
  *p++ = ':';
  return write_cid(p, cid);
}
static uint8_t *write_trace_start(uint8_t *p, int server)
{
  p = ngtcp2_cpymem(p, "\"traces\":[{\"vantage_point\":{\"name\":\"ngtcp2\",\"type\":\"", sizeof("\"traces\":[{\"vantage_point\":{\"name\":\"ngtcp2\",\"type\":\"") - 1);
  if (server)
  {
    p = ngtcp2_cpymem(p, "server", sizeof("server") - 1);
  }
  else
  {
    p = ngtcp2_cpymem(p, "client", sizeof("client") - 1);
  }
  *p++ = '"';
  *p++ = '}';
  *p++ = ',';
  return p;
}
static uint8_t *write_common_fields(uint8_t *p, const ngtcp2_cid *odcid)
{
  ngtcp2_vec name;
  p = ngtcp2_cpymem(p, "\"common_fields\":{\"protocol_type\":\"QUIC_HTTP3\",\"reference_"
                       "time\":\"0\",",
                    sizeof("\"common_fields\":{\"protocol_type\":\"QUIC_HTTP3\",\"reference_"
                           "time\":\"0\",") -
                        1);
  p = write_pair_cid(p, ((&name)->base = (uint8_t *)("group_id"), (&name)->len = sizeof("group_id") - 1, (&name)), odcid);
  *p++ = ',';
  p = write_pair_cid(p, ((&name)->base = (uint8_t *)("ODCID"), (&name)->len = sizeof("ODCID") - 1, (&name)), odcid);
  *p++ = '}';
  *p++ = ',';
  return p;
}
static uint8_t *write_event_fields(uint8_t *p)
{
  p = ngtcp2_cpymem(p, "\"event_fields\":[\"relative_time\",\"category\",\"event\",\"data\"],", sizeof("\"event_fields\":[\"relative_time\",\"category\",\"event\",\"data\"],") - 1);
  return p;
}
static uint8_t *write_events_start(uint8_t *p)
{
  p = ngtcp2_cpymem(p, "\"events\":[", sizeof("\"events\":[") - 1);
  return p;
}
static uint8_t *write_events_end(uint8_t *p)
{
  *p++ = '[';
  *p++ = ']';
  *p++ = ']';
  return p;
}
static uint8_t *write_trace_end(uint8_t *p)
{
  *p++ = '}';
  *p++ = ']';
  return p;
}
void ngtcp2_qlog_start(ngtcp2_qlog *qlog, const ngtcp2_cid *odcid, int server)
{
  uint8_t buf[1024];
  ngtcp2_vec name, value;
  uint8_t *p = buf;
  if (!qlog->write)
  {
    return;
  }
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("qlog_version"), (&name)->len = sizeof("qlog_version") - 1, (&name)),
                 ((&value)->base = (uint8_t *)("draft-01"), (&value)->len = sizeof("draft-01") - 1, (&value)));
  *p++ = ',';
  p = write_trace_start(p, server);
  p = write_common_fields(p, odcid);
  p = write_event_fields(p);
  p = write_events_start(p);
  qlog->write(qlog->user_data, NGTCP2_QLOG_WRITE_FLAG_NONE, buf,
              (size_t)(p - buf));
}
void ngtcp2_qlog_end(ngtcp2_qlog *qlog)
{
  uint8_t buf[256];
  uint8_t *p = buf;
  if (!qlog->write)
  {
    return;
  }
  p = write_events_end(p);
  p = write_trace_end(p);
  *p++ = '}';
  qlog->write(qlog->user_data, NGTCP2_QLOG_WRITE_FLAG_FIN, buf,
              (size_t)(p - buf));
}
static uint8_t *write_pkt_hd(uint8_t *p, const ngtcp2_pkt_hd *hd,
                             size_t pktlen)
{
  ngtcp2_vec value;
  *p++ = '{';
  p = write_pair_numstr(p, ((&value)->base = (uint8_t *)("packet_number"), (&value)->len = sizeof("packet_number") - 1, (&value)),
                        (uint64_t)hd->pkt_num);
  *p++ = ',';
  p = write_pair_number(p, ((&value)->base = (uint8_t *)("packet_size"), (&value)->len = sizeof("packet_size") - 1, (&value)), pktlen);
  *p++ = '}';
  return p;
}
static ngtcp2_vec *qlog_pkt_type(ngtcp2_vec *dest, const ngtcp2_pkt_hd *hd)
{
  if (hd->flags & NGTCP2_PKT_FLAG_LONG_FORM)
  {
    switch (hd->type)
    {
    case NGTCP2_PKT_INITIAL:
      return ((dest)->base = (uint8_t *)("initial"), (dest)->len = sizeof("initial") - 1, (dest));
    case NGTCP2_PKT_HANDSHAKE:
      return ((dest)->base = (uint8_t *)("handshake"), (dest)->len = sizeof("handshake") - 1, (dest));
    case NGTCP2_PKT_0RTT:
      return ((dest)->base = (uint8_t *)("0RTT"), (dest)->len = sizeof("0RTT") - 1, (dest));
    default:
      return ((dest)->base = (uint8_t *)("unknown"), (dest)->len = sizeof("unknown") - 1, (dest));
    }
  }
  return ((dest)->base = (uint8_t *)("1RTT"), (dest)->len = sizeof("1RTT") - 1, (dest));
}
static uint8_t *write_padding_frame(uint8_t *p, const ngtcp2_padding *fr)
{
  ngtcp2_vec name, value;
  (void)fr;
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("frame_type"), (&name)->len = sizeof("frame_type") - 1, (&name)),
                 ((&value)->base = (uint8_t *)("padding"), (&value)->len = sizeof("padding") - 1, (&value)));
  *p++ = '}';
  return p;
}
static uint8_t *write_ping_frame(uint8_t *p, const ngtcp2_ping *fr)
{
  ngtcp2_vec name, value;
  (void)fr;
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("frame_type"), (&name)->len = sizeof("frame_type") - 1, (&name)),
                 ((&value)->base = (uint8_t *)("ping"), (&value)->len = sizeof("ping") - 1, (&value)));
  *p++ = '}';
  return p;
}
static uint8_t *write_ack_frame(uint8_t *p, const ngtcp2_ack *fr)
{
  ngtcp2_vec name, value;
  int64_t largest_ack, min_ack;
  size_t i;
  const ngtcp2_ack_blk *blk;
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("frame_type"), (&name)->len = sizeof("frame_type") - 1, (&name)),
                 ((&value)->base = (uint8_t *)("ack"), (&value)->len = sizeof("ack") - 1, (&value)));
  *p++ = ',';
  p = write_pair_duration(p, ((&name)->base = (uint8_t *)("ack_delay"), (&name)->len = sizeof("ack_delay") - 1, (&name)),
                          fr->ack_delay_unscaled);
  *p++ = ',';
  p = write_string(p, ((&name)->base = (uint8_t *)("acked_ranges"), (&name)->len = sizeof("acked_ranges") - 1, (&name)));
  *p++ = ':';
  *p++ = '[';
  largest_ack = fr->largest_ack;
  min_ack = fr->largest_ack - (int64_t)fr->first_ack_blklen;
  *p++ = '[';
  p = write_numstr(p, (uint64_t)min_ack);
  if (largest_ack != min_ack)
  {
    *p++ = ',';
    p = write_numstr(p, (uint64_t)largest_ack);
  }
  *p++ = ']';
  for (i = 0; i < fr->num_blks; ++i)
  {
    blk = &fr->blks[i];
    largest_ack = min_ack - (int64_t)blk->gap - 2;
    min_ack = largest_ack - (int64_t)blk->blklen;
    *p++ = ',';
    *p++ = '[';
    p = write_numstr(p, (uint64_t)min_ack);
    if (largest_ack != min_ack)
    {
      *p++ = ',';
      p = write_numstr(p, (uint64_t)largest_ack);
    }
    *p++ = ']';
  }
  *p++ = ']';
  if (fr->type == NGTCP2_FRAME_ACK_ECN)
  {
    *p++ = ',';
    p = write_pair_numstr(p, ((&name)->base = (uint8_t *)("ect1"), (&name)->len = sizeof("ect1") - 1, (&name)), fr->ecn.ect1);
    *p++ = ',';
    p = write_pair_numstr(p, ((&name)->base = (uint8_t *)("ect0"), (&name)->len = sizeof("ect0") - 1, (&name)), fr->ecn.ect0);
    *p++ = ',';
    p = write_pair_numstr(p, ((&name)->base = (uint8_t *)("ce"), (&name)->len = sizeof("ce") - 1, (&name)), fr->ecn.ce);
  }
  *p++ = '}';
  return p;
}
static uint8_t *write_reset_stream_frame(uint8_t *p,
                                         const ngtcp2_reset_stream *fr)
{
  ngtcp2_vec name, value;
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("frame_type"), (&name)->len = sizeof("frame_type") - 1, (&name)),
                 ((&value)->base = (uint8_t *)("reset_stream"), (&value)->len = sizeof("reset_stream") - 1, (&value)));
  *p++ = ',';
  p = write_pair_numstr(p, ((&name)->base = (uint8_t *)("stream_id"), (&name)->len = sizeof("stream_id") - 1, (&name)),
                        (uint64_t)fr->stream_id);
  *p++ = ',';
  p = write_pair_number(p, ((&name)->base = (uint8_t *)("error_code"), (&name)->len = sizeof("error_code") - 1, (&name)),
                        fr->app_error_code);
  *p++ = ',';
  p = write_pair_numstr(p, ((&name)->base = (uint8_t *)("final_size"), (&name)->len = sizeof("final_size") - 1, (&name)), fr->final_size);
  *p++ = '}';
  return p;
}
static uint8_t *write_stop_sending_frame(uint8_t *p,
                                         const ngtcp2_stop_sending *fr)
{
  ngtcp2_vec name, value;
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("frame_type"), (&name)->len = sizeof("frame_type") - 1, (&name)),
                 ((&value)->base = (uint8_t *)("stop_sending"), (&value)->len = sizeof("stop_sending") - 1, (&value)));
  *p++ = ',';
  p = write_pair_numstr(p, ((&name)->base = (uint8_t *)("stream_id"), (&name)->len = sizeof("stream_id") - 1, (&name)),
                        (uint64_t)fr->stream_id);
  *p++ = ',';
  p = write_pair_number(p, ((&name)->base = (uint8_t *)("error_code"), (&name)->len = sizeof("error_code") - 1, (&name)),
                        fr->app_error_code);
  *p++ = '}';
  return p;
}
static uint8_t *write_crypto_frame(uint8_t *p, const ngtcp2_crypto *fr)
{
  ngtcp2_vec name, value;
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("frame_type"), (&name)->len = sizeof("frame_type") - 1, (&name)),
                 ((&value)->base = (uint8_t *)("crypto"), (&value)->len = sizeof("crypto") - 1, (&value)));
  *p++ = ',';
  p = write_pair_numstr(p, ((&name)->base = (uint8_t *)("offset"), (&name)->len = sizeof("offset") - 1, (&name)), fr->offset);
  *p++ = ',';
  p = write_pair_number(p, ((&name)->base = (uint8_t *)("length"), (&name)->len = sizeof("length") - 1, (&name)),
                        ngtcp2_vec_len(fr->data, fr->datacnt));
  *p++ = '}';
  return p;
}
static uint8_t *write_new_token_frame(uint8_t *p, const ngtcp2_new_token *fr)
{
  ngtcp2_vec name, value;
  (void)fr;
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("frame_type"), (&name)->len = sizeof("frame_type") - 1, (&name)),
                 ((&value)->base = (uint8_t *)("new_token"), (&value)->len = sizeof("new_token") - 1, (&value)));
  *p++ = ',';
  p = write_pair_number(p, ((&name)->base = (uint8_t *)("length"), (&name)->len = sizeof("length") - 1, (&name)), fr->token.len);
  *p++ = ',';
  p = write_pair_hex(p, ((&name)->base = (uint8_t *)("token"), (&name)->len = sizeof("token") - 1, (&name)), &fr->token);
  *p++ = '}';
  return p;
}
static uint8_t *write_stream_frame(uint8_t *p, const ngtcp2_stream *fr)
{
  ngtcp2_vec name, value;
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("frame_type"), (&name)->len = sizeof("frame_type") - 1, (&name)),
                 ((&value)->base = (uint8_t *)("stream"), (&value)->len = sizeof("stream") - 1, (&value)));
  *p++ = ',';
  p = write_pair_numstr(p, ((&name)->base = (uint8_t *)("stream_id"), (&name)->len = sizeof("stream_id") - 1, (&name)),
                        (uint64_t)fr->stream_id);
  *p++ = ',';
  p = write_pair_numstr(p, ((&name)->base = (uint8_t *)("offset"), (&name)->len = sizeof("offset") - 1, (&name)), fr->offset);
  *p++ = ',';
  p = write_pair_number(p, ((&name)->base = (uint8_t *)("length"), (&name)->len = sizeof("length") - 1, (&name)),
                        ngtcp2_vec_len(fr->data, fr->datacnt));
  if (fr->fin)
  {
    *p++ = ',';
    p = write_pair_bool(p, ((&name)->base = (uint8_t *)("fin"), (&name)->len = sizeof("fin") - 1, (&name)), 1);
  }
  *p++ = '}';
  return p;
}
static uint8_t *write_max_data_frame(uint8_t *p, const ngtcp2_max_data *fr)
{
  ngtcp2_vec name, value;
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("frame_type"), (&name)->len = sizeof("frame_type") - 1, (&name)),
                 ((&value)->base = (uint8_t *)("max_data"), (&value)->len = sizeof("max_data") - 1, (&value)));
  *p++ = ',';
  p = write_pair_numstr(p, ((&name)->base = (uint8_t *)("maximum"), (&name)->len = sizeof("maximum") - 1, (&name)), fr->max_data);
  *p++ = '}';
  return p;
}
static uint8_t *write_max_stream_data_frame(uint8_t *p,
                                            const ngtcp2_max_stream_data *fr)
{
  ngtcp2_vec name, value;
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("frame_type"), (&name)->len = sizeof("frame_type") - 1, (&name)),
                 ((&value)->base = (uint8_t *)("max_stream_data"), (&value)->len = sizeof("max_stream_data") - 1, (&value)));
  *p++ = ',';
  p = write_pair_numstr(p, ((&name)->base = (uint8_t *)("stream_id"), (&name)->len = sizeof("stream_id") - 1, (&name)),
                        (uint64_t)fr->stream_id);
  *p++ = ',';
  p = write_pair_numstr(p, ((&name)->base = (uint8_t *)("maximum"), (&name)->len = sizeof("maximum") - 1, (&name)),
                        fr->max_stream_data);
  *p++ = '}';
  return p;
}
static uint8_t *write_max_streams_frame(uint8_t *p,
                                        const ngtcp2_max_streams *fr)
{
  ngtcp2_vec name, value;
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("frame_type"), (&name)->len = sizeof("frame_type") - 1, (&name)),
                 ((&value)->base = (uint8_t *)("max_streams"), (&value)->len = sizeof("max_streams") - 1, (&value)));
  *p++ = ',';
  p = write_pair(p, ((&name)->base = (uint8_t *)("stream_type"), (&name)->len = sizeof("stream_type") - 1, (&name)),
                 fr->type == NGTCP2_FRAME_MAX_STREAMS_BIDI
                     ? ((&value)->base = (uint8_t *)("bidirectional"), (&value)->len = sizeof("bidirectional") - 1, (&value))
                     : ((&value)->base = (uint8_t *)("unidirectional"), (&value)->len = sizeof("unidirectional") - 1, (&value)));
  *p++ = ',';
  p = write_pair_numstr(p, ((&name)->base = (uint8_t *)("maximum"), (&name)->len = sizeof("maximum") - 1, (&name)), fr->max_streams);
  *p++ = '}';
  return p;
}
static uint8_t *write_data_blocked_frame(uint8_t *p,
                                         const ngtcp2_data_blocked *fr)
{
  ngtcp2_vec name, value;
  (void)fr;
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("frame_type"), (&name)->len = sizeof("frame_type") - 1, (&name)),
                 ((&value)->base = (uint8_t *)("data_blocked"), (&value)->len = sizeof("data_blocked") - 1, (&value)));
  *p++ = '}';
  return p;
}
static uint8_t *
write_stream_data_blocked_frame(uint8_t *p,
                                const ngtcp2_stream_data_blocked *fr)
{
  ngtcp2_vec name, value;
  (void)fr;
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("frame_type"), (&name)->len = sizeof("frame_type") - 1, (&name)),
                 ((&value)->base = (uint8_t *)("stream_data_blocked"), (&value)->len = sizeof("stream_data_blocked") - 1, (&value)));
  *p++ = '}';
  return p;
}
static uint8_t *write_streams_blocked_frame(uint8_t *p,
                                            const ngtcp2_streams_blocked *fr)
{
  ngtcp2_vec name, value;
  (void)fr;
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("frame_type"), (&name)->len = sizeof("frame_type") - 1, (&name)),
                 ((&value)->base = (uint8_t *)("streams_blocked"), (&value)->len = sizeof("streams_blocked") - 1, (&value)));
  *p++ = '}';
  return p;
}
static uint8_t *
write_new_connection_id_frame(uint8_t *p, const ngtcp2_new_connection_id *fr)
{
  ngtcp2_vec name, value;
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("frame_type"), (&name)->len = sizeof("frame_type") - 1, (&name)),
                 ((&value)->base = (uint8_t *)("new_connection_id"), (&value)->len = sizeof("new_connection_id") - 1, (&value)));
  *p++ = ',';
  p = write_pair_numstr(p, ((&name)->base = (uint8_t *)("sequence_number"), (&name)->len = sizeof("sequence_number") - 1, (&name)), fr->seq);
  *p++ = ',';
  p = write_pair_numstr(p, ((&name)->base = (uint8_t *)("retire_prior_to"), (&name)->len = sizeof("retire_prior_to") - 1, (&name)),
                        fr->retire_prior_to);
  *p++ = ',';
  p = write_pair_number(p, ((&name)->base = (uint8_t *)("length"), (&name)->len = sizeof("length") - 1, (&name)), fr->cid.datalen);
  *p++ = ',';
  p = write_pair_cid(p, ((&name)->base = (uint8_t *)("connection_id"), (&name)->len = sizeof("connection_id") - 1, (&name)), &fr->cid);
  *p++ = ',';
  p = write_pair_hex(p, ((&name)->base = (uint8_t *)("reset_token"), (&name)->len = sizeof("reset_token") - 1, (&name)),
                     ngtcp2_vec_init(&value, fr->stateless_reset_token,
                                     sizeof(fr->stateless_reset_token)));
  *p++ = '}';
  return p;
}
static uint8_t *
write_retire_connection_id_frame(uint8_t *p,
                                 const ngtcp2_retire_connection_id *fr)
{
  ngtcp2_vec name, value;
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("frame_type"), (&name)->len = sizeof("frame_type") - 1, (&name)),
                 ((&value)->base = (uint8_t *)("retire_connection_id"), (&value)->len = sizeof("retire_connection_id") - 1, (&value)));
  *p++ = ',';
  p = write_pair_numstr(p, ((&name)->base = (uint8_t *)("sequence_number"), (&name)->len = sizeof("sequence_number") - 1, (&name)), fr->seq);
  *p++ = '}';
  return p;
}
static uint8_t *write_path_challenge_frame(uint8_t *p,
                                           const ngtcp2_path_challenge *fr)
{
  ngtcp2_vec name, value;
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("frame_type"), (&name)->len = sizeof("frame_type") - 1, (&name)),
                 ((&value)->base = (uint8_t *)("path_challenge"), (&value)->len = sizeof("path_challenge") - 1, (&value)));
  *p++ = ',';
  p = write_pair_hex(p, ((&name)->base = (uint8_t *)("data"), (&name)->len = sizeof("data") - 1, (&name)),
                     ngtcp2_vec_init(&value, fr->data, sizeof(fr->data)));
  *p++ = '}';
  return p;
}
static uint8_t *write_path_response_frame(uint8_t *p,
                                          const ngtcp2_path_response *fr)
{
  ngtcp2_vec name, value;
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("frame_type"), (&name)->len = sizeof("frame_type") - 1, (&name)),
                 ((&value)->base = (uint8_t *)("path_response"), (&value)->len = sizeof("path_response") - 1, (&value)));
  *p++ = ',';
  p = write_pair_hex(p, ((&name)->base = (uint8_t *)("data"), (&name)->len = sizeof("data") - 1, (&name)),
                     ngtcp2_vec_init(&value, fr->data, sizeof(fr->data)));
  *p++ = '}';
  return p;
}
static uint8_t *
write_connection_close_frame(uint8_t *p, const ngtcp2_connection_close *fr)
{
  ngtcp2_vec name, value;
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("frame_type"), (&name)->len = sizeof("frame_type") - 1, (&name)),
                 ((&value)->base = (uint8_t *)("connection_close"), (&value)->len = sizeof("connection_close") - 1, (&value)));
  *p++ = ',';
  p = write_pair(p, ((&name)->base = (uint8_t *)("error_space"), (&name)->len = sizeof("error_space") - 1, (&name)),
                 fr->type == NGTCP2_FRAME_CONNECTION_CLOSE
                     ? ((&value)->base = (uint8_t *)("transport"), (&value)->len = sizeof("transport") - 1, (&value))
                     : ((&value)->base = (uint8_t *)("application"), (&value)->len = sizeof("application") - 1, (&value)));
  *p++ = ',';
  p = write_pair_number(p, ((&name)->base = (uint8_t *)("error_code"), (&name)->len = sizeof("error_code") - 1, (&name)), fr->error_code);
  *p++ = ',';
  p = write_pair_number(p, ((&name)->base = (uint8_t *)("raw_error_code"), (&name)->len = sizeof("raw_error_code") - 1, (&name)),
                        fr->error_code);
  *p++ = ',';
  p = write_pair(p, ((&name)->base = (uint8_t *)("reason"), (&name)->len = sizeof("reason") - 1, (&name)),
                 ((&value)->base = (uint8_t *)(""), (&value)->len = sizeof("") - 1, (&value)));
  *p++ = '}';
  return p;
}
static uint8_t *write_handshake_done_frame(uint8_t *p,
                                           const ngtcp2_handshake_done *fr)
{
  ngtcp2_vec name, value;
  (void)fr;
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("frame_type"), (&name)->len = sizeof("frame_type") - 1, (&name)),
                 ((&value)->base = (uint8_t *)("handshake_done"), (&value)->len = sizeof("handshake_done") - 1, (&value)));
  *p++ = '}';
  return p;
}
static void qlog_pkt_write_start(ngtcp2_qlog *qlog, const ngtcp2_pkt_hd *hd,
                                 int sent)
{
  uint8_t *p;
  ngtcp2_vec name, value;
  if (!qlog->write)
  {
    return;
  }
  ngtcp2_buf_reset(&qlog->buf);
  p = qlog->buf.last;
  *p++ = '[';
  p = write_tstamp(p, qlog->last_ts - qlog->ts);
  *p++ = ',';
  p = write_string(p, ((&value)->base = (uint8_t *)("transport"), (&value)->len = sizeof("transport") - 1, (&value)));
  *p++ = ',';
  p = write_string(p, sent ? ((&value)->base = (uint8_t *)("packet_sent"), (&value)->len = sizeof("packet_sent") - 1, (&value))
                           : ((&value)->base = (uint8_t *)("packet_received"), (&value)->len = sizeof("packet_received") - 1, (&value)));
  *p++ = ',';
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("packet_type"), (&name)->len = sizeof("packet_type") - 1, (&name)),
                 qlog_pkt_type(&value, hd));
  *p++ = ',';
  p = write_string(p, ((&value)->base = (uint8_t *)("frames"), (&value)->len = sizeof("frames") - 1, (&value)));
  *p++ = ':';
  *p++ = '[';
  qlog->buf.last = p;
}
static void qlog_pkt_write_end(ngtcp2_qlog *qlog, const ngtcp2_pkt_hd *hd,
                               size_t pktlen)
{
  uint8_t *p = qlog->buf.last;
  ngtcp2_vec value;
  if (!qlog->write)
  {
    return;
  }

  (static_cast<bool>(
       ngtcp2_buf_left(&qlog->buf) >= (14 + 73))
       ? void(0)
       : __assert_fail(
             "ngtcp2_buf_left(&qlog->buf) >= NGTCP2_QLOG_PKT_WRITE_END_OVERHEAD", "all.cpp", 34837, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       ngtcp2_buf_len(&qlog->buf))
       ? void(0)
       : __assert_fail(
             "ngtcp2_buf_len(&qlog->buf)", "all.cpp", 34838, __extension__ __PRETTY_FUNCTION__));
  if (*(p - 1) == ',')
  {
    --p;
  }
  *p++ = ']';
  *p++ = ',';
  p = write_string(p, ((&value)->base = (uint8_t *)("header"), (&value)->len = sizeof("header") - 1, (&value)));
  *p++ = ':';
  p = write_pkt_hd(p, hd, pktlen);
  *p++ = '}';
  *p++ = ']';
  *p++ = ',';
  qlog->buf.last = p;
  qlog->write(qlog->user_data, NGTCP2_QLOG_WRITE_FLAG_NONE, qlog->buf.pos,
              ngtcp2_buf_len(&qlog->buf));
}
void ngtcp2_qlog_write_frame(ngtcp2_qlog *qlog, const ngtcp2_frame *fr)
{
  uint8_t *p = qlog->buf.last;
  if (!qlog->write)
  {
    return;
  }
  switch (fr->type)
  {
  case NGTCP2_FRAME_PADDING:
    if (ngtcp2_buf_left(&qlog->buf) < 24 + 1 +
                                          (14 + 73))
    {
      return;
    }
    p = write_padding_frame(p, &fr->padding);
    break;
  case NGTCP2_FRAME_PING:
    if (ngtcp2_buf_left(&qlog->buf) < 21 + 1 +
                                          (14 + 73))
    {
      return;
    }
    p = write_ping_frame(p, &fr->ping);
    break;
  case NGTCP2_FRAME_ACK:
  case NGTCP2_FRAME_ACK_ECN:
    if (ngtcp2_buf_left(&qlog->buf) <
        70 +
            (size_t)(fr->type == NGTCP2_FRAME_ACK_ECN
                         ? 85
                         : 0) +
            46 * (1 + fr->ack.num_blks) + 1 +
            (14 + 73))
    {
      return;
    }
    p = write_ack_frame(p, &fr->ack);
    break;
  case NGTCP2_FRAME_RESET_STREAM:
    if (ngtcp2_buf_left(&qlog->buf) < 131 +
                                          1 +
                                          (14 + 73))
    {
      return;
    }
    p = write_reset_stream_frame(p, &fr->reset_stream);
    break;
  case NGTCP2_FRAME_STOP_SENDING:
    if (ngtcp2_buf_left(&qlog->buf) < 96 +
                                          1 +
                                          (14 + 73))
    {
      return;
    }
    p = write_stop_sending_frame(p, &fr->stop_sending);
    break;
  case NGTCP2_FRAME_CRYPTO:
    if (ngtcp2_buf_left(&qlog->buf) < 83 + 1 +
                                          (14 + 73))
    {
      return;
    }
    p = write_crypto_frame(p, &fr->crypto);
    break;
  case NGTCP2_FRAME_NEW_TOKEN:
    if (ngtcp2_buf_left(&qlog->buf) < 66 +
                                          fr->new_token.token.len * 2 + 1 +
                                          (14 + 73))
    {
      return;
    }
    p = write_new_token_frame(p, &fr->new_token);
    break;
  case NGTCP2_FRAME_STREAM:
    if (ngtcp2_buf_left(&qlog->buf) < 128 + 1 +
                                          (14 + 73))
    {
      return;
    }
    p = write_stream_frame(p, &fr->stream);
    break;
  case NGTCP2_FRAME_MAX_DATA:
    if (ngtcp2_buf_left(&qlog->buf) < 57 + 1 +
                                          (14 + 73))
    {
      return;
    }
    p = write_max_data_frame(p, &fr->max_data);
    break;
  case NGTCP2_FRAME_MAX_STREAM_DATA:
    if (ngtcp2_buf_left(&qlog->buf) <
        98 + 1 +
            (14 + 73))
    {
      return;
    }
    p = write_max_stream_data_frame(p, &fr->max_stream_data);
    break;
  case NGTCP2_FRAME_MAX_STREAMS_BIDI:
  case NGTCP2_FRAME_MAX_STREAMS_UNI:
    if (ngtcp2_buf_left(&qlog->buf) < 91 +
                                          1 +
                                          (14 + 73))
    {
      return;
    }
    p = write_max_streams_frame(p, &fr->max_streams);
    break;
  case NGTCP2_FRAME_DATA_BLOCKED:
    if (ngtcp2_buf_left(&qlog->buf) < 29 +
                                          1 +
                                          (14 + 73))
    {
      return;
    }
    p = write_data_blocked_frame(p, &fr->data_blocked);
    break;
  case NGTCP2_FRAME_STREAM_DATA_BLOCKED:
    if (ngtcp2_buf_left(&qlog->buf) <
        36 + 1 +
            (14 + 73))
    {
      return;
    }
    p = write_stream_data_blocked_frame(p, &fr->stream_data_blocked);
    break;
  case NGTCP2_FRAME_STREAMS_BLOCKED_BIDI:
  case NGTCP2_FRAME_STREAMS_BLOCKED_UNI:
    if (ngtcp2_buf_left(&qlog->buf) <
        32 + 1 +
            (14 + 73))
    {
      return;
    }
    p = write_streams_blocked_frame(p, &fr->streams_blocked);
    break;
  case NGTCP2_FRAME_NEW_CONNECTION_ID:
    if (ngtcp2_buf_left(&qlog->buf) <
        251 + 1 +
            (14 + 73))
    {
      return;
    }
    p = write_new_connection_id_frame(p, &fr->new_connection_id);
    break;
  case NGTCP2_FRAME_RETIRE_CONNECTION_ID:
    if (ngtcp2_buf_left(&qlog->buf) <
        77 + 1 +
            (14 + 73))
    {
      return;
    }
    p = write_retire_connection_id_frame(p, &fr->retire_connection_id);
    break;
  case NGTCP2_FRAME_PATH_CHALLENGE:
    if (ngtcp2_buf_left(&qlog->buf) <
        57 + 1 +
            (14 + 73))
    {
      return;
    }
    p = write_path_challenge_frame(p, &fr->path_challenge);
    break;
  case NGTCP2_FRAME_PATH_RESPONSE:
    if (ngtcp2_buf_left(&qlog->buf) < 56 +
                                          1 +
                                          (14 + 73))
    {
      return;
    }
    p = write_path_response_frame(p, &fr->path_response);
    break;
  case NGTCP2_FRAME_CONNECTION_CLOSE:
  case NGTCP2_FRAME_CONNECTION_CLOSE_APP:
    if (ngtcp2_buf_left(&qlog->buf) <
        143 + 1 +
            (14 + 73))
    {
      return;
    }
    p = write_connection_close_frame(p, &fr->connection_close);
    break;
  case NGTCP2_FRAME_HANDSHAKE_DONE:
    if (ngtcp2_buf_left(&qlog->buf) <
        31 + 1 +
            (14 + 73))
    {
      return;
    }
    p = write_handshake_done_frame(p, &fr->handshake_done);
    break;
  default:

    (static_cast<bool>(
         0)
         ? void(0)
         : __assert_fail(
               "0", "all.cpp", 35049, __extension__ __PRETTY_FUNCTION__));
  }
  *p++ = ',';
  qlog->buf.last = p;
}
void ngtcp2_qlog_pkt_received_start(ngtcp2_qlog *qlog,
                                    const ngtcp2_pkt_hd *hd)
{
  qlog_pkt_write_start(qlog, hd, 0);
}
void ngtcp2_qlog_pkt_received_end(ngtcp2_qlog *qlog, const ngtcp2_pkt_hd *hd,
                                  size_t pktlen)
{
  qlog_pkt_write_end(qlog, hd, pktlen);
}
void ngtcp2_qlog_pkt_sent_start(ngtcp2_qlog *qlog, const ngtcp2_pkt_hd *hd)
{
  qlog_pkt_write_start(qlog, hd, 1);
}
void ngtcp2_qlog_pkt_sent_end(ngtcp2_qlog *qlog, const ngtcp2_pkt_hd *hd,
                              size_t pktlen)
{
  qlog_pkt_write_end(qlog, hd, pktlen);
}
void ngtcp2_qlog_parameters_set_transport_params(
    ngtcp2_qlog *qlog, const ngtcp2_transport_params *params, int server,
    ngtcp2_qlog_side side)
{
  uint8_t buf[1024];
  uint8_t *p = buf;
  ngtcp2_vec name, value;
  const ngtcp2_preferred_addr *paddr;
  if (!qlog->write)
  {
    return;
  }
  *p++ = '[';
  p = write_tstamp(p, qlog->last_ts - qlog->ts);
  *p++ = ',';
  p = write_string(p, ((&value)->base = (uint8_t *)("transport"), (&value)->len = sizeof("transport") - 1, (&value)));
  *p++ = ',';
  p = write_string(p, ((&value)->base = (uint8_t *)("parameters_set"), (&value)->len = sizeof("parameters_set") - 1, (&value)));
  *p++ = ',';
  *p++ = '{';
  p = write_pair(p, ((&name)->base = (uint8_t *)("owner"), (&name)->len = sizeof("owner") - 1, (&name)),
                 side == NGTCP2_QLOG_SIDE_LOCAL
                     ? ((&value)->base = (uint8_t *)("local"), (&value)->len = sizeof("local") - 1, (&value))
                     : ((&value)->base = (uint8_t *)("remote"), (&value)->len = sizeof("remote") - 1, (&value)));
  *p++ = ',';
  p = write_pair_cid(p, ((&name)->base = (uint8_t *)("initial_source_connection_id"), (&name)->len = sizeof("initial_source_connection_id") - 1, (&name)),
                     &params->initial_scid);
  *p++ = ',';
  if (side == (server ? NGTCP2_QLOG_SIDE_LOCAL : NGTCP2_QLOG_SIDE_REMOTE))
  {
    p = write_pair_cid(
        p, ((&name)->base = (uint8_t *)("original_destination_connection_id"), (&name)->len = sizeof("original_destination_connection_id") - 1, (&name)),
        &params->original_dcid);
    *p++ = ',';
  }
  if (params->retry_scid_present)
  {
    p = write_pair_cid(p, ((&name)->base = (uint8_t *)("retry_source_connection_id"), (&name)->len = sizeof("retry_source_connection_id") - 1, (&name)),
                       &params->retry_scid);
    *p++ = ',';
  }
  if (params->stateless_reset_token_present)
  {
    p = write_pair_hex(p, ((&name)->base = (uint8_t *)("stateless_reset_token"), (&name)->len = sizeof("stateless_reset_token") - 1, (&name)),
                       ngtcp2_vec_init(&value, params->stateless_reset_token,
                                       sizeof(params->stateless_reset_token)));
    *p++ = ',';
  }
  p = write_pair_bool(p, ((&name)->base = (uint8_t *)("disable_active_migration"), (&name)->len = sizeof("disable_active_migration") - 1, (&name)),
                      params->disable_active_migration);
  *p++ = ',';
  p = write_pair_duration(p, ((&name)->base = (uint8_t *)("max_idle_timeout"), (&name)->len = sizeof("max_idle_timeout") - 1, (&name)),
                          params->max_idle_timeout);
  *p++ = ',';
  p = write_pair_number(p, ((&name)->base = (uint8_t *)("max_udp_payload_size"), (&name)->len = sizeof("max_udp_payload_size") - 1, (&name)),
                        params->max_udp_payload_size);
  *p++ = ',';
  p = write_pair_number(p, ((&name)->base = (uint8_t *)("ack_delay_exponent"), (&name)->len = sizeof("ack_delay_exponent") - 1, (&name)),
                        params->ack_delay_exponent);
  *p++ = ',';
  p = write_pair_duration(p, ((&name)->base = (uint8_t *)("max_ack_delay"), (&name)->len = sizeof("max_ack_delay") - 1, (&name)),
                          params->max_ack_delay);
  *p++ = ',';
  p = write_pair_number(p, ((&name)->base = (uint8_t *)("active_connection_id_limit"), (&name)->len = sizeof("active_connection_id_limit") - 1, (&name)),
                        params->active_connection_id_limit);
  *p++ = ',';
  p = write_pair_numstr(p, ((&name)->base = (uint8_t *)("initial_max_data"), (&name)->len = sizeof("initial_max_data") - 1, (&name)),
                        params->initial_max_data);
  *p++ = ',';
  p = write_pair_numstr(
      p, ((&name)->base = (uint8_t *)("initial_max_stream_data_bidi_local"), (&name)->len = sizeof("initial_max_stream_data_bidi_local") - 1, (&name)),
      params->initial_max_stream_data_bidi_local);
  *p++ = ',';
  p = write_pair_numstr(
      p, ((&name)->base = (uint8_t *)("initial_max_stream_data_bidi_remote"), (&name)->len = sizeof("initial_max_stream_data_bidi_remote") - 1, (&name)),
      params->initial_max_stream_data_bidi_remote);
  *p++ = ',';
  p = write_pair_numstr(p, ((&name)->base = (uint8_t *)("initial_max_stream_data_uni"), (&name)->len = sizeof("initial_max_stream_data_uni") - 1, (&name)),
                        params->initial_max_stream_data_uni);
  *p++ = ',';
  p = write_pair_numstr(p, ((&name)->base = (uint8_t *)("initial_max_streams_bidi"), (&name)->len = sizeof("initial_max_streams_bidi") - 1, (&name)),
                        params->initial_max_streams_bidi);
  *p++ = ',';
  p = write_pair_numstr(p, ((&name)->base = (uint8_t *)("initial_max_streams_uni"), (&name)->len = sizeof("initial_max_streams_uni") - 1, (&name)),
                        params->initial_max_streams_uni);
  if (params->preferred_address_present)
  {
    *p++ = ',';
    paddr = &params->preferred_address;
    p = write_string(p, ((&name)->base = (uint8_t *)("preferred_address"), (&name)->len = sizeof("preferred_address") - 1, (&name)));
    *p++ = ':';
    *p++ = '{';
    p = write_pair_hex(
        p, ((&name)->base = (uint8_t *)("ip_v4"), (&name)->len = sizeof("ip_v4") - 1, (&name)),
        ngtcp2_vec_init(&value, paddr->ipv4_addr, sizeof(paddr->ipv4_addr)));
    *p++ = ',';
    p = write_pair_number(p, ((&name)->base = (uint8_t *)("port_v4"), (&name)->len = sizeof("port_v4") - 1, (&name)),
                          paddr->ipv4_port);
    *p++ = ',';
    p = write_pair_hex(
        p, ((&name)->base = (uint8_t *)("ip_v6"), (&name)->len = sizeof("ip_v6") - 1, (&name)),
        ngtcp2_vec_init(&value, paddr->ipv6_addr, sizeof(paddr->ipv6_addr)));
    *p++ = ',';
    p = write_pair_number(p, ((&name)->base = (uint8_t *)("port_v6"), (&name)->len = sizeof("port_v6") - 1, (&name)),
                          paddr->ipv6_port);
    *p++ = ',';
    p = write_pair_cid(p, ((&name)->base = (uint8_t *)("connection_id"), (&name)->len = sizeof("connection_id") - 1, (&name)), &paddr->cid);
    *p++ = ',';
    p = write_pair_hex(p, ((&name)->base = (uint8_t *)("stateless_reset_token"), (&name)->len = sizeof("stateless_reset_token") - 1, (&name)),
                       ngtcp2_vec_init(&value, paddr->stateless_reset_token,
                                       sizeof(paddr->stateless_reset_token)));
    *p++ = '}';
  }
  *p++ = '}';
  *p++ = ']';
  *p++ = ',';
  qlog->write(qlog->user_data, NGTCP2_QLOG_WRITE_FLAG_NONE, buf,
              (size_t)(p - buf));
}
void ngtcp2_qlog_metrics_updated(ngtcp2_qlog *qlog,
                                 const ngtcp2_conn_stat *cstat)
{
  uint8_t buf[1024];
  uint8_t *p = buf;
  ngtcp2_vec name, value;
  if (!qlog->write)
  {
    return;
  }
  *p++ = '[';
  p = write_tstamp(p, qlog->last_ts - qlog->ts);
  *p++ = ',';
  p = write_string(p, ((&value)->base = (uint8_t *)("recovery"), (&value)->len = sizeof("recovery") - 1, (&value)));
  *p++ = ',';
  p = write_string(p, ((&value)->base = (uint8_t *)("metrics_updated"), (&value)->len = sizeof("metrics_updated") - 1, (&value)));
  *p++ = ',';
  *p++ = '{';
  if (cstat->min_rtt !=
      (18446744073709551615UL))
  {
    p = write_pair_duration(p, ((&name)->base = (uint8_t *)("min_rtt"), (&name)->len = sizeof("min_rtt") - 1, (&name)),
                            cstat->min_rtt);
    *p++ = ',';
  }
  p = write_pair_duration(p, ((&name)->base = (uint8_t *)("smoothed_rtt"), (&name)->len = sizeof("smoothed_rtt") - 1, (&name)),
                          cstat->smoothed_rtt);
  *p++ = ',';
  p = write_pair_duration(p, ((&name)->base = (uint8_t *)("latest_rtt"), (&name)->len = sizeof("latest_rtt") - 1, (&name)),
                          cstat->latest_rtt);
  *p++ = ',';
  p = write_pair_duration(p, ((&name)->base = (uint8_t *)("rtt_variance"), (&name)->len = sizeof("rtt_variance") - 1, (&name)),
                          cstat->rttvar);
  *p++ = ',';
  p = write_pair_number(p, ((&name)->base = (uint8_t *)("pto_count"), (&name)->len = sizeof("pto_count") - 1, (&name)),
                        cstat->pto_count);
  *p++ = ',';
  p = write_pair_number(p, ((&name)->base = (uint8_t *)("congestion_window"), (&name)->len = sizeof("congestion_window") - 1, (&name)),
                        cstat->cwnd);
  *p++ = ',';
  p = write_pair_number(p, ((&name)->base = (uint8_t *)("bytes_in_flight"), (&name)->len = sizeof("bytes_in_flight") - 1, (&name)),
                        cstat->bytes_in_flight);
  if (cstat->ssthresh !=
      (18446744073709551615UL))
  {
    *p++ = ',';
    p = write_pair_number(p, ((&name)->base = (uint8_t *)("ssthresh"), (&name)->len = sizeof("ssthresh") - 1, (&name)),
                          cstat->ssthresh);
  }
  *p++ = '}';
  *p++ = ']';
  *p++ = ',';
  qlog->write(qlog->user_data, NGTCP2_QLOG_WRITE_FLAG_NONE, buf,
              (size_t)(p - buf));
}
void ngtcp2_qlog_pkt_lost(ngtcp2_qlog *qlog, ngtcp2_rtb_entry *ent)
{
  uint8_t buf[256];
  uint8_t *p = buf;
  ngtcp2_vec name, value;
  ngtcp2_pkt_hd hd;
  if (!qlog->write)
  {
    return;
  }
  *p++ = '[';
  p = write_tstamp(p, qlog->last_ts - qlog->ts);
  *p++ = ',';
  p = write_string(p, ((&value)->base = (uint8_t *)("recovery"), (&value)->len = sizeof("recovery") - 1, (&value)));
  *p++ = ',';
  p = write_string(p, ((&value)->base = (uint8_t *)("packet_lost"), (&value)->len = sizeof("packet_lost") - 1, (&value)));
  *p++ = ',';
  *p++ = '{';
  hd.type = ent->hd.type;
  hd.flags = ent->hd.flags;
  p = write_pair(p, ((&name)->base = (uint8_t *)("packet_type"), (&name)->len = sizeof("packet_type") - 1, (&name)),
                 qlog_pkt_type(&value, &hd));
  *p++ = ',';
  p = write_pair_numstr(p, ((&name)->base = (uint8_t *)("packet_number"), (&name)->len = sizeof("packet_number") - 1, (&name)),
                        (uint64_t)ent->hd.pkt_num);
  *p++ = '}';
  *p++ = ']';
  *p++ = ',';
  qlog->write(qlog->user_data, NGTCP2_QLOG_WRITE_FLAG_NONE, buf,
              (size_t)(p - buf));
}
void ngtcp2_range_init(ngtcp2_range *r, uint64_t begin, uint64_t end)
{
  r->begin = begin;
  r->end = end;
}
ngtcp2_range ngtcp2_range_intersect(const ngtcp2_range *a,
                                    const ngtcp2_range *b)
{
  ngtcp2_range r = {0, 0};
  uint64_t begin = ((a->begin) > (b->begin) ? (a->begin) : (b->begin));
  uint64_t end = ((a->end) < (b->end) ? (a->end) : (b->end));
  if (begin < end)
  {
    ngtcp2_range_init(&r, begin, end);
  }
  return r;
}
uint64_t ngtcp2_range_len(const ngtcp2_range *r) { return r->end - r->begin; }
int ngtcp2_range_eq(const ngtcp2_range *a, const ngtcp2_range *b)
{
  return a->begin == b->begin && a->end == b->end;
}
void ngtcp2_range_cut(ngtcp2_range *left, ngtcp2_range *right,
                      const ngtcp2_range *a, const ngtcp2_range *b)
{
  left->begin = a->begin;
  left->end = b->begin;
  right->begin = b->end;
  right->end = a->end;
}
int ngtcp2_range_not_after(const ngtcp2_range *a, const ngtcp2_range *b)
{
  return a->end <= b->end;
}
int ngtcp2_ringbuf_init(ngtcp2_ringbuf *rb, size_t nmemb, size_t size,
                        const ngtcp2_mem *mem)
{

  (static_cast<bool>(
       1 == __builtin_popcount((unsigned int)nmemb))
       ? void(0)
       : __assert_fail(
             "1 == __builtin_popcount((unsigned int)nmemb)", "all.cpp", 35349, __extension__ __PRETTY_FUNCTION__));
  rb->buf = ngtcp2_mem_malloc(mem, nmemb * size);
  if (rb->buf ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  rb->mem = mem;
  rb->nmemb = nmemb;
  rb->size = size;
  rb->first = 0;
  rb->len = 0;
  return 0;
}
void ngtcp2_ringbuf_free(ngtcp2_ringbuf *rb)
{
  if (rb ==
      __null)
  {
    return;
  }
  ngtcp2_mem_free(rb->mem, rb->buf);
}
void *ngtcp2_ringbuf_push_front(ngtcp2_ringbuf *rb)
{
  rb->first = (rb->first - 1) & (rb->nmemb - 1);
  rb->len = ((rb->nmemb) < (rb->len + 1) ? (rb->nmemb) : (rb->len + 1));
  return (void *)&rb->buf[rb->first * rb->size];
}
void *ngtcp2_ringbuf_push_back(ngtcp2_ringbuf *rb)
{
  size_t offset = (rb->first + rb->len) & (rb->nmemb - 1);
  if (rb->len == rb->nmemb)
  {
    rb->first = (rb->first + 1) & (rb->nmemb - 1);
  }
  else
  {
    ++rb->len;
  }
  return (void *)&rb->buf[offset * rb->size];
}
void ngtcp2_ringbuf_pop_front(ngtcp2_ringbuf *rb)
{
  rb->first = (rb->first + 1) & (rb->nmemb - 1);
  --rb->len;
}
void ngtcp2_ringbuf_pop_back(ngtcp2_ringbuf *rb)
{

  (static_cast<bool>(
       rb->len)
       ? void(0)
       : __assert_fail(
             "rb->len", "all.cpp", 35402, __extension__ __PRETTY_FUNCTION__));
  --rb->len;
}
void ngtcp2_ringbuf_resize(ngtcp2_ringbuf *rb, size_t len)
{

  (static_cast<bool>(
       len <= rb->nmemb)
       ? void(0)
       : __assert_fail(
             "len <= rb->nmemb", "all.cpp", 35408, __extension__ __PRETTY_FUNCTION__));
  rb->len = len;
}
void *ngtcp2_ringbuf_get(ngtcp2_ringbuf *rb, size_t offset)
{

  (static_cast<bool>(
       offset < rb->len)
       ? void(0)
       : __assert_fail(
             "offset < rb->len", "all.cpp", 35414, __extension__ __PRETTY_FUNCTION__));
  offset = (rb->first + offset) & (rb->nmemb - 1);
  return &rb->buf[offset * rb->size];
}
int ngtcp2_ringbuf_full(ngtcp2_ringbuf *rb) { return rb->len == rb->nmemb; }
int ngtcp2_rob_gap_new(ngtcp2_rob_gap **pg, uint64_t begin, uint64_t end,
                       const ngtcp2_mem *mem)
{
  *pg = ngtcp2_mem_malloc(mem, sizeof(ngtcp2_rob_gap));
  if (*pg ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  (*pg)->range.begin = begin;
  (*pg)->range.end = end;
  return 0;
}
void ngtcp2_rob_gap_del(ngtcp2_rob_gap *g, const ngtcp2_mem *mem)
{
  ngtcp2_mem_free(mem, g);
}
int ngtcp2_rob_data_new(ngtcp2_rob_data **pd, uint64_t offset, size_t chunk,
                        const ngtcp2_mem *mem)
{
  *pd = ngtcp2_mem_malloc(mem, sizeof(ngtcp2_rob_data) + chunk);
  if (*pd ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  (*pd)->range.begin = offset;
  (*pd)->range.end = offset + chunk;
  (*pd)->begin = (uint8_t *)(*pd) + sizeof(ngtcp2_rob_data);
  (*pd)->end = (*pd)->begin + chunk;
  return 0;
}
void ngtcp2_rob_data_del(ngtcp2_rob_data *d, const ngtcp2_mem *mem)
{
  ngtcp2_mem_free(mem, d);
}
int ngtcp2_rob_init(ngtcp2_rob *rob, size_t chunk, const ngtcp2_mem *mem)
{
  int rv;
  ngtcp2_rob_gap *g;
  rv = ngtcp2_ksl_init(&rob->gapksl, ngtcp2_ksl_range_compar,
                       sizeof(ngtcp2_range), mem);
  if (rv != 0)
  {
    goto fail_gapksl_ksl_init;
  }
  rv = ngtcp2_rob_gap_new(&g, 0,
                          (18446744073709551615UL), mem);
  if (rv != 0)
  {
    goto fail_rob_gap_new;
  }
  rv = ngtcp2_ksl_insert(&rob->gapksl,
                         __null, &g->range, g);
  if (rv != 0)
  {
    goto fail_gapksl_ksl_insert;
  }
  rv = ngtcp2_ksl_init(&rob->dataksl, ngtcp2_ksl_range_compar,
                       sizeof(ngtcp2_range), mem);
  if (rv != 0)
  {
    goto fail_dataksl_ksl_init;
  }
  rob->chunk = chunk;
  rob->mem = mem;
  return 0;
fail_dataksl_ksl_init:
fail_gapksl_ksl_insert:
  ngtcp2_rob_gap_del(g, mem);
fail_rob_gap_new:
  ngtcp2_ksl_free(&rob->gapksl);
fail_gapksl_ksl_init:
  return rv;
}
void ngtcp2_rob_free(ngtcp2_rob *rob)
{
  ngtcp2_ksl_it it;
  if (rob ==
      __null)
  {
    return;
  }
  for (it = ngtcp2_ksl_begin(&rob->dataksl); !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                                                __null);
       (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
  {
    ngtcp2_rob_data_del(ngtcp2_ksl_it_get(&it), rob->mem);
  }
  for (it = ngtcp2_ksl_begin(&rob->gapksl); !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                                               __null);
       (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
  {
    ngtcp2_rob_gap_del(ngtcp2_ksl_it_get(&it), rob->mem);
  }
  ngtcp2_ksl_free(&rob->dataksl);
  ngtcp2_ksl_free(&rob->gapksl);
}
static int rob_write_data(ngtcp2_rob *rob, uint64_t offset, const uint8_t *data,
                          size_t len)
{
  size_t n;
  int rv;
  ngtcp2_rob_data *d;
  ngtcp2_range range = {offset, offset + len};
  ngtcp2_ksl_it it;
  for (it = ngtcp2_ksl_lower_bound_compar(&rob->dataksl, &range,
                                          ngtcp2_ksl_range_exclusive_compar);
       len; (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
  {
    if (((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                          __null))
    {
      d =
          __null;
    }
    else
    {
      d = ngtcp2_ksl_it_get(&it);
    }
    if (d ==
            __null ||
        offset < d->range.begin)
    {
      rv = ngtcp2_rob_data_new(&d, (offset / rob->chunk) * rob->chunk,
                               rob->chunk, rob->mem);
      if (rv != 0)
      {
        return rv;
      }
      rv = ngtcp2_ksl_insert(&rob->dataksl, &it, &d->range, d);
      if (rv != 0)
      {
        ngtcp2_rob_data_del(d, rob->mem);
        return rv;
      }
    }
    n = (size_t)(((uint64_t)len) < (d->range.begin + rob->chunk - offset) ? ((uint64_t)len) : (d->range.begin + rob->chunk - offset));
    memcpy(d->begin + (offset - d->range.begin), data, n);
    offset += n;
    data += n;
    len -= n;
  }
  return 0;
}
int ngtcp2_rob_push(ngtcp2_rob *rob, uint64_t offset, const uint8_t *data,
                    size_t datalen)
{
  int rv;
  ngtcp2_rob_gap *g;
  ngtcp2_range m, l, r, q = {offset, offset + datalen};
  ngtcp2_ksl_it it;
  it = ngtcp2_ksl_lower_bound_compar(&rob->gapksl, &q,
                                     ngtcp2_ksl_range_exclusive_compar);
  for (; !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                            __null);)
  {
    g = ngtcp2_ksl_it_get(&it);
    m = ngtcp2_range_intersect(&q, &g->range);
    if (!ngtcp2_range_len(&m))
    {
      break;
    }
    if (ngtcp2_range_eq(&g->range, &m))
    {
      ngtcp2_ksl_remove(&rob->gapksl, &it, &g->range);
      ngtcp2_rob_gap_del(g, rob->mem);
      rv = rob_write_data(rob, m.begin, data + (m.begin - offset),
                          (size_t)ngtcp2_range_len(&m));
      if (rv != 0)
      {
        return rv;
      }
      continue;
    }
    ngtcp2_range_cut(&l, &r, &g->range, &m);
    if (ngtcp2_range_len(&l))
    {
      ngtcp2_ksl_update_key(&rob->gapksl, &g->range, &l);
      g->range = l;
      if (ngtcp2_range_len(&r))
      {
        ngtcp2_rob_gap *ng;
        rv = ngtcp2_rob_gap_new(&ng, r.begin, r.end, rob->mem);
        if (rv != 0)
        {
          return rv;
        }
        rv = ngtcp2_ksl_insert(&rob->gapksl, &it, &ng->range, ng);
        if (rv != 0)
        {
          ngtcp2_rob_gap_del(ng, rob->mem);
          return rv;
        }
      }
    }
    else if (ngtcp2_range_len(&r))
    {
      ngtcp2_ksl_update_key(&rob->gapksl, &g->range, &r);
      g->range = r;
    }
    rv = rob_write_data(rob, m.begin, data + (m.begin - offset),
                        (size_t)ngtcp2_range_len(&m));
    if (rv != 0)
    {
      return rv;
    }
    (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0);
  }
  return 0;
}
int ngtcp2_rob_remove_prefix(ngtcp2_rob *rob, uint64_t offset)
{
  ngtcp2_rob_gap *g;
  ngtcp2_rob_data *d;
  ngtcp2_ksl_it it;
  it = ngtcp2_ksl_begin(&rob->gapksl);
  for (; !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                            __null);)
  {
    g = ngtcp2_ksl_it_get(&it);
    if (offset <= g->range.begin)
    {
      break;
    }
    if (offset < g->range.end)
    {
      ngtcp2_range r = {offset, g->range.end};
      ngtcp2_ksl_update_key(&rob->gapksl, &g->range, &r);
      g->range.begin = offset;
      break;
    }
    ngtcp2_ksl_remove(&rob->gapksl, &it, &g->range);
    ngtcp2_rob_gap_del(g, rob->mem);
  }
  it = ngtcp2_ksl_begin(&rob->dataksl);
  for (; !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                            __null);)
  {
    d = ngtcp2_ksl_it_get(&it);
    if (offset < d->range.begin + rob->chunk)
    {
      return 0;
    }
    ngtcp2_ksl_remove(&rob->dataksl, &it, &d->range);
    ngtcp2_rob_data_del(d, rob->mem);
  }
  return 0;
}
size_t ngtcp2_rob_data_at(ngtcp2_rob *rob, const uint8_t **pdest,
                          uint64_t offset)
{
  ngtcp2_rob_gap *g;
  ngtcp2_rob_data *d;
  ngtcp2_ksl_it it;
  it = ngtcp2_ksl_begin(&rob->gapksl);
  if (((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                        __null))
  {
    return 0;
  }
  g = ngtcp2_ksl_it_get(&it);
  if (g->range.begin <= offset)
  {
    return 0;
  }
  it = ngtcp2_ksl_begin(&rob->dataksl);
  d = ngtcp2_ksl_it_get(&it);

  (static_cast<bool>(
       d)
       ? void(0)
       : __assert_fail(
             "d", "all.cpp", 35688, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       d->range.begin <= offset)
       ? void(0)
       : __assert_fail(
             "d->range.begin <= offset", "all.cpp", 35689, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       offset < d->range.begin + rob->chunk)
       ? void(0)
       : __assert_fail(
             "offset < d->range.begin + rob->chunk", "all.cpp", 35690, __extension__ __PRETTY_FUNCTION__));
  *pdest = d->begin + (offset - d->range.begin);
  return (size_t)(((g->range.begin) < (d->range.begin + rob->chunk) ? (g->range.begin) : (d->range.begin + rob->chunk)) -
                  offset);
}
void ngtcp2_rob_pop(ngtcp2_rob *rob, uint64_t offset, size_t len)
{
  ngtcp2_ksl_it it;
  ngtcp2_rob_data *d;
  it = ngtcp2_ksl_begin(&rob->dataksl);
  d = ngtcp2_ksl_it_get(&it);

  (static_cast<bool>(
       d)
       ? void(0)
       : __assert_fail(
             "d", "all.cpp", 35702, __extension__ __PRETTY_FUNCTION__));
  if (offset + len < d->range.begin + rob->chunk)
  {
    return;
  }
  ngtcp2_ksl_remove(&rob->dataksl,
                    __null, &d->range);
  ngtcp2_rob_data_del(d, rob->mem);
}
uint64_t ngtcp2_rob_first_gap_offset(ngtcp2_rob *rob)
{
  ngtcp2_ksl_it it = ngtcp2_ksl_begin(&rob->gapksl);
  ngtcp2_rob_gap *g;
  if (((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                        __null))
  {
    return (18446744073709551615UL);
  }
  g = ngtcp2_ksl_it_get(&it);
  return g->range.begin;
}
int ngtcp2_rob_data_buffered(ngtcp2_rob *rob)
{
  return ngtcp2_ksl_len(&rob->dataksl) != 0;
}
void ngtcp2_rs_init(ngtcp2_rs *rs)
{
  rs->interval =
      (18446744073709551615UL);
  rs->delivered = 0;
  rs->prior_delivered = 0;
  rs->prior_ts = 0;
  rs->send_elapsed = 0;
  rs->ack_elapsed = 0;
  rs->is_app_limited = 0;
}
void ngtcp2_rst_init(ngtcp2_rst *rst)
{
  ngtcp2_rs_init(&rst->rs);
  rst->delivered = 0;
  rst->delivered_ts = 0;
  rst->first_sent_ts = 0;
  rst->app_limited = 0;
}
void ngtcp2_rst_on_pkt_sent(ngtcp2_rst *rst, ngtcp2_rtb_entry *ent,
                            const ngtcp2_conn_stat *cstat)
{
  if (cstat->bytes_in_flight == 0)
  {
    rst->first_sent_ts = rst->delivered_ts = ent->ts;
  }
  ent->rst.first_sent_ts = rst->first_sent_ts;
  ent->rst.delivered_ts = rst->delivered_ts;
  ent->rst.delivered = rst->delivered;
  ent->rst.is_app_limited = rst->app_limited != 0;
}
int ngtcp2_rst_on_ack_recv(ngtcp2_rst *rst, ngtcp2_conn_stat *cstat)
{
  ngtcp2_rs *rs = &rst->rs;
  if (rst->app_limited && rst->delivered > rst->app_limited)
  {
    rst->app_limited = 0;
  }
  if (rs->prior_ts == 0)
  {
    return 0;
  }
  rs->interval = ((rs->send_elapsed) > (rs->ack_elapsed) ? (rs->send_elapsed) : (rs->ack_elapsed));
  rs->delivered = rst->delivered - rs->prior_delivered;
  if (rs->interval < cstat->min_rtt)
  {
    rs->interval =
        (18446744073709551615UL);
    return 0;
  }
  if (rs->interval)
  {
    cstat->delivery_rate_sec = rs->delivered * ((uint64_t)1000000000ULL) / rs->interval;
  }
  return 0;
}
void ngtcp2_rst_update_rate_sample(ngtcp2_rst *rst, const ngtcp2_rtb_entry *ent,
                                   ngtcp2_tstamp ts)
{
  ngtcp2_rs *rs = &rst->rs;
  rst->delivered += ent->pktlen;
  rst->delivered_ts = ts;
  if (ent->rst.delivered > rs->prior_delivered)
  {
    rs->prior_delivered = ent->rst.delivered;
    rs->prior_ts = ent->rst.delivered_ts;
    rs->is_app_limited = ent->rst.is_app_limited;
    rs->send_elapsed = ent->ts - ent->rst.first_sent_ts;
    rs->ack_elapsed = rst->delivered_ts - ent->rst.delivered_ts;
    rst->first_sent_ts = ent->ts;
  }
}
void ngtcp2_rst_update_app_limited(ngtcp2_rst *rst, ngtcp2_conn_stat *cstat)
{
  (void)rst;
  (void)cstat;
}
int ngtcp2_frame_chain_new(ngtcp2_frame_chain **pfrc, const ngtcp2_mem *mem)
{
  *pfrc = ngtcp2_mem_malloc(mem, sizeof(ngtcp2_frame_chain));
  if (*pfrc ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  ngtcp2_frame_chain_init(*pfrc);
  return 0;
}
int ngtcp2_frame_chain_extralen_new(ngtcp2_frame_chain **pfrc, size_t extralen,
                                    const ngtcp2_mem *mem)
{
  *pfrc = ngtcp2_mem_malloc(mem, sizeof(ngtcp2_frame_chain) + extralen);
  if (*pfrc ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  ngtcp2_frame_chain_init(*pfrc);
  return 0;
}
int ngtcp2_frame_chain_stream_datacnt_new(ngtcp2_frame_chain **pfrc,
                                          size_t datacnt,
                                          const ngtcp2_mem *mem)
{
  size_t need = sizeof(ngtcp2_vec) * (datacnt - 1);
  size_t avail = sizeof(ngtcp2_frame) - sizeof(ngtcp2_stream);
  if (datacnt > 0 && need > avail)
  {
    return ngtcp2_frame_chain_extralen_new(pfrc, need - avail, mem);
  }
  return ngtcp2_frame_chain_new(pfrc, mem);
}
int ngtcp2_frame_chain_crypto_datacnt_new(ngtcp2_frame_chain **pfrc,
                                          size_t datacnt,
                                          const ngtcp2_mem *mem)
{
  size_t need = sizeof(ngtcp2_vec) * (datacnt - 1);
  size_t avail = sizeof(ngtcp2_frame) - sizeof(ngtcp2_crypto);
  if (datacnt > 0 && need > avail)
  {
    return ngtcp2_frame_chain_extralen_new(pfrc, need - avail, mem);
  }
  return ngtcp2_frame_chain_new(pfrc, mem);
}
int ngtcp2_frame_chain_new_token_new(ngtcp2_frame_chain **pfrc,
                                     const ngtcp2_vec *token,
                                     const ngtcp2_mem *mem)
{
  size_t avail = sizeof(ngtcp2_frame) - sizeof(ngtcp2_new_token);
  int rv;
  uint8_t *p;
  ngtcp2_frame *fr;
  if (token->len > avail)
  {
    rv = ngtcp2_frame_chain_extralen_new(pfrc, token->len - avail, mem);
  }
  else
  {
    rv = ngtcp2_frame_chain_new(pfrc, mem);
  }
  if (rv != 0)
  {
    return rv;
  }
  fr = &(*pfrc)->fr;
  fr->type = NGTCP2_FRAME_NEW_TOKEN;
  p = (uint8_t *)(*pfrc) + sizeof(ngtcp2_new_token);
  memcpy(p, token->base, token->len);
  ngtcp2_vec_init(&fr->new_token.token, p, token->len);
  return 0;
}
void ngtcp2_frame_chain_del(ngtcp2_frame_chain *frc, const ngtcp2_mem *mem)
{
  ngtcp2_frame_chain_binder *binder;
  if (frc ==
      __null)
  {
    return;
  }
  binder = frc->binder;
  if (binder && --binder->refcount == 0)
  {
    ngtcp2_mem_free(mem, binder);
  }
  ngtcp2_mem_free(mem, frc);
}
void ngtcp2_frame_chain_init(ngtcp2_frame_chain *frc)
{
  frc->next =
      __null;
  frc->binder =
      __null;
}
void ngtcp2_frame_chain_list_del(ngtcp2_frame_chain *frc,
                                 const ngtcp2_mem *mem)
{
  ngtcp2_frame_chain *next;
  for (; frc;)
  {
    next = frc->next;
    ngtcp2_frame_chain_del(frc, mem);
    frc = next;
  }
}
int ngtcp2_frame_chain_binder_new(ngtcp2_frame_chain_binder **pbinder,
                                  const ngtcp2_mem *mem)
{
  *pbinder = ngtcp2_mem_calloc(mem, 1, sizeof(ngtcp2_frame_chain_binder));
  if (*pbinder ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  return 0;
}
int ngtcp2_bind_frame_chains(ngtcp2_frame_chain *a, ngtcp2_frame_chain *b,
                             const ngtcp2_mem *mem)
{
  ngtcp2_frame_chain_binder *binder;
  int rv;

  (static_cast<bool>(
       b->binder ==
       __null)
       ? void(0)
       : __assert_fail(
             "b->binder == NULL", "all.cpp", 35949, __extension__ __PRETTY_FUNCTION__));
  if (a->binder ==
      __null)
  {
    rv = ngtcp2_frame_chain_binder_new(&binder, mem);
    if (rv != 0)
    {
      return rv;
    }
    a->binder = binder;
    ++a->binder->refcount;
  }
  b->binder = a->binder;
  ++b->binder->refcount;
  return 0;
}
int ngtcp2_rtb_entry_new(ngtcp2_rtb_entry **pent, const ngtcp2_pkt_hd *hd,
                         ngtcp2_frame_chain *frc, ngtcp2_tstamp ts,
                         size_t pktlen, uint8_t flags, const ngtcp2_mem *mem)
{
  (*pent) = ngtcp2_mem_calloc(mem, 1, sizeof(ngtcp2_rtb_entry));
  if (*pent ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  (*pent)->hd.pkt_num = hd->pkt_num;
  (*pent)->hd.type = hd->type;
  (*pent)->hd.flags = hd->flags;
  (*pent)->frc = frc;
  (*pent)->ts = ts;
  (*pent)->lost_ts =
      (18446744073709551615UL);
  (*pent)->pktlen = pktlen;
  (*pent)->flags = flags;
  (*pent)->next =
      __null;
  return 0;
}
void ngtcp2_rtb_entry_del(ngtcp2_rtb_entry *ent, const ngtcp2_mem *mem)
{
  if (ent ==
      __null)
  {
    return;
  }
  ngtcp2_frame_chain_list_del(ent->frc, mem);
  ngtcp2_mem_free(mem, ent);
}
void ngtcp2_rtb_init(ngtcp2_rtb *rtb, ngtcp2_pktns_id pktns_id,
                     ngtcp2_strm *crypto, ngtcp2_rst *rst, ngtcp2_cc *cc,
                     ngtcp2_log *log, ngtcp2_qlog *qlog,
                     const ngtcp2_mem *mem)
{
  ngtcp2_ksl_init(&rtb->ents, greater, sizeof(int64_t), mem);
  rtb->crypto = crypto;
  rtb->rst = rst;
  rtb->cc = cc;
  rtb->log = log;
  rtb->qlog = qlog;
  rtb->mem = mem;
  rtb->largest_acked_tx_pkt_num = -1;
  rtb->num_ack_eliciting = 0;
  rtb->num_retransmittable = 0;
  rtb->probe_pkt_left = 0;
  rtb->pktns_id = pktns_id;
  rtb->cc_pkt_num = 0;
  rtb->cc_bytes_in_flight = 0;
  rtb->persistent_congestion_start_ts =
      (18446744073709551615UL);
  rtb->num_lost_pkts = 0;
}
void ngtcp2_rtb_free(ngtcp2_rtb *rtb)
{
  ngtcp2_ksl_it it;
  if (rtb ==
      __null)
  {
    return;
  }
  it = ngtcp2_ksl_begin(&rtb->ents);
  for (; !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                            __null);
       (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
  {
    ngtcp2_rtb_entry_del(ngtcp2_ksl_it_get(&it), rtb->mem);
  }
  ngtcp2_ksl_free(&rtb->ents);
}
static void rtb_on_add(ngtcp2_rtb *rtb, ngtcp2_rtb_entry *ent,
                       ngtcp2_conn_stat *cstat)
{
  ngtcp2_rst_on_pkt_sent(rtb->rst, ent, cstat);

  (static_cast<bool>(
       rtb->cc_pkt_num <= ent->hd.pkt_num)
       ? void(0)
       : __assert_fail(
             "rtb->cc_pkt_num <= ent->hd.pkt_num", "all.cpp", 36038, __extension__ __PRETTY_FUNCTION__));
  cstat->bytes_in_flight += ent->pktlen;
  rtb->cc_bytes_in_flight += ent->pktlen;
  ngtcp2_rst_update_app_limited(rtb->rst, cstat);
  if (ent->flags & NGTCP2_RTB_FLAG_ACK_ELICITING)
  {
    ++rtb->num_ack_eliciting;
  }
  if (ent->flags & NGTCP2_RTB_FLAG_RETRANSMITTABLE)
  {
    ++rtb->num_retransmittable;
  }
}
static void rtb_on_remove(ngtcp2_rtb *rtb, ngtcp2_rtb_entry *ent,
                          ngtcp2_conn_stat *cstat)
{
  if (ent->flags & NGTCP2_RTB_FLAG_LOST_RETRANSMITTED)
  {

    (static_cast<bool>(
         rtb->num_lost_pkts)
         ? void(0)
         : __assert_fail(
               "rtb->num_lost_pkts", "all.cpp", 36057, __extension__ __PRETTY_FUNCTION__));
    --rtb->num_lost_pkts;
    return;
  }
  if (ent->flags & NGTCP2_RTB_FLAG_ACK_ELICITING)
  {

    (static_cast<bool>(
         rtb->num_ack_eliciting)
         ? void(0)
         : __assert_fail(
               "rtb->num_ack_eliciting", "all.cpp", 36063, __extension__ __PRETTY_FUNCTION__));
    --rtb->num_ack_eliciting;
  }
  if ((ent->flags & NGTCP2_RTB_FLAG_RETRANSMITTABLE) &&
      !(ent->flags & NGTCP2_RTB_FLAG_PTO_RECLAIMED))
  {

    (static_cast<bool>(
         rtb->num_retransmittable)
         ? void(0)
         : __assert_fail(
               "rtb->num_retransmittable", "all.cpp", 36069, __extension__ __PRETTY_FUNCTION__));
    --rtb->num_retransmittable;
  }
  if (rtb->cc_pkt_num <= ent->hd.pkt_num)
  {

    (static_cast<bool>(
         cstat->bytes_in_flight >= ent->pktlen)
         ? void(0)
         : __assert_fail(
               "cstat->bytes_in_flight >= ent->pktlen", "all.cpp", 36074, __extension__ __PRETTY_FUNCTION__));
    cstat->bytes_in_flight -= ent->pktlen;

    (static_cast<bool>(
         rtb->cc_bytes_in_flight >= ent->pktlen)
         ? void(0)
         : __assert_fail(
               "rtb->cc_bytes_in_flight >= ent->pktlen", "all.cpp", 36076, __extension__ __PRETTY_FUNCTION__));
    rtb->cc_bytes_in_flight -= ent->pktlen;
  }
}
static ngtcp2_ssize rtb_reclaim_frame(ngtcp2_rtb *rtb, ngtcp2_conn *conn,
                                      ngtcp2_pktns *pktns,
                                      ngtcp2_rtb_entry *ent)
{
  ngtcp2_frame_chain *frc, *nfrc, **pfrc = &pktns->tx.frq;
  ngtcp2_frame *fr;
  ngtcp2_strm *strm;
  ngtcp2_range gap, range;
  size_t num_reclaimed = 0;
  int rv;
  for (frc = ent->frc; frc; frc = frc->next)
  {
    fr = &frc->fr;
    if (frc->binder &&
        (frc->binder->flags & NGTCP2_FRAME_CHAIN_BINDER_FLAG_ACK))
    {
      continue;
    }
    switch (frc->fr.type)
    {
    case NGTCP2_FRAME_STREAM:
      strm = ngtcp2_conn_find_stream(conn, fr->stream.stream_id);
      if (strm ==
          __null)
      {
        continue;
      }
      gap = ngtcp2_strm_get_unacked_range_after(strm, fr->stream.offset);
      range.begin = fr->stream.offset;
      range.end = fr->stream.offset +
                  ngtcp2_vec_len(fr->stream.data, fr->stream.datacnt);
      range = ngtcp2_range_intersect(&range, &gap);
      if (ngtcp2_range_len(&range) == 0 &&
          (!fr->stream.fin || (strm->flags & NGTCP2_STRM_FLAG_FIN_ACKED)))
      {
        continue;
      }
      rv = ngtcp2_frame_chain_stream_datacnt_new(&nfrc, fr->stream.datacnt,
                                                 rtb->mem);
      if (rv != 0)
      {
        return rv;
      }
      nfrc->fr = *fr;
      ngtcp2_vec_copy(nfrc->fr.stream.data, fr->stream.data,
                      fr->stream.datacnt);
      rv = ngtcp2_strm_streamfrq_push(strm, nfrc);
      if (rv != 0)
      {
        ngtcp2_frame_chain_del(nfrc, conn->mem);
        return rv;
      }
      if (!ngtcp2_strm_is_tx_queued(strm))
      {
        strm->cycle = ngtcp2_conn_tx_strmq_first_cycle(conn);
        rv = ngtcp2_conn_tx_strmq_push(conn, strm);
        if (rv != 0)
        {
          return rv;
        }
      }
      ++num_reclaimed;
      continue;
    case NGTCP2_FRAME_CRYPTO:
      gap = ngtcp2_strm_get_unacked_range_after(rtb->crypto, fr->crypto.offset);
      range.begin = fr->crypto.offset;
      range.end = fr->crypto.offset +
                  ngtcp2_vec_len(fr->crypto.data, fr->crypto.datacnt);
      range = ngtcp2_range_intersect(&range, &gap);
      if (ngtcp2_range_len(&range) == 0)
      {
        continue;
      }
      rv = ngtcp2_frame_chain_crypto_datacnt_new(&nfrc, fr->crypto.datacnt,
                                                 rtb->mem);
      if (rv != 0)
      {
        return rv;
      }
      nfrc->fr = *fr;
      ngtcp2_vec_copy(nfrc->fr.crypto.data, fr->crypto.data,
                      fr->crypto.datacnt);
      rv = ngtcp2_ksl_insert(&pktns->crypto.tx.frq,
                             __null,
                             &nfrc->fr.crypto.offset, nfrc);
      if (rv != 0)
      {

        (static_cast<bool>(
             ngtcp2_err_is_fatal(rv))
             ? void(0)
             : __assert_fail(
                   "ngtcp2_err_is_fatal(rv)", "all.cpp", 36166, __extension__ __PRETTY_FUNCTION__));
        ngtcp2_frame_chain_del(nfrc, conn->mem);
        return rv;
      }
      ++num_reclaimed;
      continue;
    case NGTCP2_FRAME_NEW_TOKEN:
      rv = ngtcp2_frame_chain_new_token_new(&nfrc, &fr->new_token.token,
                                            rtb->mem);
      if (rv != 0)
      {
        return rv;
      }
      rv = ngtcp2_bind_frame_chains(frc, nfrc, rtb->mem);
      if (rv != 0)
      {
        return rv;
      }
      break;
    default:
      rv = ngtcp2_frame_chain_new(&nfrc, rtb->mem);
      if (rv != 0)
      {
        return rv;
      }
      nfrc->fr = *fr;
      rv = ngtcp2_bind_frame_chains(frc, nfrc, rtb->mem);
      if (rv != 0)
      {
        return rv;
      }
      break;
    }
    ++num_reclaimed;
    nfrc->next = *pfrc;
    *pfrc = nfrc;
    pfrc = &nfrc->next;
  }
  return (ngtcp2_ssize)num_reclaimed;
}
static int rtb_on_pkt_lost(ngtcp2_rtb *rtb, ngtcp2_ksl_it *it,
                           ngtcp2_rtb_entry *ent, ngtcp2_conn *conn,
                           ngtcp2_pktns *pktns, ngtcp2_tstamp ts)
{
  int rv;
  ngtcp2_ssize reclaimed;
  ngtcp2_log_pkt_lost(rtb->log, ent->hd.pkt_num, ent->hd.type, ent->hd.flags,
                      ent->ts);
  if (rtb->qlog)
  {
    ngtcp2_qlog_pkt_lost(rtb->qlog, ent);
  }
  if (!(ent->flags & NGTCP2_RTB_FLAG_PROBE))
  {
    if (ent->flags & NGTCP2_RTB_FLAG_PTO_RECLAIMED)
    {
      ngtcp2_log_info(rtb->log, NGTCP2_LOG_EVENT_RCV,
                      "pkn=%"
                      "l"
                      "d"
                      " has already been reclaimed on PTO",
                      ent->hd.pkt_num);

      (static_cast<bool>(
           !(ent->flags & NGTCP2_RTB_FLAG_LOST_RETRANSMITTED))
           ? void(0)
           : __assert_fail(
                 "!(ent->flags & NGTCP2_RTB_FLAG_LOST_RETRANSMITTED)", "all.cpp", 36226, __extension__ __PRETTY_FUNCTION__));

      (static_cast<bool>((18446744073709551615UL) == ent->lost_ts) ? void(0) : __assert_fail("UINT64_MAX == ent->lost_ts", "all.cpp", 36227, __extension__ __PRETTY_FUNCTION__));
      ent->flags |= NGTCP2_RTB_FLAG_LOST_RETRANSMITTED;
      ent->lost_ts = ts;
      ++rtb->num_lost_pkts;
      (++(it)->i == (it)->blk->n && (it)->blk->next ? ((it)->blk = (it)->blk->next, (it)->i = 0) : 0);
      return 0;
    }
    if (ent->frc)
    {

      (static_cast<bool>(
           !(ent->flags & NGTCP2_RTB_FLAG_LOST_RETRANSMITTED))
           ? void(0)
           : __assert_fail(
                 "!(ent->flags & NGTCP2_RTB_FLAG_LOST_RETRANSMITTED)", "all.cpp", 36236, __extension__ __PRETTY_FUNCTION__));

      (static_cast<bool>((18446744073709551615UL) == ent->lost_ts) ? void(0) : __assert_fail("UINT64_MAX == ent->lost_ts", "all.cpp", 36237, __extension__ __PRETTY_FUNCTION__));
      reclaimed = rtb_reclaim_frame(rtb, conn, pktns, ent);
      if (reclaimed < 0)
      {
        return (int)reclaimed;
      }
      if (reclaimed)
      {
        ent->flags |= NGTCP2_RTB_FLAG_LOST_RETRANSMITTED;
        ent->lost_ts = ts;
        ++rtb->num_lost_pkts;
        (++(it)->i == (it)->blk->n && (it)->blk->next ? ((it)->blk = (it)->blk->next, (it)->i = 0) : 0);
        return 0;
      }
    }
  }
  else
  {
    ngtcp2_log_info(rtb->log, NGTCP2_LOG_EVENT_RCV,
                    "pkn=%"
                    "l"
                    "d"

                    " is a probe packet, no retransmission is necessary",
                    ent->hd.pkt_num);
  }
  rv = ngtcp2_ksl_remove(&rtb->ents, it, &ent->hd.pkt_num);

  (static_cast<bool>(
       0 == rv)
       ? void(0)
       : __assert_fail(
             "0 == rv", "all.cpp", 36261, __extension__ __PRETTY_FUNCTION__));
  ngtcp2_rtb_entry_del(ent, rtb->mem);
  return 0;
}
int ngtcp2_rtb_add(ngtcp2_rtb *rtb, ngtcp2_rtb_entry *ent,
                   ngtcp2_conn_stat *cstat)
{
  int rv;
  rv = ngtcp2_ksl_insert(&rtb->ents,
                         __null, &ent->hd.pkt_num, ent);
  if (rv != 0)
  {
    return rv;
  }
  rtb_on_add(rtb, ent, cstat);
  return 0;
}
ngtcp2_ksl_it ngtcp2_rtb_head(ngtcp2_rtb *rtb)
{
  return ngtcp2_ksl_begin(&rtb->ents);
}
static void rtb_remove(ngtcp2_rtb *rtb, ngtcp2_ksl_it *it,
                       ngtcp2_rtb_entry **pent, ngtcp2_rtb_entry *ent,
                       ngtcp2_conn_stat *cstat)
{
  int rv;
  rv = ngtcp2_ksl_remove(&rtb->ents, it, &ent->hd.pkt_num);

  (static_cast<bool>(
       0 == rv)
       ? void(0)
       : __assert_fail(
             "0 == rv", "all.cpp", 36290, __extension__ __PRETTY_FUNCTION__));
  rtb_on_remove(rtb, ent, cstat);

  (static_cast<bool>(
       ent->next ==
       __null)
       ? void(0)
       : __assert_fail(
             "ent->next == NULL", "all.cpp", 36292, __extension__ __PRETTY_FUNCTION__));
  do
  {
    (ent)->next = *(pent);
    *(pent) = (ent);
  } while (0);
}
static int rtb_process_acked_pkt(ngtcp2_rtb *rtb, ngtcp2_rtb_entry *ent,
                                 ngtcp2_conn *conn)
{
  ngtcp2_frame_chain *frc;
  uint64_t prev_stream_offset, stream_offset;
  ngtcp2_strm *strm;
  int rv;
  uint64_t datalen;
  ngtcp2_strm *crypto = rtb->crypto;
  ngtcp2_crypto_level crypto_level;
  for (frc = ent->frc; frc; frc = frc->next)
  {
    if (frc->binder)
    {
      frc->binder->flags |= NGTCP2_FRAME_CHAIN_BINDER_FLAG_ACK;
    }
    switch (frc->fr.type)
    {
    case NGTCP2_FRAME_STREAM:
      strm = ngtcp2_conn_find_stream(conn, frc->fr.stream.stream_id);
      if (strm ==
          __null)
      {
        break;
      }
      if (frc->fr.stream.fin)
      {
        strm->flags |= NGTCP2_STRM_FLAG_FIN_ACKED;
      }
      prev_stream_offset = ngtcp2_strm_get_acked_offset(strm);
      rv = ngtcp2_strm_ack_data(
          strm, frc->fr.stream.offset,
          ngtcp2_vec_len(frc->fr.stream.data, frc->fr.stream.datacnt));
      if (rv != 0)
      {
        return rv;
      }
      if (conn->callbacks.acked_stream_data_offset)
      {
        stream_offset = ngtcp2_strm_get_acked_offset(strm);
        datalen = stream_offset - prev_stream_offset;
        if (datalen == 0 && !frc->fr.stream.fin)
        {
          break;
        }
        rv = conn->callbacks.acked_stream_data_offset(
            conn, strm->stream_id, prev_stream_offset, datalen, conn->user_data,
            strm->stream_user_data);
        if (rv != 0)
        {
          return NGTCP2_ERR_CALLBACK_FAILURE;
        }
      }
      rv = ngtcp2_conn_close_stream_if_shut_rdwr(conn, strm, 0x0u);
      if (rv != 0)
      {
        return rv;
      }
      break;
    case NGTCP2_FRAME_CRYPTO:
      prev_stream_offset = ngtcp2_strm_get_acked_offset(crypto);
      rv = ngtcp2_strm_ack_data(
          crypto, frc->fr.crypto.offset,
          ngtcp2_vec_len(frc->fr.crypto.data, frc->fr.crypto.datacnt));
      if (rv != 0)
      {
        return rv;
      }
      if (conn->callbacks.acked_crypto_offset)
      {
        stream_offset = ngtcp2_strm_get_acked_offset(crypto);
        datalen = stream_offset - prev_stream_offset;
        if (datalen == 0)
        {
          break;
        }
        switch (rtb->pktns_id)
        {
        case NGTCP2_PKTNS_ID_INITIAL:
          crypto_level = NGTCP2_CRYPTO_LEVEL_INITIAL;
          break;
        case NGTCP2_PKTNS_ID_HANDSHAKE:
          crypto_level = NGTCP2_CRYPTO_LEVEL_HANDSHAKE;
          break;
        case NGTCP2_PKTNS_ID_APP:
          crypto_level = NGTCP2_CRYPTO_LEVEL_APP;
          break;
        default:

          (static_cast<bool>(
               0)
               ? void(0)
               : __assert_fail(
                     "0", "all.cpp", 36383, __extension__ __PRETTY_FUNCTION__));
        }
        rv = conn->callbacks.acked_crypto_offset(
            conn, crypto_level, prev_stream_offset, datalen, conn->user_data);
        if (rv != 0)
        {
          return NGTCP2_ERR_CALLBACK_FAILURE;
        }
      }
      break;
    case NGTCP2_FRAME_RESET_STREAM:
      strm = ngtcp2_conn_find_stream(conn, frc->fr.reset_stream.stream_id);
      if (strm ==
          __null)
      {
        break;
      }
      strm->flags |= NGTCP2_STRM_FLAG_RST_ACKED;
      rv = ngtcp2_conn_close_stream_if_shut_rdwr(conn, strm, 0x0u);
      if (rv != 0)
      {
        return rv;
      }
      break;
    case NGTCP2_FRAME_RETIRE_CONNECTION_ID:

      (static_cast<bool>(
           conn->dcid.num_retire_queued)
           ? void(0)
           : __assert_fail(
                 "conn->dcid.num_retire_queued", "all.cpp", 36407, __extension__ __PRETTY_FUNCTION__));
      --conn->dcid.num_retire_queued;
      break;
    }
  }
  return 0;
}
static void rtb_on_pkt_acked(ngtcp2_rtb *rtb, ngtcp2_rtb_entry *ent,
                             ngtcp2_conn_stat *cstat, ngtcp2_tstamp ts)
{
  ngtcp2_cc *cc = rtb->cc;
  ngtcp2_cc_pkt pkt;
  ngtcp2_rst_update_rate_sample(rtb->rst, ent, ts);
  cc->on_pkt_acked(cc, cstat,
                   ngtcp2_cc_pkt_init(&pkt, ent->hd.pkt_num, ent->pktlen,
                                      rtb->pktns_id, ent->ts),
                   ts);
  if (!(ent->flags & NGTCP2_RTB_FLAG_PROBE) &&
      (ent->flags & NGTCP2_RTB_FLAG_ACK_ELICITING))
  {
    cstat->pto_count = 0;
  }
}
static void conn_verify_ecn(ngtcp2_conn *conn, ngtcp2_pktns *pktns,
                            ngtcp2_cc *cc, ngtcp2_conn_stat *cstat,
                            const ngtcp2_ack *fr, size_t ecn_acked,
                            ngtcp2_tstamp largest_acked_sent_ts,
                            ngtcp2_tstamp ts)
{
  if (conn->tx.ecn.state == NGTCP2_ECN_STATE_FAILED)
  {
    return;
  }
  if ((ecn_acked && fr->type == NGTCP2_FRAME_ACK) ||
      (fr->type == NGTCP2_FRAME_ACK_ECN &&
       (pktns->rx.ecn.ack.ect0 > fr->ecn.ect0 ||
        pktns->rx.ecn.ack.ect1 > fr->ecn.ect1 ||
        pktns->rx.ecn.ack.ce > fr->ecn.ce ||
        (fr->ecn.ect0 - pktns->rx.ecn.ack.ect0) +
                (fr->ecn.ce - pktns->rx.ecn.ack.ce) <
            ecn_acked ||
        fr->ecn.ect0 > pktns->tx.ecn.ect0 || fr->ecn.ect1)))
  {
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_CON,
                    "path is not ECN capable");
    conn->tx.ecn.state = NGTCP2_ECN_STATE_FAILED;
    return;
  }
  if (conn->tx.ecn.state != NGTCP2_ECN_STATE_CAPABLE && ecn_acked)
  {
    ngtcp2_log_info(&conn->log, NGTCP2_LOG_EVENT_CON, "path is ECN capable");
    conn->tx.ecn.state = NGTCP2_ECN_STATE_CAPABLE;
  }
  if (fr->type == NGTCP2_FRAME_ACK_ECN)
  {
    if (largest_acked_sent_ts !=
            (18446744073709551615UL) &&
        fr->ecn.ce > pktns->rx.ecn.ack.ce)
    {
      cc->congestion_event(cc, cstat, largest_acked_sent_ts, ts);
    }
    pktns->rx.ecn.ack.ect0 = fr->ecn.ect0;
    pktns->rx.ecn.ack.ect1 = fr->ecn.ect1;
    pktns->rx.ecn.ack.ce = fr->ecn.ce;
  }
}
ngtcp2_ssize ngtcp2_rtb_recv_ack(ngtcp2_rtb *rtb, const ngtcp2_ack *fr,
                                 ngtcp2_conn_stat *cstat, ngtcp2_conn *conn,
                                 ngtcp2_pktns *pktns, ngtcp2_tstamp pkt_ts,
                                 ngtcp2_tstamp ts)
{
  ngtcp2_rtb_entry *ent;
  int64_t largest_ack = fr->largest_ack, min_ack;
  size_t i;
  int rv;
  ngtcp2_ksl_it it;
  ngtcp2_ssize num_acked = 0;
  ngtcp2_tstamp largest_pkt_sent_ts =
      (18446744073709551615UL);
  ngtcp2_tstamp largest_acked_sent_ts =
      (18446744073709551615UL);
  int64_t pkt_num;
  ngtcp2_cc *cc = rtb->cc;
  ngtcp2_rtb_entry *acked_ent =
      __null;
  int ack_eliciting_pkt_acked = 0;
  size_t ecn_acked = 0;
  int verify_ecn = 0;
  if (conn && (conn->flags & NGTCP2_CONN_FLAG_KEY_UPDATE_NOT_CONFIRMED) &&
      largest_ack >= conn->pktns.crypto.tx.ckm->pkt_num)
  {
    conn->flags &= (uint16_t)~NGTCP2_CONN_FLAG_KEY_UPDATE_NOT_CONFIRMED;
    conn->crypto.key_update.confirmed_ts = ts;
    ngtcp2_log_info(rtb->log, NGTCP2_LOG_EVENT_CRY, "key update confirmed");
  }
  if (rtb->largest_acked_tx_pkt_num < largest_ack)
  {
    rtb->largest_acked_tx_pkt_num = largest_ack;
    verify_ecn = 1;
  }
  it = ngtcp2_ksl_lower_bound(&rtb->ents, &largest_ack);
  if (((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                        __null))
  {
    if (verify_ecn)
    {
      conn_verify_ecn(conn, pktns, rtb->cc, cstat, fr, ecn_acked,
                      largest_acked_sent_ts, ts);
    }
    return 0;
  }
  min_ack = largest_ack - (int64_t)fr->first_ack_blklen;
  for (; !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                            __null);)
  {
    pkt_num = *(int64_t *)((ngtcp2_ksl_key *)((ngtcp2_ksl_node *)(void *)(((&it)->blk)->nodes + ((&it)->ksl)->nodelen * ((&it)->i)))->key);

    (static_cast<bool>(
         pkt_num <= largest_ack)
         ? void(0)
         : __assert_fail(
               "pkt_num <= largest_ack", "all.cpp", 36520, __extension__ __PRETTY_FUNCTION__));
    if (pkt_num < min_ack)
    {
      break;
    }
    ent = ngtcp2_ksl_it_get(&it);
    if (largest_ack == pkt_num)
    {
      largest_pkt_sent_ts = ent->ts;
    }
    if (ent->flags & NGTCP2_RTB_FLAG_ACK_ELICITING)
    {
      ack_eliciting_pkt_acked = 1;
    }
    rtb_remove(rtb, &it, &acked_ent, ent, cstat);
    ++num_acked;
  }
  for (i = 0; i < fr->num_blks;)
  {
    largest_ack = min_ack - (int64_t)fr->blks[i].gap - 2;
    min_ack = largest_ack - (int64_t)fr->blks[i].blklen;
    it = ngtcp2_ksl_lower_bound(&rtb->ents, &largest_ack);
    if (((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                          __null))
    {
      break;
    }
    for (; !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                              __null);)
    {
      pkt_num = *(int64_t *)((ngtcp2_ksl_key *)((ngtcp2_ksl_node *)(void *)(((&it)->blk)->nodes + ((&it)->ksl)->nodelen * ((&it)->i)))->key);
      if (pkt_num < min_ack)
      {
        break;
      }
      ent = ngtcp2_ksl_it_get(&it);
      if (ent->flags & NGTCP2_RTB_FLAG_ACK_ELICITING)
      {
        ack_eliciting_pkt_acked = 1;
      }
      rtb_remove(rtb, &it, &acked_ent, ent, cstat);
      ++num_acked;
    }
    ++i;
  }
  if (largest_pkt_sent_ts !=
          (18446744073709551615UL) &&
      ack_eliciting_pkt_acked)
  {
    ngtcp2_conn_update_rtt(conn, pkt_ts - largest_pkt_sent_ts,
                           fr->ack_delay_unscaled, ts);
    if (cc->new_rtt_sample)
    {
      cc->new_rtt_sample(cc, cstat, ts);
    }
  }
  ngtcp2_rst_on_ack_recv(rtb->rst, cstat);
  if (conn)
  {
    for (ent = acked_ent; ent; ent = acked_ent)
    {
      if (ent->hd.pkt_num >= pktns->tx.ecn.start_pkt_num &&
          (ent->flags & NGTCP2_RTB_FLAG_ECN))
      {
        ++ecn_acked;
      }

      (static_cast<bool>(
           largest_acked_sent_ts ==
               (18446744073709551615UL) ||
           largest_acked_sent_ts <= ent->ts)
           ? void(0)
           : __assert_fail(
                 "largest_acked_sent_ts == UINT64_MAX || largest_acked_sent_ts <= ent->ts",
                 "all.cpp",
                 36583, __extension__ __PRETTY_FUNCTION__))

          ;
      largest_acked_sent_ts = ent->ts;
      rv = rtb_process_acked_pkt(rtb, ent, conn);
      if (rv != 0)
      {
        goto fail;
      }
      rtb_on_pkt_acked(rtb, ent, cstat, ts);
      acked_ent = ent->next;
      ngtcp2_rtb_entry_del(ent, rtb->mem);
    }
    if (verify_ecn)
    {
      conn_verify_ecn(conn, pktns, rtb->cc, cstat, fr, ecn_acked,
                      largest_acked_sent_ts, ts);
    }
  }
  else
  {
    for (ent = acked_ent; ent; ent = acked_ent)
    {
      rtb_on_pkt_acked(rtb, ent, cstat, ts);
      acked_ent = ent->next;
      ngtcp2_rtb_entry_del(ent, rtb->mem);
    }
  }
  cc->on_ack_recv(cc, cstat, ts);
  return num_acked;
fail:
  for (ent = acked_ent; ent; ent = acked_ent)
  {
    acked_ent = ent->next;
    ngtcp2_rtb_entry_del(ent, rtb->mem);
  }
  return rv;
}
static int rtb_pkt_lost(ngtcp2_rtb *rtb, ngtcp2_conn_stat *cstat,
                        const ngtcp2_rtb_entry *ent, uint64_t loss_delay,
                        ngtcp2_tstamp lost_send_time, uint64_t pkt_thres)
{
  ngtcp2_tstamp loss_time;
  if (ent->ts <= lost_send_time ||
      rtb->largest_acked_tx_pkt_num >= ent->hd.pkt_num + (int64_t)pkt_thres)
  {
    return 1;
  }
  loss_time = cstat->loss_time[rtb->pktns_id];
  if (loss_time ==
      (18446744073709551615UL))
  {
    loss_time = ent->ts + loss_delay;
  }
  else
  {
    loss_time = ((loss_time) < (ent->ts + loss_delay) ? (loss_time) : (ent->ts + loss_delay));
  }
  cstat->loss_time[rtb->pktns_id] = loss_time;
  return 0;
}
static ngtcp2_duration compute_pkt_loss_delay(const ngtcp2_conn_stat *cstat)
{
  ngtcp2_duration loss_delay =
      ((cstat->latest_rtt) > (cstat->smoothed_rtt) ? (cstat->latest_rtt) : (cstat->smoothed_rtt)) * 9 / 8;
  return ((loss_delay) > (((uint64_t)1000000ULL)) ? (loss_delay) : (((uint64_t)1000000ULL)));
}
static int conn_all_ecn_pkt_lost(ngtcp2_conn *conn)
{
  ngtcp2_pktns *in_pktns = conn->in_pktns;
  ngtcp2_pktns *hs_pktns = conn->hs_pktns;
  ngtcp2_pktns *pktns = &conn->pktns;
  return (!in_pktns || in_pktns->tx.ecn.validation_pkt_sent ==
                           in_pktns->tx.ecn.validation_pkt_lost) &&
         (!hs_pktns || hs_pktns->tx.ecn.validation_pkt_sent ==
                           hs_pktns->tx.ecn.validation_pkt_lost) &&
         pktns->tx.ecn.validation_pkt_sent == pktns->tx.ecn.validation_pkt_lost;
}
int ngtcp2_rtb_detect_lost_pkt(ngtcp2_rtb *rtb, ngtcp2_conn *conn,
                               ngtcp2_pktns *pktns, ngtcp2_conn_stat *cstat,
                               ngtcp2_duration pto, ngtcp2_tstamp ts)
{
  ngtcp2_rtb_entry *ent;
  ngtcp2_duration loss_delay;
  ngtcp2_tstamp lost_send_time;
  ngtcp2_ksl_it it;
  ngtcp2_tstamp latest_ts, oldest_ts;
  int64_t last_lost_pkt_num;
  ngtcp2_duration loss_window, congestion_period;
  ngtcp2_cc *cc = rtb->cc;
  int rv;
  uint64_t pkt_thres =
      rtb->cc_bytes_in_flight / cstat->max_udp_payload_size / 2;
  size_t ecn_pkt_lost = 0;
  ngtcp2_tstamp start_ts;
  pkt_thres = ((pkt_thres) > (3) ? (pkt_thres) : (3));
  cstat->loss_time[rtb->pktns_id] =
      (18446744073709551615UL);
  loss_delay = compute_pkt_loss_delay(cstat);
  lost_send_time = ts - loss_delay;
  it = ngtcp2_ksl_lower_bound(&rtb->ents, &rtb->largest_acked_tx_pkt_num);
  for (; !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                            __null);
       (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
  {
    ent = ngtcp2_ksl_it_get(&it);
    if (ent->flags & NGTCP2_RTB_FLAG_LOST_RETRANSMITTED)
    {
      break;
    }
    if (rtb_pkt_lost(rtb, cstat, ent, loss_delay, lost_send_time, pkt_thres))
    {
      latest_ts = oldest_ts = ent->ts;
      last_lost_pkt_num = ent->hd.pkt_num;
      congestion_period = (cstat->smoothed_rtt +
                           ((4 * cstat->rttvar) > (((uint64_t)1000000ULL)) ? (4 * cstat->rttvar) : (((uint64_t)1000000ULL))) +
                           conn->remote.transport_params.max_ack_delay) *
                          3;
      start_ts = ((rtb->persistent_congestion_start_ts) > (cstat->first_rtt_sample_ts) ? (rtb->persistent_congestion_start_ts) : (cstat->first_rtt_sample_ts));
      for (; !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                __null);)
      {
        ent = ngtcp2_ksl_it_get(&it);
        if (last_lost_pkt_num == ent->hd.pkt_num + 1 && ent->ts >= start_ts)
        {
          last_lost_pkt_num = ent->hd.pkt_num;
          oldest_ts = ent->ts;
        }
        else
        {
          last_lost_pkt_num = -1;
        }
        if ((ent->flags & NGTCP2_RTB_FLAG_LOST_RETRANSMITTED))
        {
          if (rtb->pktns_id != NGTCP2_PKTNS_ID_APP || last_lost_pkt_num == -1 ||
              latest_ts - oldest_ts >= congestion_period)
          {
            break;
          }
          (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0);
          continue;
        }
        if (ent->hd.pkt_num >= pktns->tx.ecn.start_pkt_num &&
            (ent->flags & NGTCP2_RTB_FLAG_ECN))
        {
          ++ecn_pkt_lost;
        }
        rtb_on_remove(rtb, ent, cstat);
        rv = rtb_on_pkt_lost(rtb, &it, ent, conn, pktns, ts);
        if (rv != 0)
        {
          return rv;
        }
      }
      switch (conn->tx.ecn.state)
      {
      case NGTCP2_ECN_STATE_TESTING:
        if (conn->tx.ecn.validation_start_ts ==
            (18446744073709551615UL))
        {
          break;
        }
        if (ts - conn->tx.ecn.validation_start_ts < 3 * pto)
        {
          pktns->tx.ecn.validation_pkt_lost += ecn_pkt_lost;

          (static_cast<bool>(
               pktns->tx.ecn.validation_pkt_sent >= pktns->tx.ecn.validation_pkt_lost)
               ? void(0)
               : __assert_fail(
                     "pktns->tx.ecn.validation_pkt_sent >= pktns->tx.ecn.validation_pkt_lost",
                     "all.cpp",
                     36747, __extension__ __PRETTY_FUNCTION__))

              ;
          break;
        }
        conn->tx.ecn.state = NGTCP2_ECN_STATE_UNKNOWN;
      case NGTCP2_ECN_STATE_UNKNOWN:
        pktns->tx.ecn.validation_pkt_lost += ecn_pkt_lost;

        (static_cast<bool>(
             pktns->tx.ecn.validation_pkt_sent >= pktns->tx.ecn.validation_pkt_lost)
             ? void(0)
             : __assert_fail(
                   "pktns->tx.ecn.validation_pkt_sent >= pktns->tx.ecn.validation_pkt_lost",
                   "all.cpp",
                   36754, __extension__ __PRETTY_FUNCTION__))

            ;
        if (conn_all_ecn_pkt_lost(conn))
        {
          conn->tx.ecn.state = NGTCP2_ECN_STATE_FAILED;
        }
        break;
      default:
        break;
      }
      cc->congestion_event(cc, cstat, latest_ts, ts);
      loss_window = latest_ts - oldest_ts;
      if (rtb->pktns_id == NGTCP2_PKTNS_ID_APP && loss_window > 0)
      {
        if (loss_window >= congestion_period)
        {
          ngtcp2_log_info(rtb->log, NGTCP2_LOG_EVENT_RCV,
                          "persistent congestion loss_window=%"
                          "l"
                          "u"

                          " congestion_period=%"
                          "l"
                          "u",
                          loss_window, congestion_period);
          cstat->min_rtt =
              (18446744073709551615UL);
          cstat->smoothed_rtt = conn->local.settings.initial_rtt;
          cstat->rttvar = conn->local.settings.initial_rtt / 2;
          cstat->first_rtt_sample_ts =
              (18446744073709551615UL);
          cc->on_persistent_congestion(cc, cstat, ts);
        }
      }
      break;
    }
  }
  ngtcp2_rtb_remove_excessive_lost_pkt(rtb, pkt_thres);
  return 0;
}
void ngtcp2_rtb_remove_excessive_lost_pkt(ngtcp2_rtb *rtb, size_t n)
{
  ngtcp2_ksl_it it = ngtcp2_ksl_end(&rtb->ents);
  ngtcp2_rtb_entry *ent;
  int rv;
  for (; rtb->num_lost_pkts > n;)
  {

    (static_cast<bool>(
         ((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                           __null))
         ? void(0)
         : __assert_fail(
               "ngtcp2_ksl_it_end(&it)", "all.cpp", 36794, __extension__ __PRETTY_FUNCTION__));
    ngtcp2_ksl_it_prev(&it);
    ent = ngtcp2_ksl_it_get(&it);

    (static_cast<bool>(
         ent->flags & NGTCP2_RTB_FLAG_LOST_RETRANSMITTED)
         ? void(0)
         : __assert_fail(
               "ent->flags & NGTCP2_RTB_FLAG_LOST_RETRANSMITTED", "all.cpp", 36797, __extension__ __PRETTY_FUNCTION__));
    ngtcp2_log_info(rtb->log, NGTCP2_LOG_EVENT_RCV,
                    "removing stale lost pkn=%"
                    "l"
                    "d",
                    ent->hd.pkt_num);
    --rtb->num_lost_pkts;
    rv = ngtcp2_ksl_remove(&rtb->ents, &it, &ent->hd.pkt_num);

    (static_cast<bool>(
         0 == rv)
         ? void(0)
         : __assert_fail(
               "0 == rv", "all.cpp", 36802, __extension__ __PRETTY_FUNCTION__));
    ngtcp2_rtb_entry_del(ent, rtb->mem);
  }
}
void ngtcp2_rtb_remove_expired_lost_pkt(ngtcp2_rtb *rtb, ngtcp2_duration pto,
                                        ngtcp2_tstamp ts)
{
  ngtcp2_ksl_it it;
  ngtcp2_rtb_entry *ent;
  int rv;
  if (ngtcp2_ksl_len(&rtb->ents) == 0)
  {
    return;
  }
  it = ngtcp2_ksl_end(&rtb->ents);
  for (;;)
  {

    (static_cast<bool>(
         ((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                           __null))
         ? void(0)
         : __assert_fail(
               "ngtcp2_ksl_it_end(&it)", "all.cpp", 36820, __extension__ __PRETTY_FUNCTION__));
    ngtcp2_ksl_it_prev(&it);
    ent = ngtcp2_ksl_it_get(&it);
    if (!(ent->flags & NGTCP2_RTB_FLAG_LOST_RETRANSMITTED) ||
        ts - ent->lost_ts < pto)
    {
      return;
    }
    ngtcp2_log_info(rtb->log, NGTCP2_LOG_EVENT_RCV,
                    "removing stale lost pkn=%"
                    "l"
                    "d",
                    ent->hd.pkt_num);
    --rtb->num_lost_pkts;
    rv = ngtcp2_ksl_remove(&rtb->ents, &it, &ent->hd.pkt_num);

    (static_cast<bool>(
         0 == rv)
         ? void(0)
         : __assert_fail(
               "0 == rv", "all.cpp", 36832, __extension__ __PRETTY_FUNCTION__));
    ngtcp2_rtb_entry_del(ent, rtb->mem);
    if (ngtcp2_ksl_len(&rtb->ents) == 0)
    {
      return;
    }
  }
}
ngtcp2_tstamp ngtcp2_rtb_lost_pkt_ts(ngtcp2_rtb *rtb)
{
  ngtcp2_ksl_it it;
  ngtcp2_rtb_entry *ent;
  if (ngtcp2_ksl_len(&rtb->ents) == 0)
  {
    return (18446744073709551615UL);
  }
  it = ngtcp2_ksl_end(&rtb->ents);
  ngtcp2_ksl_it_prev(&it);
  ent = ngtcp2_ksl_it_get(&it);
  if (!(ent->flags & NGTCP2_RTB_FLAG_LOST_RETRANSMITTED))
  {
    return (18446744073709551615UL);
  }
  return ent->lost_ts;
}
static int rtb_on_pkt_lost_resched_move(ngtcp2_rtb *rtb, ngtcp2_conn *conn,
                                        ngtcp2_pktns *pktns,
                                        ngtcp2_rtb_entry *ent)
{
  ngtcp2_frame_chain **pfrc, *frc;
  ngtcp2_stream *sfr;
  ngtcp2_strm *strm;
  int rv;
  ngtcp2_log_pkt_lost(rtb->log, ent->hd.pkt_num, ent->hd.type, ent->hd.flags,
                      ent->ts);
  if (rtb->qlog)
  {
    ngtcp2_qlog_pkt_lost(rtb->qlog, ent);
  }
  if (ent->flags & NGTCP2_RTB_FLAG_PROBE)
  {
    ngtcp2_log_info(rtb->log, NGTCP2_LOG_EVENT_RCV,
                    "pkn=%"
                    "l"
                    "d"

                    " is a probe packet, no retransmission is necessary",
                    ent->hd.pkt_num);
    return 0;
  }
  if (!ent->frc)
  {

    (static_cast<bool>(
         !(ent->flags & NGTCP2_RTB_FLAG_LOST_RETRANSMITTED))
         ? void(0)
         : __assert_fail(
               "!(ent->flags & NGTCP2_RTB_FLAG_LOST_RETRANSMITTED)", "all.cpp", 36883, __extension__ __PRETTY_FUNCTION__));

    (static_cast<bool>(
         !(ent->flags & NGTCP2_RTB_FLAG_PTO_RECLAIMED))
         ? void(0)
         : __assert_fail(
               "!(ent->flags & NGTCP2_RTB_FLAG_PTO_RECLAIMED)", "all.cpp", 36884, __extension__ __PRETTY_FUNCTION__));
    return 0;
  }
  if (ent->flags & NGTCP2_RTB_FLAG_LOST_RETRANSMITTED)
  {
    --rtb->num_lost_pkts;
  }
  if (ent->flags & NGTCP2_RTB_FLAG_LOST_RETRANSMITTED)
  {
    ngtcp2_log_info(rtb->log, NGTCP2_LOG_EVENT_RCV,
                    "pkn=%"
                    "l"
                    "d"

                    " was declared lost and has already been retransmitted",
                    ent->hd.pkt_num);
    return 0;
  }
  if (ent->flags & NGTCP2_RTB_FLAG_PTO_RECLAIMED)
  {
    ngtcp2_log_info(rtb->log, NGTCP2_LOG_EVENT_RCV,
                    "pkn=%"
                    "l"
                    "d"
                    " has already been reclaimed on PTO",
                    ent->hd.pkt_num);
    return 0;
  }
  pfrc = &ent->frc;
  for (; *pfrc;)
  {
    switch ((*pfrc)->fr.type)
    {
    case NGTCP2_FRAME_STREAM:
      frc = *pfrc;
      *pfrc = frc->next;
      frc->next =
          __null;
      sfr = &frc->fr.stream;
      strm = ngtcp2_conn_find_stream(conn, sfr->stream_id);
      if (!strm)
      {
        ngtcp2_frame_chain_del(frc, conn->mem);
        break;
      }
      rv = ngtcp2_strm_streamfrq_push(strm, frc);
      if (rv != 0)
      {
        ngtcp2_frame_chain_del(frc, conn->mem);
        return rv;
      }
      if (!ngtcp2_strm_is_tx_queued(strm))
      {
        strm->cycle = ngtcp2_conn_tx_strmq_first_cycle(conn);
        rv = ngtcp2_conn_tx_strmq_push(conn, strm);
        if (rv != 0)
        {
          return rv;
        }
      }
      break;
    case NGTCP2_FRAME_CRYPTO:
      frc = *pfrc;
      *pfrc = frc->next;
      frc->next =
          __null;
      rv = ngtcp2_ksl_insert(&pktns->crypto.tx.frq,
                             __null,
                             &frc->fr.crypto.offset, frc);
      if (rv != 0)
      {

        (static_cast<bool>(
             ngtcp2_err_is_fatal(rv))
             ? void(0)
             : __assert_fail(
                   "ngtcp2_err_is_fatal(rv)", "all.cpp", 36946, __extension__ __PRETTY_FUNCTION__));
        ngtcp2_frame_chain_del(frc, conn->mem);
        return rv;
      }
      break;
    default:
      pfrc = &(*pfrc)->next;
    }
  }
  *pfrc = pktns->tx.frq;
  pktns->tx.frq = ent->frc;
  ent->frc =
      __null;
  return 0;
}
int ngtcp2_rtb_remove_all(ngtcp2_rtb *rtb, ngtcp2_conn *conn,
                          ngtcp2_pktns *pktns, ngtcp2_conn_stat *cstat)
{
  ngtcp2_rtb_entry *ent;
  ngtcp2_ksl_it it;
  int rv;
  it = ngtcp2_ksl_begin(&rtb->ents);
  for (; !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                            __null);)
  {
    ent = ngtcp2_ksl_it_get(&it);
    rtb_on_remove(rtb, ent, cstat);
    rv = ngtcp2_ksl_remove(&rtb->ents, &it, &ent->hd.pkt_num);

    (static_cast<bool>(
         0 == rv)
         ? void(0)
         : __assert_fail(
               "0 == rv", "all.cpp", 36973, __extension__ __PRETTY_FUNCTION__));
    rv = rtb_on_pkt_lost_resched_move(rtb, conn, pktns, ent);
    ngtcp2_rtb_entry_del(ent, rtb->mem);
    if (rv != 0)
    {
      return rv;
    }
  }
  return 0;
}
int ngtcp2_rtb_empty(ngtcp2_rtb *rtb)
{
  return ngtcp2_ksl_len(&rtb->ents) == 0;
}
void ngtcp2_rtb_reset_cc_state(ngtcp2_rtb *rtb, int64_t cc_pkt_num)
{
  rtb->cc_pkt_num = cc_pkt_num;
  rtb->cc_bytes_in_flight = 0;
}
ngtcp2_ssize ngtcp2_rtb_reclaim_on_pto(ngtcp2_rtb *rtb, ngtcp2_conn *conn,
                                       ngtcp2_pktns *pktns, size_t num_pkts)
{
  ngtcp2_ksl_it it;
  ngtcp2_rtb_entry *ent;
  ngtcp2_ssize reclaimed;
  size_t atmost = num_pkts;
  it = ngtcp2_ksl_end(&rtb->ents);
  for (; !ngtcp2_ksl_it_begin(&it) && num_pkts >= 1;)
  {
    ngtcp2_ksl_it_prev(&it);
    ent = ngtcp2_ksl_it_get(&it);
    if ((ent->flags & (NGTCP2_RTB_FLAG_LOST_RETRANSMITTED |
                       NGTCP2_RTB_FLAG_PTO_RECLAIMED)) ||
        !(ent->flags & NGTCP2_RTB_FLAG_RETRANSMITTABLE))
    {
      continue;
    }

    (static_cast<bool>(
         ent->frc)
         ? void(0)
         : __assert_fail(
               "ent->frc", "all.cpp", 37013, __extension__ __PRETTY_FUNCTION__));
    reclaimed = rtb_reclaim_frame(rtb, conn, pktns, ent);
    if (reclaimed < 0)
    {
      return reclaimed;
    }
    ent->flags |= NGTCP2_RTB_FLAG_PTO_RECLAIMED;

    (static_cast<bool>(
         rtb->num_retransmittable)
         ? void(0)
         : __assert_fail(
               "rtb->num_retransmittable", "all.cpp", 37020, __extension__ __PRETTY_FUNCTION__));
    --rtb->num_retransmittable;
    if (reclaimed)
    {
      --num_pkts;
    }
  }
  return (ngtcp2_ssize)(atmost - num_pkts);
}
void *ngtcp2_cpymem(void *dest, const void *src, size_t n)
{
  memcpy(dest, src, n);
  return (uint8_t *)dest + n;
}
uint8_t *ngtcp2_setmem(uint8_t *dest, uint8_t b, size_t n)
{
  memset(dest, b, n);
  return dest + n;
}
uint8_t *ngtcp2_encode_hex(uint8_t *dest, const uint8_t *data, size_t len)
{
  size_t i;
  uint8_t *p = dest;
  for (i = 0; i < len; ++i)
  {
    *p++ = (uint8_t) "0123456789abcdef"[data[i] >> 4];
    *p++ = (uint8_t) "0123456789abcdef"[data[i] & 0xf];
  }
  *p = '\0';
  return dest;
}
char *ngtcp2_encode_printable_ascii(char *dest, const uint8_t *data,
                                    size_t len)
{
  size_t i;
  char *p = dest;
  uint8_t c;
  for (i = 0; i < len; ++i)
  {
    c = data[i];
    if (0x20 <= c && c <= 0x7e)
    {
      *p++ = (char)c;
    }
    else
    {
      *p++ = '.';
    }
  }
  *p = '\0';
  return dest;
}
static uint8_t *write_uint(uint8_t *p, uint64_t n)
{
  size_t nlen = 0;
  uint64_t t;
  uint8_t *res;
  if (n == 0)
  {
    *p++ = '0';
    return p;
  }
  for (t = n; t; t /= 10, ++nlen)
    ;
  p += nlen;
  res = p;
  for (; n; n /= 10)
  {
    *--p = (uint8_t)((n % 10) + '0');
  }
  return res;
}
uint8_t *ngtcp2_encode_ipv4(uint8_t *dest, const uint8_t *addr)
{
  size_t i;
  uint8_t *p = dest;
  p = write_uint(p, addr[0]);
  for (i = 1; i < 4; ++i)
  {
    *p++ = '.';
    p = write_uint(p, addr[i]);
  }
  *p = '\0';
  return dest;
}
static uint8_t *write_hex_zsup(uint8_t *dest, const uint8_t *data, size_t len)
{
  size_t i;
  uint8_t *p = dest;
  uint8_t d;
  for (i = 0; i < len; ++i)
  {
    d = data[i];
    if (d >> 4)
    {
      break;
    }
    d &= 0xf;
    if (d)
    {
      *p++ = (uint8_t) "0123456789abcdef"[d];
      ++i;
      break;
    }
  }
  if (p == dest && i == len)
  {
    *p++ = '0';
    return p;
  }
  for (; i < len; ++i)
  {
    d = data[i];
    *p++ = (uint8_t) "0123456789abcdef"[d >> 4];
    *p++ = (uint8_t) "0123456789abcdef"[d & 0xf];
  }
  return p;
}
uint8_t *ngtcp2_encode_ipv6(uint8_t *dest, const uint8_t *addr)
{
  uint16_t blks[8];
  size_t i;
  size_t zlen, zoff;
  size_t max_zlen = 0, max_zoff = 8;
  uint8_t *p = dest;
  for (i = 0; i < 16; i += sizeof(uint16_t))
  {
    memcpy(&blks[i / sizeof(uint16_t)], addr + i, sizeof(uint16_t));
  }
  for (i = 0; i < 8;)
  {
    if (blks[i])
    {
      ++i;
      continue;
    }
    zlen = 1;
    zoff = i;
    ++i;
    for (; i < 8 && blks[i] == 0; ++i, ++zlen)
      ;
    if (zlen > max_zlen)
    {
      max_zlen = zlen;
      max_zoff = zoff;
    }
  }
  if (max_zlen == 1)
  {
    max_zoff = 8;
  }
  if (max_zoff != 0)
  {
    p = write_hex_zsup(p, (const uint8_t *)blks, sizeof(uint16_t));
    for (i = 1; i < max_zoff; ++i)
    {
      *p++ = ':';
      p = write_hex_zsup(p, (const uint8_t *)(blks + i), sizeof(uint16_t));
    }
  }
  if (max_zoff != 8)
  {
    *p++ = ':';
    if (max_zoff + max_zlen == 8)
    {
      *p++ = ':';
    }
    else
    {
      for (i = max_zoff + max_zlen; i < 8; ++i)
      {
        *p++ = ':';
        p = write_hex_zsup(p, (const uint8_t *)(blks + i), sizeof(uint16_t));
      }
    }
  }
  *p = '\0';
  return dest;
}
int ngtcp2_verify_stateless_reset_token(const uint8_t *want,
                                        const uint8_t *got)
{
  return !ngtcp2_check_invalid_stateless_reset_token(got) &&
                 ngtcp2_cmemeq(want, got, 16)
             ? 0
             : NGTCP2_ERR_INVALID_ARGUMENT;
}
int ngtcp2_check_invalid_stateless_reset_token(const uint8_t *token)
{
  static uint8_t invalid_token[16] = {0};
  return 0 == memcmp(invalid_token, token, 16);
}
int ngtcp2_cmemeq(const uint8_t *a, const uint8_t *b, size_t n)
{
  size_t i;
  int rv = 0;
  for (i = 0; i < n; ++i)
  {
    rv |= a[i] ^ b[i];
  }
  return rv == 0;
}
static int offset_less(const ngtcp2_ksl_key *lhs, const ngtcp2_ksl_key *rhs)
{
  return *(int64_t *)lhs < *(int64_t *)rhs;
}
int ngtcp2_strm_init(ngtcp2_strm *strm, int64_t stream_id, uint32_t flags,
                     uint64_t max_rx_offset, uint64_t max_tx_offset,
                     void *stream_user_data, const ngtcp2_mem *mem)
{
  strm->cycle = 0;
  strm->tx.acked_offset =
      __null;
  strm->tx.cont_acked_offset = 0;
  strm->tx.streamfrq =
      __null;
  strm->tx.offset = 0;
  strm->tx.max_offset = max_tx_offset;
  strm->tx.last_max_stream_data_ts =
      (18446744073709551615UL);
  strm->rx.rob =
      __null;
  strm->rx.cont_offset = 0;
  strm->rx.last_offset = 0;
  strm->stream_id = stream_id;
  strm->flags = flags;
  strm->stream_user_data = stream_user_data;
  strm->rx.window = strm->rx.max_offset = strm->rx.unsent_max_offset =
      max_rx_offset;
  strm->me.key = (uint64_t)stream_id;
  strm->me.next =
      __null;
  strm->pe.index =
      (18446744073709551615UL);
  strm->mem = mem;
  strm->app_error_code = 0;
  return 0;
}
void ngtcp2_strm_free(ngtcp2_strm *strm)
{
  ngtcp2_ksl_it it;
  if (strm ==
      __null)
  {
    return;
  }
  if (strm->tx.streamfrq)
  {
    for (it = ngtcp2_ksl_begin(strm->tx.streamfrq); !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                                                       __null);
         (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
    {
      ngtcp2_frame_chain_del(ngtcp2_ksl_it_get(&it), strm->mem);
    }
    ngtcp2_ksl_free(strm->tx.streamfrq);
    ngtcp2_mem_free(strm->mem, strm->tx.streamfrq);
  }
  ngtcp2_rob_free(strm->rx.rob);
  ngtcp2_mem_free(strm->mem, strm->rx.rob);
  ngtcp2_gaptr_free(strm->tx.acked_offset);
  ngtcp2_mem_free(strm->mem, strm->tx.acked_offset);
}
static int strm_rob_init(ngtcp2_strm *strm)
{
  int rv;
  ngtcp2_rob *rob = ngtcp2_mem_malloc(strm->mem, sizeof(*rob));
  if (rob ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  rv = ngtcp2_rob_init(rob, 8 * 1024, strm->mem);
  if (rv != 0)
  {
    ngtcp2_mem_free(strm->mem, rob);
    return rv;
  }
  strm->rx.rob = rob;
  return 0;
}
uint64_t ngtcp2_strm_rx_offset(ngtcp2_strm *strm)
{
  if (strm->rx.rob ==
      __null)
  {
    return strm->rx.cont_offset;
  }
  return ngtcp2_rob_first_gap_offset(strm->rx.rob);
}
int ngtcp2_strm_recv_reordering(ngtcp2_strm *strm, const uint8_t *data,
                                size_t datalen, uint64_t offset)
{
  int rv;
  if (strm->rx.rob ==
      __null)
  {
    rv = strm_rob_init(strm);
    if (rv != 0)
    {
      return rv;
    }
    if (strm->rx.cont_offset)
    {
      rv = ngtcp2_rob_remove_prefix(strm->rx.rob, strm->rx.cont_offset);
      if (rv != 0)
      {
        return rv;
      }
    }
  }
  return ngtcp2_rob_push(strm->rx.rob, offset, data, datalen);
}
int ngtcp2_strm_update_rx_offset(ngtcp2_strm *strm, uint64_t offset)
{
  if (strm->rx.rob ==
      __null)
  {
    strm->rx.cont_offset = offset;
    return 0;
  }
  return ngtcp2_rob_remove_prefix(strm->rx.rob, offset);
}
void ngtcp2_strm_shutdown(ngtcp2_strm *strm, uint32_t flags)
{
  strm->flags |= flags & NGTCP2_STRM_FLAG_SHUT_RDWR;
}
static int strm_streamfrq_init(ngtcp2_strm *strm)
{
  int rv;
  ngtcp2_ksl *streamfrq = ngtcp2_mem_malloc(strm->mem, sizeof(*streamfrq));
  if (streamfrq ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  rv = ngtcp2_ksl_init(streamfrq, offset_less, sizeof(uint64_t), strm->mem);
  if (rv != 0)
  {
    ngtcp2_mem_free(strm->mem, streamfrq);
    return rv;
  }
  strm->tx.streamfrq = streamfrq;
  return 0;
}
int ngtcp2_strm_streamfrq_push(ngtcp2_strm *strm, ngtcp2_frame_chain *frc)
{
  int rv;

  (static_cast<bool>(
       frc->fr.type == NGTCP2_FRAME_STREAM)
       ? void(0)
       : __assert_fail(
             "frc->fr.type == NGTCP2_FRAME_STREAM", "all.cpp", 37382, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       frc->next ==
       __null)
       ? void(0)
       : __assert_fail(
             "frc->next == NULL", "all.cpp", 37383, __extension__ __PRETTY_FUNCTION__));
  if (strm->tx.streamfrq ==
      __null)
  {
    rv = strm_streamfrq_init(strm);
    if (rv != 0)
    {
      return rv;
    }
  }
  return ngtcp2_ksl_insert(strm->tx.streamfrq,
                           __null, &frc->fr.stream.offset,
                           frc);
}
static int strm_streamfrq_unacked_pop(ngtcp2_strm *strm,
                                      ngtcp2_frame_chain **pfrc)
{
  ngtcp2_frame_chain *frc, *nfrc;
  ngtcp2_stream *fr, *nfr;
  uint64_t offset, end_offset;
  size_t idx, end_idx;
  uint64_t base_offset, end_base_offset;
  ngtcp2_range gap;
  ngtcp2_vec *v;
  int rv;
  ngtcp2_ksl_it it;
  *pfrc =
      __null;

  (static_cast<bool>(
       strm->tx.streamfrq)
       ? void(0)
       : __assert_fail(
             "strm->tx.streamfrq", "all.cpp", 37409, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       ngtcp2_ksl_len(strm->tx.streamfrq))
       ? void(0)
       : __assert_fail(
             "ngtcp2_ksl_len(strm->tx.streamfrq)", "all.cpp", 37410, __extension__ __PRETTY_FUNCTION__));
  for (it = ngtcp2_ksl_begin(strm->tx.streamfrq); !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                                                     __null);)
  {
    frc = ngtcp2_ksl_it_get(&it);
    fr = &frc->fr.stream;
    ngtcp2_ksl_remove(strm->tx.streamfrq, &it, &fr->offset);
    idx = 0;
    offset = fr->offset;
    base_offset = 0;
    gap = ngtcp2_strm_get_unacked_range_after(strm, offset);
    if (gap.begin < offset)
    {
      gap.begin = offset;
    }
    for (; idx < fr->datacnt && offset < gap.begin; ++idx)
    {
      v = &fr->data[idx];
      if (offset + v->len > gap.begin)
      {
        base_offset = gap.begin - offset;
        break;
      }
      offset += v->len;
    }
    if (idx == fr->datacnt)
    {
      if (fr->fin)
      {
        if (strm->flags & NGTCP2_STRM_FLAG_FIN_ACKED)
        {
          ngtcp2_frame_chain_del(frc, strm->mem);

          (static_cast<bool>(
               ngtcp2_ksl_len(strm->tx.streamfrq) == 0)
               ? void(0)
               : __assert_fail(
                     "ngtcp2_ksl_len(strm->tx.streamfrq) == 0", "all.cpp", 37441, __extension__ __PRETTY_FUNCTION__));
          return 0;
        }
        fr->offset = fr->offset + ngtcp2_vec_len(fr->data, fr->datacnt);
        fr->datacnt = 0;
        *pfrc = frc;
        return 0;
      }
      ngtcp2_frame_chain_del(frc, strm->mem);
      continue;
    }

    (static_cast<bool>(
         gap.begin == offset + base_offset)
         ? void(0)
         : __assert_fail(
               "gap.begin == offset + base_offset", "all.cpp", 37452, __extension__ __PRETTY_FUNCTION__));
    end_idx = idx;
    end_offset = offset;
    end_base_offset = 0;
    for (; end_idx < fr->datacnt; ++end_idx)
    {
      v = &fr->data[end_idx];
      if (end_offset + v->len > gap.end)
      {
        end_base_offset = gap.end - end_offset;
        break;
      }
      end_offset += v->len;
    }
    if (fr->offset == offset && base_offset == 0 && fr->datacnt == end_idx)
    {
      *pfrc = frc;
      return 0;
    }
    if (fr->datacnt == end_idx)
    {
      memmove(fr->data, fr->data + idx, sizeof(fr->data[0]) * (end_idx - idx));

      (static_cast<bool>(
           fr->data[0].len > base_offset)
           ? void(0)
           : __assert_fail(
                 "fr->data[0].len > base_offset", "all.cpp", 37474, __extension__ __PRETTY_FUNCTION__));
      fr->offset = offset + base_offset;
      fr->datacnt = end_idx - idx;
      fr->data[0].base += base_offset;
      fr->data[0].len -= (size_t)base_offset;
      *pfrc = frc;
      return 0;
    }
    rv = ngtcp2_frame_chain_stream_datacnt_new(&nfrc, fr->datacnt - end_idx,
                                               strm->mem);
    if (rv != 0)
    {
      ngtcp2_frame_chain_del(frc, strm->mem);
      return rv;
    }
    nfr = &nfrc->fr.stream;
    memcpy(nfr->data, fr->data + end_idx,
           sizeof(nfr->data[0]) * (fr->datacnt - end_idx));

    (static_cast<bool>(
         nfr->data[0].len > end_base_offset)
         ? void(0)
         : __assert_fail(
               "nfr->data[0].len > end_base_offset", "all.cpp", 37492, __extension__ __PRETTY_FUNCTION__));
    nfr->type = NGTCP2_FRAME_STREAM;
    nfr->flags = 0;
    nfr->fin = fr->fin;
    nfr->stream_id = fr->stream_id;
    nfr->offset = end_offset + end_base_offset;
    nfr->datacnt = fr->datacnt - end_idx;
    nfr->data[0].base += end_base_offset;
    nfr->data[0].len -= (size_t)end_base_offset;
    rv = ngtcp2_ksl_insert(strm->tx.streamfrq,
                           __null, &nfr->offset, nfrc);
    if (rv != 0)
    {

      (static_cast<bool>(
           ngtcp2_err_is_fatal(rv))
           ? void(0)
           : __assert_fail(
                 "ngtcp2_err_is_fatal(rv)", "all.cpp", 37504, __extension__ __PRETTY_FUNCTION__));
      ngtcp2_frame_chain_del(nfrc, strm->mem);
      ngtcp2_frame_chain_del(frc, strm->mem);
      return rv;
    }
    if (end_base_offset)
    {
      ++end_idx;
    }
    memmove(fr->data, fr->data + idx, sizeof(fr->data[0]) * (end_idx - idx));

    (static_cast<bool>(
         fr->data[0].len > base_offset)
         ? void(0)
         : __assert_fail(
               "fr->data[0].len > base_offset", "all.cpp", 37514, __extension__ __PRETTY_FUNCTION__));
    fr->fin = 0;
    fr->offset = offset + base_offset;
    fr->datacnt = end_idx - idx;
    if (end_base_offset)
    {

      (static_cast<bool>(
           fr->data[fr->datacnt - 1].len > end_base_offset)
           ? void(0)
           : __assert_fail(
                 "fr->data[fr->datacnt - 1].len > end_base_offset", "all.cpp", 37520, __extension__ __PRETTY_FUNCTION__));
      fr->data[fr->datacnt - 1].len = (size_t)end_base_offset;
    }
    fr->data[0].base += base_offset;
    fr->data[0].len -= (size_t)base_offset;
    *pfrc = frc;
    return 0;
  }
  return 0;
}
int ngtcp2_strm_streamfrq_pop(ngtcp2_strm *strm, ngtcp2_frame_chain **pfrc,
                              size_t left)
{
  ngtcp2_stream *fr, *nfr;
  ngtcp2_frame_chain *frc, *nfrc;
  int rv;
  size_t nmerged;
  size_t datalen;
  ngtcp2_vec a[256];
  ngtcp2_vec b[256];
  size_t acnt, bcnt;
  uint64_t unacked_offset;
  if (strm->tx.streamfrq ==
          __null ||
      ngtcp2_ksl_len(strm->tx.streamfrq) == 0)
  {
    *pfrc =
        __null;
    return 0;
  }
  rv = strm_streamfrq_unacked_pop(strm, &frc);
  if (rv != 0)
  {
    return rv;
  }
  if (frc ==
      __null)
  {
    *pfrc =
        __null;
    return 0;
  }
  fr = &frc->fr.stream;
  datalen = ngtcp2_vec_len(fr->data, fr->datacnt);
  if (left == 0)
  {
    if (datalen || ngtcp2_ksl_len(strm->tx.streamfrq) > 1)
    {
      rv = ngtcp2_ksl_insert(strm->tx.streamfrq,
                             __null, &fr->offset, frc);
      if (rv != 0)
      {

        (static_cast<bool>(
             ngtcp2_err_is_fatal(rv))
             ? void(0)
             : __assert_fail(
                   "ngtcp2_err_is_fatal(rv)", "all.cpp", 37567, __extension__ __PRETTY_FUNCTION__));
        ngtcp2_frame_chain_del(frc, strm->mem);
        return rv;
      }
      *pfrc =
          __null;
      return 0;
    }
  }
  if (datalen > left)
  {
    ngtcp2_vec_copy(a, fr->data, fr->datacnt);
    acnt = fr->datacnt;
    bcnt = 0;
    ngtcp2_vec_split(a, &acnt, b, &bcnt, left, 256);

    (static_cast<bool>(
         acnt > 0)
         ? void(0)
         : __assert_fail(
               "acnt > 0", "all.cpp", 37581, __extension__ __PRETTY_FUNCTION__));

    (static_cast<bool>(
         bcnt > 0)
         ? void(0)
         : __assert_fail(
               "bcnt > 0", "all.cpp", 37582, __extension__ __PRETTY_FUNCTION__));
    rv = ngtcp2_frame_chain_stream_datacnt_new(&nfrc, bcnt, strm->mem);
    if (rv != 0)
    {

      (static_cast<bool>(
           ngtcp2_err_is_fatal(rv))
           ? void(0)
           : __assert_fail(
                 "ngtcp2_err_is_fatal(rv)", "all.cpp", 37586, __extension__ __PRETTY_FUNCTION__));
      ngtcp2_frame_chain_del(frc, strm->mem);
      return rv;
    }
    nfr = &nfrc->fr.stream;
    nfr->type = NGTCP2_FRAME_STREAM;
    nfr->flags = 0;
    nfr->fin = fr->fin;
    nfr->stream_id = fr->stream_id;
    nfr->offset = fr->offset + left;
    nfr->datacnt = bcnt;
    ngtcp2_vec_copy(nfr->data, b, bcnt);
    rv = ngtcp2_ksl_insert(strm->tx.streamfrq,
                           __null, &nfr->offset, nfrc);
    if (rv != 0)
    {

      (static_cast<bool>(
           ngtcp2_err_is_fatal(rv))
           ? void(0)
           : __assert_fail(
                 "ngtcp2_err_is_fatal(rv)", "all.cpp", 37601, __extension__ __PRETTY_FUNCTION__));
      ngtcp2_frame_chain_del(nfrc, strm->mem);
      ngtcp2_frame_chain_del(frc, strm->mem);
      return rv;
    }
    rv = ngtcp2_frame_chain_stream_datacnt_new(&nfrc, acnt, strm->mem);
    if (rv != 0)
    {

      (static_cast<bool>(
           ngtcp2_err_is_fatal(rv))
           ? void(0)
           : __assert_fail(
                 "ngtcp2_err_is_fatal(rv)", "all.cpp", 37609, __extension__ __PRETTY_FUNCTION__));
      ngtcp2_frame_chain_del(frc, strm->mem);
      return rv;
    }
    nfr = &nfrc->fr.stream;
    *nfr = *fr;
    nfr->fin = 0;
    nfr->datacnt = acnt;
    ngtcp2_vec_copy(nfr->data, a, acnt);
    ngtcp2_frame_chain_del(frc, strm->mem);
    *pfrc = nfrc;
    return 0;
  }
  left -= datalen;
  ngtcp2_vec_copy(a, fr->data, fr->datacnt);
  acnt = fr->datacnt;
  for (; left && ngtcp2_ksl_len(strm->tx.streamfrq);)
  {
    unacked_offset = ngtcp2_strm_streamfrq_unacked_offset(strm);
    if (unacked_offset != fr->offset + datalen)
    {

      (static_cast<bool>(
           fr->offset + datalen < unacked_offset)
           ? void(0)
           : __assert_fail(
                 "fr->offset + datalen < unacked_offset", "all.cpp", 37630, __extension__ __PRETTY_FUNCTION__));
      break;
    }
    rv = strm_streamfrq_unacked_pop(strm, &nfrc);
    if (rv != 0)
    {

      (static_cast<bool>(
           ngtcp2_err_is_fatal(rv))
           ? void(0)
           : __assert_fail(
                 "ngtcp2_err_is_fatal(rv)", "all.cpp", 37636, __extension__ __PRETTY_FUNCTION__));
      ngtcp2_frame_chain_del(frc, strm->mem);
      return rv;
    }
    if (nfrc ==
        __null)
    {
      break;
    }
    nfr = &nfrc->fr.stream;
    if (nfr->fin && nfr->datacnt == 0)
    {
      fr->fin = 1;
      ngtcp2_frame_chain_del(nfrc, strm->mem);
      break;
    }
    nmerged = ngtcp2_vec_merge(a, &acnt, nfr->data, &nfr->datacnt, left,
                               256);
    if (nmerged == 0)
    {
      rv = ngtcp2_ksl_insert(strm->tx.streamfrq,
                             __null, &nfr->offset, nfrc);
      if (rv != 0)
      {

        (static_cast<bool>(
             ngtcp2_err_is_fatal(rv))
             ? void(0)
             : __assert_fail(
                   "ngtcp2_err_is_fatal(rv)", "all.cpp", 37658, __extension__ __PRETTY_FUNCTION__));
        ngtcp2_frame_chain_del(nfrc, strm->mem);
        ngtcp2_frame_chain_del(frc, strm->mem);
        return rv;
      }
      break;
    }
    datalen += nmerged;
    left -= nmerged;
    if (nfr->datacnt == 0)
    {
      fr->fin = nfr->fin;
      ngtcp2_frame_chain_del(nfrc, strm->mem);
      continue;
    }
    nfr->offset += nmerged;
    rv = ngtcp2_ksl_insert(strm->tx.streamfrq,
                           __null, &nfr->offset, nfrc);
    if (rv != 0)
    {
      ngtcp2_frame_chain_del(nfrc, strm->mem);
      ngtcp2_frame_chain_del(frc, strm->mem);
      return rv;
    }
    break;
  }
  if (acnt == fr->datacnt)
  {
    if (acnt > 0)
    {
      fr->data[acnt - 1] = a[acnt - 1];
    }
    *pfrc = frc;
    return 0;
  }

  (static_cast<bool>(
       acnt > fr->datacnt)
       ? void(0)
       : __assert_fail(
             "acnt > fr->datacnt", "all.cpp", 37692, __extension__ __PRETTY_FUNCTION__));
  rv = ngtcp2_frame_chain_stream_datacnt_new(&nfrc, acnt, strm->mem);
  if (rv != 0)
  {
    ngtcp2_frame_chain_del(frc, strm->mem);
    return rv;
  }
  nfr = &nfrc->fr.stream;
  *nfr = *fr;
  nfr->datacnt = acnt;
  ngtcp2_vec_copy(nfr->data, a, acnt);
  ngtcp2_frame_chain_del(frc, strm->mem);
  *pfrc = nfrc;
  return 0;
}
uint64_t ngtcp2_strm_streamfrq_unacked_offset(ngtcp2_strm *strm)
{
  ngtcp2_frame_chain *frc;
  ngtcp2_stream *fr;
  ngtcp2_range gap;
  ngtcp2_ksl_it it;
  size_t datalen;

  (static_cast<bool>(
       strm->tx.streamfrq)
       ? void(0)
       : __assert_fail(
             "strm->tx.streamfrq", "all.cpp", 37715, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       ngtcp2_ksl_len(strm->tx.streamfrq))
       ? void(0)
       : __assert_fail(
             "ngtcp2_ksl_len(strm->tx.streamfrq)", "all.cpp", 37716, __extension__ __PRETTY_FUNCTION__));
  for (it = ngtcp2_ksl_begin(strm->tx.streamfrq); !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                                                     __null);
       (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
  {
    frc = ngtcp2_ksl_it_get(&it);
    fr = &frc->fr.stream;
    gap = ngtcp2_strm_get_unacked_range_after(strm, fr->offset);
    datalen = ngtcp2_vec_len(fr->data, fr->datacnt);
    if (gap.begin <= fr->offset)
    {
      return fr->offset;
    }
    if (gap.begin < fr->offset + datalen)
    {
      return gap.begin;
    }
    if (fr->offset + datalen == gap.begin && fr->fin &&
        !(strm->flags & NGTCP2_STRM_FLAG_FIN_ACKED))
    {
      return fr->offset + datalen;
    }
  }
  return (uint64_t)-1;
}
ngtcp2_frame_chain *ngtcp2_strm_streamfrq_top(ngtcp2_strm *strm)
{
  ngtcp2_ksl_it it;

  (static_cast<bool>(
       strm->tx.streamfrq)
       ? void(0)
       : __assert_fail(
             "strm->tx.streamfrq", "all.cpp", 37744, __extension__ __PRETTY_FUNCTION__));

  (static_cast<bool>(
       ngtcp2_ksl_len(strm->tx.streamfrq))
       ? void(0)
       : __assert_fail(
             "ngtcp2_ksl_len(strm->tx.streamfrq)", "all.cpp", 37745, __extension__ __PRETTY_FUNCTION__));
  it = ngtcp2_ksl_begin(strm->tx.streamfrq);
  return ngtcp2_ksl_it_get(&it);
}
int ngtcp2_strm_streamfrq_empty(ngtcp2_strm *strm)
{
  return strm->tx.streamfrq ==
             __null ||
         ngtcp2_ksl_len(strm->tx.streamfrq) == 0;
}
void ngtcp2_strm_streamfrq_clear(ngtcp2_strm *strm)
{
  ngtcp2_frame_chain *frc;
  ngtcp2_ksl_it it;
  if (strm->tx.streamfrq ==
      __null)
  {
    return;
  }
  for (it = ngtcp2_ksl_begin(strm->tx.streamfrq); !((&it)->blk->n == (&it)->i && (&it)->blk->next ==
                                                                                     __null);
       (++(&it)->i == (&it)->blk->n && (&it)->blk->next ? ((&it)->blk = (&it)->blk->next, (&it)->i = 0) : 0))
  {
    frc = ngtcp2_ksl_it_get(&it);
    ngtcp2_frame_chain_del(frc, strm->mem);
  }
  ngtcp2_ksl_clear(strm->tx.streamfrq);
}
int ngtcp2_strm_is_tx_queued(ngtcp2_strm *strm)
{
  return strm->pe.index !=
         (18446744073709551615UL);
}
int ngtcp2_strm_is_all_tx_data_acked(ngtcp2_strm *strm)
{
  if (strm->tx.acked_offset ==
      __null)
  {
    return strm->tx.cont_acked_offset == strm->tx.offset;
  }
  return ngtcp2_gaptr_first_gap_offset(strm->tx.acked_offset) ==
         strm->tx.offset;
}
ngtcp2_range ngtcp2_strm_get_unacked_range_after(ngtcp2_strm *strm,
                                                 uint64_t offset)
{
  ngtcp2_ksl_it gapit;
  ngtcp2_range gap;
  if (strm->tx.acked_offset ==
      __null)
  {
    gap.begin = strm->tx.cont_acked_offset;
    gap.end =
        (18446744073709551615UL);
    return gap;
  }
  gapit = ngtcp2_gaptr_get_first_gap_after(strm->tx.acked_offset, offset);
  return *(ngtcp2_range *)((ngtcp2_ksl_key *)((ngtcp2_ksl_node *)(void *)(((&gapit)->blk)->nodes + ((&gapit)->ksl)->nodelen * ((&gapit)->i)))->key);
}
uint64_t ngtcp2_strm_get_acked_offset(ngtcp2_strm *strm)
{
  if (strm->tx.acked_offset ==
      __null)
  {
    return strm->tx.cont_acked_offset;
  }
  return ngtcp2_gaptr_first_gap_offset(strm->tx.acked_offset);
}
static int strm_acked_offset_init(ngtcp2_strm *strm)
{
  int rv;
  ngtcp2_gaptr *acked_offset =
      ngtcp2_mem_malloc(strm->mem, sizeof(*acked_offset));
  if (acked_offset ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  rv = ngtcp2_gaptr_init(acked_offset, strm->mem);
  if (rv != 0)
  {
    ngtcp2_mem_free(strm->mem, acked_offset);
    return rv;
  }
  strm->tx.acked_offset = acked_offset;
  return 0;
}
int ngtcp2_strm_ack_data(ngtcp2_strm *strm, uint64_t offset, uint64_t len)
{
  int rv;
  if (strm->tx.acked_offset ==
      __null)
  {
    if (strm->tx.cont_acked_offset == offset)
    {
      strm->tx.cont_acked_offset += len;
      return 0;
    }
    rv = strm_acked_offset_init(strm);
    if (rv != 0)
    {
      return rv;
    }
    rv =
        ngtcp2_gaptr_push(strm->tx.acked_offset, 0, strm->tx.cont_acked_offset);
    if (rv != 0)
    {
      return rv;
    }
  }
  return ngtcp2_gaptr_push(strm->tx.acked_offset, offset, len);
}
ngtcp2_vec *ngtcp2_vec_init(ngtcp2_vec *vec, const uint8_t *base, size_t len)
{
  vec->base = (uint8_t *)base;
  vec->len = len;
  return vec;
}
int ngtcp2_vec_new(ngtcp2_vec **pvec, const uint8_t *data, size_t datalen,
                   const ngtcp2_mem *mem)
{
  size_t len;
  uint8_t *p;
  len = sizeof(ngtcp2_vec) + datalen;
  *pvec = ngtcp2_mem_malloc(mem, len);
  if (*pvec ==
      __null)
  {
    return NGTCP2_ERR_NOMEM;
  }
  p = (uint8_t *)(*pvec) + sizeof(ngtcp2_vec);
  (*pvec)->base = p;
  (*pvec)->len = datalen;
  if (datalen)
  {
    ngtcp2_cpymem(p, data, datalen);
  }
  return 0;
}
void ngtcp2_vec_del(ngtcp2_vec *vec, const ngtcp2_mem *mem)
{
  ngtcp2_mem_free(mem, vec);
}
size_t ngtcp2_vec_len(const ngtcp2_vec *vec, size_t n)
{
  size_t i;
  size_t res = 0;
  for (i = 0; i < n; ++i)
  {
    res += vec[i].len;
  }
  return res;
}
ngtcp2_ssize ngtcp2_vec_split(ngtcp2_vec *src, size_t *psrccnt, ngtcp2_vec *dst,
                              size_t *pdstcnt, size_t left, size_t maxcnt)
{
  size_t i;
  size_t srccnt = *psrccnt;
  size_t nmove;
  size_t extra = 0;
  for (i = 0; i < srccnt; ++i)
  {
    if (left >= src[i].len)
    {
      left -= src[i].len;
      continue;
    }
    if (*pdstcnt && src[srccnt - 1].base + src[srccnt - 1].len == dst[0].base)
    {
      if (*pdstcnt + srccnt - i - 1 > maxcnt)
      {
        return -1;
      }
      dst[0].len += src[srccnt - 1].len;
      dst[0].base = src[srccnt - 1].base;
      extra = src[srccnt - 1].len;
      --srccnt;
    }
    else if (*pdstcnt + srccnt - i > maxcnt)
    {
      return -1;
    }
    if (left == 0)
    {
      *psrccnt = i;
    }
    else
    {
      *psrccnt = i + 1;
    }
    nmove = srccnt - i;
    if (nmove)
    {
      memmove(dst + nmove, dst, sizeof(ngtcp2_vec) * (*pdstcnt));
      *pdstcnt += nmove;
      memcpy(dst, src + i, sizeof(ngtcp2_vec) * nmove);
    }
    dst[0].len -= left;
    dst[0].base += left;
    src[i].len = left;
    if (nmove == 0)
    {
      extra -= left;
    }
    return (ngtcp2_ssize)(ngtcp2_vec_len(dst, nmove) + extra);
  }
  return 0;
}
size_t ngtcp2_vec_merge(ngtcp2_vec *dst, size_t *pdstcnt, ngtcp2_vec *src,
                        size_t *psrccnt, size_t left, size_t maxcnt)
{
  size_t orig_left = left;
  size_t i;
  ngtcp2_vec *a, *b;

  (static_cast<bool>(
       maxcnt)
       ? void(0)
       : __assert_fail(
             "maxcnt", "all.cpp", 37965, __extension__ __PRETTY_FUNCTION__));
  if (*pdstcnt == 0)
  {
    if (*psrccnt == 0)
    {
      return 0;
    }
    a = &dst[0];
    b = &src[0];
    if (left >= b->len)
    {
      *a = *b;
      ++*pdstcnt;
      left -= b->len;
      i = 1;
    }
    else
    {
      a->len = left;
      a->base = b->base;
      b->len -= left;
      b->base += left;
      return left;
    }
  }
  else
  {
    i = 0;
  }
  for (; left && i < *psrccnt; ++i)
  {
    a = &dst[*pdstcnt - 1];
    b = &src[i];
    if (left >= b->len)
    {
      if (a->base + a->len == b->base)
      {
        a->len += b->len;
      }
      else if (*pdstcnt == maxcnt)
      {
        break;
      }
      else
      {
        dst[(*pdstcnt)++] = *b;
      }
      left -= b->len;
      continue;
    }
    if (a->base + a->len == b->base)
    {
      a->len += left;
    }
    else if (*pdstcnt == maxcnt)
    {
      break;
    }
    else
    {
      dst[*pdstcnt].len = left;
      dst[*pdstcnt].base = b->base;
      ++*pdstcnt;
    }
    b->len -= left;
    b->base += left;
    left = 0;
    break;
  }
  memmove(src, src + i, sizeof(ngtcp2_vec) * (*psrccnt - i));
  *psrccnt -= i;
  return orig_left - left;
}
size_t ngtcp2_vec_copy_at_most(ngtcp2_vec *dst, size_t *pnwritten,
                               size_t dstcnt, const ngtcp2_vec *src,
                               size_t srccnt, size_t left)
{
  size_t i, j;
  size_t len = left;
  *pnwritten = 0;
  for (i = 0, j = 0; left > 0 && i < srccnt && j < dstcnt;)
  {
    if (src[i].len == 0)
    {
      ++i;
      continue;
    }
    dst[j] = src[i];
    if (dst[j].len > left)
    {
      dst[j].len = left;
      *pnwritten = len;
      return j + 1;
    }
    left -= dst[j].len;
    ++i;
    ++j;
  }
  *pnwritten = len - left;
  return j;
}
void ngtcp2_vec_copy(ngtcp2_vec *dst, const ngtcp2_vec *src, size_t cnt)
{
  memcpy(dst, src, sizeof(ngtcp2_vec) * cnt);
}
ngtcp2_info *ngtcp2_version(int least_version)
{
  if (least_version > 0x000100)
  {
    return __null;
  }
  return (ngtcp2_info *)&version;
}
static const char data[] =
    "POST /joyent/http-parser HTTP/1.1\r\n"
    "Host: github.com\r\n"
    "DNT: 1\r\n"
    "Accept-Encoding: gzip, deflate, sdch\r\n"
    "Accept-Language: ru-RU,ru;q=0.8,en-US;q=0.6,en;q=0.4\r\n"
    "User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_10_1) "
    "AppleWebKit/537.36 (KHTML, like Gecko) "
    "Chrome/39.0.2171.65 Safari/537.36\r\n"
    "Accept: text/html,application/xhtml+xml,application/xml;q=0.9,"
    "image/webp,*/*;q=0.8\r\n"
    "Referer: https://github.com/joyent/http-parser\r\n"
    "Connection: keep-alive\r\n"
    "Transfer-Encoding: chunked\r\n"
    "Cache-Control: max-age=0\r\n\r\nb\r\nhello world\r\n0\r\n\r\n";
static const size_t data_len = sizeof(data) - 1;
static int on_info(http_parser *p)
{
  return 0;
}
static int on_data(http_parser *p, const char *at, size_t length)
{
  return 0;
}
extern "C"
{
  static http_parser_settings settings = {
      .on_message_begin = on_info,
      .on_url = on_data,
      .on_status = on_data,
      .on_header_field = on_data,
      .on_header_value = on_data,
      .on_headers_complete = on_info,
      .on_body = on_data,
      .on_message_complete = on_info};
}
static const char *method_strings[] =
    {
        "DELETE",
        "GET",
        "HEAD",
        "POST",
        "PUT",
        "CONNECT",
        "OPTIONS",
        "TRACE",
        "COPY",
        "LOCK",
        "MKCOL",
        "MOVE",
        "PROPFIND",
        "PROPPATCH",
        "SEARCH",
        "UNLOCK",
        "BIND",
        "REBIND",
        "UNBIND",
        "ACL",
        "REPORT",
        "MKACTIVITY",
        "CHECKOUT",
        "MERGE",
        "M-SEARCH",
        "NOTIFY",
        "SUBSCRIBE",
        "UNSUBSCRIBE",
        "PATCH",
        "PURGE",
        "MKCALENDAR",
        "LINK",
        "UNLINK",
};
static const char tokens[256] = {
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, 0, 0, 0, 0, 0, 0, 0,
    0, '!', 0, '#', '$', '%', '&', '\'',
    0, 0, '*', '+', 0, '-', '.', 0,
    '0', '1', '2', '3', '4', '5', '6', '7',
    '8', '9', 0, 0, 0, 0, 0, 0,
    0, 'a', 'b', 'c', 'd', 'e', 'f', 'g',
    'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w',
    'x', 'y', 'z', 0, 0, 0, '^', '_',
    '`', 'a', 'b', 'c', 'd', 'e', 'f', 'g',
    'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o',
    'p', 'q', 'r', 's', 't', 'u', 'v', 'w',
    'x', 'y', 'z', 0, '|', 0, '~', 0};
static const int8_t unhex[256] =
    {-1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, 10, 11, 12, 13, 14, 15, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1};
static const uint8_t normal_url_char[32] = {
    0 | 0 | 0 | 0 | 0 | 0 | 0 | 0,
    0 | 0 | 0 | 0 | 0 | 0 | 0 | 0,
    0 | 0 | 0 | 0 | 0 | 0 | 0 | 0,
    0 | 0 | 0 | 0 | 0 | 0 | 0 | 0,
    0 | 2 | 4 | 0 | 16 | 32 | 64 | 128,
    1 | 2 | 4 | 8 | 16 | 32 | 64 | 128,
    1 | 2 | 4 | 8 | 16 | 32 | 64 | 128,
    1 | 2 | 4 | 8 | 16 | 32 | 64 | 0,
    1 | 2 | 4 | 8 | 16 | 32 | 64 | 128,
    1 | 2 | 4 | 8 | 16 | 32 | 64 | 128,
    1 | 2 | 4 | 8 | 16 | 32 | 64 | 128,
    1 | 2 | 4 | 8 | 16 | 32 | 64 | 128,
    1 | 2 | 4 | 8 | 16 | 32 | 64 | 128,
    1 | 2 | 4 | 8 | 16 | 32 | 64 | 128,
    1 | 2 | 4 | 8 | 16 | 32 | 64 | 128,
    1 | 2 | 4 | 8 | 16 | 32 | 64 | 0,
};
enum state
{
  s_dead = 1,
  s_start_req_or_res,
  s_res_or_resp_H,
  s_start_res,
  s_res_H,
  s_res_HT,
  s_res_HTT,
  s_res_HTTP,
  s_res_http_major,
  s_res_http_dot,
  s_res_http_minor,
  s_res_http_end,
  s_res_first_status_code,
  s_res_status_code,
  s_res_status_start,
  s_res_status,
  s_res_line_almost_done,
  s_start_req,
  s_req_method,
  s_req_spaces_before_url,
  s_req_schema,
  s_req_schema_slash,
  s_req_schema_slash_slash,
  s_req_server_start,
  s_req_server,
  s_req_server_with_at,
  s_req_path,
  s_req_query_string_start,
  s_req_query_string,
  s_req_fragment_start,
  s_req_fragment,
  s_req_http_start,
  s_req_http_H,
  s_req_http_HT,
  s_req_http_HTT,
  s_req_http_HTTP,
  s_req_http_major,
  s_req_http_dot,
  s_req_http_minor,
  s_req_http_end,
  s_req_line_almost_done,
  s_header_field_start,
  s_header_field,
  s_header_value_discard_ws,
  s_header_value_discard_ws_almost_done,
  s_header_value_discard_lws,
  s_header_value_start,
  s_header_value,
  s_header_value_lws,
  s_header_almost_done,
  s_chunk_size_start,
  s_chunk_size,
  s_chunk_parameters,
  s_chunk_size_almost_done,
  s_headers_almost_done,
  s_headers_done,
  s_chunk_data,
  s_chunk_data_almost_done,
  s_chunk_data_done,
  s_body_identity,
  s_body_identity_eof,
  s_message_done
};
enum header_states
{
  h_general = 0,
  h_C,
  h_CO,
  h_CON,
  h_matching_connection,
  h_matching_proxy_connection,
  h_matching_content_length,
  h_matching_transfer_encoding,
  h_matching_upgrade,
  h_connection,
  h_content_length,
  h_transfer_encoding,
  h_upgrade,
  h_matching_transfer_encoding_chunked,
  h_matching_connection_token_start,
  h_matching_connection_keep_alive,
  h_matching_connection_close,
  h_matching_connection_upgrade,
  h_matching_connection_token,
  h_transfer_encoding_chunked,
  h_connection_keep_alive,
  h_connection_close,
  h_connection_upgrade
};
enum http_host_state
{
  s_http_host_dead = 1,
  s_http_userinfo_start,
  s_http_userinfo,
  s_http_host_start,
  s_http_host_v6_start,
  s_http_host,
  s_http_host_v6,
  s_http_host_v6_end,
  s_http_host_v6_zone_start,
  s_http_host_v6_zone,
  s_http_host_port_start,
  s_http_host_port
};
static struct
{
  const char *name;
  const char *description;
} http_strerror_tab[] = {
    {"HPE_"
     "OK",
     "success"},
    {"HPE_"
     "CB_message_begin",
     "the on_message_begin callback failed"},
    {"HPE_"
     "CB_url",
     "the on_url callback failed"},
    {"HPE_"
     "CB_header_field",
     "the on_header_field callback failed"},
    {"HPE_"
     "CB_header_value",
     "the on_header_value callback failed"},
    {"HPE_"
     "CB_headers_complete",
     "the on_headers_complete callback failed"},
    {"HPE_"
     "CB_body",
     "the on_body callback failed"},
    {"HPE_"
     "CB_message_complete",
     "the on_message_complete callback failed"},
    {"HPE_"
     "CB_status",
     "the on_status callback failed"},
    {"HPE_"
     "CB_chunk_header",
     "the on_chunk_header callback failed"},
    {"HPE_"
     "CB_chunk_complete",
     "the on_chunk_complete callback failed"},
    {"HPE_"
     "INVALID_EOF_STATE",
     "stream ended at an unexpected time"},
    {"HPE_"
     "HEADER_OVERFLOW",
     "too many header bytes seen; overflow detected"},
    {"HPE_"
     "CLOSED_CONNECTION",
     "data received after completed connection: close message"},
    {"HPE_"
     "INVALID_VERSION",
     "invalid HTTP version"},
    {"HPE_"
     "INVALID_STATUS",
     "invalid HTTP status code"},
    {"HPE_"
     "INVALID_METHOD",
     "invalid HTTP method"},
    {"HPE_"
     "INVALID_URL",
     "invalid URL"},
    {"HPE_"
     "INVALID_HOST",
     "invalid host"},
    {"HPE_"
     "INVALID_PORT",
     "invalid port"},
    {"HPE_"
     "INVALID_PATH",
     "invalid path"},
    {"HPE_"
     "INVALID_QUERY_STRING",
     "invalid query string"},
    {"HPE_"
     "INVALID_FRAGMENT",
     "invalid fragment"},
    {"HPE_"
     "LF_EXPECTED",
     "LF character expected"},
    {"HPE_"
     "INVALID_HEADER_TOKEN",
     "invalid character in header"},
    {"HPE_"
     "INVALID_CONTENT_LENGTH",
     "invalid character in content-length header"},
    {"HPE_"
     "UNEXPECTED_CONTENT_LENGTH",
     "unexpected content-length header"},
    {"HPE_"
     "INVALID_CHUNK_SIZE",
     "invalid character in chunk size header"},
    {"HPE_"
     "INVALID_CONSTANT",
     "invalid constant string"},
    {"HPE_"
     "INVALID_INTERNAL_STATE",
     "encountered unexpected internal state"},
    {"HPE_"
     "STRICT",
     "strict mode assertion failed"},
    {"HPE_"
     "PAUSED",
     "parser is paused"},
    {"HPE_"
     "UNKNOWN",
     "an unknown error occurred"},
};
int http_message_needs_eof(const http_parser *parser);
static enum state
parse_url_char(enum state s, const char ch)
{
  if (ch == ' ' || ch == '\r' || ch == '\n')
  {
    return s_dead;
  }
  if (ch == '\t' || ch == '\f')
  {
    return s_dead;
  }
  switch (s)
  {
  case s_req_spaces_before_url:
    if (ch == '/' || ch == '*')
    {
      return s_req_path;
    }
    if (((unsigned char)(ch | 0x20) >= 'a' && (unsigned char)(ch | 0x20) <= 'z'))
    {
      return s_req_schema;
    }
    break;
  case s_req_schema:
    if (((unsigned char)(ch | 0x20) >= 'a' && (unsigned char)(ch | 0x20) <= 'z'))
    {
      return s;
    }
    if (ch == ':')
    {
      return s_req_schema_slash;
    }
    break;
  case s_req_schema_slash:
    if (ch == '/')
    {
      return s_req_schema_slash_slash;
    }
    break;
  case s_req_schema_slash_slash:
    if (ch == '/')
    {
      return s_req_server_start;
    }
    break;
  case s_req_server_with_at:
    if (ch == '@')
    {
      return s_dead;
    }
  case s_req_server_start:
  case s_req_server:
    if (ch == '/')
    {
      return s_req_path;
    }
    if (ch == '?')
    {
      return s_req_query_string_start;
    }
    if (ch == '@')
    {
      return s_req_server_with_at;
    }
    if (((((unsigned char)(ch | 0x20) >= 'a' && (unsigned char)(ch | 0x20) <= 'z') || ((ch) >= '0' && (ch) <= '9')) || ((ch) == '-' || (ch) == '_' || (ch) == '.' || (ch) == '!' || (ch) == '~' || (ch) == '*' || (ch) == '\'' || (ch) == '(' || (ch) == ')') || (ch) == '%' || (ch) == ';' || (ch) == ':' || (ch) == '&' || (ch) == '=' || (ch) == '+' || (ch) == '$' || (ch) == ',') || ch == '[' || ch == ']')
    {
      return s_req_server;
    }
    break;
  case s_req_path:
    if (((!!((unsigned int)(normal_url_char)[(unsigned int)((unsigned char)ch) >> 3] & (1 << ((unsigned int)((unsigned char)ch) & 7))))))
    {
      return s;
    }
    switch (ch)
    {
    case '?':
      return s_req_query_string_start;
    case '#':
      return s_req_fragment_start;
    }
    break;
  case s_req_query_string_start:
  case s_req_query_string:
    if (((!!((unsigned int)(normal_url_char)[(unsigned int)((unsigned char)ch) >> 3] & (1 << ((unsigned int)((unsigned char)ch) & 7))))))
    {
      return s_req_query_string;
    }
    switch (ch)
    {
    case '?':
      return s_req_query_string;
    case '#':
      return s_req_fragment_start;
    }
    break;
  case s_req_fragment_start:
    if (((!!((unsigned int)(normal_url_char)[(unsigned int)((unsigned char)ch) >> 3] & (1 << ((unsigned int)((unsigned char)ch) & 7))))))
    {
      return s_req_fragment;
    }
    switch (ch)
    {
    case '?':
      return s_req_fragment;
    case '#':
      return s;
    }
    break;
  case s_req_fragment:
    if (((!!((unsigned int)(normal_url_char)[(unsigned int)((unsigned char)ch) >> 3] & (1 << ((unsigned int)((unsigned char)ch) & 7))))))
    {
      return s;
    }
    switch (ch)
    {
    case '?':
    case '#':
      return s;
    }
    break;
  default:
    break;
  }
  return s_dead;
}
size_t http_parser_execute(http_parser *parser,
                           const http_parser_settings *settings,
                           const char *data,
                           size_t len)
{
  char c, ch;
  int8_t unhex_val;
  const char *p = data;
  const char *header_field_mark = 0;
  const char *header_value_mark = 0;
  const char *url_mark = 0;
  const char *body_mark = 0;
  const char *status_mark = 0;
  enum state p_state = (enum state)parser->state;
  const unsigned int lenient = parser->lenient_http_headers;
  if (((enum http_errno)(parser)->http_errno) != HPE_OK)
  {
    return 0;
  }
  if (len == 0)
  {
    switch (p_state)
    {
    case s_body_identity_eof:
      do
      {
        (static_cast<bool>(
             ((enum http_errno)(parser)->http_errno) == HPE_OK)
             ? void(0)
             : __assert_fail(
                   "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 38621, __extension__ __PRETTY_FUNCTION__));
        if (__builtin_expect(!!(settings->on_message_complete), 1))
        {
          parser->state = p_state;
          if (__builtin_expect(!!(0 != settings->on_message_complete(parser)), 0))
          {
            do
            {
              parser->http_errno = (HPE_CB_message_complete);
            } while (0);
          }
          p_state = (enum state)(parser->state);
          ;
          if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
          {
            return (p - data);
          }
        }
      } while (0);
      return 0;
    case s_dead:
    case s_start_req_or_res:
    case s_start_res:
    case s_start_req:
      return 0;
    default:
      do
      {
        parser->http_errno = (HPE_INVALID_EOF_STATE);
      } while (0);
      return 1;
    }
  }
  if (p_state == s_header_field)
    header_field_mark = data;
  if (p_state == s_header_value)
    header_value_mark = data;
  switch (p_state)
  {
  case s_req_path:
  case s_req_schema:
  case s_req_schema_slash:
  case s_req_schema_slash_slash:
  case s_req_server_start:
  case s_req_server:
  case s_req_server_with_at:
  case s_req_query_string_start:
  case s_req_query_string:
  case s_req_fragment_start:
  case s_req_fragment:
    url_mark = data;
    break;
  case s_res_status:
    status_mark = data;
    break;
  default:
    break;
  }
  for (p = data; p != data + len; p++)
  {
    ch = *p;
    if ((p_state <= s_headers_done))
      do
      {
        parser->nread += (1);
        if (__builtin_expect(!!(parser->nread > ((80 * 1024))), 0))
        {
          do
          {
            parser->http_errno = (HPE_HEADER_OVERFLOW);
          } while (0);
          goto error;
        }
      } while (0);
  reexecute:
    switch (p_state)
    {
    case s_dead:
      if (__builtin_expect(!!(ch == '\r' || ch == '\n'), 1))
        break;
      do
      {
        parser->http_errno = (HPE_CLOSED_CONNECTION);
      } while (0);
      goto error;
    case s_start_req_or_res:
    {
      if (ch == '\r' || ch == '\n')
        break;
      parser->flags = 0;
      parser->content_length =
          (0x7fffffffffffffffLL * 2ULL + 1);
      if (ch == 'H')
      {
        p_state = (enum state)(s_res_or_resp_H);
        ;
        do
        {
          (static_cast<bool>(
               ((enum http_errno)(parser)->http_errno) == HPE_OK)
               ? void(0)
               : __assert_fail(
                     "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 38680, __extension__ __PRETTY_FUNCTION__));
          if (__builtin_expect(!!(settings->on_message_begin), 1))
          {
            parser->state = p_state;
            if (__builtin_expect(!!(0 != settings->on_message_begin(parser)), 0))
            {
              do
              {
                parser->http_errno = (HPE_CB_message_begin);
              } while (0);
            }
            p_state = (enum state)(parser->state);
            ;
            if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
            {
              return (p - data + 1);
            }
          }
        } while (0);
      }
      else
      {
        parser->type = HTTP_REQUEST;
        p_state = (enum state)(s_start_req);
        ;
        goto reexecute;
        ;
      }
      break;
    }
    case s_res_or_resp_H:
      if (ch == 'T')
      {
        parser->type = HTTP_RESPONSE;
        p_state = (enum state)(s_res_HT);
        ;
      }
      else
      {
        if (__builtin_expect(!!(ch != 'E'), 0))
        {
          do
          {
            parser->http_errno = (HPE_INVALID_CONSTANT);
          } while (0);
          goto error;
        }
        parser->type = HTTP_REQUEST;
        parser->method = HTTP_HEAD;
        parser->index = 2;
        p_state = (enum state)(s_req_method);
        ;
      }
      break;
    case s_start_res:
    {
      parser->flags = 0;
      parser->content_length =
          (0x7fffffffffffffffLL * 2ULL + 1);
      switch (ch)
      {
      case 'H':
        p_state = (enum state)(s_res_H);
        ;
        break;
      case '\r':
      case '\n':
        break;
      default:
        do
        {
          parser->http_errno = (HPE_INVALID_CONSTANT);
        } while (0);
        goto error;
      }
      do
      {
        (static_cast<bool>(
             ((enum http_errno)(parser)->http_errno) == HPE_OK)
             ? void(0)
             : __assert_fail(
                   "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 38725, __extension__ __PRETTY_FUNCTION__));
        if (__builtin_expect(!!(settings->on_message_begin), 1))
        {
          parser->state = p_state;
          if (__builtin_expect(!!(0 != settings->on_message_begin(parser)), 0))
          {
            do
            {
              parser->http_errno = (HPE_CB_message_begin);
            } while (0);
          }
          p_state = (enum state)(parser->state);
          ;
          if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
          {
            return (p - data + 1);
          }
        }
      } while (0);
      break;
    }
    case s_res_H:
      do
      {
        if (ch != 'T')
        {
          do
          {
            parser->http_errno = (HPE_STRICT);
          } while (0);
          goto error;
        }
      } while (0);
      p_state = (enum state)(s_res_HT);
      ;
      break;
    case s_res_HT:
      do
      {
        if (ch != 'T')
        {
          do
          {
            parser->http_errno = (HPE_STRICT);
          } while (0);
          goto error;
        }
      } while (0);
      p_state = (enum state)(s_res_HTT);
      ;
      break;
    case s_res_HTT:
      do
      {
        if (ch != 'P')
        {
          do
          {
            parser->http_errno = (HPE_STRICT);
          } while (0);
          goto error;
        }
      } while (0);
      p_state = (enum state)(s_res_HTTP);
      ;
      break;
    case s_res_HTTP:
      do
      {
        if (ch != '/')
        {
          do
          {
            parser->http_errno = (HPE_STRICT);
          } while (0);
          goto error;
        }
      } while (0);
      p_state = (enum state)(s_res_http_major);
      ;
      break;
    case s_res_http_major:
      if (__builtin_expect(!!(!((ch) >= '0' && (ch) <= '9')), 0))
      {
        do
        {
          parser->http_errno = (HPE_INVALID_VERSION);
        } while (0);
        goto error;
      }
      parser->http_major = ch - '0';
      p_state = (enum state)(s_res_http_dot);
      ;
      break;
    case s_res_http_dot:
    {
      if (__builtin_expect(!!(ch != '.'), 0))
      {
        do
        {
          parser->http_errno = (HPE_INVALID_VERSION);
        } while (0);
        goto error;
      }
      p_state = (enum state)(s_res_http_minor);
      ;
      break;
    }
    case s_res_http_minor:
      if (__builtin_expect(!!(!((ch) >= '0' && (ch) <= '9')), 0))
      {
        do
        {
          parser->http_errno = (HPE_INVALID_VERSION);
        } while (0);
        goto error;
      }
      parser->http_minor = ch - '0';
      p_state = (enum state)(s_res_http_end);
      ;
      break;
    case s_res_http_end:
    {
      if (__builtin_expect(!!(ch != ' '), 0))
      {
        do
        {
          parser->http_errno = (HPE_INVALID_VERSION);
        } while (0);
        goto error;
      }
      p_state = (enum state)(s_res_first_status_code);
      ;
      break;
    }
    case s_res_first_status_code:
    {
      if (!((ch) >= '0' && (ch) <= '9'))
      {
        if (ch == ' ')
        {
          break;
        }
        do
        {
          parser->http_errno = (HPE_INVALID_STATUS);
        } while (0);
        goto error;
      }
      parser->status_code = ch - '0';
      p_state = (enum state)(s_res_status_code);
      ;
      break;
    }
    case s_res_status_code:
    {
      if (!((ch) >= '0' && (ch) <= '9'))
      {
        switch (ch)
        {
        case ' ':
          p_state = (enum state)(s_res_status_start);
          ;
          break;
        case '\r':
        case '\n':
          p_state = (enum state)(s_res_status_start);
          ;
          goto reexecute;
          ;
          break;
        default:
          do
          {
            parser->http_errno = (HPE_INVALID_STATUS);
          } while (0);
          goto error;
        }
        break;
      }
      parser->status_code *= 10;
      parser->status_code += ch - '0';
      if (__builtin_expect(!!(parser->status_code > 999), 0))
      {
        do
        {
          parser->http_errno = (HPE_INVALID_STATUS);
        } while (0);
        goto error;
      }
      break;
    }
    case s_res_status_start:
    {
      do
      {
        if (!status_mark)
        {
          status_mark = p;
        }
      } while (0);
      p_state = (enum state)(s_res_status);
      ;
      parser->index = 0;
      if (ch == '\r' || ch == '\n')
        goto reexecute;
      ;
      break;
    }
    case s_res_status:
      if (ch == '\r')
      {
        p_state = (enum state)(s_res_line_almost_done);
        ;
        do
        {
          (static_cast<bool>(
               ((enum http_errno)(parser)->http_errno) == HPE_OK)
               ? void(0)
               : __assert_fail(
                     "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 38839, __extension__ __PRETTY_FUNCTION__));
          if (status_mark)
          {
            if (__builtin_expect(!!(settings->on_status), 1))
            {
              parser->state = p_state;
              if (__builtin_expect(!!(0 != settings->on_status(parser, status_mark, (p - status_mark))), 0))
              {
                do
                {
                  parser->http_errno = (HPE_CB_status);
                } while (0);
              }
              p_state = (enum state)(parser->state);
              ;
              if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
              {
                return (p - data + 1);
              }
            }
            status_mark =
                __null;
          }
        } while (0);
        break;
      }
      if (ch == '\n')
      {
        p_state = (enum state)(s_header_field_start);
        ;
        do
        {
          (static_cast<bool>(
               ((enum http_errno)(parser)->http_errno) == HPE_OK)
               ? void(0)
               : __assert_fail(
                     "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 38845, __extension__ __PRETTY_FUNCTION__));
          if (status_mark)
          {
            if (__builtin_expect(!!(settings->on_status), 1))
            {
              parser->state = p_state;
              if (__builtin_expect(!!(0 != settings->on_status(parser, status_mark, (p - status_mark))), 0))
              {
                do
                {
                  parser->http_errno = (HPE_CB_status);
                } while (0);
              }
              p_state = (enum state)(parser->state);
              ;
              if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
              {
                return (p - data + 1);
              }
            }
            status_mark =
                __null;
          }
        } while (0);
        break;
      }
      break;
    case s_res_line_almost_done:
      do
      {
        if (ch != '\n')
        {
          do
          {
            parser->http_errno = (HPE_STRICT);
          } while (0);
          goto error;
        }
      } while (0);
      p_state = (enum state)(s_header_field_start);
      ;
      break;
    case s_start_req:
    {
      if (ch == '\r' || ch == '\n')
        break;
      parser->flags = 0;
      parser->content_length =
          (0x7fffffffffffffffLL * 2ULL + 1);
      if (__builtin_expect(!!(!((unsigned char)(ch | 0x20) >= 'a' && (unsigned char)(ch | 0x20) <= 'z')), 0))
      {
        do
        {
          parser->http_errno = (HPE_INVALID_METHOD);
        } while (0);
        goto error;
      }
      parser->method = (enum http_method)0;
      parser->index = 1;
      switch (ch)
      {
      case 'A':
        parser->method = HTTP_ACL;
        break;
      case 'B':
        parser->method = HTTP_BIND;
        break;
      case 'C':
        parser->method = HTTP_CONNECT;
        break;
      case 'D':
        parser->method = HTTP_DELETE;
        break;
      case 'G':
        parser->method = HTTP_GET;
        break;
      case 'H':
        parser->method = HTTP_HEAD;
        break;
      case 'L':
        parser->method = HTTP_LOCK;
        break;
      case 'M':
        parser->method = HTTP_MKCOL;
        break;
      case 'N':
        parser->method = HTTP_NOTIFY;
        break;
      case 'O':
        parser->method = HTTP_OPTIONS;
        break;
      case 'P':
        parser->method = HTTP_POST;
        break;
      case 'R':
        parser->method = HTTP_REPORT;
        break;
      case 'S':
        parser->method = HTTP_SUBSCRIBE;
        break;
      case 'T':
        parser->method = HTTP_TRACE;
        break;
      case 'U':
        parser->method = HTTP_UNLOCK;
        break;
      default:
        do
        {
          parser->http_errno = (HPE_INVALID_METHOD);
        } while (0);
        goto error;
      }
      p_state = (enum state)(s_req_method);
      ;
      do
      {
        (static_cast<bool>(
             ((enum http_errno)(parser)->http_errno) == HPE_OK)
             ? void(0)
             : __assert_fail(
                   "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 38918, __extension__ __PRETTY_FUNCTION__));
        if (__builtin_expect(!!(settings->on_message_begin), 1))
        {
          parser->state = p_state;
          if (__builtin_expect(!!(0 != settings->on_message_begin(parser)), 0))
          {
            do
            {
              parser->http_errno = (HPE_CB_message_begin);
            } while (0);
          }
          p_state = (enum state)(parser->state);
          ;
          if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
          {
            return (p - data + 1);
          }
        }
      } while (0);
      break;
    }
    case s_req_method:
    {
      const char *matcher;
      if (__builtin_expect(!!(ch == '\0'), 0))
      {
        do
        {
          parser->http_errno = (HPE_INVALID_METHOD);
        } while (0);
        goto error;
      }
      matcher = method_strings[parser->method];
      if (ch == ' ' && matcher[parser->index] == '\0')
      {
        p_state = (enum state)(s_req_spaces_before_url);
        ;
      }
      else if (ch == matcher[parser->index])
      {
        ;
      }
      else if ((ch >= 'A' && ch <= 'Z') || ch == '-')
      {
        switch (parser->method << 16 | parser->index << 8 | ch)
        {
        case (HTTP_POST << 16 | 1 << 8 | 'U'):
          parser->method = HTTP_PUT;
          break;
        case (HTTP_POST << 16 | 1 << 8 | 'A'):
          parser->method = HTTP_PATCH;
          break;
        case (HTTP_POST << 16 | 1 << 8 | 'R'):
          parser->method = HTTP_PROPFIND;
          break;
        case (HTTP_PUT << 16 | 2 << 8 | 'R'):
          parser->method = HTTP_PURGE;
          break;
        case (HTTP_CONNECT << 16 | 1 << 8 | 'H'):
          parser->method = HTTP_CHECKOUT;
          break;
        case (HTTP_CONNECT << 16 | 2 << 8 | 'P'):
          parser->method = HTTP_COPY;
          break;
        case (HTTP_MKCOL << 16 | 1 << 8 | 'O'):
          parser->method = HTTP_MOVE;
          break;
        case (HTTP_MKCOL << 16 | 1 << 8 | 'E'):
          parser->method = HTTP_MERGE;
          break;
        case (HTTP_MKCOL << 16 | 1 << 8 | '-'):
          parser->method = HTTP_MSEARCH;
          break;
        case (HTTP_MKCOL << 16 | 2 << 8 | 'A'):
          parser->method = HTTP_MKACTIVITY;
          break;
        case (HTTP_MKCOL << 16 | 3 << 8 | 'A'):
          parser->method = HTTP_MKCALENDAR;
          break;
        case (HTTP_SUBSCRIBE << 16 | 1 << 8 | 'E'):
          parser->method = HTTP_SEARCH;
          break;
        case (HTTP_REPORT << 16 | 2 << 8 | 'B'):
          parser->method = HTTP_REBIND;
          break;
        case (HTTP_PROPFIND << 16 | 4 << 8 | 'P'):
          parser->method = HTTP_PROPPATCH;
          break;
        case (HTTP_LOCK << 16 | 1 << 8 | 'I'):
          parser->method = HTTP_LINK;
          break;
        case (HTTP_UNLOCK << 16 | 2 << 8 | 'S'):
          parser->method = HTTP_UNSUBSCRIBE;
          break;
        case (HTTP_UNLOCK << 16 | 2 << 8 | 'B'):
          parser->method = HTTP_UNBIND;
          break;
        case (HTTP_UNLOCK << 16 | 3 << 8 | 'I'):
          parser->method = HTTP_UNLINK;
          break;
        default:
          do
          {
            parser->http_errno = (HPE_INVALID_METHOD);
          } while (0);
          goto error;
        }
      }
      else
      {
        do
        {
          parser->http_errno = (HPE_INVALID_METHOD);
        } while (0);
        goto error;
      }
      ++parser->index;
      break;
    }
    case s_req_spaces_before_url:
    {
      if (ch == ' ')
        break;
      do
      {
        if (!url_mark)
        {
          url_mark = p;
        }
      } while (0);
      if (parser->method == HTTP_CONNECT)
      {
        p_state = (enum state)(s_req_server_start);
        ;
      }
      p_state = (enum state)(parse_url_char(p_state, ch));
      ;
      if (__builtin_expect(!!(p_state == s_dead), 0))
      {
        do
        {
          parser->http_errno = (HPE_INVALID_URL);
        } while (0);
        goto error;
      }
      break;
    }
    case s_req_schema:
    case s_req_schema_slash:
    case s_req_schema_slash_slash:
    case s_req_server_start:
    {
      switch (ch)
      {
      case ' ':
      case '\r':
      case '\n':
        do
        {
          parser->http_errno = (HPE_INVALID_URL);
        } while (0);
        goto error;
      default:
        p_state = (enum state)(parse_url_char(p_state, ch));
        ;
        if (__builtin_expect(!!(p_state == s_dead), 0))
        {
          do
          {
            parser->http_errno = (HPE_INVALID_URL);
          } while (0);
          goto error;
        }
      }
      break;
    }
    case s_req_server:
    case s_req_server_with_at:
    case s_req_path:
    case s_req_query_string_start:
    case s_req_query_string:
    case s_req_fragment_start:
    case s_req_fragment:
    {
      switch (ch)
      {
      case ' ':
        p_state = (enum state)(s_req_http_start);
        ;
        do
        {
          (static_cast<bool>(
               ((enum http_errno)(parser)->http_errno) == HPE_OK)
               ? void(0)
               : __assert_fail(
                     "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 39029, __extension__ __PRETTY_FUNCTION__));
          if (url_mark)
          {
            if (__builtin_expect(!!(settings->on_url), 1))
            {
              parser->state = p_state;
              if (__builtin_expect(!!(0 != settings->on_url(parser, url_mark, (p - url_mark))), 0))
              {
                do
                {
                  parser->http_errno = (HPE_CB_url);
                } while (0);
              }
              p_state = (enum state)(parser->state);
              ;
              if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
              {
                return (p - data + 1);
              }
            }
            url_mark =
                __null;
          }
        } while (0);
        break;
      case '\r':
      case '\n':
        parser->http_major = 0;
        parser->http_minor = 9;
        do
        {
          (static_cast<bool>(
               ((enum http_errno)(parser)->http_errno) == HPE_OK)
               ? void(0)
               : __assert_fail(
                     "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 39035, __extension__ __PRETTY_FUNCTION__));
          if (url_mark)
          {
            if (__builtin_expect(!!(settings->on_url), 1))
            {
              parser->state = p_state;
              if (__builtin_expect(!!(0 != settings->on_url(parser, url_mark, (p - url_mark))), 0))
              {
                do
                {
                  parser->http_errno = (HPE_CB_url);
                } while (0);
              }
              p_state = (enum state)(parser->state);
              ;
              if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
              {
                return (p - data + 1);
              }
            }
            url_mark =
                __null;
          }
        } while (0);
        if (ch == '\r')
        {
          p_state = (enum state)(s_req_line_almost_done);
          ;
        }
        else
        {
          p_state = (enum state)(s_headers_almost_done);
          ;
          goto reexecute;
          ;
        }
        break;
      default:
        p_state = (enum state)(parse_url_char(p_state, ch));
        ;
        if (__builtin_expect(!!(p_state == s_dead), 0))
        {
          do
          {
            parser->http_errno = (HPE_INVALID_URL);
          } while (0);
          goto error;
        }
      }
      break;
    }
    case s_req_http_start:
      switch (ch)
      {
      case 'H':
        p_state = (enum state)(s_req_http_H);
        ;
        break;
      case ' ':
        break;
      default:
        do
        {
          parser->http_errno = (HPE_INVALID_CONSTANT);
        } while (0);
        goto error;
      }
      break;
    case s_req_http_H:
      do
      {
        if (ch != 'T')
        {
          do
          {
            parser->http_errno = (HPE_STRICT);
          } while (0);
          goto error;
        }
      } while (0);
      p_state = (enum state)(s_req_http_HT);
      ;
      break;
    case s_req_http_HT:
      do
      {
        if (ch != 'T')
        {
          do
          {
            parser->http_errno = (HPE_STRICT);
          } while (0);
          goto error;
        }
      } while (0);
      p_state = (enum state)(s_req_http_HTT);
      ;
      break;
    case s_req_http_HTT:
      do
      {
        if (ch != 'P')
        {
          do
          {
            parser->http_errno = (HPE_STRICT);
          } while (0);
          goto error;
        }
      } while (0);
      p_state = (enum state)(s_req_http_HTTP);
      ;
      break;
    case s_req_http_HTTP:
      do
      {
        if (ch != '/')
        {
          do
          {
            parser->http_errno = (HPE_STRICT);
          } while (0);
          goto error;
        }
      } while (0);
      p_state = (enum state)(s_req_http_major);
      ;
      break;
    case s_req_http_major:
      if (__builtin_expect(!!(!((ch) >= '0' && (ch) <= '9')), 0))
      {
        do
        {
          parser->http_errno = (HPE_INVALID_VERSION);
        } while (0);
        goto error;
      }
      parser->http_major = ch - '0';
      p_state = (enum state)(s_req_http_dot);
      ;
      break;
    case s_req_http_dot:
    {
      if (__builtin_expect(!!(ch != '.'), 0))
      {
        do
        {
          parser->http_errno = (HPE_INVALID_VERSION);
        } while (0);
        goto error;
      }
      p_state = (enum state)(s_req_http_minor);
      ;
      break;
    }
    case s_req_http_minor:
      if (__builtin_expect(!!(!((ch) >= '0' && (ch) <= '9')), 0))
      {
        do
        {
          parser->http_errno = (HPE_INVALID_VERSION);
        } while (0);
        goto error;
      }
      parser->http_minor = ch - '0';
      p_state = (enum state)(s_req_http_end);
      ;
      break;
    case s_req_http_end:
    {
      if (ch == '\r')
      {
        p_state = (enum state)(s_req_line_almost_done);
        ;
        break;
      }
      if (ch == '\n')
      {
        p_state = (enum state)(s_header_field_start);
        ;
        break;
      }
      do
      {
        parser->http_errno = (HPE_INVALID_VERSION);
      } while (0);
      goto error;
      break;
    }
    case s_req_line_almost_done:
    {
      if (__builtin_expect(!!(ch != '\n'), 0))
      {
        do
        {
          parser->http_errno = (HPE_LF_EXPECTED);
        } while (0);
        goto error;
      }
      if (parser->http_major == 0)
      {
        p_state = (enum state)(s_headers_almost_done);
        ;
        goto reexecute;
        ;
      }
      else
      {
        p_state = (enum state)(s_header_field_start);
        ;
      }
      break;
    }
    case s_header_field_start:
    {
      if (ch == '\r')
      {
        p_state = (enum state)(s_headers_almost_done);
        ;
        break;
      }
      if (ch == '\n')
      {
        p_state = (enum state)(s_headers_almost_done);
        ;
        goto reexecute;
        ;
      }
      c = (tokens[(unsigned char)ch]);
      if (__builtin_expect(!!(!c), 0))
      {
        do
        {
          parser->http_errno = (HPE_INVALID_HEADER_TOKEN);
        } while (0);
        goto error;
      }
      do
      {
        if (!header_field_mark)
        {
          header_field_mark = p;
        }
      } while (0);
      parser->index = 0;
      p_state = (enum state)(s_header_field);
      ;
      switch (c)
      {
      case 'c':
        parser->header_state = h_C;
        break;
      case 'p':
        parser->header_state = h_matching_proxy_connection;
        break;
      case 't':
        parser->header_state = h_matching_transfer_encoding;
        break;
      case 'u':
        parser->header_state = h_matching_upgrade;
        break;
      default:
        parser->header_state = h_general;
        break;
      }
      break;
    }
    case s_header_field:
    {
      const char *start = p;
      for (; p != data + len; p++)
      {
        ch = *p;
        c = (tokens[(unsigned char)ch]);
        if (!c)
          break;
        switch (parser->header_state)
        {
        case h_general:
          break;
        case h_C:
          parser->index++;
          parser->header_state = (c == 'o' ? h_CO : h_general);
          break;
        case h_CO:
          parser->index++;
          parser->header_state = (c == 'n' ? h_CON : h_general);
          break;
        case h_CON:
          parser->index++;
          switch (c)
          {
          case 'n':
            parser->header_state = h_matching_connection;
            break;
          case 't':
            parser->header_state = h_matching_content_length;
            break;
          default:
            parser->header_state = h_general;
            break;
          }
          break;
        case h_matching_connection:
          parser->index++;
          if (parser->index > sizeof("connection") - 1 || c != "connection"[parser->index])
          {
            parser->header_state = h_general;
          }
          else if (parser->index == sizeof("connection") - 2)
          {
            parser->header_state = h_connection;
          }
          break;
        case h_matching_proxy_connection:
          parser->index++;
          if (parser->index > sizeof("proxy-connection") - 1 || c != "proxy-connection"[parser->index])
          {
            parser->header_state = h_general;
          }
          else if (parser->index == sizeof("proxy-connection") - 2)
          {
            parser->header_state = h_connection;
          }
          break;
        case h_matching_content_length:
          parser->index++;
          if (parser->index > sizeof("content-length") - 1 || c != "content-length"[parser->index])
          {
            parser->header_state = h_general;
          }
          else if (parser->index == sizeof("content-length") - 2)
          {
            parser->header_state = h_content_length;
          }
          break;
        case h_matching_transfer_encoding:
          parser->index++;
          if (parser->index > sizeof("transfer-encoding") - 1 || c != "transfer-encoding"[parser->index])
          {
            parser->header_state = h_general;
          }
          else if (parser->index == sizeof("transfer-encoding") - 2)
          {
            parser->header_state = h_transfer_encoding;
          }
          break;
        case h_matching_upgrade:
          parser->index++;
          if (parser->index > sizeof("upgrade") - 1 || c != "upgrade"[parser->index])
          {
            parser->header_state = h_general;
          }
          else if (parser->index == sizeof("upgrade") - 2)
          {
            parser->header_state = h_upgrade;
          }
          break;
        case h_connection:
        case h_content_length:
        case h_transfer_encoding:
        case h_upgrade:
          if (ch != ' ')
            parser->header_state = h_general;
          break;
        default:

          (static_cast<bool>(
               0 && "Unknown header_state")
               ? void(0)
               : __assert_fail(
                     "0 && \"Unknown header_state\"", "all.cpp", 39287, __extension__ __PRETTY_FUNCTION__));
          break;
        }
      }
      do
      {
        parser->nread += (p - start);
        if (__builtin_expect(!!(parser->nread > ((80 * 1024))), 0))
        {
          do
          {
            parser->http_errno = (HPE_HEADER_OVERFLOW);
          } while (0);
          goto error;
        }
      } while (0);
      if (p == data + len)
      {
        --p;
        break;
      }
      if (ch == ':')
      {
        p_state = (enum state)(s_header_value_discard_ws);
        ;
        do
        {
          (static_cast<bool>(
               ((enum http_errno)(parser)->http_errno) == HPE_OK)
               ? void(0)
               : __assert_fail(
                     "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 39300, __extension__ __PRETTY_FUNCTION__));
          if (header_field_mark)
          {
            if (__builtin_expect(!!(settings->on_header_field), 1))
            {
              parser->state = p_state;
              if (__builtin_expect(!!(0 != settings->on_header_field(parser, header_field_mark, (p - header_field_mark))), 0))
              {
                do
                {
                  parser->http_errno = (HPE_CB_header_field);
                } while (0);
              }
              p_state = (enum state)(parser->state);
              ;
              if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
              {
                return (p - data + 1);
              }
            }
            header_field_mark =
                __null;
          }
        } while (0);
        break;
      }
      do
      {
        parser->http_errno = (HPE_INVALID_HEADER_TOKEN);
      } while (0);
      goto error;
    }
    case s_header_value_discard_ws:
      if (ch == ' ' || ch == '\t')
        break;
      if (ch == '\r')
      {
        p_state = (enum state)(s_header_value_discard_ws_almost_done);
        ;
        break;
      }
      if (ch == '\n')
      {
        p_state = (enum state)(s_header_value_discard_lws);
        ;
        break;
      }
    case s_header_value_start:
    {
      do
      {
        if (!header_value_mark)
        {
          header_value_mark = p;
        }
      } while (0);
      p_state = (enum state)(s_header_value);
      ;
      parser->index = 0;
      c = (unsigned char)(ch | 0x20);
      switch (parser->header_state)
      {
      case h_upgrade:
        parser->flags |= F_UPGRADE;
        parser->header_state = h_general;
        break;
      case h_transfer_encoding:
        if ('c' == c)
        {
          parser->header_state = h_matching_transfer_encoding_chunked;
        }
        else
        {
          parser->header_state = h_general;
        }
        break;
      case h_content_length:
        if (__builtin_expect(!!(!((ch) >= '0' && (ch) <= '9')), 0))
        {
          do
          {
            parser->http_errno = (HPE_INVALID_CONTENT_LENGTH);
          } while (0);
          goto error;
        }
        if (parser->flags & F_CONTENTLENGTH)
        {
          do
          {
            parser->http_errno = (HPE_UNEXPECTED_CONTENT_LENGTH);
          } while (0);
          goto error;
        }
        parser->flags |= F_CONTENTLENGTH;
        parser->content_length = ch - '0';
        break;
      case h_connection:
        if (c == 'k')
        {
          parser->header_state = h_matching_connection_keep_alive;
        }
        else if (c == 'c')
        {
          parser->header_state = h_matching_connection_close;
        }
        else if (c == 'u')
        {
          parser->header_state = h_matching_connection_upgrade;
        }
        else
        {
          parser->header_state = h_matching_connection_token;
        }
        break;
      case h_matching_connection_token_start:
        break;
      default:
        parser->header_state = h_general;
        break;
      }
      break;
    }
    case s_header_value:
    {
      const char *start = p;
      enum header_states h_state = (enum header_states)parser->header_state;
      for (; p != data + len; p++)
      {
        ch = *p;
        if (ch == '\r')
        {
          p_state = (enum state)(s_header_almost_done);
          ;
          parser->header_state = h_state;
          do
          {
            (static_cast<bool>(
                 ((enum http_errno)(parser)->http_errno) == HPE_OK)
                 ? void(0)
                 : __assert_fail(
                       "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 39392, __extension__ __PRETTY_FUNCTION__));
            if (header_value_mark)
            {
              if (__builtin_expect(!!(settings->on_header_value), 1))
              {
                parser->state = p_state;
                if (__builtin_expect(!!(0 != settings->on_header_value(parser, header_value_mark, (p - header_value_mark))), 0))
                {
                  do
                  {
                    parser->http_errno = (HPE_CB_header_value);
                  } while (0);
                }
                p_state = (enum state)(parser->state);
                ;
                if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
                {
                  return (p - data + 1);
                }
              }
              header_value_mark =
                  __null;
            }
          } while (0);
          break;
        }
        if (ch == '\n')
        {
          p_state = (enum state)(s_header_almost_done);
          ;
          do
          {
            parser->nread += (p - start);
            if (__builtin_expect(!!(parser->nread > ((80 * 1024))), 0))
            {
              do
              {
                parser->http_errno = (HPE_HEADER_OVERFLOW);
              } while (0);
              goto error;
            }
          } while (0);
          parser->header_state = h_state;
          do
          {
            (static_cast<bool>(
                 ((enum http_errno)(parser)->http_errno) == HPE_OK)
                 ? void(0)
                 : __assert_fail(
                       "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 39400, __extension__ __PRETTY_FUNCTION__));
            if (header_value_mark)
            {
              if (__builtin_expect(!!(settings->on_header_value), 1))
              {
                parser->state = p_state;
                if (__builtin_expect(!!(0 != settings->on_header_value(parser, header_value_mark, (p - header_value_mark))), 0))
                {
                  do
                  {
                    parser->http_errno = (HPE_CB_header_value);
                  } while (0);
                }
                p_state = (enum state)(parser->state);
                ;
                if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
                {
                  return (p - data);
                }
              }
              header_value_mark =
                  __null;
            }
          } while (0);
          goto reexecute;
          ;
        }
        if (!lenient && !(ch == '\r' || ch == '\n' || ch == 9 || ((unsigned char)ch > 31 && ch != 127)))
        {
          do
          {
            parser->http_errno = (HPE_INVALID_HEADER_TOKEN);
          } while (0);
          goto error;
        }
        c = (unsigned char)(ch | 0x20);
        switch (h_state)
        {
        case h_general:
        {
          const char *p_cr;
          const char *p_lf;
          size_t limit = data + len - p;
          limit = ((limit) < ((80 * 1024)) ? (limit) : ((80 * 1024)));
          p_cr = (const char *)memchr(p, '\r', limit);
          p_lf = (const char *)memchr(p, '\n', limit);
          if (p_cr !=
              __null)
          {
            if (p_lf !=
                    __null &&
                p_cr >= p_lf)
              p = p_lf;
            else
              p = p_cr;
          }
          else if (__builtin_expect(!!(p_lf !=
                                       __null),
                                    0))
          {
            p = p_lf;
          }
          else
          {
            p = data + len;
          }
          --p;
          break;
        }
        case h_connection:
        case h_transfer_encoding:

          (static_cast<bool>(
               0 && "Shouldn't get here.")
               ? void(0)
               : __assert_fail(
                     "0 && \"Shouldn't get here.\"", "all.cpp", 39439, __extension__ __PRETTY_FUNCTION__));
          break;
        case h_content_length:
        {
          uint64_t t;
          if (ch == ' ')
            break;
          if (__builtin_expect(!!(!((ch) >= '0' && (ch) <= '9')), 0))
          {
            do
            {
              parser->http_errno = (HPE_INVALID_CONTENT_LENGTH);
            } while (0);
            parser->header_state = h_state;
            goto error;
          }
          t = parser->content_length;
          t *= 10;
          t += ch - '0';
          if (__builtin_expect(!!((
                                      (0x7fffffffffffffffLL * 2ULL + 1) - 10) /
                                      10 <
                                  parser->content_length),
                               0))
          {
            do
            {
              parser->http_errno = (HPE_INVALID_CONTENT_LENGTH);
            } while (0);
            parser->header_state = h_state;
            goto error;
          }
          parser->content_length = t;
          break;
        }
        case h_matching_transfer_encoding_chunked:
          parser->index++;
          if (parser->index > sizeof("chunked") - 1 || c != "chunked"[parser->index])
          {
            h_state = h_general;
          }
          else if (parser->index == sizeof("chunked") - 2)
          {
            h_state = h_transfer_encoding_chunked;
          }
          break;
        case h_matching_connection_token_start:
          if (c == 'k')
          {
            h_state = h_matching_connection_keep_alive;
          }
          else if (c == 'c')
          {
            h_state = h_matching_connection_close;
          }
          else if (c == 'u')
          {
            h_state = h_matching_connection_upgrade;
          }
          else if ((tokens[(unsigned char)c]))
          {
            h_state = h_matching_connection_token;
          }
          else if (c == ' ' || c == '\t')
          {
          }
          else
          {
            h_state = h_general;
          }
          break;
        case h_matching_connection_keep_alive:
          parser->index++;
          if (parser->index > sizeof("keep-alive") - 1 || c != "keep-alive"[parser->index])
          {
            h_state = h_matching_connection_token;
          }
          else if (parser->index == sizeof("keep-alive") - 2)
          {
            h_state = h_connection_keep_alive;
          }
          break;
        case h_matching_connection_close:
          parser->index++;
          if (parser->index > sizeof("close") - 1 || c != "close"[parser->index])
          {
            h_state = h_matching_connection_token;
          }
          else if (parser->index == sizeof("close") - 2)
          {
            h_state = h_connection_close;
          }
          break;
        case h_matching_connection_upgrade:
          parser->index++;
          if (parser->index > sizeof("upgrade") - 1 ||
              c != "upgrade"[parser->index])
          {
            h_state = h_matching_connection_token;
          }
          else if (parser->index == sizeof("upgrade") - 2)
          {
            h_state = h_connection_upgrade;
          }
          break;
        case h_matching_connection_token:
          if (ch == ',')
          {
            h_state = h_matching_connection_token_start;
            parser->index = 0;
          }
          break;
        case h_transfer_encoding_chunked:
          if (ch != ' ')
            h_state = h_general;
          break;
        case h_connection_keep_alive:
        case h_connection_close:
        case h_connection_upgrade:
          if (ch == ',')
          {
            if (h_state == h_connection_keep_alive)
            {
              parser->flags |= F_CONNECTION_KEEP_ALIVE;
            }
            else if (h_state == h_connection_close)
            {
              parser->flags |= F_CONNECTION_CLOSE;
            }
            else if (h_state == h_connection_upgrade)
            {
              parser->flags |= F_CONNECTION_UPGRADE;
            }
            h_state = h_matching_connection_token_start;
            parser->index = 0;
          }
          else if (ch != ' ')
          {
            h_state = h_matching_connection_token;
          }
          break;
        default:
          p_state = (enum state)(s_header_value);
          ;
          h_state = h_general;
          break;
        }
      }
      parser->header_state = h_state;
      do
      {
        parser->nread += (p - start);
        if (__builtin_expect(!!(parser->nread > ((80 * 1024))), 0))
        {
          do
          {
            parser->http_errno = (HPE_HEADER_OVERFLOW);
          } while (0);
          goto error;
        }
      } while (0);
      if (p == data + len)
        --p;
      break;
    }
    case s_header_almost_done:
    {
      if (__builtin_expect(!!(ch != '\n'), 0))
      {
        do
        {
          parser->http_errno = (HPE_LF_EXPECTED);
        } while (0);
        goto error;
      }
      p_state = (enum state)(s_header_value_lws);
      ;
      break;
    }
    case s_header_value_lws:
    {
      if (ch == ' ' || ch == '\t')
      {
        p_state = (enum state)(s_header_value_start);
        ;
        goto reexecute;
        ;
      }
      switch (parser->header_state)
      {
      case h_connection_keep_alive:
        parser->flags |= F_CONNECTION_KEEP_ALIVE;
        break;
      case h_connection_close:
        parser->flags |= F_CONNECTION_CLOSE;
        break;
      case h_transfer_encoding_chunked:
        parser->flags |= F_CHUNKED;
        break;
      case h_connection_upgrade:
        parser->flags |= F_CONNECTION_UPGRADE;
        break;
      default:
        break;
      }
      p_state = (enum state)(s_header_field_start);
      ;
      goto reexecute;
      ;
    }
    case s_header_value_discard_ws_almost_done:
    {
      do
      {
        if (ch != '\n')
        {
          do
          {
            parser->http_errno = (HPE_STRICT);
          } while (0);
          goto error;
        }
      } while (0);
      p_state = (enum state)(s_header_value_discard_lws);
      ;
      break;
    }
    case s_header_value_discard_lws:
    {
      if (ch == ' ' || ch == '\t')
      {
        p_state = (enum state)(s_header_value_discard_ws);
        ;
        break;
      }
      else
      {
        switch (parser->header_state)
        {
        case h_connection_keep_alive:
          parser->flags |= F_CONNECTION_KEEP_ALIVE;
          break;
        case h_connection_close:
          parser->flags |= F_CONNECTION_CLOSE;
          break;
        case h_connection_upgrade:
          parser->flags |= F_CONNECTION_UPGRADE;
          break;
        case h_transfer_encoding_chunked:
          parser->flags |= F_CHUNKED;
          break;
        default:
          break;
        }
        do
        {
          if (!header_value_mark)
          {
            header_value_mark = p;
          }
        } while (0);
        p_state = (enum state)(s_header_field_start);
        ;
        do
        {
          (static_cast<bool>(
               ((enum http_errno)(parser)->http_errno) == HPE_OK)
               ? void(0)
               : __assert_fail(
                     "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 39653, __extension__ __PRETTY_FUNCTION__));
          if (header_value_mark)
          {
            if (__builtin_expect(!!(settings->on_header_value), 1))
            {
              parser->state = p_state;
              if (__builtin_expect(!!(0 != settings->on_header_value(parser, header_value_mark, (p - header_value_mark))), 0))
              {
                do
                {
                  parser->http_errno = (HPE_CB_header_value);
                } while (0);
              }
              p_state = (enum state)(parser->state);
              ;
              if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
              {
                return (p - data);
              }
            }
            header_value_mark =
                __null;
          }
        } while (0);
        goto reexecute;
        ;
      }
    }
    case s_headers_almost_done:
    {
      do
      {
        if (ch != '\n')
        {
          do
          {
            parser->http_errno = (HPE_STRICT);
          } while (0);
          goto error;
        }
      } while (0);
      if (parser->flags & F_TRAILING)
      {
        p_state = (enum state)(s_message_done);
        ;
        do
        {
          (static_cast<bool>(
               ((enum http_errno)(parser)->http_errno) == HPE_OK)
               ? void(0)
               : __assert_fail(
                     "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 39663, __extension__ __PRETTY_FUNCTION__));
          if (__builtin_expect(!!(settings->on_chunk_complete), 1))
          {
            parser->state = p_state;
            if (__builtin_expect(!!(0 != settings->on_chunk_complete(parser)), 0))
            {
              do
              {
                parser->http_errno = (HPE_CB_chunk_complete);
              } while (0);
            }
            p_state = (enum state)(parser->state);
            ;
            if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
            {
              return (p - data);
            }
          }
        } while (0);
        goto reexecute;
        ;
      }
      if ((parser->flags & F_CHUNKED) &&
          (parser->flags & F_CONTENTLENGTH))
      {
        do
        {
          parser->http_errno = (HPE_UNEXPECTED_CONTENT_LENGTH);
        } while (0);
        goto error;
      }
      p_state = (enum state)(s_headers_done);
      ;
      if ((parser->flags & F_UPGRADE) &&
          (parser->flags & F_CONNECTION_UPGRADE))
      {
        parser->upgrade =
            (parser->type == HTTP_REQUEST || parser->status_code == 101);
      }
      else
      {
        parser->upgrade = (parser->method == HTTP_CONNECT);
      }
      if (settings->on_headers_complete)
      {
        switch (settings->on_headers_complete(parser))
        {
        case 0:
          break;
        case 2:
          parser->upgrade = 1;
        case 1:
          parser->flags |= F_SKIPBODY;
          break;
        default:
          do
          {
            parser->http_errno = (HPE_CB_headers_complete);
          } while (0);
          do
          {
            parser->state = p_state;
            return (p - data);
          } while (0);
          ;
        }
      }
      if (((enum http_errno)(parser)->http_errno) != HPE_OK)
      {
        do
        {
          parser->state = p_state;
          return (p - data);
        } while (0);
        ;
      }
      goto reexecute;
      ;
    }
    case s_headers_done:
    {
      int hasBody;
      do
      {
        if (ch != '\n')
        {
          do
          {
            parser->http_errno = (HPE_STRICT);
          } while (0);
          goto error;
        }
      } while (0);
      parser->nread = 0;
      hasBody = parser->flags & F_CHUNKED ||
                (parser->content_length > 0 && parser->content_length !=
                                                   (0x7fffffffffffffffLL * 2ULL + 1));
      if (parser->upgrade && (parser->method == HTTP_CONNECT ||
                              (parser->flags & F_SKIPBODY) || !hasBody))
      {
        p_state = (enum state)((http_should_keep_alive(parser) ? (parser->type == HTTP_REQUEST ? s_start_req : s_start_res) : s_dead));
        ;
        do
        {
          (static_cast<bool>(
               ((enum http_errno)(parser)->http_errno) == HPE_OK)
               ? void(0)
               : __assert_fail(
                     "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 39716, __extension__ __PRETTY_FUNCTION__));
          if (__builtin_expect(!!(settings->on_message_complete), 1))
          {
            parser->state = p_state;
            if (__builtin_expect(!!(0 != settings->on_message_complete(parser)), 0))
            {
              do
              {
                parser->http_errno = (HPE_CB_message_complete);
              } while (0);
            }
            p_state = (enum state)(parser->state);
            ;
            if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
            {
              return (p - data + 1);
            }
          }
        } while (0);
        do
        {
          parser->state = p_state;
          return ((p - data) + 1);
        } while (0);
        ;
      }
      if (parser->flags & F_SKIPBODY)
      {
        p_state = (enum state)((http_should_keep_alive(parser) ? (parser->type == HTTP_REQUEST ? s_start_req : s_start_res) : s_dead));
        ;
        do
        {
          (static_cast<bool>(
               ((enum http_errno)(parser)->http_errno) == HPE_OK)
               ? void(0)
               : __assert_fail(
                     "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 39722, __extension__ __PRETTY_FUNCTION__));
          if (__builtin_expect(!!(settings->on_message_complete), 1))
          {
            parser->state = p_state;
            if (__builtin_expect(!!(0 != settings->on_message_complete(parser)), 0))
            {
              do
              {
                parser->http_errno = (HPE_CB_message_complete);
              } while (0);
            }
            p_state = (enum state)(parser->state);
            ;
            if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
            {
              return (p - data + 1);
            }
          }
        } while (0);
      }
      else if (parser->flags & F_CHUNKED)
      {
        p_state = (enum state)(s_chunk_size_start);
        ;
      }
      else
      {
        if (parser->content_length == 0)
        {
          p_state = (enum state)((http_should_keep_alive(parser) ? (parser->type == HTTP_REQUEST ? s_start_req : s_start_res) : s_dead));
          ;
          do
          {
            (static_cast<bool>(
                 ((enum http_errno)(parser)->http_errno) == HPE_OK)
                 ? void(0)
                 : __assert_fail(
                       "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 39733, __extension__ __PRETTY_FUNCTION__));
            if (__builtin_expect(!!(settings->on_message_complete), 1))
            {
              parser->state = p_state;
              if (__builtin_expect(!!(0 != settings->on_message_complete(parser)), 0))
              {
                do
                {
                  parser->http_errno = (HPE_CB_message_complete);
                } while (0);
              }
              p_state = (enum state)(parser->state);
              ;
              if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
              {
                return (p - data + 1);
              }
            }
          } while (0);
        }
        else if (parser->content_length !=
                 (0x7fffffffffffffffLL * 2ULL + 1))
        {
          p_state = (enum state)(s_body_identity);
          ;
        }
        else
        {
          if (!http_message_needs_eof(parser))
          {
            p_state = (enum state)((http_should_keep_alive(parser) ? (parser->type == HTTP_REQUEST ? s_start_req : s_start_res) : s_dead));
            ;
            do
            {
              (static_cast<bool>(
                   ((enum http_errno)(parser)->http_errno) == HPE_OK)
                   ? void(0)
                   : __assert_fail(
                         "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 39744, __extension__ __PRETTY_FUNCTION__));
              if (__builtin_expect(!!(settings->on_message_complete), 1))
              {
                parser->state = p_state;
                if (__builtin_expect(!!(0 != settings->on_message_complete(parser)), 0))
                {
                  do
                  {
                    parser->http_errno = (HPE_CB_message_complete);
                  } while (0);
                }
                p_state = (enum state)(parser->state);
                ;
                if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
                {
                  return (p - data + 1);
                }
              }
            } while (0);
          }
          else
          {
            p_state = (enum state)(s_body_identity_eof);
            ;
          }
        }
      }
      break;
    }
    case s_body_identity:
    {
      uint64_t to_read = ((parser->content_length) < ((uint64_t)((data + len) - p)) ? (parser->content_length) : ((uint64_t)((data + len) - p)));

      (static_cast<bool>(
           parser->content_length != 0 && parser->content_length !=
                                              (0x7fffffffffffffffLL * 2ULL + 1))
           ? void(0)
           : __assert_fail(
                 "parser->content_length != 0 && parser->content_length != ULLONG_MAX", "all.cpp", 39758, __extension__ __PRETTY_FUNCTION__));
      do
      {
        if (!body_mark)
        {
          body_mark = p;
        }
      } while (0);
      parser->content_length -= to_read;
      p += to_read - 1;
      if (parser->content_length == 0)
      {
        p_state = (enum state)(s_message_done);
        ;
        do
        {
          (static_cast<bool>(
               ((enum http_errno)(parser)->http_errno) == HPE_OK)
               ? void(0)
               : __assert_fail(
                     "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 39765, __extension__ __PRETTY_FUNCTION__));
          if (body_mark)
          {
            if (__builtin_expect(!!(settings->on_body), 1))
            {
              parser->state = p_state;
              if (__builtin_expect(!!(0 != settings->on_body(parser, body_mark, (p - body_mark + 1))), 0))
              {
                do
                {
                  parser->http_errno = (HPE_CB_body);
                } while (0);
              }
              p_state = (enum state)(parser->state);
              ;
              if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
              {
                return (p - data);
              }
            }
            body_mark =
                __null;
          }
        } while (0);
        goto reexecute;
        ;
      }
      break;
    }
    case s_body_identity_eof:
      do
      {
        if (!body_mark)
        {
          body_mark = p;
        }
      } while (0);
      p = data + len - 1;
      break;
    case s_message_done:
      p_state = (enum state)((http_should_keep_alive(parser) ? (parser->type == HTTP_REQUEST ? s_start_req : s_start_res) : s_dead));
      ;
      do
      {
        (static_cast<bool>(
             ((enum http_errno)(parser)->http_errno) == HPE_OK)
             ? void(0)
             : __assert_fail(
                   "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 39776, __extension__ __PRETTY_FUNCTION__));
        if (__builtin_expect(!!(settings->on_message_complete), 1))
        {
          parser->state = p_state;
          if (__builtin_expect(!!(0 != settings->on_message_complete(parser)), 0))
          {
            do
            {
              parser->http_errno = (HPE_CB_message_complete);
            } while (0);
          }
          p_state = (enum state)(parser->state);
          ;
          if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
          {
            return (p - data + 1);
          }
        }
      } while (0);
      if (parser->upgrade)
      {
        do
        {
          parser->state = p_state;
          return ((p - data) + 1);
        } while (0);
        ;
      }
      break;
    case s_chunk_size_start:
    {

      (static_cast<bool>(
           parser->nread == 1)
           ? void(0)
           : __assert_fail(
                 "parser->nread == 1", "all.cpp", 39784, __extension__ __PRETTY_FUNCTION__));

      (static_cast<bool>(
           parser->flags & F_CHUNKED)
           ? void(0)
           : __assert_fail(
                 "parser->flags & F_CHUNKED", "all.cpp", 39785, __extension__ __PRETTY_FUNCTION__));
      unhex_val = unhex[(unsigned char)ch];
      if (__builtin_expect(!!(unhex_val == -1), 0))
      {
        do
        {
          parser->http_errno = (HPE_INVALID_CHUNK_SIZE);
        } while (0);
        goto error;
      }
      parser->content_length = unhex_val;
      p_state = (enum state)(s_chunk_size);
      ;
      break;
    }
    case s_chunk_size:
    {
      uint64_t t;

      (static_cast<bool>(
           parser->flags & F_CHUNKED)
           ? void(0)
           : __assert_fail(
                 "parser->flags & F_CHUNKED", "all.cpp", 39799, __extension__ __PRETTY_FUNCTION__));
      if (ch == '\r')
      {
        p_state = (enum state)(s_chunk_size_almost_done);
        ;
        break;
      }
      unhex_val = unhex[(unsigned char)ch];
      if (unhex_val == -1)
      {
        if (ch == ';' || ch == ' ')
        {
          p_state = (enum state)(s_chunk_parameters);
          ;
          break;
        }
        do
        {
          parser->http_errno = (HPE_INVALID_CHUNK_SIZE);
        } while (0);
        goto error;
      }
      t = parser->content_length;
      t *= 16;
      t += unhex_val;
      if (__builtin_expect(!!((
                                  (0x7fffffffffffffffLL * 2ULL + 1) - 16) /
                                  16 <
                              parser->content_length),
                           0))
      {
        do
        {
          parser->http_errno = (HPE_INVALID_CONTENT_LENGTH);
        } while (0);
        goto error;
      }
      parser->content_length = t;
      break;
    }
    case s_chunk_parameters:
    {

      (static_cast<bool>(
           parser->flags & F_CHUNKED)
           ? void(0)
           : __assert_fail(
                 "parser->flags & F_CHUNKED", "all.cpp", 39829, __extension__ __PRETTY_FUNCTION__));
      if (ch == '\r')
      {
        p_state = (enum state)(s_chunk_size_almost_done);
        ;
        break;
      }
      break;
    }
    case s_chunk_size_almost_done:
    {

      (static_cast<bool>(
           parser->flags & F_CHUNKED)
           ? void(0)
           : __assert_fail(
                 "parser->flags & F_CHUNKED", "all.cpp", 39839, __extension__ __PRETTY_FUNCTION__));
      do
      {
        if (ch != '\n')
        {
          do
          {
            parser->http_errno = (HPE_STRICT);
          } while (0);
          goto error;
        }
      } while (0);
      parser->nread = 0;
      if (parser->content_length == 0)
      {
        parser->flags |= F_TRAILING;
        p_state = (enum state)(s_header_field_start);
        ;
      }
      else
      {
        p_state = (enum state)(s_chunk_data);
        ;
      }
      do
      {
        (static_cast<bool>(
             ((enum http_errno)(parser)->http_errno) == HPE_OK)
             ? void(0)
             : __assert_fail(
                   "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 39851, __extension__ __PRETTY_FUNCTION__));
        if (__builtin_expect(!!(settings->on_chunk_header), 1))
        {
          parser->state = p_state;
          if (__builtin_expect(!!(0 != settings->on_chunk_header(parser)), 0))
          {
            do
            {
              parser->http_errno = (HPE_CB_chunk_header);
            } while (0);
          }
          p_state = (enum state)(parser->state);
          ;
          if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
          {
            return (p - data + 1);
          }
        }
      } while (0);
      break;
    }
    case s_chunk_data:
    {
      uint64_t to_read = ((parser->content_length) < ((uint64_t)((data + len) - p)) ? (parser->content_length) : ((uint64_t)((data + len) - p)));

      (static_cast<bool>(
           parser->flags & F_CHUNKED)
           ? void(0)
           : __assert_fail(
                 "parser->flags & F_CHUNKED", "all.cpp", 39858, __extension__ __PRETTY_FUNCTION__));

      (static_cast<bool>(
           parser->content_length != 0 && parser->content_length !=
                                              (0x7fffffffffffffffLL * 2ULL + 1))
           ? void(0)
           : __assert_fail(
                 "parser->content_length != 0 && parser->content_length != ULLONG_MAX", "all.cpp", 39859, __extension__ __PRETTY_FUNCTION__));
      do
      {
        if (!body_mark)
        {
          body_mark = p;
        }
      } while (0);
      parser->content_length -= to_read;
      p += to_read - 1;
      if (parser->content_length == 0)
      {
        p_state = (enum state)(s_chunk_data_almost_done);
        ;
      }
      break;
    }
    case s_chunk_data_almost_done:

      (static_cast<bool>(
           parser->flags & F_CHUNKED)
           ? void(0)
           : __assert_fail(
                 "parser->flags & F_CHUNKED", "all.cpp", 39870, __extension__ __PRETTY_FUNCTION__));

      (static_cast<bool>(
           parser->content_length == 0)
           ? void(0)
           : __assert_fail(
                 "parser->content_length == 0", "all.cpp", 39871, __extension__ __PRETTY_FUNCTION__));
      do
      {
        if (ch != '\r')
        {
          do
          {
            parser->http_errno = (HPE_STRICT);
          } while (0);
          goto error;
        }
      } while (0);
      p_state = (enum state)(s_chunk_data_done);
      ;
      do
      {
        (static_cast<bool>(
             ((enum http_errno)(parser)->http_errno) == HPE_OK)
             ? void(0)
             : __assert_fail(
                   "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 39874, __extension__ __PRETTY_FUNCTION__));
        if (body_mark)
        {
          if (__builtin_expect(!!(settings->on_body), 1))
          {
            parser->state = p_state;
            if (__builtin_expect(!!(0 != settings->on_body(parser, body_mark, (p - body_mark))), 0))
            {
              do
              {
                parser->http_errno = (HPE_CB_body);
              } while (0);
            }
            p_state = (enum state)(parser->state);
            ;
            if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
            {
              return (p - data + 1);
            }
          }
          body_mark =
              __null;
        }
      } while (0);
      break;
    case s_chunk_data_done:

      (static_cast<bool>(
           parser->flags & F_CHUNKED)
           ? void(0)
           : __assert_fail(
                 "parser->flags & F_CHUNKED", "all.cpp", 39877, __extension__ __PRETTY_FUNCTION__));
      do
      {
        if (ch != '\n')
        {
          do
          {
            parser->http_errno = (HPE_STRICT);
          } while (0);
          goto error;
        }
      } while (0);
      parser->nread = 0;
      p_state = (enum state)(s_chunk_size_start);
      ;
      do
      {
        (static_cast<bool>(
             ((enum http_errno)(parser)->http_errno) == HPE_OK)
             ? void(0)
             : __assert_fail(
                   "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 39881, __extension__ __PRETTY_FUNCTION__));
        if (__builtin_expect(!!(settings->on_chunk_complete), 1))
        {
          parser->state = p_state;
          if (__builtin_expect(!!(0 != settings->on_chunk_complete(parser)), 0))
          {
            do
            {
              parser->http_errno = (HPE_CB_chunk_complete);
            } while (0);
          }
          p_state = (enum state)(parser->state);
          ;
          if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
          {
            return (p - data + 1);
          }
        }
      } while (0);
      break;
    default:

      (static_cast<bool>(
           0 && "unhandled state")
           ? void(0)
           : __assert_fail(
                 "0 && \"unhandled state\"", "all.cpp", 39884, __extension__ __PRETTY_FUNCTION__));
      do
      {
        parser->http_errno = (HPE_INVALID_INTERNAL_STATE);
      } while (0);
      goto error;
    }
  }

  (static_cast<bool>(
       ((header_field_mark ? 1 : 0) + (header_value_mark ? 1 : 0) + (url_mark ? 1 : 0) + (body_mark ? 1 : 0) + (status_mark ? 1 : 0)) <= 1)
       ? void(0)
       : __assert_fail(
             "((header_field_mark ? 1 : 0) + (header_value_mark ? 1 : 0) + (url_mark ? 1 : 0) + (body_mark ? 1 : 0) + (status_mark ? 1 : 0)) <= 1",
             "all.cpp",
             39893, __extension__ __PRETTY_FUNCTION__))

      ;
  do
  {
    (static_cast<bool>(
         ((enum http_errno)(parser)->http_errno) == HPE_OK)
         ? void(0)
         : __assert_fail(
               "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 39894, __extension__ __PRETTY_FUNCTION__));
    if (header_field_mark)
    {
      if (__builtin_expect(!!(settings->on_header_field), 1))
      {
        parser->state = p_state;
        if (__builtin_expect(!!(0 != settings->on_header_field(parser, header_field_mark, (p - header_field_mark))), 0))
        {
          do
          {
            parser->http_errno = (HPE_CB_header_field);
          } while (0);
        }
        p_state = (enum state)(parser->state);
        ;
        if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
        {
          return (p - data);
        }
      }
      header_field_mark =
          __null;
    }
  } while (0);
  do
  {
    (static_cast<bool>(
         ((enum http_errno)(parser)->http_errno) == HPE_OK)
         ? void(0)
         : __assert_fail(
               "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 39895, __extension__ __PRETTY_FUNCTION__));
    if (header_value_mark)
    {
      if (__builtin_expect(!!(settings->on_header_value), 1))
      {
        parser->state = p_state;
        if (__builtin_expect(!!(0 != settings->on_header_value(parser, header_value_mark, (p - header_value_mark))), 0))
        {
          do
          {
            parser->http_errno = (HPE_CB_header_value);
          } while (0);
        }
        p_state = (enum state)(parser->state);
        ;
        if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
        {
          return (p - data);
        }
      }
      header_value_mark =
          __null;
    }
  } while (0);
  do
  {
    (static_cast<bool>(
         ((enum http_errno)(parser)->http_errno) == HPE_OK)
         ? void(0)
         : __assert_fail(
               "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 39896, __extension__ __PRETTY_FUNCTION__));
    if (url_mark)
    {
      if (__builtin_expect(!!(settings->on_url), 1))
      {
        parser->state = p_state;
        if (__builtin_expect(!!(0 != settings->on_url(parser, url_mark, (p - url_mark))), 0))
        {
          do
          {
            parser->http_errno = (HPE_CB_url);
          } while (0);
        }
        p_state = (enum state)(parser->state);
        ;
        if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
        {
          return (p - data);
        }
      }
      url_mark =
          __null;
    }
  } while (0);
  do
  {
    (static_cast<bool>(
         ((enum http_errno)(parser)->http_errno) == HPE_OK)
         ? void(0)
         : __assert_fail(
               "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 39897, __extension__ __PRETTY_FUNCTION__));
    if (body_mark)
    {
      if (__builtin_expect(!!(settings->on_body), 1))
      {
        parser->state = p_state;
        if (__builtin_expect(!!(0 != settings->on_body(parser, body_mark, (p - body_mark))), 0))
        {
          do
          {
            parser->http_errno = (HPE_CB_body);
          } while (0);
        }
        p_state = (enum state)(parser->state);
        ;
        if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
        {
          return (p - data);
        }
      }
      body_mark =
          __null;
    }
  } while (0);
  do
  {
    (static_cast<bool>(
         ((enum http_errno)(parser)->http_errno) == HPE_OK)
         ? void(0)
         : __assert_fail(
               "HTTP_PARSER_ERRNO(parser) == HPE_OK", "all.cpp", 39898, __extension__ __PRETTY_FUNCTION__));
    if (status_mark)
    {
      if (__builtin_expect(!!(settings->on_status), 1))
      {
        parser->state = p_state;
        if (__builtin_expect(!!(0 != settings->on_status(parser, status_mark, (p - status_mark))), 0))
        {
          do
          {
            parser->http_errno = (HPE_CB_status);
          } while (0);
        }
        p_state = (enum state)(parser->state);
        ;
        if (__builtin_expect(!!(((enum http_errno)(parser)->http_errno) != HPE_OK), 0))
        {
          return (p - data);
        }
      }
      status_mark =
          __null;
    }
  } while (0);
  do
  {
    parser->state = p_state;
    return (len);
  } while (0);
  ;
error:
  if (((enum http_errno)(parser)->http_errno) == HPE_OK)
  {
    do
    {
      parser->http_errno = (HPE_UNKNOWN);
    } while (0);
  }
  do
  {
    parser->state = p_state;
    return (p - data);
  } while (0);
  ;
}
int http_message_needs_eof(const http_parser *parser)
{
  if (parser->type == HTTP_REQUEST)
  {
    return 0;
  }
  if (parser->status_code / 100 == 1 ||
      parser->status_code == 204 ||
      parser->status_code == 304 ||
      parser->flags & F_SKIPBODY)
  {
    return 0;
  }
  if ((parser->flags & F_CHUNKED) || parser->content_length !=
                                         (0x7fffffffffffffffLL * 2ULL + 1))
  {
    return 0;
  }
  return 1;
}
int http_should_keep_alive(const http_parser *parser)
{
  if (parser->http_major > 0 && parser->http_minor > 0)
  {
    if (parser->flags & F_CONNECTION_CLOSE)
    {
      return 0;
    }
  }
  else
  {
    if (!(parser->flags & F_CONNECTION_KEEP_ALIVE))
    {
      return 0;
    }
  }
  return !http_message_needs_eof(parser);
}
const char *
http_method_str(enum http_method m)
{
  return ((unsigned int)(m) < (sizeof(method_strings) / sizeof((method_strings)[0])) ? (method_strings)[(m)] : ("<unknown>"));
}
void http_parser_init(http_parser *parser, enum http_parser_type t)
{
  void *data = parser->data;
  memset(parser, 0, sizeof(*parser));
  parser->data = data;
  parser->type = t;
  parser->state = (t == HTTP_REQUEST ? s_start_req : (t == HTTP_RESPONSE ? s_start_res : s_start_req_or_res));
  parser->http_errno = HPE_OK;
}
void http_parser_settings_init(http_parser_settings *settings)
{
  memset(settings, 0, sizeof(*settings));
}
const char *
http_errno_name(enum http_errno err)
{

  (static_cast<bool>(
       ((size_t)err) < (sizeof(http_strerror_tab) / sizeof((http_strerror_tab)[0])))
       ? void(0)
       : __assert_fail(
             "((size_t)err) < ARRAY_SIZE(http_strerror_tab)", "all.cpp", 39972, __extension__ __PRETTY_FUNCTION__));
  return http_strerror_tab[err].name;
}
const char *
http_errno_description(enum http_errno err)
{

  (static_cast<bool>(
       ((size_t)err) < (sizeof(http_strerror_tab) / sizeof((http_strerror_tab)[0])))
       ? void(0)
       : __assert_fail(
             "((size_t)err) < ARRAY_SIZE(http_strerror_tab)", "all.cpp", 39979, __extension__ __PRETTY_FUNCTION__));
  return http_strerror_tab[err].description;
}
static enum http_host_state
http_parse_host_char(enum http_host_state s, const char ch)
{
  switch (s)
  {
  case s_http_userinfo:
  case s_http_userinfo_start:
    if (ch == '@')
    {
      return s_http_host_start;
    }
    if (((((unsigned char)(ch | 0x20) >= 'a' && (unsigned char)(ch | 0x20) <= 'z') || ((ch) >= '0' && (ch) <= '9')) || ((ch) == '-' || (ch) == '_' || (ch) == '.' || (ch) == '!' || (ch) == '~' || (ch) == '*' || (ch) == '\'' || (ch) == '(' || (ch) == ')') || (ch) == '%' || (ch) == ';' || (ch) == ':' || (ch) == '&' || (ch) == '=' || (ch) == '+' || (ch) == '$' || (ch) == ','))
    {
      return s_http_userinfo;
    }
    break;
  case s_http_host_start:
    if (ch == '[')
    {
      return s_http_host_v6_start;
    }
    if (((((unsigned char)(ch | 0x20) >= 'a' && (unsigned char)(ch | 0x20) <= 'z') || ((ch) >= '0' && (ch) <= '9')) || (ch) == '.' || (ch) == '-'))
    {
      return s_http_host;
    }
    break;
  case s_http_host:
    if (((((unsigned char)(ch | 0x20) >= 'a' && (unsigned char)(ch | 0x20) <= 'z') || ((ch) >= '0' && (ch) <= '9')) || (ch) == '.' || (ch) == '-'))
    {
      return s_http_host;
    }
  case s_http_host_v6_end:
    if (ch == ':')
    {
      return s_http_host_port_start;
    }
    break;
  case s_http_host_v6:
    if (ch == ']')
    {
      return s_http_host_v6_end;
    }
  case s_http_host_v6_start:
    if ((((ch) >= '0' && (ch) <= '9') || ((unsigned char)(ch | 0x20) >= 'a' && (unsigned char)(ch | 0x20) <= 'f')) || ch == ':' || ch == '.')
    {
      return s_http_host_v6;
    }
    if (s == s_http_host_v6 && ch == '%')
    {
      return s_http_host_v6_zone_start;
    }
    break;
  case s_http_host_v6_zone:
    if (ch == ']')
    {
      return s_http_host_v6_end;
    }
  case s_http_host_v6_zone_start:
    if ((((unsigned char)(ch | 0x20) >= 'a' && (unsigned char)(ch | 0x20) <= 'z') || ((ch) >= '0' && (ch) <= '9')) || ch == '%' || ch == '.' || ch == '-' || ch == '_' ||
        ch == '~')
    {
      return s_http_host_v6_zone;
    }
    break;
  case s_http_host_port:
  case s_http_host_port_start:
    if (((ch) >= '0' && (ch) <= '9'))
    {
      return s_http_host_port;
    }
    break;
  default:
    break;
  }
  return s_http_host_dead;
}
static int
http_parse_host(const char *buf, struct http_parser_url *u, int found_at)
{
  enum http_host_state s;
  const char *p;
  size_t buflen = u->field_data[UF_HOST].off + u->field_data[UF_HOST].len;

  (static_cast<bool>(
       u->field_set & (1 << UF_HOST))
       ? void(0)
       : __assert_fail(
             "u->field_set & (1 << UF_HOST)", "all.cpp", 40066, __extension__ __PRETTY_FUNCTION__));
  u->field_data[UF_HOST].len = 0;
  s = found_at ? s_http_userinfo_start : s_http_host_start;
  for (p = buf + u->field_data[UF_HOST].off; p < buf + buflen; p++)
  {
    enum http_host_state new_s = http_parse_host_char(s, *p);
    if (new_s == s_http_host_dead)
    {
      return 1;
    }
    switch (new_s)
    {
    case s_http_host:
      if (s != s_http_host)
      {
        u->field_data[UF_HOST].off = p - buf;
      }
      u->field_data[UF_HOST].len++;
      break;
    case s_http_host_v6:
      if (s != s_http_host_v6)
      {
        u->field_data[UF_HOST].off = p - buf;
      }
      u->field_data[UF_HOST].len++;
      break;
    case s_http_host_v6_zone_start:
    case s_http_host_v6_zone:
      u->field_data[UF_HOST].len++;
      break;
    case s_http_host_port:
      if (s != s_http_host_port)
      {
        u->field_data[UF_PORT].off = p - buf;
        u->field_data[UF_PORT].len = 0;
        u->field_set |= (1 << UF_PORT);
      }
      u->field_data[UF_PORT].len++;
      break;
    case s_http_userinfo:
      if (s != s_http_userinfo)
      {
        u->field_data[UF_USERINFO].off = p - buf;
        u->field_data[UF_USERINFO].len = 0;
        u->field_set |= (1 << UF_USERINFO);
      }
      u->field_data[UF_USERINFO].len++;
      break;
    default:
      break;
    }
    s = new_s;
  }
  switch (s)
  {
  case s_http_host_start:
  case s_http_host_v6_start:
  case s_http_host_v6:
  case s_http_host_v6_zone_start:
  case s_http_host_v6_zone:
  case s_http_host_port_start:
  case s_http_userinfo:
  case s_http_userinfo_start:
    return 1;
  default:
    break;
  }
  return 0;
}
void http_parser_url_init(struct http_parser_url *u)
{
  memset(u, 0, sizeof(*u));
}
int http_parser_parse_url(const char *buf, size_t buflen, int is_connect,
                          struct http_parser_url *u)
{
  enum state s;
  const char *p;
  enum http_parser_url_fields uf, old_uf;
  int found_at = 0;
  u->port = u->field_set = 0;
  s = is_connect ? s_req_server_start : s_req_spaces_before_url;
  old_uf = UF_MAX;
  for (p = buf; p < buf + buflen; p++)
  {
    s = parse_url_char(s, *p);
    switch (s)
    {
    case s_dead:
      return 1;
    case s_req_schema_slash:
    case s_req_schema_slash_slash:
    case s_req_server_start:
    case s_req_query_string_start:
    case s_req_fragment_start:
      continue;
    case s_req_schema:
      uf = UF_SCHEMA;
      break;
    case s_req_server_with_at:
      found_at = 1;
    case s_req_server:
      uf = UF_HOST;
      break;
    case s_req_path:
      uf = UF_PATH;
      break;
    case s_req_query_string:
      uf = UF_QUERY;
      break;
    case s_req_fragment:
      uf = UF_FRAGMENT;
      break;
    default:

      (static_cast<bool>(
           !"Unexpected state")
           ? void(0)
           : __assert_fail(
                 "!\"Unexpected state\"", "all.cpp", 40182, __extension__ __PRETTY_FUNCTION__));
      return 1;
    }
    if (uf == old_uf)
    {
      u->field_data[uf].len++;
      continue;
    }
    u->field_data[uf].off = p - buf;
    u->field_data[uf].len = 1;
    u->field_set |= (1 << uf);
    old_uf = uf;
  }
  if ((u->field_set & (1 << UF_SCHEMA)) &&
      (u->field_set & (1 << UF_HOST)) == 0)
  {
    return 1;
  }
  if (u->field_set & (1 << UF_HOST))
  {
    if (http_parse_host(buf, u, found_at) != 0)
    {
      return 1;
    }
  }
  if (is_connect && u->field_set != ((1 << UF_HOST) | (1 << UF_PORT)))
  {
    return 1;
  }
  if (u->field_set & (1 << UF_PORT))
  {
    unsigned long v = strtoul(buf + u->field_data[UF_PORT].off,
                              __null, 10);
    if (v > 0xffff)
    {
      return 1;
    }
    u->port = (uint16_t)v;
  }
  return 0;
}
void http_parser_pause(http_parser *parser, int paused)
{
  if (((enum http_errno)(parser)->http_errno) == HPE_OK ||
      ((enum http_errno)(parser)->http_errno) == HPE_PAUSED)
  {
    do
    {
      parser->http_errno = ((paused) ? HPE_PAUSED : HPE_OK);
    } while (0);
  }
  else
  {

    (static_cast<bool>(
         0 && "Attempting to pause parser in error state")
         ? void(0)
         : __assert_fail(
               "0 && \"Attempting to pause parser in error state\"", "all.cpp", 40232, __extension__ __PRETTY_FUNCTION__));
  }
}
int http_body_is_final(const struct http_parser *parser)
{
  return parser->state == s_message_done;
}
unsigned long
http_parser_version(void)
{
  return 2 * 0x10000 |
         7 * 0x00100 |
         1 * 0x00001;
}
int on_message_begin(http_parser *_)
{
  (void)_;
  printf("\n***MESSAGE BEGIN***\n\n");
  return 0;
}
int on_headers_complete(http_parser *_)
{
  (void)_;
  printf("\n***HEADERS COMPLETE***\n\n");
  return 0;
}
int on_message_complete(http_parser *_)
{
  (void)_;
  printf("\n***MESSAGE COMPLETE***\n\n");
  return 0;
}
int on_url(http_parser *_, const char *at, size_t length)
{
  (void)_;
  printf("Url: %.*s\n", (int)length, at);
  return 0;
}
int on_header_field(http_parser *_, const char *at, size_t length)
{
  (void)_;
  printf("Header field: %.*s\n", (int)length, at);
  return 0;
}
int on_header_value(http_parser *_, const char *at, size_t length)
{
  (void)_;
  printf("Header value: %.*s\n", (int)length, at);
  return 0;
}
int on_body(http_parser *_, const char *at, size_t length)
{
  (void)_;
  printf("Body: %.*s\n", (int)length, at);
  return 0;
}
void usage(const char *name)
{
  fprintf(
      stderr,
      "Usage: %s $type $filename\n"
      "  type: -x, where x is one of {r,b,q}\n"
      "  parses file as a Response, reQuest, or Both\n",
      name);
  exit(
      1);
}
void dump_url(const char *url, const struct http_parser_url *u)
{
  unsigned int i;
  printf("\tfield_set: 0x%x, port: %u\n", u->field_set, u->port);
  for (i = 0; i < UF_MAX; i++)
  {
    if ((u->field_set & (1 << i)) == 0)
    {
      printf("\tfield_data[%u]: unset\n", i);
      continue;
    }
    printf("\tfield_data[%u]: off: %u, len: %u, part: %.*s\n",
           i,
           u->field_data[i].off,
           u->field_data[i].len,
           u->field_data[i].len,
           url + u->field_data[i].off);
  }
}
namespace ngtcp2
{
  namespace debug
  {
    namespace
    {
      auto randgen = util::make_mt19937();
    }
    namespace
    {
      auto *outfile =
          stderr;
    }
    int handshake_completed(ngtcp2_conn *conn, void *user_data)
    {
      fprintf(outfile, "QUIC handshake has completed\n");
      return 0;
    }
    int handshake_confirmed(ngtcp2_conn *conn, void *user_data)
    {
      fprintf(outfile, "QUIC handshake has been confirmed\n");
      return 0;
    }
    bool packet_lost(double prob)
    {
      auto p = std::uniform_real_distribution<>(0, 1)(randgen);
      return p < prob;
    }
    void print_crypto_data(ngtcp2_crypto_level crypto_level, const uint8_t *data,
                           size_t datalen)
    {
      const char *crypto_level_str;
      switch (crypto_level)
      {
      case NGTCP2_CRYPTO_LEVEL_INITIAL:
        crypto_level_str = "Initial";
        break;
      case NGTCP2_CRYPTO_LEVEL_HANDSHAKE:
        crypto_level_str = "Handshake";
        break;
      case NGTCP2_CRYPTO_LEVEL_APP:
        crypto_level_str = "Application";
        break;
      default:

        (static_cast<bool>(
             0)
             ? void(0)
             : __assert_fail(
                   "0", "all.cpp", 40376, __extension__ __PRETTY_FUNCTION__));
      }
      fprintf(outfile, "Ordered CRYPTO data in %s crypto level\n",
              crypto_level_str);
      util::hexdump(outfile, data, datalen);
    }
    void print_stream_data(int64_t stream_id, const uint8_t *data, size_t datalen)
    {
      fprintf(outfile, "Ordered STREAM data stream_id=0x%"
                       "l"
                       "x"
                       "\n",
              stream_id);
      util::hexdump(outfile, data, datalen);
    }
    void print_initial_secret(const uint8_t *data, size_t len)
    {
      fprintf(outfile, "initial_secret=%s\n", util::format_hex(data, len).c_str());
    }
    void print_client_in_secret(const uint8_t *data, size_t len)
    {
      fprintf(outfile, "client_in_secret=%s\n",
              util::format_hex(data, len).c_str());
    }
    void print_server_in_secret(const uint8_t *data, size_t len)
    {
      fprintf(outfile, "server_in_secret=%s\n",
              util::format_hex(data, len).c_str());
    }
    void print_handshake_secret(const uint8_t *data, size_t len)
    {
      fprintf(outfile, "handshake_secret=%s\n",
              util::format_hex(data, len).c_str());
    }
    void print_client_hs_secret(const uint8_t *data, size_t len)
    {
      fprintf(outfile, "client_hs_secret=%s\n",
              util::format_hex(data, len).c_str());
    }
    void print_server_hs_secret(const uint8_t *data, size_t len)
    {
      fprintf(outfile, "server_hs_secret=%s\n",
              util::format_hex(data, len).c_str());
    }
    void print_client_0rtt_secret(const uint8_t *data, size_t len)
    {
      fprintf(outfile, "client_0rtt_secret=%s\n",
              util::format_hex(data, len).c_str());
    }
    void print_client_1rtt_secret(const uint8_t *data, size_t len)
    {
      fprintf(outfile, "client_1rtt_secret=%s\n",
              util::format_hex(data, len).c_str());
    }
    void print_server_1rtt_secret(const uint8_t *data, size_t len)
    {
      fprintf(outfile, "server_1rtt_secret=%s\n",
              util::format_hex(data, len).c_str());
    }
    void print_client_pp_key(const uint8_t *data, size_t len)
    {
      fprintf(outfile, "+ client_pp_key=%s\n", util::format_hex(data, len).c_str());
    }
    void print_server_pp_key(const uint8_t *data, size_t len)
    {
      fprintf(outfile, "+ server_pp_key=%s\n", util::format_hex(data, len).c_str());
    }
    void print_client_pp_iv(const uint8_t *data, size_t len)
    {
      fprintf(outfile, "+ client_pp_iv=%s\n", util::format_hex(data, len).c_str());
    }
    void print_server_pp_iv(const uint8_t *data, size_t len)
    {
      fprintf(outfile, "+ server_pp_iv=%s\n", util::format_hex(data, len).c_str());
    }
    void print_client_pp_hp(const uint8_t *data, size_t len)
    {
      fprintf(outfile, "+ client_pp_hp=%s\n", util::format_hex(data, len).c_str());
    }
    void print_server_pp_hp(const uint8_t *data, size_t len)
    {
      fprintf(outfile, "+ server_pp_hp=%s\n", util::format_hex(data, len).c_str());
    }
    void print_secrets(const uint8_t *secret, size_t secretlen, const uint8_t *key,
                       size_t keylen, const uint8_t *iv, size_t ivlen,
                       const uint8_t *hp, size_t hplen)
    {
      std::cerr << "+ secret=" << util::format_hex(secret, secretlen) << "\n"
                << "+ key=" << util::format_hex(key, keylen) << "\n"
                << "+ iv=" << util::format_hex(iv, ivlen) << "\n"
                << "+ hp=" << util::format_hex(hp, hplen) << std::endl;
    }
    void print_secrets(const uint8_t *secret, size_t secretlen, const uint8_t *key,
                       size_t keylen, const uint8_t *iv, size_t ivlen)
    {
      std::cerr << "+ secret=" << util::format_hex(secret, secretlen) << "\n"
                << "+ key=" << util::format_hex(key, keylen) << "\n"
                << "+ iv=" << util::format_hex(iv, ivlen) << std::endl;
    }
    void print_hp_mask(const uint8_t *mask, size_t masklen, const uint8_t *sample,
                       size_t samplelen)
    {
      fprintf(outfile, "mask=%s sample=%s\n",
              util::format_hex(mask, masklen).c_str(),
              util::format_hex(sample, samplelen).c_str());
    }
    void log_printf(void *user_data, const char *fmt, ...)
    {
      va_list ap;

      __builtin_va_start(
          ap,
          fmt);
      vfprintf(
          stderr, fmt, ap);

      __builtin_va_end(
          ap);
      fprintf(
          stderr, "\n");
    }
    void path_validation(const ngtcp2_path *path,
                         ngtcp2_path_validation_result res)
    {
      auto local_addr = util::straddr(
          reinterpret_cast<sockaddr *>(path->local.addr), path->local.addrlen);
      auto remote_addr = util::straddr(
          reinterpret_cast<sockaddr *>(path->remote.addr), path->remote.addrlen);
      std::cerr << "Path validation against path {local:" << local_addr
                << ", remote:" << remote_addr << "} "
                << (res == NGTCP2_PATH_VALIDATION_RESULT_SUCCESS ? "succeeded"
                                                                 : "failed")
                << std::endl;
    }
    void print_http_begin_request_headers(int64_t stream_id)
    {
      fprintf(outfile, "http: stream 0x%"
                       "l"
                       "x"
                       " request headers started\n",
              stream_id);
    }
    void print_http_begin_response_headers(int64_t stream_id)
    {
      fprintf(outfile, "http: stream 0x%"
                       "l"
                       "x"
                       " response headers started\n",
              stream_id);
    }
    namespace
    {
      void print_header(const uint8_t *name, size_t namelen, const uint8_t *value,
                        size_t valuelen, uint8_t flags)
      {
        fprintf(outfile, "[%.*s: %.*s]%s\n", static_cast<int>(namelen), name,
                static_cast<int>(valuelen), value,
                (flags & NGHTTP3_NV_FLAG_NEVER_INDEX) ? "(sensitive)" : "");
      }
    } // namespace
    namespace
    {
      void print_header(const nghttp3_rcbuf *name, const nghttp3_rcbuf *value,
                        uint8_t flags)
      {
        auto namebuf = nghttp3_rcbuf_get_buf(name);
        auto valuebuf = nghttp3_rcbuf_get_buf(value);
        print_header(namebuf.base, namebuf.len, valuebuf.base, valuebuf.len, flags);
      }
    } // namespace
    namespace
    {
      void print_header(const nghttp3_nv &nv)
      {
        print_header(nv.name, nv.namelen, nv.value, nv.valuelen, nv.flags);
      }
    } // namespace
    void print_http_header(int64_t stream_id, const nghttp3_rcbuf *name,
                           const nghttp3_rcbuf *value, uint8_t flags)
    {
      fprintf(outfile, "http: stream 0x%"
                       "l"
                       "x"
                       " ",
              stream_id);
      print_header(name, value, flags);
    }
    void print_http_end_headers(int64_t stream_id)
    {
      fprintf(outfile, "http: stream 0x%"
                       "l"
                       "x"
                       " headers ended\n",
              stream_id);
    }
    void print_http_data(int64_t stream_id, const uint8_t *data, size_t datalen)
    {
      fprintf(outfile, "http: stream 0x%"
                       "l"
                       "x"
                       " body %zu bytes\n",
              stream_id,
              datalen);
      util::hexdump(outfile, data, datalen);
    }
    void print_http_begin_trailers(int64_t stream_id)
    {
      fprintf(outfile, "http: stream 0x%"
                       "l"
                       "x"
                       " trailers started\n",
              stream_id);
    }
    void print_http_end_trailers(int64_t stream_id)
    {
      fprintf(outfile, "http: stream 0x%"
                       "l"
                       "x"
                       " trailers ended\n",
              stream_id);
    }
    void print_http_begin_push_promise(int64_t stream_id, int64_t push_id)
    {
      fprintf(outfile, "http: stream 0x%"
                       "l"
                       "x"
                       " push 0x%"
                       "l"
                       "x"
                       " started\n",
              stream_id, push_id);
    }
    void print_http_push_promise(int64_t stream_id, int64_t push_id,
                                 const nghttp3_rcbuf *name,
                                 const nghttp3_rcbuf *value, uint8_t flags)
    {
      fprintf(outfile, "http: stream 0x%"
                       "l"
                       "x"
                       " push 0x%"
                       "l"
                       "x"
                       " ",
              stream_id,
              push_id);
      print_header(name, value, flags);
    }
    void print_http_end_push_promise(int64_t stream_id, int64_t push_id)
    {
      fprintf(outfile, "http: stream 0x%"
                       "l"
                       "x"
                       " push 0x%"
                       "l"
                       "x"
                       " ended\n",
              stream_id, push_id);
    }
    void cancel_push(int64_t push_id, int64_t stream_id)
    {
      fprintf(outfile,
              "http: push 0x%"
              "l"
              "x"
              " (stream 0x%"
              "l"
              "x"

              ") has been cancelled by remote endpoint\n",
              push_id, stream_id);
    }
    void push_stream(int64_t push_id, int64_t stream_id)
    {
      fprintf(outfile,
              "http: push 0x%"
              "l"
              "x"
              " promise fulfilled stream 0x%"
              "l"
              "x"
              "\n",
              push_id, stream_id);
    }
    void print_http_request_headers(int64_t stream_id, const nghttp3_nv *nva,
                                    size_t nvlen)
    {
      fprintf(outfile, "http: stream 0x%"
                       "l"
                       "x"
                       " submit request headers\n",
              stream_id);
      for (size_t i = 0; i < nvlen; ++i)
      {
        auto &nv = nva[i];
        print_header(nv);
      }
    }
    void print_http_response_headers(int64_t stream_id, const nghttp3_nv *nva,
                                     size_t nvlen)
    {
      fprintf(outfile, "http: stream 0x%"
                       "l"
                       "x"
                       " submit response headers\n",
              stream_id);
      for (size_t i = 0; i < nvlen; ++i)
      {
        auto &nv = nva[i];
        print_header(nv);
      }
    }
    void print_http_push_promise(int64_t stream_id, int64_t push_id,
                                 const nghttp3_nv *nva, size_t nvlen)
    {
      fprintf(outfile, "http: stream 0x%"
                       "l"
                       "x"
                       " submit push 0x%"
                       "l"
                       "x"
                       "\n",
              stream_id, push_id);
      for (size_t i = 0; i < nvlen; ++i)
      {
        auto &nv = nva[i];
        print_header(nv);
      }
    }
  } // namespace debug
} // namespace ngtcp2
namespace ngtcp2
{
  namespace http
  {
    std::string get_reason_phrase(unsigned int status_code);
  }
} // namespace ngtcp2
namespace ngtcp2
{
  namespace http
  {
    std::string get_reason_phrase(unsigned int status_code)
    {
      switch (status_code)
      {
      case 100:
        return "Continue";
      case 101:
        return "Switching Protocols";
      case 200:
        return "OK";
      case 201:
        return "Created";
      case 202:
        return "Accepted";
      case 203:
        return "Non-Authoritative Information";
      case 204:
        return "No Content";
      case 205:
        return "Reset Content";
      case 206:
        return "Partial Content";
      case 300:
        return "Multiple Choices";
      case 301:
        return "Moved Permanently";
      case 302:
        return "Found";
      case 303:
        return "See Other";
      case 304:
        return "Not Modified";
      case 305:
        return "Use Proxy";
      case 307:
        return "Temporary Redirect";
      case 308:
        return "Permanent Redirect";
      case 400:
        return "Bad Request";
      case 401:
        return "Unauthorized";
      case 402:
        return "Payment Required";
      case 403:
        return "Forbidden";
      case 404:
        return "Not Found";
      case 405:
        return "Method Not Allowed";
      case 406:
        return "Not Acceptable";
      case 407:
        return "Proxy Authentication Required";
      case 408:
        return "Request Timeout";
      case 409:
        return "Conflict";
      case 410:
        return "Gone";
      case 411:
        return "Length Required";
      case 412:
        return "Precondition Failed";
      case 413:
        return "Payload Too Large";
      case 414:
        return "URI Too Long";
      case 415:
        return "Unsupported Media Type";
      case 416:
        return "Requested Range Not Satisfiable";
      case 417:
        return "Expectation Failed";
      case 421:
        return "Misdirected Request";
      case 426:
        return "Upgrade Required";
      case 428:
        return "Precondition Required";
      case 429:
        return "Too Many Requests";
      case 431:
        return "Request Header Fields Too Large";
      case 451:
        return "Unavailable For Legal Reasons";
      case 500:
        return "Internal Server Error";
      case 501:
        return "Not Implemented";
      case 502:
        return "Bad Gateway";
      case 503:
        return "Service Unavailable";
      case 504:
        return "Gateway Timeout";
      case 505:
        return "HTTP Version Not Supported";
      case 511:
        return "Network Authentication Required";
      default:
        return "";
      }
    }
  } // namespace http
} // namespace ngtcp2
namespace ngtcp2
{
  namespace keylog
  {
    constexpr char QUIC_CLIENT_EARLY_TRAFFIC_SECRET[] =
        "CLIENT_EARLY_TRAFFIC_SECRET";
    constexpr char QUIC_CLIENT_HANDSHAKE_TRAFFIC_SECRET[] =
        "CLIENT_HANDSHAKE_TRAFFIC_SECRET";
    constexpr char QUIC_CLIENT_TRAFFIC_SECRET_0[] = "CLIENT_TRAFFIC_SECRET_0";
    constexpr char QUIC_SERVER_HANDSHAKE_TRAFFIC_SECRET[] =
        "SERVER_HANDSHAKE_TRAFFIC_SECRET";
    constexpr char QUIC_SERVER_TRAFFIC_SECRET_0[] = "SERVER_TRAFFIC_SECRET_0";
    void log_secret(SSL *ssl, const char *name, const unsigned char *secret,
                    size_t secretlen);
  } // namespace keylog
} // namespace ngtcp2
namespace ngtcp2
{
  namespace keylog
  {
    void log_secret(SSL *ssl, const char *name, const unsigned char *secret,
                    size_t secretlen)
    {
      if (auto keylog_cb = SSL_CTX_get_keylog_callback(SSL_get_SSL_CTX(ssl)))
      {
        unsigned char crandom[32];
        if (SSL_get_client_random(ssl, crandom, 32) != 32)
        {
          return;
        }
        std::string line = name;
        line += " " + util::format_hex(crandom, 32);
        line += " " + util::format_hex(secret, secretlen);
        keylog_cb(ssl, line.c_str());
      }
    }
  } // namespace keylog
} // namespace ngtcp2

namespace ngtcp2
{
  enum network_error
  {
    NETWORK_ERR_OK = 0,
    NETWORK_ERR_FATAL = -10,
    NETWORK_ERR_SEND_BLOCKED = -11,
    NETWORK_ERR_CLOSE_WAIT = -12,
    NETWORK_ERR_RETRY = -13,
    NETWORK_ERR_DROP_CONN = -14,
  };
  union sockaddr_union
  {
    sockaddr_storage storage;
    sockaddr sa;
    sockaddr_in6 in6;
    sockaddr_in in;
  };
  struct Address
  {
    socklen_t len;
    union sockaddr_union su;
  };
  struct PathStorage
  {
    PathStorage()
    {
      path.local.addr = reinterpret_cast<sockaddr *>(&local_addrbuf);
      path.remote.addr = reinterpret_cast<sockaddr *>(&remote_addrbuf);
    }
    ngtcp2_path path;
    sockaddr_storage local_addrbuf;
    sockaddr_storage remote_addrbuf;
  };
} // namespace ngtcp2

namespace ngtcp2
{
  namespace util
  {
    namespace
    {
      constexpr char LOWER_XDIGITS[] = "0123456789abcdef";
    }
    std::string format_hex(uint8_t c)
    {
      std::string s;
      s.resize(2);
      s[0] = LOWER_XDIGITS[c >> 4];
      s[1] = LOWER_XDIGITS[c & 0xf];
      return s;
    }
    std::string format_hex(const uint8_t *s, size_t len)
    {
      std::string res;
      res.resize(len * 2);
      for (size_t i = 0; i < len; ++i)
      {
        auto c = s[i];
        res[i * 2] = LOWER_XDIGITS[c >> 4];
        res[i * 2 + 1] = LOWER_XDIGITS[c & 0x0f];
      }
      return res;
    }
    std::string format_hex(const std::string &s)
    {
      return format_hex(reinterpret_cast<const uint8_t *>(s.data()), s.size());
    }
    std::string decode_hex(const std::string &s)
    {

      (static_cast<bool>(
           s.size() % 2 == 0)
           ? void(0)
           : __assert_fail(
                 "s.size() % 2 == 0", "all.cpp", 45025, __extension__ __PRETTY_FUNCTION__));
      std::string res(s.size() / 2, '0');
      auto p = std::begin(res);
      for (auto it = std::begin(s); it != std::end(s); it += 2)
      {
        *p++ = (hex_to_uint(*it) << 4) | hex_to_uint(*(it + 1));
      }
      return res;
    }
    namespace
    {
      std::string format_fraction2(uint32_t n)
      {
        n /= 10;
        if (n < 10)
        {
          return {'.', '0', static_cast<char>('0' + n)};
        }
        return {'.', static_cast<char>('0' + n / 10),
                static_cast<char>('0' + (n % 10))};
      }
    } // namespace
    namespace
    {
      uint64_t round2even(uint64_t n)
      {
        if (n % 10 == 5)
        {
          if ((n / 10) & 1)
          {
            n += 10;
          }
        }
        else
        {
          n += 5;
        }
        return n;
      }
    } // namespace
    std::string format_durationf(uint64_t ns)
    {
      static constexpr const char *units[] = {"us", "ms", "s"};
      if (ns < 1000)
      {
        return std::to_string(ns) + "ns";
      }
      auto unit = 0;
      if (ns < 1000000)
      {
      }
      else if (ns < 1000000000)
      {
        ns /= 1000;
        unit = 1;
      }
      else
      {
        ns /= 1000000;
        unit = 2;
      }
      ns = round2even(ns);
      if (ns / 1000 >= 1000 && unit < 2)
      {
        ns /= 1000;
        ++unit;
      }
      return std::to_string(ns / 1000) + format_fraction2(ns % 1000) + units[unit];
    }
    std::mt19937 make_mt19937()
    {
      std::random_device rd;
      return std::mt19937(rd());
    }
    ngtcp2_tstamp timestamp(struct ev_loop *loop)
    {
      return std::chrono::duration_cast<std::chrono::nanoseconds>(
                 std::chrono::steady_clock::now().time_since_epoch())
          .count();
    }
    bool numeric_host(const char *hostname)
    {
      return numeric_host(hostname,
                          2) ||
             numeric_host(hostname,
                          10);
    }
    bool numeric_host(const char *hostname, int family)
    {
      int rv;
      std::array<uint8_t, sizeof(struct in6_addr)> dst;
      rv = inet_pton(family, hostname, dst.data());
      return rv == 1;
    }
    namespace
    {
      void hexdump8(FILE *out, const uint8_t *first, const uint8_t *last)
      {
        auto stop = std::min(first + 8, last);
        for (auto k = first; k != stop; ++k)
        {
          fprintf(out, "%02x ", *k);
        }
        for (; stop != first + 8; ++stop)
        {
          fputs("   ", out);
        }
        fputc(' ', out);
      }
    } // namespace
    void hexdump(FILE *out, const uint8_t *src, size_t len)
    {
      if (len == 0)
      {
        return;
      }
      size_t buflen = 0;
      auto repeated = false;
      std::array<uint8_t, 16> buf{};
      auto end = src + len;
      auto i = src;
      for (;;)
      {
        auto nextlen =
            std::min(static_cast<size_t>(16), static_cast<size_t>(end - i));
        if (nextlen == buflen &&
            std::equal(std::begin(buf), std::begin(buf) + buflen, i))
        {
          if (!repeated)
          {
            repeated = true;
            fputs("*\n", out);
          }
          i += nextlen;
          continue;
        }
        repeated = false;
        fprintf(out, "%08lx", static_cast<unsigned long>(i - src));
        if (i == end)
        {
          fputc('\n', out);
          break;
        }
        fputs("  ", out);
        hexdump8(out, i, end);
        hexdump8(out, i + 8, std::max(i + 8, end));
        fputc('|', out);
        auto stop = std::min(i + 16, end);
        buflen = stop - i;
        auto p = buf.data();
        for (; i != stop; ++i)
        {
          *p++ = *i;
          if (0x20 <= *i && *i <= 0x7e)
          {
            fputc(*i, out);
          }
          else
          {
            fputc('.', out);
          }
        }
        fputs("|\n", out);
      }
    }
    std::string make_cid_key(const ngtcp2_cid *cid)
    {
      return std::string(cid->data, cid->data + cid->datalen);
    }
    std::string make_cid_key(const uint8_t *cid, size_t cidlen)
    {
      return std::string(cid, cid + cidlen);
    }
    std::string straddr(const sockaddr *sa, socklen_t salen)
    {
      std::array<char,
                 1025>
          host;
      std::array<char,
                 32>
          port;
      auto rv = getnameinfo(sa, salen, host.data(), host.size(), port.data(),
                            port.size(),
                            1 |
                                2);
      if (rv != 0)
      {
        std::cerr << "getnameinfo: " << gai_strerror(rv) << std::endl;
        return "";
      }
      std::string res = "[";
      res.append(host.data(), strlen(host.data()));
      res += "]:";
      res.append(port.data(), strlen(port.data()));
      return res;
    }
    namespace
    {
      constexpr bool rws(char c) { return c == '\t' || c == ' '; }
    } // namespace
    int read_mime_types(std::unordered_map<std::string, std::string> &dest,
                        const char *filename)
    {
      std::ifstream f(filename);
      if (!f)
      {
        return -1;
      }
      std::string line;
      while (std::getline(f, line))
      {
        if (line.empty() || line[0] == '#')
        {
          continue;
        }
        auto p = std::find_if(std::begin(line), std::end(line), rws);
        if (p == std::begin(line) || p == std::end(line))
        {
          continue;
        }
        auto media_type = std::string{std::begin(line), p};
        for (;;)
        {
          auto ext = std::find_if_not(p, std::end(line), rws);
          if (ext == std::end(line))
          {
            break;
          }
          p = std::find_if(ext, std::end(line), rws);
          dest.emplace(std::string{ext, p}, media_type);
        }
      }
      return 0;
    }
    ngtcp2_crypto_level from_ossl_level(OSSL_ENCRYPTION_LEVEL ossl_level)
    {
      switch (ossl_level)
      {
      case ssl_encryption_initial:
        return NGTCP2_CRYPTO_LEVEL_INITIAL;
      case ssl_encryption_early_data:
        return NGTCP2_CRYPTO_LEVEL_EARLY;
      case ssl_encryption_handshake:
        return NGTCP2_CRYPTO_LEVEL_HANDSHAKE;
      case ssl_encryption_application:
        return NGTCP2_CRYPTO_LEVEL_APP;
      default:

        (static_cast<bool>(
             0)
             ? void(0)
             : __assert_fail(
                   "0", "all.cpp", 45274, __extension__ __PRETTY_FUNCTION__));
      }
    }
    OSSL_ENCRYPTION_LEVEL from_ngtcp2_level(ngtcp2_crypto_level crypto_level)
    {
      switch (crypto_level)
      {
      case NGTCP2_CRYPTO_LEVEL_INITIAL:
        return ssl_encryption_initial;
      case NGTCP2_CRYPTO_LEVEL_HANDSHAKE:
        return ssl_encryption_handshake;
      case NGTCP2_CRYPTO_LEVEL_APP:
        return ssl_encryption_application;
      case NGTCP2_CRYPTO_LEVEL_EARLY:
        return ssl_encryption_early_data;
      default:

        (static_cast<bool>(
             0)
             ? void(0)
             : __assert_fail(
                   "0", "all.cpp", 45290, __extension__ __PRETTY_FUNCTION__));
      }
    }
    std::string format_duration(ngtcp2_duration n)
    {
      if (n >= 3600 * ((uint64_t)1000000000ULL) && (n % (3600 * ((uint64_t)1000000000ULL))) == 0)
      {
        return format_uint(n / (3600 * ((uint64_t)1000000000ULL))) + 'h';
      }
      if (n >= 60 * ((uint64_t)1000000000ULL) && (n % (60 * ((uint64_t)1000000000ULL))) == 0)
      {
        return format_uint(n / (60 * ((uint64_t)1000000000ULL))) + 'm';
      }
      if (n >= ((uint64_t)1000000000ULL) && (n % ((uint64_t)1000000000ULL)) == 0)
      {
        return format_uint(n / ((uint64_t)1000000000ULL)) + 's';
      }
      if (n >= ((uint64_t)1000000ULL) && (n % ((uint64_t)1000000ULL)) == 0)
      {
        return format_uint(n / ((uint64_t)1000000ULL)) + "ms";
      }
      if (n >= ((uint64_t)1000ULL) && (n % ((uint64_t)1000ULL)) == 0)
      {
        return format_uint(n / ((uint64_t)1000ULL)) + "us";
      }
      return format_uint(n) + "ns";
    }
    std::tuple<uint64_t, size_t, int>
    parse_uint_internal(const std::string_view &s)
    {
      uint64_t res = 0;
      if (s.empty())
      {
        return {0, 0, -1};
      }
      for (size_t i = 0; i < s.size(); ++i)
      {
        auto c = s[i];
        if (c < '0' || '9' < c)
        {
          return {res, i, 0};
        }
        auto d = c - '0';
        if (res > (std::numeric_limits<uint64_t>::max() - d) / 10)
        {
          return {0, i, -1};
        }
        res *= 10;
        res += d;
      }
      return {res, s.size(), 0};
    }
    std::pair<uint64_t, int> parse_uint(const std::string_view &s)
    {
      auto [res, idx, rv] = parse_uint_internal(s);
      if (rv != 0 || idx != s.size())
      {
        return {0, -1};
      }
      return {res, 0};
    }
    std::pair<uint64_t, int> parse_uint_iec(const std::string_view &s)
    {
      auto [res, idx, rv] = parse_uint_internal(s);
      if (rv != 0)
      {
        return {0, rv};
      }
      if (idx == s.size())
      {
        return {res, 0};
      }
      if (idx + 1 != s.size())
      {
        return {0, -1};
      }
      uint64_t m;
      switch (s[idx])
      {
      case 'G':
      case 'g':
        m = 1 << 30;
        break;
      case 'M':
      case 'm':
        m = 1 << 20;
        break;
      case 'K':
      case 'k':
        m = 1 << 10;
        break;
      default:
        return {0, -1};
      }
      if (res > std::numeric_limits<uint64_t>::max() / m)
      {
        return {0, -1};
      }
      return {res * m, 0};
    }
    std::pair<uint64_t, int> parse_duration(const std::string_view &s)
    {
      auto [res, idx, rv] = parse_uint_internal(s);
      if (rv != 0)
      {
        return {0, rv};
      }
      if (idx == s.size())
      {
        return {res * ((uint64_t)1000000000ULL), 0};
      }
      uint64_t m;
      if (idx + 1 == s.size())
      {
        switch (s[idx])
        {
        case 'H':
        case 'h':
          m = 3600 * ((uint64_t)1000000000ULL);
          break;
        case 'M':
        case 'm':
          m = 60 * ((uint64_t)1000000000ULL);
          break;
        case 'S':
        case 's':
          m = ((uint64_t)1000000000ULL);
          break;
        default:
          return {0, -1};
        }
      }
      else if (idx + 2 == s.size() && (s[idx + 1] == 's' || s[idx + 1] == 'S'))
      {
        switch (s[idx])
        {
        case 'M':
        case 'm':
          m = ((uint64_t)1000000ULL);
          break;
        case 'U':
        case 'u':
          m = ((uint64_t)1000ULL);
          break;
        case 'N':
        case 'n':
          return {res, 0};
        default:
          return {0, -1};
        }
      }
      else
      {
        return {0, -1};
      }
      if (res > std::numeric_limits<uint64_t>::max() / m)
      {
        return {0, -1};
      }
      return {res * m, 0};
    }
    namespace
    {
      auto randgen = make_mt19937();
    }
    int generate_secret(uint8_t *secret, size_t secretlen)
    {
      std::array<uint8_t, 16> rand;
      std::array<uint8_t, 32> md;

      (static_cast<bool>(md.size() == secretlen) ? void(0) : __assert_fail("md.size() == secretlen", "all.cpp", 45462, __extension__ __PRETTY_FUNCTION__));
      auto dis = std::uniform_int_distribution<uint8_t>(0, 255);
      std::generate_n(rand.data(), rand.size(), [&dis]() { return dis(randgen); });
      auto ctx = EVP_MD_CTX_new();
      if (ctx == nullptr)
      {
        return -1;
      }
      auto ctx_deleter = defer(EVP_MD_CTX_free, ctx);
      unsigned int mdlen = md.size();
      if (!EVP_DigestInit_ex(ctx, EVP_sha256(), nullptr) ||
          !EVP_DigestUpdate(ctx, rand.data(), rand.size()) ||
          !EVP_DigestFinal_ex(ctx, md.data(), &mdlen))
      {
        return -1;
      }
      std::copy_n(std::begin(md), secretlen, secret);
      return 0;
    }
    namespace
    {
      template <typename InputIt>
      InputIt eat_file(InputIt first, InputIt last)
      {
        if (first == last)
        {
          *first++ = '/';
          return first;
        }
        if (*(last - 1) == '/')
        {
          return last;
        }
        auto p = last;
        for (; p != first && *(p - 1) != '/'; --p)
          ;
        if (p == first)
        {
          *first++ = '/';
          return first;
        }
        return p;
      }
    } // namespace
    namespace
    {
      template <typename InputIt>
      InputIt eat_dir(InputIt first, InputIt last)
      {
        auto p = eat_file(first, last);
        --p;

        (static_cast<bool>(
             *p == '/')
             ? void(0)
             : __assert_fail(
                   "*p == '/'", "all.cpp", 45515, __extension__ __PRETTY_FUNCTION__));
        return eat_file(first, p);
      }
    } // namespace
    std::string normalize_path(const std::string &path)
    {

      (static_cast<bool>(
           path.size() <= 1024)
           ? void(0)
           : __assert_fail(
                 "path.size() <= 1024", "all.cpp", 45521, __extension__ __PRETTY_FUNCTION__));

      (static_cast<bool>(
           path.size() > 0)
           ? void(0)
           : __assert_fail(
                 "path.size() > 0", "all.cpp", 45522, __extension__ __PRETTY_FUNCTION__));

      (static_cast<bool>(
           path[0] == '/')
           ? void(0)
           : __assert_fail(
                 "path[0] == '/'", "all.cpp", 45523, __extension__ __PRETTY_FUNCTION__));
      std::array<char, 1024> res;
      auto p = res.data();
      auto first = std::begin(path);
      auto last = std::end(path);
      *p++ = '/';
      ++first;
      for (; first != last && *first == '/'; ++first)
        ;
      for (; first != last;)
      {
        if (*first == '.')
        {
          if (first + 1 == last)
          {
            break;
          }
          if (*(first + 1) == '/')
          {
            first += 2;
            continue;
          }
          if (*(first + 1) == '.')
          {
            if (first + 2 == last)
            {
              p = eat_dir(res.data(), p);
              break;
            }
            if (*(first + 2) == '/')
            {
              p = eat_dir(res.data(), p);
              first += 3;
              continue;
            }
          }
        }
        if (*(p - 1) != '/')
        {
          p = eat_file(res.data(), p);
        }
        auto slash = std::find(first, last, '/');
        if (slash == last)
        {
          p = std::copy(first, last, p);
          break;
        }
        p = std::copy(first, slash + 1, p);
        first = slash + 1;
        for (; first != last && *first == '/'; ++first)
          ;
      }
      return std::string{res.data(), p};
    }
  } // namespace util
  std::ostream &operator<<(std::ostream &os, const ngtcp2_cid &cid)
  {
    return os << "0x" << util::format_hex(cid.data, cid.datalen);
  }
} // namespace ngtcp2
namespace ngtcp2
{
  QUICError quic_err_transport(int liberr)
  {
    if (liberr == NGTCP2_ERR_RECV_VERSION_NEGOTIATION)
    {
      return {QUICErrorType::TransportVersionNegotiation, 0};
    }
    return {QUICErrorType::Transport,
            ngtcp2_err_infer_quic_transport_error_code(liberr)};
  }
  QUICError quic_err_idle_timeout()
  {
    return {QUICErrorType::TransportIdleTimeout, 0};
  }
  QUICError quic_err_tls(int alert)
  {
    return {QUICErrorType::Transport,
            static_cast<uint64_t>(0x100u | alert)};
  }
  QUICError quic_err_app(int liberr)
  {
    return {QUICErrorType::Application,
            nghttp3_err_infer_quic_app_error_code(liberr)};
  }
  unsigned int msghdr_get_ecn(msghdr *msg, int family)
  {
    switch (family)
    {
    case 2:
      for (auto cmsg =
               ((size_t)(
                    msg)
                            ->msg_controllen >= sizeof(struct cmsghdr)
                    ? (struct cmsghdr *)(msg)->msg_control
                    : (struct cmsghdr *)0);
           cmsg; cmsg =
                     __cmsg_nxthdr(
                         msg,
                         cmsg))
      {
        if (cmsg->cmsg_level ==
                IPPROTO_IP &&
            cmsg->cmsg_type ==
                1 &&
            cmsg->cmsg_len)
        {
          return *reinterpret_cast<uint8_t *>(
              ((
                   cmsg)
                   ->__cmsg_data));
        }
      }
      break;
    case 10:
      for (auto cmsg =
               ((size_t)(
                    msg)
                            ->msg_controllen >= sizeof(struct cmsghdr)
                    ? (struct cmsghdr *)(msg)->msg_control
                    : (struct cmsghdr *)0);
           cmsg; cmsg =
                     __cmsg_nxthdr(
                         msg,
                         cmsg))
      {
        if (cmsg->cmsg_level ==
                IPPROTO_IPV6 &&
            cmsg->cmsg_type ==
                67 &&
            cmsg->cmsg_len)
        {
          return *reinterpret_cast<uint8_t *>(
              ((
                   cmsg)
                   ->__cmsg_data));
        }
      }
      break;
    }
    return 0;
  }
  void fd_set_ecn(int fd, int family, unsigned int ecn)
  {
    switch (family)
    {
    case 2:
      if (setsockopt(fd,
                     IPPROTO_IP,
                     1, &ecn,
                     static_cast<socklen_t>(sizeof(ecn))) == -1)
      {
        std::cerr << "setsockopt: " << strerror((*__errno_location())) << std::endl;
      }
      break;
    case 10:
      if (setsockopt(fd,
                     IPPROTO_IPV6,
                     67, &ecn,
                     static_cast<socklen_t>(sizeof(ecn))) == -1)
      {
        std::cerr << "setsockopt: " << strerror((*__errno_location())) << std::endl;
      }
      break;
    }
  }
  void fd_set_recv_ecn(int fd, int family)
  {
    unsigned int tos = 1;
    switch (family)
    {
    case 2:
      if (setsockopt(fd,
                     IPPROTO_IP,
                     13, &tos,
                     static_cast<socklen_t>(sizeof(tos))) == -1)
      {
        std::cerr << "setsockopt: " << strerror((*__errno_location())) << std::endl;
      }
      break;
    case 10:
      if (setsockopt(fd,
                     IPPROTO_IPV6,
                     66, &tos,
                     static_cast<socklen_t>(sizeof(tos))) == -1)
      {
        std::cerr << "setsockopt: " << strerror((*__errno_location())) << std::endl;
      }
      break;
    }
  }
} // namespace ngtcp2
